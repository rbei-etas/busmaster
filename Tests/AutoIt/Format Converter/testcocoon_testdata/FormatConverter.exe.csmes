
























CRuntimeClass* __stdcall CDefConverterPage::_GetBaseClass() { return ((CRuntimeClass*)(&CPropertyPage::classCPropertyPage)); }  const  CRuntimeClass CDefConverterPage::classCDefConverterPage = { "CDefConverterPage", sizeof(class CDefConverterPage), 0xFFFF, 0, &CDefConverterPage::_GetBaseClass, 0 }; CRuntimeClass* CDefConverterPage::GetRuntimeClass() const { return ((CRuntimeClass*)(&CDefConverterPage::classCDefConverterPage)); }

CDefConverterPage::CDefConverterPage()
    : CPropertyPage(CDefConverterPage::IDD)
    , m_pouPluginManager(0)
    , m_omStrInputFilePath("")
    , m_omStrOutputFilePath("")
    , m_omstrConversionComment("")
    , m_omstrEditHelp("")
{
}

CDefConverterPage::~CDefConverterPage()
{
}

void CDefConverterPage::DoDataExchange(CDataExchange* pDX)
{
    CString str;
    CPropertyPage::DoDataExchange(pDX);
    DDX_Control(pDX, 1003, m_omComboConverterNames);
    DDX_Control(pDX, 1004, m_omEditInputPath);
    DDX_Control(pDX, 1005, m_omEditOutputPath);
    DDX_Text(pDX, 1004, m_omStrInputFilePath);
    DDX_Text(pDX, 1005, m_omStrOutputFilePath);
    DDX_Text(pDX, 1010, m_omstrConversionComment);
    DDX_Text(pDX, 1011, m_omstrEditHelp);
    DDV_MaxChars(pDX, m_omstrEditHelp, 1024);
}


const AFX_MSGMAP* __stdcall CDefConverterPage::_GetBaseMessageMap() { return &CPropertyPage::messageMap; } const AFX_MSGMAP* CDefConverterPage::GetMessageMap() const { return &CDefConverterPage::messageMap; }   const AFX_MSGMAP CDefConverterPage::messageMap = { &CDefConverterPage::_GetBaseMessageMap, &CDefConverterPage::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CDefConverterPage::_messageEntries[] = {
    { 0x0111, (WORD)0, (WORD)1006, (WORD)1006, AfxSig_vv, (AFX_PMSG)&CDefConverterPage::OnBnClickedBtnInput },
    { 0x0111, (WORD)0, (WORD)1007, (WORD)1007, AfxSig_vv, (AFX_PMSG)&CDefConverterPage::OnBnClickedBtnOutput },
    { 0x0111, (WORD)0, (WORD)1008, (WORD)1008, AfxSig_vv, (AFX_PMSG)&CDefConverterPage::OnBnClickedBtnConvert },
    { 0x0111, (WORD)1, (WORD)1003, (WORD)1003, AfxSig_vv, (AFX_PMSG)&CDefConverterPage::OnCbnSelchangeComboConversions },
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };



HRESULT CDefConverterPage::SetPluginManager(CPluginManagerBase* pouPluginManager)
{
    m_pouPluginManager = pouPluginManager;
    return ((HRESULT)1L);
}
HRESULT CDefConverterPage::LoadConverters()
{
    HRESULT hResult = ((HRESULT)1L);

    if(m_pouPluginManager != 0)
    {
        INT nCount = m_pouPluginManager->m_ConverterList.GetCount();
        string strConverterName;

        for(INT i = 0; i < nCount; i++)
        {
            POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(i);
            ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

            if(ouConverterInfo.m_pouConverter->bHaveOwnWindow() == 0)
            {
                ouConverterInfo.m_pouConverter->GetConverterName(strConverterName);
                INT nItem = m_omComboConverterNames.AddString(strConverterName.c_str());

                if(nItem >= 0)
                {
                    m_omComboConverterNames.SetItemData(nItem, i);
                }
            }
        }

        hResult = ((HRESULT)0L);
    }

    return hResult;
}
BOOL CDefConverterPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    
    LoadConverters();
    m_omComboConverterNames.SetCurSel(0);
    OnCbnSelchangeComboConversions();
    return 1;  
}

void CDefConverterPage::OnBnClickedBtnInput()
{
    
    string strFileExt;
    string strFileFilters;
    INT nSelected = GetConverterPos();

    if( nSelected < m_pouPluginManager->m_ConverterList.GetCount())
    {
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelected);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

        if( ouConverterInfo.m_pouConverter != 0)
        {
            ouConverterInfo.m_pouConverter->GetInputFileFilters(strFileExt, strFileFilters);
        }

        CFileDialog fileDlg( 1,     
                             strFileExt.c_str(),     
                             0,     
                             0x00000002|0x00001000|
                             0x00000800,
                             strFileFilters.c_str(),
                             this );
        INT_PTR nRetVal = fileDlg.DoModal();

        if(1 == nRetVal)
        {
            m_omEditInputPath.SetWindowTextA(fileDlg.GetPathName());
            CString omStrOutputFile = (LPCTSTR) fileDlg.GetPathName();
            INT nIndex = omStrOutputFile.ReverseFind('.');

            if ( nIndex >= 0)
            {
                omStrOutputFile = omStrOutputFile.Left(nIndex);
                ouConverterInfo.m_pouConverter->GetOutputFileFilters(strFileExt, strFileFilters);
                omStrOutputFile += ".";
                omStrOutputFile += strFileExt.c_str();
                m_omEditOutputPath.SetWindowTextA(omStrOutputFile);
            }

            GetDlgItem(1010)->SetWindowTextA("");
        }
    }
}

void CDefConverterPage::OnBnClickedBtnOutput()
{
    string strFileExt;
    string strFileFilters;
    INT nSelected = GetConverterPos();

    if( nSelected < m_pouPluginManager->m_ConverterList.GetCount())
    {
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelected);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

        if( ouConverterInfo.m_pouConverter != 0)
        {
            ouConverterInfo.m_pouConverter->GetOutputFileFilters(strFileExt, strFileFilters);
        }
    }

    CFileDialog fileDlg( 1,     
                         strFileExt.c_str(),     
                         0,     
                         0x00000004 | 0x00000002,
                         strFileFilters.c_str(),
                         this );
    INT_PTR nRetVal = fileDlg.DoModal();

    if(1 == nRetVal)
    {
        m_omEditOutputPath.SetWindowTextA(fileDlg.GetPathName());
    }
}

void CDefConverterPage::OnBnClickedBtnConvert()
{
    
    INT nSelected = GetConverterPos();
    { AFX_EXCEPTION_LINK _afxExceptionLink; try {
    {
        if( (nSelected >= 0 ) && (nSelected < m_pouPluginManager->m_ConverterList.GetCount()))
        {
            POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelected);
            ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

            if( ouConverterInfo.m_pouConverter != 0)
            {
                UpdateData();
                string inputFilePath  = (LPCTSTR) m_omStrInputFilePath;
                string outputFilePath = (LPCTSTR) m_omStrOutputFilePath;

				if( ((HRESULT)0L) == ValidateFileExtensions(m_omStrInputFilePath, m_omStrOutputFilePath, ouConverterInfo.m_pouConverter))
				{
					HRESULT hResult = ouConverterInfo.m_pouConverter->ConvertFile(inputFilePath, outputFilePath);
					string conversionComment;
					ouConverterInfo.m_pouConverter->GetLastConversionStatus(hResult, conversionComment);
					m_omstrConversionComment = conversionComment.c_str();
					UpdateData(0);
				}
				else
				{
					MessageBoxA("Invalid Input/Output Files", "Error", 0x00000000L|0x00000010L);
				}
            }
        }
    }
    } catch (CException* e) { ((void)0); _afxExceptionLink.m_pException = e;
    {
        MessageBoxA("Unexpected Error Occured.Conversion Oberted", "Error", 0x00000000L|0x00000010L);
    }
    } }
}

void CDefConverterPage::OnCbnSelchangeComboConversions()
{
    
    m_omStrInputFilePath = "";
    m_omStrOutputFilePath = "";
    m_omstrConversionComment = "";
    string m_omstrConversionName;
    INT nSelectedItemIndex = GetConverterPos();

    if( nSelectedItemIndex >= 0 )
    {
        string chHelpText;
        string chConversionName;
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelectedItemIndex);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);
        ouConverterInfo.m_pouConverter->GetHelpText(chHelpText);
        ouConverterInfo.m_pouConverter->GetConverterName(chConversionName);
        m_omstrEditHelp = chHelpText.c_str();
        m_omstrConversionName = chConversionName.c_str();
        
        
        TCITEMA tcItem;
        tcItem.mask = 0x0001;
        tcItem.pszText = (LPTSTR)(m_omstrConversionName.c_str());
        ((CPropertySheet*)GetParent())->GetTabControl()->SetItem(0, &tcItem );
        SetWindowTextA(m_omstrConversionName.c_str());
    }

    UpdateData(0);
}


INT CDefConverterPage::GetConverterPos()
{
    INT nComboBoxIndex = m_omComboConverterNames.GetCurSel();
    INT nListIndex = m_omComboConverterNames.GetItemData(nComboBoxIndex);

    if( (nListIndex >= 0 ) && (nListIndex < m_pouPluginManager->m_ConverterList.GetCount()))
    {
        return nListIndex;
    }
    else
    {
        return -1;
    }
}
HRESULT CDefConverterPage::ValidateFileExtensions(CString& m_omStrInputFilePath, CString& m_omStrOutputFilePath, CBaseConverter*& m_pouConverter)
{
	CString omStrExtension;
	CString omStrFileExtension;
	string strFilter1, strFilter2;
	HRESULT hResult = ((HRESULT)0L);
	if(m_pouConverter == 0)
	{
		return ((HRESULT)1L);
	}

	INT nIndex = m_omStrInputFilePath.ReverseFind('.');
	if( nIndex >= 0 )
	{
		omStrExtension = m_omStrInputFilePath.Right(m_omStrInputFilePath.GetLength() - nIndex-1);
		omStrExtension.MakeLower();
		m_pouConverter->GetInputFileFilters(strFilter1, strFilter2);
		omStrFileExtension = strFilter1.c_str();
		omStrFileExtension.MakeLower();
		if(omStrExtension == strFilter1.c_str())
		{
			nIndex = m_omStrOutputFilePath.ReverseFind('.');
			if( nIndex >= 0 )
			{
				omStrExtension = m_omStrOutputFilePath.Right(m_omStrOutputFilePath.GetLength() - nIndex-1);
				omStrExtension.MakeLower();
				m_pouConverter->GetOutputFileFilters(strFilter1, strFilter2);
				omStrFileExtension = strFilter1.c_str();
				omStrFileExtension.MakeLower();
				if(omStrExtension != strFilter1.c_str())
				{
					hResult = ((HRESULT)1L); 
				}
			}
			else
			{
				hResult = ((HRESULT)1L); 
			}
		}
		else
		{
			hResult = ((HRESULT)1L); 
		}
	}
	else
	{
		hResult = ((HRESULT)1L); 
	}
	return hResult;
}

























#pragma once

typedef struct tagConverterInfo
{
    CBaseConverter* m_pouConverter;
    HMODULE m_hModule;
    CString m_strFileName;
    CPropertyPage* m_pomPage;
    tagConverterInfo()
    {
        m_pomPage = 0;
        m_pouConverter = 0;
        m_hModule = 0;
    }
} ConverterInfo;

typedef CList<ConverterInfo, ConverterInfo& > ConvertersInfoList;

class CPluginManagerBase
{
    
public:
    ConvertersInfoList m_ConverterList;
    
public:
    CPluginManagerBase(void);
    virtual ~CPluginManagerBase(void);
    virtual HRESULT LoadConvertersFromFolder(const TCHAR* pchPluginFolder = 0)=0;
    virtual HRESULT LoadConverter(CString& strFileName)=0;
    virtual HRESULT UnLoadAllPlugins()=0;
protected:
};
























#pragma once



class CBaseConverter
{
public:
    virtual ~CBaseConverter() {};
    virtual HRESULT GetInputFileFilters(string&, string& ) = 0;
    virtual HRESULT GetOutputFileFilters(string&, string& ) = 0;
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile) = 0;
    virtual HRESULT GetConverterName(string& strConverterName) = 0;
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus) = 0;
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus) = 0;
    virtual HRESULT GetHelpText(string& pchHelpText)=0;
    virtual BOOL bHaveOwnWindow() = 0;
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage ) = 0;
};
          Æ   "   Æ   ^   Ãÿÿÿÿ   Ãÿÿÿÿ    iÅ      expression was true       (nSelected < m_pouPluginManager->m_ConverterList.GetCount())    Æÿÿÿÿ   Ã   "   Æÿÿÿÿ   Ã   ^   expression was false       (nSelected < m_pouPluginManager->m_ConverterList.GetCount())    Æÿÿÿÿ   Ã   "   Æÿÿÿÿ   Ã   ^               iÃX         Æ      Æ      Ãÿÿÿÿ   Ãÿÿÿÿ    iÄ0      expression was true       (nSelected >= 0 )    Æÿÿÿÿ   Ã      Æÿÿÿÿ   Ã      expression was false       (nSelected >= 0 )    Æÿÿÿÿ   Ã      Æÿÿÿÿ   Ã                  iÂ(         S      S   "   Pÿÿÿÿ   Pÿÿÿÿ    d:Ğ      expression was false       i < nCount    Sÿÿÿÿ   P      Sÿÿÿÿ   P   "                   	       	ÿÿÿÿ  	ÿÿÿÿ    BC¨      expression was true       (nListIndex >= 0 )   ÿÿÿÿ  	   	  ÿÿÿÿ  	      expression was false       (nListIndex >= 0 )   ÿÿÿÿ  	   	  ÿÿÿÿ  	                  BA         2     2   ,  /ÿÿÿÿ  /ÿÿÿÿ    86ğ      expression was false       omStrExtension != strFilter1.c_str()   2ÿÿÿÿ  /     2ÿÿÿÿ  /   ,               82                   ÿÿÿÿ  ÿÿÿÿ    '/°      expression was false       m_pouConverter == 0   ÿÿÿÿ       ÿÿÿÿ                    '.    	      ğ   	   ğ       íÿÿÿÿ   íÿÿÿÿ    @ù       expression was false       nSelectedItemIndex >= 0    ğÿÿÿÿ   í   	   ğÿÿÿÿ   í                   0
h   
      Ë      Ë   4   Èÿÿÿÿ   Èÿÿÿÿ    fŒH      expression was false       ouConverterInfo.m_pouConverter != 0    Ëÿÿÿÿ   È      Ëÿÿÿÿ   È   4               iÊ°                \  	ÿÿÿÿ  	ÿÿÿÿ    BD      expression was true       (nListIndex < m_pouPluginManager->m_ConverterList.GetCount())   ÿÿÿÿ  	     ÿÿÿÿ  	   \   expression was false       (nListIndex < m_pouPluginManager->m_ConverterList.GetCount())   ÿÿÿÿ  	     ÿÿÿÿ  	   \               BBĞ         º      º      ·ÿÿÿÿ   ·ÿÿÿÿ    Ëˆ      expression was false       1 == nRetVal    ºÿÿÿÿ   ·      ºÿÿÿÿ   ·                  É@         ¬      ¬   0   ©ÿÿÿÿ   ©ÿÿÿÿ    Ä`      expression was false       ouConverterInfo.m_pouConverter != 0    ¬ÿÿÿÿ   ©      ¬ÿÿÿÿ   ©   0               @»ğ         §   	   §   C   ¤ÿÿÿÿ   ¤ÿÿÿÿ    Æ       expression was false       nSelected < m_pouPluginManager->m_ConverterList.GetCount()    §ÿÿÿÿ   ¤   	   §ÿÿÿÿ   ¤   C                 “      “      ÿÿÿÿ   ÿÿÿÿ    En¸      expression was false       nIndex >= 0    “ÿÿÿÿ         “ÿÿÿÿ                     Egˆ                     Šÿÿÿÿ   Šÿÿÿÿ    @°à      expression was false       1 == nRetVal    ÿÿÿÿ   Š      ÿÿÿÿ   Š                  dN€                  0   |ÿÿÿÿ   |ÿÿÿÿ    dKP      expression was false       ouConverterInfo.m_pouConverter != 0    ÿÿÿÿ   |      ÿÿÿÿ   |   0               dH¨         z   	   z   C   wÿÿÿÿ   wÿÿÿÿ    @²      expression was false       nSelected < m_pouPluginManager->m_ConverterList.GetCount()    zÿÿÿÿ   w   	   zÿÿÿÿ   w   C                 ]      ]      Zÿÿÿÿ   Zÿÿÿÿ    d7P      expression was false       nItem >= 0    ]ÿÿÿÿ   Z      ]ÿÿÿÿ   Z                  d4ğ         X      X   E   Uÿÿÿÿ   Uÿÿÿÿ    d9      expression was false       ouConverterInfo.m_pouConverter->bHaveOwnWindow() == 0    Xÿÿÿÿ   U      Xÿÿÿÿ   U   E               d18         N      N      Kÿÿÿÿ   Kÿÿÿÿ    d      expression was false       m_pouPluginManager != 0    Nÿÿÿÿ   K      Nÿÿÿÿ   K                  :…€        E     E     Bÿÿÿÿ  Bÿÿÿÿ    8Gh       statement executed        return hResult;   Eÿÿÿÿ  B     Eÿÿÿÿ  B                   D     D     Aÿÿÿÿ  Aÿÿÿÿ    8E¨       statement executed        }   Dÿÿÿÿ  A     Dÿÿÿÿ  A                   ?     ?     <ÿÿÿÿ  <ÿÿÿÿ    8@À       statement executed        }   ?ÿÿÿÿ  <     ?ÿÿÿÿ  <                   :     :     7ÿÿÿÿ  7ÿÿÿÿ    8;Ø       statement executed        }   :ÿÿÿÿ  7     :ÿÿÿÿ  7                   6     6     3ÿÿÿÿ  3ÿÿÿÿ    87Ø       statement executed        }   6ÿÿÿÿ  3     6ÿÿÿÿ  3                   5     5     2ÿÿÿÿ  2ÿÿÿÿ    86       statement executed        }   5ÿÿÿÿ  2     5ÿÿÿÿ  2                             ÿÿÿÿ  ÿÿÿÿ    '.Ø       statement executed        return ((HRESULT)1L);   ÿÿÿÿ       ÿÿÿÿ                        	       ÿÿÿÿ  ÿÿÿÿ    BG`       statement executed        return -1;   ÿÿÿÿ     	  ÿÿÿÿ                        	       ÿÿÿÿ  ÿÿÿÿ    BFˆ       statement executed        return nListIndex;   ÿÿÿÿ     	  ÿÿÿÿ                                ÿÿÿÿ  ÿÿÿÿ    @ú¸       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                !                şÿÿÿÿ   şÿÿÿÿ    @øÈ       statement executed        }   ÿÿÿÿ   ş     ÿÿÿÿ   ş              "      å      å      âÿÿÿÿ   âÿÿÿÿ    0¨       statement executed        }    åÿÿÿÿ   â      åÿÿÿÿ   â              #      ä      ä      áÿÿÿÿ   áÿÿÿÿ    0Ğ       statement executed        }    äÿÿÿÿ   á      äÿÿÿÿ   á              $      à      à      İÿÿÿÿ   İÿÿÿÿ    fğ       statement executed        }    àÿÿÿÿ   İ      àÿÿÿÿ   İ              %      Ş   	   Ş   
   Ûÿÿÿÿ   Ûÿÿÿÿ    f0       statement executed        }    Şÿÿÿÿ   Û   	   Şÿÿÿÿ   Û   
           &      Ü      Ü      Ùÿÿÿÿ   Ùÿÿÿÿ    fŠˆ       statement executed        }    Üÿÿÿÿ   Ù      Üÿÿÿÿ   Ù              '      Ø      Ø      Õÿÿÿÿ   Õÿÿÿÿ    f‰h       statement executed        }    Øÿÿÿÿ   Õ      Øÿÿÿÿ   Õ              (      ¾      ¾      »ÿÿÿÿ   »ÿÿÿÿ    Ìp       statement executed        }    ¾ÿÿÿÿ   »      ¾ÿÿÿÿ   »              )      ½      ½      ºÿÿÿÿ   ºÿÿÿÿ    Ê°       statement executed        }    ½ÿÿÿÿ   º      ½ÿÿÿÿ   º              *      °      °      ­ÿÿÿÿ   ­ÿÿÿÿ    ÅH       statement executed        }    °ÿÿÿÿ   ­      °ÿÿÿÿ   ­              +      ¯   	   ¯   
   ¬ÿÿÿÿ   ¬ÿÿÿÿ    Ãˆ       statement executed        }    ¯ÿÿÿÿ   ¬   	   ¯ÿÿÿÿ   ¬   
           ,      Ÿ      Ÿ      œÿÿÿÿ   œÿÿÿÿ    @³h       statement executed        }    Ÿÿÿÿÿ   œ      Ÿÿÿÿÿ   œ              -                  ›ÿÿÿÿ   ›ÿÿÿÿ    @±¸       statement executed        }    ÿÿÿÿ   ›      ÿÿÿÿ   ›              .         	      
   šÿÿÿÿ   šÿÿÿÿ    @°       statement executed        }    ÿÿÿÿ   š   	   ÿÿÿÿ   š   
           /      š      š      —ÿÿÿÿ   —ÿÿÿÿ    Emà       statement executed        }    šÿÿÿÿ   —      šÿÿÿÿ   —              0      ‚   	   ‚   
   ÿÿÿÿ   ÿÿÿÿ    dJx       statement executed        }    ‚ÿÿÿÿ      	   ‚ÿÿÿÿ      
           1      p      p      mÿÿÿÿ   mÿÿÿÿ    h8       statement executed        return 1;    pÿÿÿÿ   m      pÿÿÿÿ   m              2      g      g      dÿÿÿÿ   dÿÿÿÿ    dğ       statement executed        return hResult;    gÿÿÿÿ   d      gÿÿÿÿ   d              3      e      e      bÿÿÿÿ   bÿÿÿÿ    c0       statement executed        }    eÿÿÿÿ   b      eÿÿÿÿ   b              4      b   	   b   
   _ÿÿÿÿ   _ÿÿÿÿ    d9ø       statement executed        }    bÿÿÿÿ   _   	   bÿÿÿÿ   _   
           5      a      a      ^ÿÿÿÿ   ^ÿÿÿÿ    d88       statement executed        }    aÿÿÿÿ   ^      aÿÿÿÿ   ^              6      `      `      ]ÿÿÿÿ   ]ÿÿÿÿ    d6x       statement executed        }    `ÿÿÿÿ   ]      `ÿÿÿÿ   ]              7      H      H      Eÿÿÿÿ   Eÿÿÿÿ    :€       statement executed        return ((HRESULT)1L);    Hÿÿÿÿ   E      Hÿÿÿÿ   E              8      <   ©   <   Ï   9ÿÿÿÿ   9ÿÿÿÿ    Få@       statement executed        return &CDefConverterPage::messageMap;    <ÿÿÿÿ   9   ©   <ÿÿÿÿ   9   Ï           9      <   G   <   i   9ÿÿÿÿ   9ÿÿÿÿ    FãÈ       statement executed        return &CPropertyPage::messageMap;    <ÿÿÿÿ   9   G   <ÿÿÿÿ   9   i           <         ?      }   ÿÿÿÿ   ÿÿÿÿ    1‡P       statement executed        return ((CRuntimeClass*)(&CPropertyPage::classCPropertyPage));    ÿÿÿÿ      ?   ÿÿÿÿ      }           =        i     ¯   ÿÿÿÿ   ÿÿÿÿ    1‰X       statement executed        return ((CRuntimeClass*)(&CDefConverterPage::classCDefConverterPage));    ÿÿÿÿ     i   ÿÿÿÿ     ¯           >      '      '      $ÿÿÿÿ   $ÿÿÿÿ    1‹È       statement executed        }    'ÿÿÿÿ   $      'ÿÿÿÿ   $              ?      +      +      (ÿÿÿÿ   (ÿÿÿÿ    1H       statement executed        }    +ÿÿÿÿ   (      +ÿÿÿÿ   (              @      9      9      6ÿÿÿÿ   6ÿÿÿÿ    Fá¸       statement executed        }    9ÿÿÿÿ   6      9ÿÿÿÿ   6              ;      (      (      &ÿÿÿÿ   &ÿÿÿÿ     ÿa¨       statement executed        }    (ÿÿÿÿ   &      (ÿÿÿÿ   &              :                  !    ÿÿÿÿ    ÿÿÿÿ    P0       statement executed        }     ÿÿÿÿ            ÿÿÿÿ       !        CDefConverterPage::_GetBaseClass CRuntimeClass* __stdcall CDefConverterPage::_GetBaseClass()       =         ÿÿÿÿ   ÿÿÿÿCDefConverterPage::GetRuntimeClass CRuntimeClass* CDefConverterPage::GetRuntimeClass()      g     ±   ÿÿÿÿ   ÿÿÿÿCDefConverterPage::CDefConverterPage CDefConverterPage::CDefConverterPage()    &      '      #ÿÿÿÿ   $ÿÿÿÿCDefConverterPage::~CDefConverterPage CDefConverterPage::~CDefConverterPage()    *      +      'ÿÿÿÿ   (ÿÿÿÿCDefConverterPage::DoDataExchange void CDefConverterPage::DoDataExchange(CDataExchange* pDX)    .      9      +ÿÿÿÿ   6ÿÿÿÿCDefConverterPage::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CDefConverterPage::_GetBaseMessageMap()    <   E   <   k   9ÿÿÿÿ   9ÿÿÿÿCDefConverterPage::GetMessageMap const AFX_MSGMAP* CDefConverterPage::GetMessageMap()    <   §   <   Ñ   9ÿÿÿÿ   9ÿÿÿÿCDefConverterPage::SetPluginManager HRESULT CDefConverterPage::SetPluginManager(CPluginManagerBase* pouPluginManager)    F      I      Cÿÿÿÿ   FÿÿÿÿCDefConverterPage::LoadConverters HRESULT CDefConverterPage::LoadConverters()    K      h      Hÿÿÿÿ   eÿÿÿÿCDefConverterPage::OnInitDialog BOOL CDefConverterPage::OnInitDialog()    j      q      gÿÿÿÿ   nÿÿÿÿCDefConverterPage::OnBnClickedBtnInput void CDefConverterPage::OnBnClickedBtnInput()    t      Ÿ      qÿÿÿÿ   œÿÿÿÿCDefConverterPage::OnBnClickedBtnOutput void CDefConverterPage::OnBnClickedBtnOutput()    ¢      ¾      Ÿÿÿÿÿ   »ÿÿÿÿCDefConverterPage::OnBnClickedBtnConvert void CDefConverterPage::OnBnClickedBtnConvert()    Á      å      ¾ÿÿÿÿ   âÿÿÿÿCDefConverterPage::OnCbnSelchangeComboConversions void CDefConverterPage::OnCbnSelchangeComboConversions()    è           åÿÿÿÿ  ÿÿÿÿCDefConverterPage::GetConverterPos INT CDefConverterPage::GetConverterPos()             ÿÿÿÿ  ÿÿÿÿCDefConverterPage::ValidateFileExtensions HRESULT CDefConverterPage::ValidateFileExtensions(CString& m_omStrInputFilePath, CString& m_omStrOutputFilePath, CBaseConverter*& m_pouConverter)        F     ÿÿÿÿ  Cÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿtagConverterInfo::tagConverterInfo tagConverterInfo()    $      (      "ÿÿÿÿ   &ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿCBaseConverter::~CBaseConverter ~CBaseConverter()               !    ÿÿÿÿ    ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      DefConverterPage.h
 * \brief     Implementation of CDefConverterPage dialog
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of CDefConverterPage dialog
 */

#include "stdafx.h"
#include "DefConverterPage.h"
#include <strsafe.h>

IMPLEMENT_DYNAMIC(CDefConverterPage, CPropertyPage)

CDefConverterPage::CDefConverterPage()
    : CPropertyPage(CDefConverterPage::IDD)
    , m_pouPluginManager(0)
    , m_omStrInputFilePath(_T(""))
    , m_omStrOutputFilePath(_T(""))
    , m_omstrConversionComment(_T(""))
    , m_omstrEditHelp(_T(""))
{
}

CDefConverterPage::~CDefConverterPage()
{
}

void CDefConverterPage::DoDataExchange(CDataExchange* pDX)
{
    CString str;
    CPropertyPage::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_COMBO_CONVERSIONS, m_omComboConverterNames);
    DDX_Control(pDX, IDC_EDIT_INPUTFILEPATH, m_omEditInputPath);
    DDX_Control(pDX, IDC_EDIT_OUTPUTFILEPATH, m_omEditOutputPath);
    DDX_Text(pDX, IDC_EDIT_INPUTFILEPATH, m_omStrInputFilePath);
    DDX_Text(pDX, IDC_EDIT_OUTPUTFILEPATH, m_omStrOutputFilePath);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_omstrConversionComment);
    DDX_Text(pDX, IDC_EDIT_HELP, m_omstrEditHelp);
    DDV_MaxChars(pDX, m_omstrEditHelp, 1024);
}


BEGIN_MESSAGE_MAP(CDefConverterPage, CPropertyPage)
    ON_BN_CLICKED(IDC_BTN_INPUT, CDefConverterPage::OnBnClickedBtnInput)
    ON_BN_CLICKED(IDC_BTN_OUTPUT, CDefConverterPage::OnBnClickedBtnOutput)
    ON_BN_CLICKED(IDC_BTN_CONVERT, CDefConverterPage::OnBnClickedBtnConvert)
    ON_CBN_SELCHANGE(IDC_COMBO_CONVERSIONS, CDefConverterPage::OnCbnSelchangeComboConversions)
END_MESSAGE_MAP()


// CDefConverterPage message handlers
HRESULT CDefConverterPage::SetPluginManager(CPluginManagerBase* pouPluginManager)
{
    m_pouPluginManager = pouPluginManager;
    return S_FALSE;
}
HRESULT CDefConverterPage::LoadConverters()
{
    HRESULT hResult = S_FALSE;

    if(m_pouPluginManager != NULL)
    {
        INT nCount = m_pouPluginManager->m_ConverterList.GetCount();
        string strConverterName;

        for(INT i = 0; i < nCount; i++)
        {
            POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(i);
            ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

            if(ouConverterInfo.m_pouConverter->bHaveOwnWindow() == FALSE)
            {
                ouConverterInfo.m_pouConverter->GetConverterName(strConverterName);
                INT nItem = m_omComboConverterNames.AddString(strConverterName.c_str());

                if(nItem >= 0)
                {
                    m_omComboConverterNames.SetItemData(nItem, i);
                }
            }
        }

        hResult = S_OK;
    }

    return hResult;
}
BOOL CDefConverterPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    // TODO:  Add extra initialization here
    LoadConverters();
    m_omComboConverterNames.SetCurSel(0);
    OnCbnSelchangeComboConversions();
    return TRUE;  // return TRUE unless you set the focus to a control
}

void CDefConverterPage::OnBnClickedBtnInput()
{
    // TODO: Add your control notification handler code here
    string strFileExt;
    string strFileFilters;
    INT nSelected = GetConverterPos();

    if( nSelected < m_pouPluginManager->m_ConverterList.GetCount())
    {
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelected);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

        if( ouConverterInfo.m_pouConverter != NULL)
        {
            ouConverterInfo.m_pouConverter->GetInputFileFilters(strFileExt, strFileFilters);
        }

        CFileDialog fileDlg( TRUE,     // Open File dialog
                             strFileExt.c_str(),     // Default Extension,
                             NULL,     // Initial file name.
                             OFN_OVERWRITEPROMPT|OFN_FILEMUSTEXIST|
                             OFN_PATHMUSTEXIST,
                             strFileFilters.c_str(),
                             this );
        INT_PTR nRetVal = fileDlg.DoModal();

        if(IDOK == nRetVal)
        {
            m_omEditInputPath.SetWindowText(fileDlg.GetPathName());
            CString omStrOutputFile = (LPCTSTR) fileDlg.GetPathName();
            INT nIndex = omStrOutputFile.ReverseFind('.');

            if ( nIndex >= 0)
            {
                omStrOutputFile = omStrOutputFile.Left(nIndex);
                ouConverterInfo.m_pouConverter->GetOutputFileFilters(strFileExt, strFileFilters);
                omStrOutputFile += ".";
                omStrOutputFile += strFileExt.c_str();
                m_omEditOutputPath.SetWindowText(omStrOutputFile);
            }

            GetDlgItem(IDC_EDIT_COMMENT)->SetWindowText("");
        }
    }
}

void CDefConverterPage::OnBnClickedBtnOutput()
{
    string strFileExt;
    string strFileFilters;
    INT nSelected = GetConverterPos();

    if( nSelected < m_pouPluginManager->m_ConverterList.GetCount())
    {
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelected);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

        if( ouConverterInfo.m_pouConverter != NULL)
        {
            ouConverterInfo.m_pouConverter->GetOutputFileFilters(strFileExt, strFileFilters);
        }
    }

    CFileDialog fileDlg( TRUE,     // Open File dialog
                         strFileExt.c_str(),     // Default Extension,
                         NULL,     // Initial file name.
                         OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
                         strFileFilters.c_str(),
                         this );
    INT_PTR nRetVal = fileDlg.DoModal();

    if(IDOK == nRetVal)
    {
        m_omEditOutputPath.SetWindowText(fileDlg.GetPathName());
    }
}

void CDefConverterPage::OnBnClickedBtnConvert()
{
    // TODO: Add your control notification handler code here
    INT nSelected = GetConverterPos();
    TRY
    {
        if( (nSelected >= 0 ) && (nSelected < m_pouPluginManager->m_ConverterList.GetCount()))
        {
            POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelected);
            ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

            if( ouConverterInfo.m_pouConverter != NULL)
            {
                UpdateData();
                string inputFilePath  = (LPCTSTR) m_omStrInputFilePath;
                string outputFilePath = (LPCTSTR) m_omStrOutputFilePath;

				if( S_OK == ValidateFileExtensions(m_omStrInputFilePath, m_omStrOutputFilePath, ouConverterInfo.m_pouConverter))
				{
					HRESULT hResult = ouConverterInfo.m_pouConverter->ConvertFile(inputFilePath, outputFilePath);
					string conversionComment;
					ouConverterInfo.m_pouConverter->GetLastConversionStatus(hResult, conversionComment);
					m_omstrConversionComment = conversionComment.c_str();
					UpdateData(FALSE);
				}
				else
				{
					MessageBox("Invalid Input/Output Files", "Error", MB_OK|MB_ICONERROR);
				}
            }
        }
    }
    CATCH(CException, e)
    {
        MessageBox("Unexpected Error Occured.Conversion Oberted", "Error", MB_OK|MB_ICONERROR);
    }
    END_CATCH
}

void CDefConverterPage::OnCbnSelchangeComboConversions()
{
    // TODO: Add your control notification handler code here
    m_omStrInputFilePath = _T("");
    m_omStrOutputFilePath = _T("");
    m_omstrConversionComment = _T("");
    string m_omstrConversionName;
    INT nSelectedItemIndex = GetConverterPos();

    if( nSelectedItemIndex >= 0 )
    {
        string chHelpText;
        string chConversionName;
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(nSelectedItemIndex);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);
        ouConverterInfo.m_pouConverter->GetHelpText(chHelpText);
        ouConverterInfo.m_pouConverter->GetConverterName(chConversionName);
        m_omstrEditHelp = chHelpText.c_str();
        m_omstrConversionName = chConversionName.c_str();
        //TODO::Require some more knowledge on how to change
        //propertypage title.
        TC_ITEM tcItem;
        tcItem.mask = TCIF_TEXT;
        tcItem.pszText = (LPTSTR)(m_omstrConversionName.c_str());
        ((CPropertySheet*)GetParent())->GetTabControl()->SetItem(0, &tcItem );
        SetWindowText(m_omstrConversionName.c_str());
    }

    UpdateData(FALSE);
}


INT CDefConverterPage::GetConverterPos()
{
    INT nComboBoxIndex = m_omComboConverterNames.GetCurSel();
    INT nListIndex = m_omComboConverterNames.GetItemData(nComboBoxIndex);

    if( (nListIndex >= 0 ) && (nListIndex < m_pouPluginManager->m_ConverterList.GetCount()))
    {
        return nListIndex;
    }
    else
    {
        return -1;
    }
}
HRESULT CDefConverterPage::ValidateFileExtensions(CString& m_omStrInputFilePath, CString& m_omStrOutputFilePath, CBaseConverter*& m_pouConverter)
{
	CString omStrExtension;
	CString omStrFileExtension;
	string strFilter1, strFilter2;
	HRESULT hResult = S_OK;
	if(m_pouConverter == NULL)
	{
		return S_FALSE;
	}

	INT nIndex = m_omStrInputFilePath.ReverseFind('.');
	if( nIndex >= 0 )
	{
		omStrExtension = m_omStrInputFilePath.Right(m_omStrInputFilePath.GetLength() - nIndex-1);
		omStrExtension.MakeLower();
		m_pouConverter->GetInputFileFilters(strFilter1, strFilter2);
		omStrFileExtension = strFilter1.c_str();
		omStrFileExtension.MakeLower();
		if(omStrExtension == strFilter1.c_str())
		{
			nIndex = m_omStrOutputFilePath.ReverseFind('.');
			if( nIndex >= 0 )
			{
				omStrExtension = m_omStrOutputFilePath.Right(m_omStrOutputFilePath.GetLength() - nIndex-1);
				omStrExtension.MakeLower();
				m_pouConverter->GetOutputFileFilters(strFilter1, strFilter2);
				omStrFileExtension = strFilter1.c_str();
				omStrFileExtension.MakeLower();
				if(omStrExtension != strFilter1.c_str())
				{
					hResult = S_FALSE; 
				}
			}
			else
			{
				hResult = S_FALSE; 
			}
		}
		else
		{
			hResult = S_FALSE; 
		}
	}
	else
	{
		hResult = S_FALSE; 
	}
	return hResult;
}

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      PluginManagerBase.h
 * \brief     Definition of Plugin Manager Base
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Definition of Plugin Manager Base
 */

#pragma once

#include "BaseConverter.h"
#include "afxtempl.h"
typedef struct tagConverterInfo
{
    CBaseConverter* m_pouConverter;
    HMODULE m_hModule;
    CString m_strFileName;
    CPropertyPage* m_pomPage;
    tagConverterInfo()
    {
        m_pomPage = NULL;
        m_pouConverter = NULL;
        m_hModule = NULL;
    }
} ConverterInfo;

typedef CList<ConverterInfo, ConverterInfo& > ConvertersInfoList;

class CPluginManagerBase
{
    //Member variables
public:
    ConvertersInfoList m_ConverterList;
    //Member functions
public:
    CPluginManagerBase(void);
    virtual ~CPluginManagerBase(void);
    virtual HRESULT LoadConvertersFromFolder(CONST TCHAR* pchPluginFolder = NULL)=0;
    virtual HRESULT LoadConverter(CString& strFileName)=0;
    virtual HRESULT UnLoadAllPlugins()=0;
protected:
};
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      BaseConverter.h
 * \brief     Definition of base converter class
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Definition of the base converter class.
 */

#pragma once

#include "stdafx.h"

class CBaseConverter
{
public:
    virtual ~CBaseConverter() {};
    virtual HRESULT GetInputFileFilters(string&, string& ) = 0;
    virtual HRESULT GetOutputFileFilters(string&, string& ) = 0;
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile) = 0;
    virtual HRESULT GetConverterName(string& strConverterName) = 0;
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus) = 0;
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus) = 0;
    virtual HRESULT GetHelpText(string& pchHelpText)=0;
    virtual BOOL bHaveOwnWindow() = 0;
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage ) = 0;
};































const AFX_MSGMAP* __stdcall CFormatConverterApp::_GetBaseMessageMap() { return &CWinApp::messageMap; } const AFX_MSGMAP* CFormatConverterApp::GetMessageMap() const { return &CFormatConverterApp::messageMap; }   const AFX_MSGMAP CFormatConverterApp::messageMap = { &CFormatConverterApp::_GetBaseMessageMap, &CFormatConverterApp::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CFormatConverterApp::_messageEntries[] = {
    { 0x0111, 0, (WORD)0xE146, (WORD)0xE146, AfxSig_vv, (AFX_PMSG)&CWinApp::OnHelp },
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };




CFormatConverterApp::CFormatConverterApp()
{
    
    
}




CFormatConverterApp theApp;




BOOL CFormatConverterApp::InitInstance()
{
    
    
    
    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(InitCtrls);
    
    
    InitCtrls.dwICC = 0x000000FF;
    InitCommonControlsEx(&InitCtrls);
    CWinApp::InitInstance();
    AfxEnableControlContainer();
    
    
    
    
    
    
    
    SetRegistryKey("Local AppWizard-Generated Applications");
    CFormatConverterWnd dlg("BUSMASTER Format Conversions");
    dlg.m_psh.dwFlags &= ~0x00000200;
    dlg.m_psh.dwFlags &= ~0x00000080;
    dlg.LoadConverters();
    m_pMainWnd = &dlg;
    INT_PTR nResponse = dlg.DoModal();

    if (nResponse == 1)
    {
        
        
    }
    else if (nResponse == 2)
    {
        
        
    }

    
    
    return 0;
}
          Y      Y      Vÿÿÿÿ   Vÿÿÿÿ    PÀ      expression was false       nResponse == 2    Yÿÿÿÿ   V      Yÿÿÿÿ   V                  P         a      a      ^ÿÿÿÿ   ^ÿÿÿÿ    Ph       statement executed        return 0;    aÿÿÿÿ   ^      aÿÿÿÿ   ^                    ]      ]      Zÿÿÿÿ   Zÿÿÿÿ    Pè       statement executed        }    ]ÿÿÿÿ   Z      ]ÿÿÿÿ   Z                    X      X      Uÿÿÿÿ   Uÿÿÿÿ    P       statement executed        }    Xÿÿÿÿ   U      Xÿÿÿÿ   U                    .      .      +ÿÿÿÿ   +ÿÿÿÿ    nø       statement executed        }    .ÿÿÿÿ   +      .ÿÿÿÿ   +                    #   §   #   Ï    ÿÿÿÿ    ÿÿÿÿ    nˆ       statement executed        return &CFormatConverterApp::messageMap;    #ÿÿÿÿ       §   #ÿÿÿÿ       Ï                 #   I   #   e    ÿÿÿÿ    ÿÿÿÿ    nˆ       statement executed        return &CWinApp::messageMap;    #ÿÿÿÿ       I   #ÿÿÿÿ       e                 (      (      &ÿÿÿÿ   &ÿÿÿÿ    ")8       statement executed        }    (ÿÿÿÿ   &      (ÿÿÿÿ   &                                !    ÿÿÿÿ    ÿÿÿÿ    lÑ        statement executed        }     ÿÿÿÿ            ÿÿÿÿ       !        CFormatConverterApp::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CFormatConverterApp::_GetBaseMessageMap()    #   G   #   g    ÿÿÿÿ    ÿÿÿÿCFormatConverterApp::GetMessageMap const AFX_MSGMAP* CFormatConverterApp::GetMessageMap()    #   ¥   #   Ñ    ÿÿÿÿ    ÿÿÿÿCFormatConverterApp::CFormatConverterApp CFormatConverterApp::CFormatConverterApp()    +      .      (ÿÿÿÿ   +ÿÿÿÿCFormatConverterApp::InitInstance BOOL CFormatConverterApp::InitInstance()    9      b      6ÿÿÿÿ   _ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      FormatConverterApp.h
 * \brief     Defines the class behaviors for the application.
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines the class behaviors for the application.
 */

#include "stdafx.h"
#include "FormatConverterApp.h"
#include "FormatConverterWnd.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CFormatConverterApp

BEGIN_MESSAGE_MAP(CFormatConverterApp, CWinApp)
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()


// CFormatConverterApp construction

CFormatConverterApp::CFormatConverterApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}


// The one and only CFormatConverterApp object

CFormatConverterApp theApp;


// CFormatConverterApp initialization

BOOL CFormatConverterApp::InitInstance()
{
    // InitCommonControlsEx() is required on Windows XP if an application
    // manifest specifies use of ComCtl32.dll version 6 or later to enable
    // visual styles.  Otherwise, any window creation will fail.
    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(InitCtrls);
    // Set this to include all the common control classes you want to use
    // in your application.
    InitCtrls.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&InitCtrls);
    CWinApp::InitInstance();
    AfxEnableControlContainer();
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    // of your final executable, you should remove from the following
    // the specific initialization routines you do not need
    // Change the registry key under which our settings are stored
    // TODO: You should modify this string to be something appropriate
    // such as the name of your company or organization
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));
    CFormatConverterWnd dlg(_T("BUSMASTER Format Conversions"));
    dlg.m_psh.dwFlags &= ~PSH_HASHELP;
    dlg.m_psh.dwFlags &= ~PSH_NOAPPLYNOW;
    dlg.LoadConverters();
    m_pMainWnd = &dlg;
    INT_PTR nResponse = dlg.DoModal();

    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}


























CRuntimeClass* __stdcall CFormatConverterWnd::_GetBaseClass() { return ((CRuntimeClass*)(&CPropertySheet::classCPropertySheet)); }  const  CRuntimeClass CFormatConverterWnd::classCFormatConverterWnd = { "CFormatConverterWnd", sizeof(class CFormatConverterWnd), 0xFFFF, 0, &CFormatConverterWnd::_GetBaseClass, 0 }; CRuntimeClass* CFormatConverterWnd::GetRuntimeClass() const { return ((CRuntimeClass*)(&CFormatConverterWnd::classCFormatConverterWnd)); }

CFormatConverterWnd::CFormatConverterWnd(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    m_pouPluginManager = 0;
    m_pomDefConverterPage = 0;
}

CFormatConverterWnd::CFormatConverterWnd(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    m_pouPluginManager = 0;
    m_pomDefConverterPage = 0;
}

CFormatConverterWnd::~CFormatConverterWnd()
{
    if( m_pouPluginManager != 0)
    {
        m_pouPluginManager->UnLoadAllPlugins();
        delete m_pouPluginManager;
    }

    if(m_pomDefConverterPage != 0)
    {
        delete m_pomDefConverterPage;
    }
}


const AFX_MSGMAP* __stdcall CFormatConverterWnd::_GetBaseMessageMap() { return &CPropertySheet::messageMap; } const AFX_MSGMAP* CFormatConverterWnd::GetMessageMap() const { return &CFormatConverterWnd::messageMap; }   const AFX_MSGMAP CFormatConverterWnd::messageMap = { &CFormatConverterWnd::_GetBaseMessageMap, &CFormatConverterWnd::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CFormatConverterWnd::_messageEntries[] = {
    { 0x0001, 0, 0, 0, AfxSig_is, (AFX_PMSG)(AFX_PMSGW)(int ( CWnd::*)(LPCREATESTRUCT))&OnCreate },
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };




BOOL CFormatConverterWnd::OnInitDialog()
{
    BOOL bResult = CPropertySheet::OnInitDialog();
    
    ModifyStyle(0, 0x00020000L);
    CButton* omBtn;
    WINDOWPLACEMENT omWndPlace;
    omBtn = reinterpret_cast<CButton*>(GetDlgItem(0x3021));
    omBtn->ShowWindow(0);
    omBtn->GetWindowPlacement(&omWndPlace);
    omBtn = reinterpret_cast<CButton*>(GetDlgItem(1));
    omBtn->ShowWindow(0);
    omBtn = reinterpret_cast<CButton*>(GetDlgItem(2));
    omBtn->SetWindowTextA("Close");
    omBtn->SetWindowPlacement(&omWndPlace);
    return bResult;
}

int CFormatConverterWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    
    return 0;
}

BOOL CFormatConverterWnd::Create(CWnd* pParentWnd , DWORD dwStyle , DWORD dwExStyle)
{
    
    CPropertySheet::Create(pParentWnd, dwStyle, dwExStyle);
    return 1;
}


HRESULT CFormatConverterWnd::LoadConverters()
{
    if (m_pouPluginManager != 0)
    {
        delete m_pouPluginManager;
    }

    m_pouPluginManager = new CPluginManagerDLL();
    m_pouPluginManager->LoadConvertersFromFolder();
    INT nCount = m_pouPluginManager->m_ConverterList.GetCount();
    m_pomDefConverterPage = new CDefConverterPage();
    m_pomDefConverterPage->SetPluginManager(m_pouPluginManager);
    m_pomDefConverterPage->m_psp.dwFlags &= ~0x00000020;
    
    AddPage(m_pomDefConverterPage);

    for(INT i = 0; i < nCount; i++)
    {
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(i);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

        if(ouConverterInfo.m_pouConverter->bHaveOwnWindow() == 1)
        {
            
            ouConverterInfo.m_pouConverter->GetPropertyPage(ouConverterInfo.m_pomPage);

            if(ouConverterInfo.m_pomPage != 0)
            {
                ouConverterInfo.m_pomPage->m_psp.dwFlags &= ~0x00000020;
                AddPage(ouConverterInfo.m_pomPage);
            }
        }
    }

    return ((HRESULT)0L);
}

BOOL CFormatConverterWnd::PreCreateWindow(CREATESTRUCT& cs)
{
    
    cs.dwExStyle = cs.dwExStyle | 0x00000080L;
    return CPropertySheet::PreCreateWindow(cs);
}
          x      x      vÿÿÿÿ   vÿÿÿÿ     /š¨      expression was false       i < nCount    xÿÿÿÿ   v      xÿÿÿÿ   v                    ‚      ‚   .   €ÿÿÿÿ   €ÿÿÿÿ     /—H      expression was false       ouConverterInfo.m_pomPage != 0    ‚ÿÿÿÿ   €      ‚ÿÿÿÿ   €   .                ,¨(         }      }   A   {ÿÿÿÿ   {ÿÿÿÿ     /˜ø      expression was false       ouConverterInfo.m_pouConverter->bHaveOwnWindow() == 1    }ÿÿÿÿ   {      }ÿÿÿÿ   {   A                ,¦         j   	   j       hÿÿÿÿ   hÿÿÿÿ    Ào0      expression was false       m_pouPluginManager != 0    jÿÿÿÿ   h   	   jÿÿÿÿ   h                   Àlğ         W   	   W   7   Uÿÿÿÿ   Uÿÿÿÿ    Àgx      expression was false       CPropertySheet::OnCreate(lpCreateStruct) == -1    Wÿÿÿÿ   U   	   Wÿÿÿÿ   U   7               ÀeÈ         5      5   "   3ÿÿÿÿ   3ÿÿÿÿ    WQˆ      expression was false       m_pomDefConverterPage != 0    5ÿÿÿÿ   3      5ÿÿÿÿ   3   "               lß@         /   	   /       -ÿÿÿÿ   -ÿÿÿÿ    lŞ      expression was false       m_pouPluginManager != 0    /ÿÿÿÿ   -   	   /ÿÿÿÿ   -                   lÛH         ‘      ‘   0   ÿÿÿÿ   ÿÿÿÿ     /ø       statement executed        return CPropertySheet::PreCreateWindow(cs);    ‘ÿÿÿÿ         ‘ÿÿÿÿ      0                 Š      Š      ˆÿÿÿÿ   ˆÿÿÿÿ     /›€       statement executed        return ((HRESULT)0L);    Šÿÿÿÿ   ˆ      Šÿÿÿÿ   ˆ              	      ˆ      ˆ      †ÿÿÿÿ   †ÿÿÿÿ     /™Ğ       statement executed        }    ˆÿÿÿÿ   †      ˆÿÿÿÿ   †              
      ‡   	   ‡   
   …ÿÿÿÿ   …ÿÿÿÿ     /˜        statement executed        }    ‡ÿÿÿÿ   …   	   ‡ÿÿÿÿ   …   
                 †      †      „ÿÿÿÿ   „ÿÿÿÿ     /–¸       statement executed        }    †ÿÿÿÿ   „      †ÿÿÿÿ   „                    m      m      kÿÿÿÿ   kÿÿÿÿ    ÀnX       statement executed        }    mÿÿÿÿ   k      mÿÿÿÿ   k                    d      d      bÿÿÿÿ   bÿÿÿÿ    Àj°       statement executed        return 1;    dÿÿÿÿ   b      dÿÿÿÿ   b                    ]      ]      [ÿÿÿÿ   [ÿÿÿÿ    Àh`       statement executed        return 0;    ]ÿÿÿÿ   [      ]ÿÿÿÿ   [                    Y   	   Y      Wÿÿÿÿ   Wÿÿÿÿ    Àf        statement executed        return -1;    Yÿÿÿÿ   W   	   Yÿÿÿÿ   W                    R      R      Pÿÿÿÿ   Pÿÿÿÿ    Àcˆ       statement executed        return bResult;    Rÿÿÿÿ   P      Rÿÿÿÿ   P                    <   ®   <   Ö   :ÿÿÿÿ   :ÿÿÿÿ    WW       statement executed        return &CFormatConverterWnd::messageMap;    <ÿÿÿÿ   :   ®   <ÿÿÿÿ   :   Ö                 <   I   <   l   :ÿÿÿÿ   :ÿÿÿÿ    WUP       statement executed        return &CPropertySheet::messageMap;    <ÿÿÿÿ   :   I   <ÿÿÿÿ   :   l                    A         ÿÿÿÿ   ÿÿÿÿ    :½@       statement executed        return ((CRuntimeClass*)(&CPropertySheet::classCPropertySheet));    ÿÿÿÿ      A   ÿÿÿÿ                         y     Ã   ÿÿÿÿ   ÿÿÿÿ    :¾ğ       statement executed        return ((CRuntimeClass*)(&CFormatConverterWnd::classCFormatConverterWnd));    ÿÿÿÿ     y   ÿÿÿÿ     Ã                 $      $      "ÿÿÿÿ   "ÿÿÿÿ    lÓ        statement executed        }    $ÿÿÿÿ   "      $ÿÿÿÿ   "                    +      +      )ÿÿÿÿ   )ÿÿÿÿ    lØ˜       statement executed        }    +ÿÿÿÿ   )      +ÿÿÿÿ   )                    3      3      1ÿÿÿÿ   1ÿÿÿÿ    lİ0       statement executed        }    3ÿÿÿÿ   1      3ÿÿÿÿ   1                    8      8      6ÿÿÿÿ   6ÿÿÿÿ    WP°       statement executed        }    8ÿÿÿÿ   6      8ÿÿÿÿ   6                    9      9      7ÿÿÿÿ   7ÿÿÿÿ    WRp       statement executed        }    9ÿÿÿÿ   7      9ÿÿÿÿ   7                    (      (      &ÿÿÿÿ   &ÿÿÿÿ    BP       statement executed        }    (ÿÿÿÿ   &      (ÿÿÿÿ   &                                !    ÿÿÿÿ    ÿÿÿÿ     ÿkğ       statement executed        }     ÿÿÿÿ            ÿÿÿÿ       !        CFormatConverterWnd::_GetBaseClass CRuntimeClass* __stdcall CFormatConverterWnd::_GetBaseClass()       ?      ƒ   ÿÿÿÿ   ÿÿÿÿCFormatConverterWnd::GetRuntimeClass CRuntimeClass* CFormatConverterWnd::GetRuntimeClass()      w     Å   ÿÿÿÿ   ÿÿÿÿCFormatConverterWnd::CFormatConverterWnd CFormatConverterWnd::CFormatConverterWnd(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)    !      $      ÿÿÿÿ   "ÿÿÿÿCFormatConverterWnd::CFormatConverterWnd CFormatConverterWnd::CFormatConverterWnd(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)    (      +      &ÿÿÿÿ   )ÿÿÿÿCFormatConverterWnd::~CFormatConverterWnd CFormatConverterWnd::~CFormatConverterWnd()    .      9      ,ÿÿÿÿ   7ÿÿÿÿCFormatConverterWnd::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CFormatConverterWnd::_GetBaseMessageMap()    <   G   <   n   :ÿÿÿÿ   :ÿÿÿÿCFormatConverterWnd::GetMessageMap const AFX_MSGMAP* CFormatConverterWnd::GetMessageMap()    <   ¬   <   Ø   :ÿÿÿÿ   :ÿÿÿÿCFormatConverterWnd::OnInitDialog BOOL CFormatConverterWnd::OnInitDialog()    D      S      Bÿÿÿÿ   QÿÿÿÿCFormatConverterWnd::OnCreate int CFormatConverterWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)    V      ^      Tÿÿÿÿ   \ÿÿÿÿCFormatConverterWnd::Create BOOL CFormatConverterWnd::Create(CWnd* pParentWnd , DWORD dwStyle , DWORD dwExStyle)    a      e      _ÿÿÿÿ   cÿÿÿÿCFormatConverterWnd::LoadConverters HRESULT CFormatConverterWnd::LoadConverters()    i      ‹      gÿÿÿÿ   ‰ÿÿÿÿCFormatConverterWnd::PreCreateWindow BOOL CFormatConverterWnd::PreCreateWindow(CREATESTRUCT& cs)          ’      Œÿÿÿÿ   ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      FormatConverterWnd.h
 * \brief     Implementation of CFormatConverterWnd class
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of CFormatConverterWnd class
 */

#include "stdafx.h"
#include "FormatConverterWnd.h"
#include "DefConverterPage.h"

IMPLEMENT_DYNAMIC(CFormatConverterWnd, CPropertySheet)

CFormatConverterWnd::CFormatConverterWnd(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    m_pouPluginManager = NULL;
    m_pomDefConverterPage = NULL;
}

CFormatConverterWnd::CFormatConverterWnd(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    m_pouPluginManager = NULL;
    m_pomDefConverterPage = NULL;
}

CFormatConverterWnd::~CFormatConverterWnd()
{
    if( m_pouPluginManager != NULL)
    {
        m_pouPluginManager->UnLoadAllPlugins();
        delete m_pouPluginManager;
    }

    if(m_pomDefConverterPage != NULL)
    {
        delete m_pomDefConverterPage;
    }
}


BEGIN_MESSAGE_MAP(CFormatConverterWnd, CPropertySheet)
    ON_WM_CREATE()
END_MESSAGE_MAP()


// CFormatConverterWnd message handlers

BOOL CFormatConverterWnd::OnInitDialog()
{
    BOOL bResult = CPropertySheet::OnInitDialog();
    // TODO:  Add your specialized code here
    ModifyStyle(0, WS_MINIMIZEBOX);
    CButton* omBtn;
    WINDOWPLACEMENT omWndPlace;
    omBtn = reinterpret_cast<CButton*>(GetDlgItem(ID_APPLY_NOW));
    omBtn->ShowWindow(SW_HIDE);
    omBtn->GetWindowPlacement(&omWndPlace);
    omBtn = reinterpret_cast<CButton*>(GetDlgItem(IDOK));
    omBtn->ShowWindow(SW_HIDE);
    omBtn = reinterpret_cast<CButton*>(GetDlgItem(IDCANCEL));
    omBtn->SetWindowText("Close");
    omBtn->SetWindowPlacement(&omWndPlace);
    return bResult;
}

int CFormatConverterWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    // TODO:  Add your specialized creation code here
    return 0;
}

BOOL CFormatConverterWnd::Create(CWnd* pParentWnd , DWORD dwStyle , DWORD dwExStyle)
{
    // TODO: Add your specialized code here and/or call the base class
    CPropertySheet::Create(pParentWnd, dwStyle, dwExStyle);
    return TRUE;
}


HRESULT CFormatConverterWnd::LoadConverters()
{
    if (m_pouPluginManager != NULL)
    {
        delete m_pouPluginManager;
    }

    m_pouPluginManager = new CPluginManagerDLL();
    m_pouPluginManager->LoadConvertersFromFolder();
    INT nCount = m_pouPluginManager->m_ConverterList.GetCount();
    m_pomDefConverterPage = new CDefConverterPage();
    m_pomDefConverterPage->SetPluginManager(m_pouPluginManager);
    m_pomDefConverterPage->m_psp.dwFlags &= ~PSP_HASHELP;
    //m_pomDefConverterPage->m_psp.dwFlags &= ~PSP_HIDEHEADER;
    AddPage(m_pomDefConverterPage);

    for(INT i = 0; i < nCount; i++)
    {
        POSITION pos = m_pouPluginManager->m_ConverterList.FindIndex(i);
        ConverterInfo& ouConverterInfo = m_pouPluginManager->m_ConverterList.GetAt(pos);

        if(ouConverterInfo.m_pouConverter->bHaveOwnWindow() == TRUE)
        {
            //CPropertyPage *pPage = NULL;
            ouConverterInfo.m_pouConverter->GetPropertyPage(ouConverterInfo.m_pomPage);

            if(ouConverterInfo.m_pomPage != NULL)
            {
                ouConverterInfo.m_pomPage->m_psp.dwFlags &= ~PSP_HASHELP;
                AddPage(ouConverterInfo.m_pomPage);
            }
        }
    }

    return S_OK;
}

BOOL CFormatConverterWnd::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Add your specialized code here and/or call the base class
    cs.dwExStyle = cs.dwExStyle | WS_EX_TOOLWINDOW;
    return CPropertySheet::PreCreateWindow(cs);
}





























CPluginManagerBase::CPluginManagerBase(void)
{
}

CPluginManagerBase::~CPluginManagerBase(void)
{
}
          &      &      $ÿÿÿÿ   $ÿÿÿÿ     ÿkğ       statement executed        }    &ÿÿÿÿ   $      &ÿÿÿÿ   $                    "      "       ÿÿÿÿ    ÿÿÿÿ     ÿjh       statement executed        }    "ÿÿÿÿ          "ÿÿÿÿ                        (      (      &ÿÿÿÿ   &ÿÿÿÿ     ûÀ       statement executed        }    (ÿÿÿÿ   &      (ÿÿÿÿ   &                                !    ÿÿÿÿ    ÿÿÿÿ     ïÀ       statement executed        }     ÿÿÿÿ            ÿÿÿÿ       !        CPluginManagerBase::CPluginManagerBase CPluginManagerBase::CPluginManagerBase(void)    !      "      ÿÿÿÿ    ÿÿÿÿCPluginManagerBase::~CPluginManagerBase CPluginManagerBase::~CPluginManagerBase(void)    %      &      #ÿÿÿÿ   $ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      PluginManagerBase.cpp
 * \brief     Implementation of Plugin Manager Base
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of Plugin Manager Base
 */

#include "StdAfx.h"
#include "PluginManagerBase.h"

//TODO::Move the definition to header file
#define PLUGIN_START_COMMAND 10000


CPluginManagerBase::CPluginManagerBase(void)
{
}

CPluginManagerBase::~CPluginManagerBase(void)
{
}



























typedef HRESULT (*GETCONVERTERINTERFACE)(CBaseConverter*&);

CPluginManagerDLL::CPluginManagerDLL()
{
}

CPluginManagerDLL::~CPluginManagerDLL()
{
}
HRESULT CPluginManagerDLL::LoadConvertersFromFolder(const TCHAR* pchPluginFolder)
{
    TCHAR m_acEvalFilePath[260];
    CString strPluginPath;

    if(pchPluginFolder == 0)
    {
        GetModuleFileNameA( 0, m_acEvalFilePath, 260 );
        PathRemoveFileSpecA(m_acEvalFilePath);
        strPluginPath = m_acEvalFilePath;
        strPluginPath += "\\ConverterPlugins";;
    }
    else
    {
        strPluginPath = pchPluginFolder;
    }

    if(PathFileExistsA(strPluginPath) == 1)
    {
        SetCurrentDirectoryA(strPluginPath);
        CFileFind omFileFinder;
        CString strWildCard = "*.dll"; 
        BOOL bWorking = omFileFinder.FindFile(strWildCard);

        while (bWorking)
        {
            bWorking = omFileFinder.FindNextFileA();

            if (omFileFinder.IsDots() || omFileFinder.IsDirectory())
            {
                continue;
            }

            LoadConverter(omFileFinder.GetFilePath());
        }

        return ((HRESULT)0L);
    }
    else
    {
        return ((HRESULT)1L);
    }
}

HRESULT CPluginManagerDLL::LoadConverter(CString& strFileName)
{
    ConverterInfo ConverterInfo;
    ConverterInfo.m_hModule = LoadLibraryA(strFileName);

    if ( !ConverterInfo.m_hModule )
    {
        MessageBoxA(0, strFileName, "Plugin Loading Error", 0x00000000L);
    }
    else
    {
        BOOL bSuccess = 1;
        GETCONVERTERINTERFACE pFnBaseConverter;
        pFnBaseConverter = (GETCONVERTERINTERFACE)GetProcAddress(ConverterInfo.m_hModule, "GetBaseConverter");

        if(pFnBaseConverter != 0)
        {
            pFnBaseConverter(ConverterInfo.m_pouConverter);
        }
        else
        {
            return ((HRESULT)1L);
        }

        
        if(bSuccess == 1)
        {
            m_ConverterList.AddTail(ConverterInfo);
        }
    }

    return ((HRESULT)0L);
}


HRESULT CPluginManagerDLL::UnLoadAllPlugins()
{
    INT_PTR nCount = m_ConverterList.GetCount();

    for(INT_PTR i = 0; i < nCount; i++)
    {
        POSITION pos = m_ConverterList.FindIndex(i);
        ConverterInfo& ouConverterInfo = m_ConverterList.GetAt(pos);

        if(ouConverterInfo.m_pouConverter != 0)
        {
            delete ouConverterInfo.m_pouConverter;
        }

        if(ouConverterInfo.m_pomPage != 0)
        {
            delete ouConverterInfo.m_pomPage;
        }

        if( ouConverterInfo.m_hModule != 0)
        {
            FreeLibrary(ouConverterInfo.m_hModule);
        }
    }

    return ((HRESULT)0L);
}
          D      D   &   Aÿÿÿÿ   Aÿÿÿÿ    =”`      expression was true       omFileFinder.IsDots()    Dÿÿÿÿ   A      Dÿÿÿÿ   A   &   expression was false       omFileFinder.IsDots()    Dÿÿÿÿ   A      Dÿÿÿÿ   A   &                 {      {   "   xÿÿÿÿ   xÿÿÿÿ    ".      expression was false       i < nCount    {ÿÿÿÿ   x      {ÿÿÿÿ   x   "                 @      @      =ÿÿÿÿ   =ÿÿÿÿ    =™p      expression was false       bWorking    @ÿÿÿÿ   =      @ÿÿÿÿ   =                    Š      Š   +   ‡ÿÿÿÿ   ‡ÿÿÿÿ    ",X      expression was false       ouConverterInfo.m_hModule != 0    Šÿÿÿÿ   ‡      Šÿÿÿÿ   ‡   +               "*H         …      …   *   ‚ÿÿÿÿ   ‚ÿÿÿÿ    ")0      expression was false       ouConverterInfo.m_pomPage != 0    …ÿÿÿÿ   ‚      …ÿÿÿÿ   ‚   *               "&˜         €      €   /   }ÿÿÿÿ   }ÿÿÿÿ    "%ˆ      expression was false       ouConverterInfo.m_pouConverter != 0    €ÿÿÿÿ   }      €ÿÿÿÿ   }   /               "#         m      m      jÿÿÿÿ   jÿÿÿÿ    !È      expression was false       bSuccess == 1    mÿÿÿÿ   j      mÿÿÿÿ   j                   ó¿x         D   *   D   D   Aÿÿÿÿ   Aÿÿÿÿ    =”ğ      expression was true       omFileFinder.IsDirectory()    Dÿÿÿÿ   A   *   Dÿÿÿÿ   A   D   expression was false       omFileFinder.IsDirectory()    Dÿÿÿÿ   A   *   Dÿÿÿÿ   A   D           
                  ÿÿÿÿ   ÿÿÿÿ    ".ğ       statement executed        return ((HRESULT)0L);    ÿÿÿÿ         ÿÿÿÿ                                   ‹ÿÿÿÿ   ‹ÿÿÿÿ    "-@       statement executed        }    ÿÿÿÿ   ‹      ÿÿÿÿ   ‹                       	      
   Šÿÿÿÿ   Šÿÿÿÿ    "+€       statement executed        }    ÿÿÿÿ   Š   	   ÿÿÿÿ   Š   
                 ˆ   	   ˆ   
   …ÿÿÿÿ   …ÿÿÿÿ    "(X       statement executed        }    ˆÿÿÿÿ   …   	   ˆÿÿÿÿ   …   
                 ƒ   	   ƒ   
   €ÿÿÿÿ   €ÿÿÿÿ    "$°       statement executed        }    ƒÿÿÿÿ   €   	   ƒÿÿÿÿ   €   
                 s      s      pÿÿÿÿ   pÿÿÿÿ    $p       statement executed        return ((HRESULT)0L);    sÿÿÿÿ   p      sÿÿÿÿ   p                    q      q      nÿÿÿÿ   nÿÿÿÿ    "°       statement executed        }    qÿÿÿÿ   n      qÿÿÿÿ   n                    #      #       ÿÿÿÿ    ÿÿÿÿ    4f¨       statement executed        }    #ÿÿÿÿ          #ÿÿÿÿ                        '      '      $ÿÿÿÿ   $ÿÿÿÿ    4hà       statement executed        }    'ÿÿÿÿ   $      'ÿÿÿÿ   $                    3      3      0ÿÿÿÿ   0ÿÿÿÿ    T       statement executed        }    3ÿÿÿÿ   0      3ÿÿÿÿ   0                    7      7      4ÿÿÿÿ   4ÿÿÿÿ    Vx       statement executed        }    7ÿÿÿÿ   4      7ÿÿÿÿ   4                    F      F      Cÿÿÿÿ   Cÿÿÿÿ    =–¸       statement executed        continue;    Fÿÿÿÿ   C      Fÿÿÿÿ   C                    J   	   J   
   Gÿÿÿÿ   Gÿÿÿÿ    =˜˜       statement executed        }    Jÿÿÿÿ   G   	   Jÿÿÿÿ   G   
                 L   	   L      Iÿÿÿÿ   Iÿÿÿÿ    =šH       statement executed        return ((HRESULT)0L);    Lÿÿÿÿ   I   	   Lÿÿÿÿ   I                    P   	   P      Mÿÿÿÿ   Mÿÿÿÿ    =›        statement executed        return ((HRESULT)1L);    Pÿÿÿÿ   M   	   Pÿÿÿÿ   M                    \      \      Yÿÿÿÿ   Yÿÿÿÿ     óµè       statement executed        }    \ÿÿÿÿ   Y      \ÿÿÿÿ   Y                    f   	   f   
   cÿÿÿÿ   cÿÿÿÿ     ó¼°       statement executed        }    fÿÿÿÿ   c   	   fÿÿÿÿ   c   
                 i      i   "   fÿÿÿÿ   fÿÿÿÿ     ó½ˆ       statement executed        return ((HRESULT)1L);    iÿÿÿÿ   f      iÿÿÿÿ   f   "                 p   	   p   
   mÿÿÿÿ   mÿÿÿÿ     ğ       statement executed        }    pÿÿÿÿ   m   	   pÿÿÿÿ   m   
                 (      (      &ÿÿÿÿ   &ÿÿÿÿ     ïÀ˜       statement executed        }    (ÿÿÿÿ   &      (ÿÿÿÿ   &                                !    ÿÿÿÿ    ÿÿÿÿ     'KĞ       statement executed        }     ÿÿÿÿ            ÿÿÿÿ       !        CPluginManagerDLL::CPluginManagerDLL CPluginManagerDLL::CPluginManagerDLL()    "      #      ÿÿÿÿ    ÿÿÿÿCPluginManagerDLL::~CPluginManagerDLL CPluginManagerDLL::~CPluginManagerDLL()    &      '      #ÿÿÿÿ   $ÿÿÿÿCPluginManagerDLL::LoadConvertersFromFolder HRESULT CPluginManagerDLL::LoadConvertersFromFolder(const TCHAR* pchPluginFolder)    )      R      &ÿÿÿÿ   OÿÿÿÿCPluginManagerDLL::LoadConverter HRESULT CPluginManagerDLL::LoadConverter(CString& strFileName)    U      t      Rÿÿÿÿ   qÿÿÿÿCPluginManagerDLL::UnLoadAllPlugins HRESULT CPluginManagerDLL::UnLoadAllPlugins()    x      ‘      uÿÿÿÿ   ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      PluginManagerDLL.cpp
 * \brief     Implementation of CPluginManagerDLL command target
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of CPluginManagerDLL command target
 */

#include "stdafx.h"
#include "PluginManagerDLL.h"
#include <shlwapi.h>

// CPluginManagerDLL

typedef HRESULT (*GETCONVERTERINTERFACE)(CBaseConverter*&);

CPluginManagerDLL::CPluginManagerDLL()
{
}

CPluginManagerDLL::~CPluginManagerDLL()
{
}
HRESULT CPluginManagerDLL::LoadConvertersFromFolder(CONST TCHAR* pchPluginFolder)
{
    TCHAR m_acEvalFilePath[MAX_PATH];
    CString strPluginPath;

    if(pchPluginFolder == NULL)
    {
        GetModuleFileName( NULL, m_acEvalFilePath, MAX_PATH );
        PathRemoveFileSpec(m_acEvalFilePath);
        strPluginPath = m_acEvalFilePath;
        strPluginPath += defDEFAULTPLUGINFOLDER;
    }
    else
    {
        strPluginPath = pchPluginFolder;
    }

    if(PathFileExists(strPluginPath) == TRUE)
    {
        SetCurrentDirectory(strPluginPath);
        CFileFind omFileFinder;
        CString strWildCard = defDLLFILEEXTENSION; //look for the plugin files
        BOOL bWorking = omFileFinder.FindFile(strWildCard);

        while (bWorking)
        {
            bWorking = omFileFinder.FindNextFile();

            if (omFileFinder.IsDots() || omFileFinder.IsDirectory())
            {
                continue;
            }

            LoadConverter(omFileFinder.GetFilePath());
        }

        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT CPluginManagerDLL::LoadConverter(CString& strFileName)
{
    ConverterInfo ConverterInfo;
    ConverterInfo.m_hModule = LoadLibrary(strFileName);

    if ( !ConverterInfo.m_hModule )
    {
        MessageBox(NULL, strFileName, _T("Plugin Loading Error"), MB_OK);
    }
    else
    {
        BOOL bSuccess = TRUE;
        GETCONVERTERINTERFACE pFnBaseConverter;
        pFnBaseConverter = (GETCONVERTERINTERFACE)GetProcAddress(ConverterInfo.m_hModule, defCONVERTERINTERFACE);

        if(pFnBaseConverter != NULL)
        {
            pFnBaseConverter(ConverterInfo.m_pouConverter);
        }
        else
        {
            return S_FALSE;
        }

        //Vlaidation
        if(bSuccess == TRUE)
        {
            m_ConverterList.AddTail(ConverterInfo);
        }
    }

    return S_OK;
}


HRESULT CPluginManagerDLL::UnLoadAllPlugins()
{
    INT_PTR nCount = m_ConverterList.GetCount();

    for(INT_PTR i = 0; i < nCount; i++)
    {
        POSITION pos = m_ConverterList.FindIndex(i);
        ConverterInfo& ouConverterInfo = m_ConverterList.GetAt(pos);

        if(ouConverterInfo.m_pouConverter != NULL)
        {
            delete ouConverterInfo.m_pouConverter;
        }

        if(ouConverterInfo.m_pomPage != NULL)
        {
            delete ouConverterInfo.m_pomPage;
        }

        if( ouConverterInfo.m_hModule != NULL)
        {
            FreeLibrary(ouConverterInfo.m_hModule);
        }
    }

    return S_OK;
}


























CRuntimeClass* __stdcall CExportLogFileDlg::_GetBaseClass() { return ((CRuntimeClass*)(&CPropertyPage::classCPropertyPage)); }  const  CRuntimeClass CExportLogFileDlg::classCExportLogFileDlg = { "CExportLogFileDlg", sizeof(class CExportLogFileDlg), 0xFFFF, 0, &CExportLogFileDlg::_GetBaseClass, 0 }; CRuntimeClass* CExportLogFileDlg::GetRuntimeClass() const { return ((CRuntimeClass*)(&CExportLogFileDlg::classCExportLogFileDlg)); }
CExportLogFileDlg::CExportLogFileDlg(ETYPE_BUS eBus, CWnd* pParent )
    : CPropertyPage(CExportLogFileDlg::IDD)
    , m_omStrLogFileName("")
    , m_omStrCSVFileName("")
{
    m_eBus = eBus;

    if (m_eBus == CAN)
    {
        m_pacFields = (CHAR_ARRAY_20*) acFields_CAN;
        m_unNoOfFileds = 7;
    }
    else if (m_eBus == J1939)
    {
        m_pacFields = (CHAR_ARRAY_20*)acFields_J1939;
        m_unNoOfFileds = 11;
    }
}

CExportLogFileDlg::~CExportLogFileDlg()
{
}

void CExportLogFileDlg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    DDX_Text(pDX, 1002, m_omStrLogFileName);
    DDX_Text(pDX, 1003, m_omStrCSVFileName);
    DDX_Control(pDX, 1004, m_omAvailableList);
    DDX_Control(pDX, 1005, m_omSelectedList);
    DDX_Control(pDX, 1006, m_omSelectAllFields);
    DDX_Control(pDX, 1007, m_omSelectOneField);
    DDX_Control(pDX, 1008, m_omRemoveOneField);
    DDX_Control(pDX, 1009, m_omRemoveAllFields);
    DDX_Control(pDX, 1015, m_omBusType);
}

const AFX_MSGMAP* __stdcall CExportLogFileDlg::_GetBaseMessageMap() { return &CPropertyPage::messageMap; } const AFX_MSGMAP* CExportLogFileDlg::GetMessageMap() const { return &CExportLogFileDlg::messageMap; }   const AFX_MSGMAP CExportLogFileDlg::messageMap = { &CExportLogFileDlg::_GetBaseMessageMap, &CExportLogFileDlg::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CExportLogFileDlg::_messageEntries[] = {
    { 0x0111, (WORD)0, (WORD)1010, (WORD)1010, AfxSig_vv, (AFX_PMSG)&OnBnClickedBtnLogBrowse },
    { 0x0111, (WORD)0, (WORD)1011, (WORD)1011, AfxSig_vv, (AFX_PMSG)&OnBnClickedBtnCsvBrowse },
    { 0x0111, (WORD)0, (WORD)1006, (WORD)1006, AfxSig_vv, (AFX_PMSG)&OnBnClickedButtonSelectall },
    { 0x0111, (WORD)0, (WORD)1012, (WORD)1012, AfxSig_vv, (AFX_PMSG)&OnBnClickedConvert },
    { 0x0111, (WORD)1, (WORD)1004, (WORD)1004, AfxSig_vv, (AFX_PMSG)&OnLbnSelchangeLstAvailable },
    { 0x0111, (WORD)1, (WORD)1005, (WORD)1005, AfxSig_vv, (AFX_PMSG)&OnLbnSelchangeLstSelected },
    { 0x0111, (WORD)0, (WORD)1007, (WORD)1007, AfxSig_vv, (AFX_PMSG)&OnBnClickedButtonSelectone },
    { 0x0111, (WORD)0, (WORD)1008, (WORD)1008, AfxSig_vv, (AFX_PMSG)&OnBnClickedButtonRemoveone },
    { 0x0111, (WORD)0, (WORD)1009, (WORD)1009, AfxSig_vv, (AFX_PMSG)&OnBnClickedButtonRemoveall },
    { 0x0111, (WORD)1, (WORD)1015, (WORD)1015, AfxSig_vv, (AFX_PMSG)&OnCbnSelchangeComboBustype },
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };







void CExportLogFileDlg::OnBnClickedBtnLogBrowse()
{
    UpdateData( 1 );
    
    CFileDialog omSaveAsDlg( 1 ,                 
                             "log",     
                             0,
                             0x00000004 | 0x00000002,
                             "*.log |*.log||",
                             0 );
    
    omSaveAsDlg.m_ofn.lpstrTitle  = "Select Log File";

    
    if ( omSaveAsDlg.DoModal() == 1 )
    {
        
        m_omStrLogFileName = omSaveAsDlg.GetPathName();
        INT nIndex = m_omStrLogFileName.ReverseFind('.');

        if ( nIndex >= 0)
        {
            CString omStrOutputFile = m_omStrLogFileName.Left(nIndex);
            omStrOutputFile += ".xls";
            m_omStrCSVFileName = omStrOutputFile;
        }

        UpdateData( 0 );
    }
}






void CExportLogFileDlg::OnBnClickedBtnCsvBrowse()
{
    UpdateData( 1 );
    
    CFileDialog omSaveAsDlg( 0,                 
                             "xls",     
                             0,
                             0x00000004 | 0x00000002,
                             "Comma Separated Values format (*.xls)|*.xls||",
                             0 );
    
    omSaveAsDlg.m_ofn.lpstrTitle  = "Select Export File";

    
    if ( omSaveAsDlg.DoModal() == 1 )
    {
        
        m_omStrCSVFileName = omSaveAsDlg.GetPathName();
        UpdateData( 0 );
    }
}






void CExportLogFileDlg::vEnableDisableControls()
{
    BOOL bSelectAllButtonEnable = 0;
    BOOL bRemoveAllButtonEnable = 0;
    BOOL bSelectOneButtonEnable = 0;
    BOOL bRemoveOneButtonEnable = 0;

    
    if( m_omAvailableList.GetCount() != 0 && m_omAvailableList.GetCurSel() != -1 )
    {
        bSelectAllButtonEnable = 1;
        bSelectOneButtonEnable = 1;
    }

    if( m_omSelectedList.GetCount() != 0 && m_omSelectedList.GetCurSel() != -1 )
    {
        bRemoveAllButtonEnable = 1;
        bRemoveOneButtonEnable = 1;
    }

    
    m_omSelectAllFields.EnableWindow( bSelectAllButtonEnable );
    m_omSelectOneField.EnableWindow( bSelectOneButtonEnable );
    m_omRemoveOneField.EnableWindow( bRemoveOneButtonEnable );
    m_omRemoveAllFields.EnableWindow( bRemoveAllButtonEnable );
}






void CExportLogFileDlg::vPopulateAvailableList()
{
    
    m_omAvailableList.ResetContent();
    m_omSelectedList.ResetContent();

    for( UINT unIndex = 0; unIndex < m_unNoOfFileds; unIndex++)
    {
        m_omAvailableList.InsertString( unIndex, m_pacFields[unIndex]);
        m_omAvailableList.SetItemData( unIndex, unIndex );
    }
}






void CExportLogFileDlg::OnBnClickedButtonSelectall()
{
    int nSelectedItem = m_omAvailableList.GetCurSel();
    DWORD_PTR nFieldIndex;

    if( nSelectedItem != -1 )
    {
        nSelectedItem=0;

        while(m_omAvailableList.GetCount()!=0)
        {
            nFieldIndex = m_omAvailableList.GetItemData( nSelectedItem );
            m_omAvailableList.DeleteString( nSelectedItem );
            m_omAvailableList.SetCurSel( nSelectedItem );
            
            int nNewItemIndex = m_omSelectedList.InsertString(
                                    m_omSelectedList.GetCount(),
                                    m_pacFields[ nFieldIndex ] );
            
            m_omSelectedList.SetItemData( nNewItemIndex, nFieldIndex );
            
            m_omSelectedList.SetCurSel( nNewItemIndex );
        }
    }

    
    vEnableDisableControls();
}






BOOL CExportLogFileDlg::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    CString omStrBus;

    if (m_eBus == CAN)
    {
        omStrBus = "CAN";
    }
    else if (m_eBus == J1939)
    {
        omStrBus = "J1939";
    }

    m_omBusType.SelectString(0, omStrBus);
    vPopulateAvailableList();
    vEnableDisableControls();
    return 1;
}






void CExportLogFileDlg::OnBnClickedConvert()
{
    
    CString strLogFileName = m_omStrLogFileName;
    CString strCSVFileName = m_omStrCSVFileName;

    

    if( strLogFileName != "" && strCSVFileName != "" )
    {
        if( m_omSelectedList.GetCount() != 0 )
        {
            
            
            CLogToExcel oExport( strLogFileName.GetBuffer(260),strCSVFileName.GetBuffer(260), m_unNoOfFileds, m_pacFields);
            
            oExport.fnSetSelectedFields( &(this->m_omSelectedList) );

            
			HRESULT hResult = oExport.bConvert();
            if( ((HRESULT)0L) != hResult )
            {
				string omStrError;
				oExport.GetErrorString( hResult, omStrError);
                MessageBoxA(omStrError.c_str(),"BUSMASTER",0x00000000L);
            }
            else
            {
				MessageBoxA("Successfully converted text file to Excel File!","BUSMASTER",0x00000000L);
                
            }
        }
        else
        {
            MessageBoxA("No fields selected!","BUSMASTER",0x00000000L);
        }
    }
    else
    {
        MessageBoxA("Enter Log and CSV file details!","BUSMASTER",0x00000000L);
    }
}







void CExportLogFileDlg::OnLbnSelchangeLstAvailable()
{
    
    vEnableDisableControls();
}






void CExportLogFileDlg::OnLbnSelchangeLstSelected()
{
    vEnableDisableControls();
}






void CExportLogFileDlg::OnBnClickedButtonSelectone()
{
    
    int nSelectedItem = m_omAvailableList.GetCurSel();

    
    if( nSelectedItem != -1 )
    {
        
        DWORD_PTR nFieldIndex = m_omAvailableList.GetItemData( nSelectedItem );

        if( nFieldIndex >= 0 && nFieldIndex < m_unNoOfFileds )
        {
            
            m_omAvailableList.DeleteString( nSelectedItem );

            
            if( nSelectedItem == m_omAvailableList.GetCount() )
            {
                nSelectedItem--;
            }

            m_omAvailableList.SetCurSel( nSelectedItem );
            
            int nNewItemIndex = m_omSelectedList.InsertString(
                                    m_omSelectedList.GetCount(),
                                    m_pacFields[ nFieldIndex ] );
            
            m_omSelectedList.SetItemData( nNewItemIndex, nFieldIndex );
            
            m_omSelectedList.SetCurSel( nNewItemIndex );
            
            vEnableDisableControls();
        }
    }
}






void CExportLogFileDlg::OnBnClickedButtonRemoveone()
{
    
    int nSelectedItem = m_omSelectedList.GetCurSel();

    
    if( nSelectedItem != -1 )
    {
        
        DWORD_PTR nFieldIndex = m_omSelectedList.GetItemData( nSelectedItem );
        
        m_omSelectedList.DeleteString( nSelectedItem );

        
        if( nSelectedItem == m_omSelectedList.GetCount() )
        {
            nSelectedItem--;
        }

        m_omSelectedList.SetCurSel( nSelectedItem );
        
        int nNewItemIndex = m_omAvailableList.GetCount();

        for( int nIndex = 0; nIndex < m_omAvailableList.GetCount(); nIndex++ )
        {
            if( m_omAvailableList.GetItemData( nIndex ) > nFieldIndex )
            {
                nNewItemIndex = nIndex;
                
                nIndex = m_omAvailableList.GetCount();
            }
        }

        if( nNewItemIndex != -1 )
        {
            m_omAvailableList.InsertString( nNewItemIndex,
                                            m_pacFields[ nFieldIndex ] );
        }
        else
        {
            nNewItemIndex = m_omAvailableList.AddString(
                                m_pacFields[ nFieldIndex ] );
        }

        
        m_omAvailableList.SetItemData( nNewItemIndex, nFieldIndex );
        
        m_omAvailableList.SetCurSel( nNewItemIndex );
        
        vEnableDisableControls();
    }
}






void CExportLogFileDlg::OnBnClickedButtonRemoveall()
{
    int nSelectedItem = m_omSelectedList.GetCurSel();
    DWORD_PTR nFieldIndex;

    if( nSelectedItem != -1 )
    {
        nSelectedItem=0;

        while(m_omSelectedList.GetCount()!=0)
        {
            
            nFieldIndex = m_omSelectedList.GetItemData( nSelectedItem );
            
            m_omSelectedList.DeleteString( nSelectedItem );
            
            m_omSelectedList.SetCurSel( nSelectedItem );
            
            int nNewItemIndex = m_omAvailableList.GetCount();

            for( int nIndex = 0; nIndex < m_omAvailableList.GetCount(); nIndex++ )
            {
                if( m_omAvailableList.GetItemData( nIndex ) > nFieldIndex )
                {
                    nNewItemIndex = nIndex;
                    
                    nIndex = m_omAvailableList.GetCount();
                }
            }

            if( nNewItemIndex != -1 )
            {
                m_omAvailableList.InsertString( nNewItemIndex,
                                                m_pacFields[ nFieldIndex ] );
            }
            else
            {
                nNewItemIndex = m_omAvailableList.AddString(
                                    m_pacFields[ nFieldIndex ] );
            }

            
            m_omAvailableList.SetItemData( nNewItemIndex, nFieldIndex );
            
            m_omAvailableList.SetCurSel( nNewItemIndex );
            
        }
    }

    vEnableDisableControls();
}






void CExportLogFileDlg::OnCbnSelchangeComboBustype()
{
    CString omStrBus;
    m_omBusType.GetWindowTextA(omStrBus);
    CString omTitle("Export Log File - ");

    if( omStrBus == "CAN")
    {
        omTitle += "CAN";
        m_eBus = CAN;
        m_pacFields = (CHAR_ARRAY_20*) acFields_CAN;
        m_unNoOfFileds = 7;
    }
    else if ( omStrBus == "J1939")
    {
        omTitle += "J1939";
        m_eBus = J1939;
        m_pacFields = (CHAR_ARRAY_20*)acFields_J1939;
        m_unNoOfFileds = 11;
    }

    SetWindowTextA(omTitle);
    vPopulateAvailableList();
    vEnableDisableControls();
	m_omStrLogFileName = "";
	m_omStrCSVFileName = "";
	UpdateData(0);
}
          ¤   -   ¤   O   ¢ÿÿÿÿ   ¢ÿÿÿÿ    :ç       expression was true       m_omSelectedList.GetCurSel() != -1    ¤ÿÿÿÿ   ¢   -   ¤ÿÿÿÿ   ¢   O   expression was false       m_omSelectedList.GetCurSel() != -1    ¤ÿÿÿÿ   ¢   -   ¤ÿÿÿÿ   ¢   O               :èĞ         ¤   	   ¤   )   ¢ÿÿÿÿ   ¢ÿÿÿÿ    :æH      expression was true       m_omSelectedList.GetCount() != 0    ¤ÿÿÿÿ   ¢   	   ¤ÿÿÿÿ   ¢   )   expression was false       m_omSelectedList.GetCount() != 0    ¤ÿÿÿÿ   ¢   	   ¤ÿÿÿÿ   ¢   )                ç             .      Q   œÿÿÿÿ   œÿÿÿÿ     îE       expression was true       m_omAvailableList.GetCurSel() != -1    ÿÿÿÿ   œ   .   ÿÿÿÿ   œ   Q   expression was false       m_omAvailableList.GetCurSel() != -1    ÿÿÿÿ   œ   .   ÿÿÿÿ   œ   Q               ,èĞ            	      *   œÿÿÿÿ   œÿÿÿÿ    ,é¨      expression was true       m_omAvailableList.GetCount() != 0    ÿÿÿÿ   œ   	   ÿÿÿÿ   œ   *   expression was false       m_omAvailableList.GetCount() != 0    ÿÿÿÿ   œ   	   ÿÿÿÿ   œ   *               :ä(        Á   "  Á   G  ¿ÿÿÿÿ  ¿ÿÿÿÿ    h      expression was false       nIndex < m_omAvailableList.GetCount()   Áÿÿÿÿ  ¿   "  Áÿÿÿÿ  ¿   G           	     Š     Š   C  ˆÿÿÿÿ  ˆÿÿÿÿ    	ü¨      expression was false       nIndex < m_omAvailableList.GetCount()   Šÿÿÿÿ  ˆ     Šÿÿÿÿ  ˆ   C           
      ¼      ¼   4   ºÿÿÿÿ   ºÿÿÿÿ     ïËH      expression was false       unIndex < m_unNoOfFileds    ¼ÿÿÿÿ   º      ¼ÿÿÿÿ   º   4                ¶     ¶   -  ´ÿÿÿÿ  ´ÿÿÿÿ    H      expression was false       m_omSelectedList.GetCount()!=0   ¶ÿÿÿÿ  ´     ¶ÿÿÿÿ  ´   -                        Ñ      Ñ   .   Ïÿÿÿÿ   Ïÿÿÿÿ     *ôÀ      expression was false       m_omAvailableList.GetCount()!=0    Ñÿÿÿÿ   Ï      Ñÿÿÿÿ   Ï   .               “-x           	       	ÿÿÿÿ  	ÿÿÿÿ     ı¨      expression was true       strLogFileName != ""   ÿÿÿÿ  	   	  ÿÿÿÿ  	      expression was false       strLogFileName != ""   ÿÿÿÿ  	   	  ÿÿÿÿ  	                   ı¦         ó     ó   "  ñÿÿÿÿ  ñÿÿÿÿ    ^À      expression was false       omStrBus == "J1939"   óÿÿÿÿ  ñ     óÿÿÿÿ  ñ   "               W        Ã     Ã   J  Áÿÿÿÿ  Áÿÿÿÿ    
¸      expression was false       m_omAvailableList.GetItemData( nIndex ) > nFieldIndex   Ãÿÿÿÿ  Á     Ãÿÿÿÿ  Á   J                ²   	  ²     °ÿÿÿÿ  °ÿÿÿÿ    IĞ      expression was false       nSelectedItem != -1   ²ÿÿÿÿ  °   	  ²ÿÿÿÿ  °                   /®p        Œ     Œ   F  Šÿÿÿÿ  Šÿÿÿÿ    	úø      expression was false       m_omAvailableList.GetItemData( nIndex ) > nFieldIndex   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š   F                        9  ÿÿÿÿ  ÿÿÿÿ    	ó€      expression was false       nSelectedItem == m_omSelectedList.GetCount()   ÿÿÿÿ       ÿÿÿÿ     9               	ñp        y   	  y     wÿÿÿÿ  wÿÿÿÿ     /¨      expression was false       nSelectedItem != -1   yÿÿÿÿ  w   	  yÿÿÿÿ  w                  b‹H        Z     Z   >  Xÿÿÿÿ  Xÿÿÿÿ    WÜp      expression was false       nSelectedItem == m_omAvailableList.GetCount()   Zÿÿÿÿ  X     Zÿÿÿÿ  X   >               WÚ`           !     5  	ÿÿÿÿ  	ÿÿÿÿ     ı©       expression was true       strCSVFileName != ""   ÿÿÿÿ  	   !  ÿÿÿÿ  	   5   expression was false       strCSVFileName != ""   ÿÿÿÿ  	   !  ÿÿÿÿ  	   5                ı§@        O   	  O     Mÿÿÿÿ  Mÿÿÿÿ    b†      expression was false       nSelectedItem != -1   Oÿÿÿÿ  M   	  Oÿÿÿÿ  M                  WÒ`         ó      ó      ñÿÿÿÿ   ñÿÿÿÿ    „Ãğ      expression was false       m_eBus == J1939    óÿÿÿÿ   ñ      óÿÿÿÿ   ñ                  „Á          Í   	   Í      Ëÿÿÿÿ   Ëÿÿÿÿ    ((€      expression was false       nSelectedItem != -1    Íÿÿÿÿ   Ë   	   Íÿÿÿÿ   Ë                  “+        T     T     Rÿÿÿÿ  Rÿÿÿÿ    WÖp      expression was true       nFieldIndex >= 0   Tÿÿÿÿ  R     Tÿÿÿÿ  R      expression was false       nFieldIndex >= 0   Tÿÿÿÿ  R     Tÿÿÿÿ  R                  WÕP        T   !  T   =  Rÿÿÿÿ  Rÿÿÿÿ    W×X      expression was true       nFieldIndex < m_unNoOfFileds   Tÿÿÿÿ  R   !  Tÿÿÿÿ  R   =   expression was false       nFieldIndex < m_unNoOfFileds   Tÿÿÿÿ  R   !  Tÿÿÿÿ  R   =                 ‰   
   ‰   $   ‡ÿÿÿÿ   ‡ÿÿÿÿ    À      expression was false       omSaveAsDlg.DoModal() == 1    ‰ÿÿÿÿ   ‡   
   ‰ÿÿÿÿ   ‡   $               0š@          k      k      iÿÿÿÿ   iÿÿÿÿ    Àè      expression was false       nIndex >= 0    kÿÿÿÿ   i      kÿÿÿÿ   i                   ç`   !      e   
   e   $   cÿÿÿÿ   cÿÿÿÿ     çp      expression was false       omSaveAsDlg.DoModal() == 1    eÿÿÿÿ   c   
   eÿÿÿÿ   c   $               Mp   "      +      +      )ÿÿÿÿ   )ÿÿÿÿ     îK      expression was false       m_eBus == J1939    +ÿÿÿÿ   )      +ÿÿÿÿ   )                  ¿PÀ   #               ÿÿÿÿÿ  ÿÿÿÿÿ    †RØ       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              $     ù     ù     ÷ÿÿÿÿ  ÷ÿÿÿÿ    ]è       statement executed        }   ùÿÿÿÿ  ÷     ùÿÿÿÿ  ÷              %     ò     ò     ğÿÿÿÿ  ğÿÿÿÿ    V       statement executed        }   òÿÿÿÿ  ğ     òÿÿÿÿ  ğ              &     ß     ß     İÿÿÿÿ  İÿÿÿÿ    K       statement executed        }   ßÿÿÿÿ  İ     ßÿÿÿÿ  İ              '     Ü     Ü     Úÿÿÿÿ  Úÿÿÿÿ    Hø       statement executed        }   Üÿÿÿÿ  Ú     Üÿÿÿÿ  Ú              (     Û   	  Û   
  Ùÿÿÿÿ  Ùÿÿÿÿ    G8       statement executed        }   Ûÿÿÿÿ  Ù   	  Ûÿÿÿÿ  Ù   
           )     Ô     Ô     Òÿÿÿÿ  Òÿÿÿÿ    D`       statement executed        }   Ôÿÿÿÿ  Ò     Ôÿÿÿÿ  Ò              *     Ï     Ï     Íÿÿÿÿ  Íÿÿÿÿ    à       statement executed        }   Ïÿÿÿÿ  Í     Ïÿÿÿÿ  Í              +     É     É     Çÿÿÿÿ  Çÿÿÿÿ           statement executed        }   Éÿÿÿÿ  Ç     Éÿÿÿÿ  Ç              ,     È     È     Æÿÿÿÿ  Æÿÿÿÿ    	à       statement executed        }   Èÿÿÿÿ  Æ     Èÿÿÿÿ  Æ              -     ¦     ¦     ¤ÿÿÿÿ  ¤ÿÿÿÿ     /©x       statement executed        }   ¦ÿÿÿÿ  ¤     ¦ÿÿÿÿ  ¤              .     ¥     ¥     £ÿÿÿÿ  £ÿÿÿÿ     /§¸       statement executed        }   ¥ÿÿÿÿ  £     ¥ÿÿÿÿ  £              /        	     
  ›ÿÿÿÿ  ›ÿÿÿÿ     /¤       statement executed        }   ÿÿÿÿ  ›   	  ÿÿÿÿ  ›   
           0     ˜   	  ˜   
  –ÿÿÿÿ  –ÿÿÿÿ     /¢H       statement executed        }   ˜ÿÿÿÿ  –   	  ˜ÿÿÿÿ  –   
           1     ’   	  ’   
  ÿÿÿÿ  ÿÿÿÿ    	ûĞ       statement executed        }   ’ÿÿÿÿ     	  ’ÿÿÿÿ     
           2     ‘     ‘     ÿÿÿÿ  ÿÿÿÿ    	ú        statement executed        }   ‘ÿÿÿÿ       ‘ÿÿÿÿ                3     „   	  „   
  ‚ÿÿÿÿ  ‚ÿÿÿÿ    	ò¨       statement executed        }   „ÿÿÿÿ  ‚   	  „ÿÿÿÿ  ‚   
           4     l     l     jÿÿÿÿ  jÿÿÿÿ    b†ø       statement executed        }   lÿÿÿÿ  j     lÿÿÿÿ  j              5     k     k     iÿÿÿÿ  iÿÿÿÿ    b…8       statement executed        }   kÿÿÿÿ  i     kÿÿÿÿ  i              6     j   	  j   
  hÿÿÿÿ  hÿÿÿÿ    bƒx       statement executed        }   jÿÿÿÿ  h   	  jÿÿÿÿ  h   
           7     ]     ]     [ÿÿÿÿ  [ÿÿÿÿ    WÛ˜       statement executed        }   ]ÿÿÿÿ  [     ]ÿÿÿÿ  [              8     B     B     @ÿÿÿÿ  @ÿÿÿÿ    dğ       statement executed        }   Bÿÿÿÿ  @     Bÿÿÿÿ  @              9     8     8     6ÿÿÿÿ  6ÿÿÿÿ    d@       statement executed        }   8ÿÿÿÿ  6     8ÿÿÿÿ  6              :     +     +     )ÿÿÿÿ  )ÿÿÿÿ    d       statement executed        }   +ÿÿÿÿ  )     +ÿÿÿÿ  )              ;     &   	  &   
  $ÿÿÿÿ  $ÿÿÿÿ    d(       statement executed        }   &ÿÿÿÿ  $   	  &ÿÿÿÿ  $   
           <     !     !     ÿÿÿÿ  ÿÿÿÿ    dh       statement executed        }   !ÿÿÿÿ       !ÿÿÿÿ                =               ÿÿÿÿ  ÿÿÿÿ    :n°       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                >      û      û      ùÿÿÿÿ   ùÿÿÿÿ     ı h       statement executed        return 1;    ûÿÿÿÿ   ù      ûÿÿÿÿ   ù              ?      ö      ö      ôÿÿÿÿ   ôÿÿÿÿ    „Ã       statement executed        }    öÿÿÿÿ   ô      öÿÿÿÿ   ô              @         ?      }   ÿÿÿÿ   ÿÿÿÿ    6Â(       statement executed        return ((CRuntimeClass*)(&CPropertyPage::classCPropertyPage));    ÿÿÿÿ      ?   ÿÿÿÿ      }           A        i     ¯   ÿÿÿÿ   ÿÿÿÿ    ¿Q˜       statement executed        return ((CRuntimeClass*)(&CExportLogFileDlg::classCExportLogFileDlg));    ÿÿÿÿ     i   ÿÿÿÿ     ¯           B      *      *      (ÿÿÿÿ   (ÿÿÿÿ    ¿YÈ       statement executed        }    *ÿÿÿÿ   (      *ÿÿÿÿ   (              C      /      /      -ÿÿÿÿ   -ÿÿÿÿ    ,æ        statement executed        }    /ÿÿÿÿ   -      /ÿÿÿÿ   -              D      4      4      2ÿÿÿÿ   2ÿÿÿÿ     ñX        statement executed        }    4ÿÿÿÿ   2      4ÿÿÿÿ   2              E      B      B      @ÿÿÿÿ   @ÿÿÿÿ    ¿Tğ       statement executed        }    Bÿÿÿÿ   @      Bÿÿÿÿ   @              F      D   G   D   i   Bÿÿÿÿ   Bÿÿÿÿ    6Ê¸       statement executed        return &CPropertyPage::messageMap;    Dÿÿÿÿ   B   G   Dÿÿÿÿ   B   i           G      D   ©   D   Ï   Bÿÿÿÿ   Bÿÿÿÿ    6Ã`       statement executed        return &CExportLogFileDlg::messageMap;    Dÿÿÿÿ   B   ©   Dÿÿÿÿ   B   Ï           H      p   	   p   
   nÿÿÿÿ   nÿÿÿÿ     çà       statement executed        }    pÿÿÿÿ   n   	   pÿÿÿÿ   n   
           I      s      s      qÿÿÿÿ   qÿÿÿÿ    Àx       statement executed        }    sÿÿÿÿ   q      sÿÿÿÿ   q              J      t      t      rÿÿÿÿ   rÿÿÿÿ    6ÆP       statement executed        }    tÿÿÿÿ   r      tÿÿÿÿ   r              K                  Œÿÿÿÿ   Œÿÿÿÿ     , à       statement executed        }    ÿÿÿÿ   Œ      ÿÿÿÿ   Œ              L                  ÿÿÿÿ   ÿÿÿÿ    À˜       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                 M      ¢      ¢       ÿÿÿÿ    ÿÿÿÿ    ÀW        statement executed        }    ¢ÿÿÿÿ          ¢ÿÿÿÿ                  N      ¨      ¨      ¦ÿÿÿÿ   ¦ÿÿÿÿ     îG        statement executed        }    ¨ÿÿÿÿ   ¦      ¨ÿÿÿÿ   ¦              O      ¯      ¯      ­ÿÿÿÿ   ­ÿÿÿÿ    ,pè       statement executed        }    ¯ÿÿÿÿ   ­      ¯ÿÿÿÿ   ­              P      À      À      ¾ÿÿÿÿ   ¾ÿÿÿÿ     ïÊp       statement executed        }    Àÿÿÿÿ   ¾      Àÿÿÿÿ   ¾              Q      Á      Á      ¿ÿÿÿÿ   ¿ÿÿÿÿ     ïÌ        statement executed        }    Áÿÿÿÿ   ¿      Áÿÿÿÿ   ¿              R      Ş   	   Ş   
   Üÿÿÿÿ   Üÿÿÿÿ     *óè       statement executed        }    Şÿÿÿÿ   Ü   	   Şÿÿÿÿ   Ü   
           S      ß      ß      İÿÿÿÿ   İÿÿÿÿ     *õ¨       statement executed        }    ßÿÿÿÿ   İ      ßÿÿÿÿ   İ              T      ã      ã      áÿÿÿÿ   áÿÿÿÿ    ()`       statement executed        }    ãÿÿÿÿ   á      ãÿÿÿÿ   á              U      ò      ò      ğÿÿÿÿ   ğÿÿÿÿ    „À       statement executed        }    òÿÿÿÿ   ğ      òÿÿÿÿ   ğ           CExportLogFileDlg::_GetBaseClass CRuntimeClass* __stdcall CExportLogFileDlg::_GetBaseClass()       =         ÿÿÿÿ   ÿÿÿÿCExportLogFileDlg::GetRuntimeClass CRuntimeClass* CExportLogFileDlg::GetRuntimeClass()      g     ±   ÿÿÿÿ   ÿÿÿÿCExportLogFileDlg::CExportLogFileDlg CExportLogFileDlg::CExportLogFileDlg(ETYPE_BUS eBus, CWnd* pParent )    #      0      !ÿÿÿÿ   .ÿÿÿÿCExportLogFileDlg::~CExportLogFileDlg CExportLogFileDlg::~CExportLogFileDlg()    3      4      1ÿÿÿÿ   2ÿÿÿÿCExportLogFileDlg::DoDataExchange void CExportLogFileDlg::DoDataExchange(CDataExchange* pDX)    7      B      5ÿÿÿÿ   @ÿÿÿÿCExportLogFileDlg::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CExportLogFileDlg::_GetBaseMessageMap()    D   E   D   k   Bÿÿÿÿ   BÿÿÿÿCExportLogFileDlg::GetMessageMap const AFX_MSGMAP* CExportLogFileDlg::GetMessageMap()    D   §   D   Ñ   Bÿÿÿÿ   BÿÿÿÿCExportLogFileDlg::OnBnClickedBtnLogBrowse void CExportLogFileDlg::OnBnClickedBtnLogBrowse()    X      t      Vÿÿÿÿ   rÿÿÿÿCExportLogFileDlg::OnBnClickedBtnCsvBrowse void CExportLogFileDlg::OnBnClickedBtnCsvBrowse()    |            zÿÿÿÿ   ÿÿÿÿCExportLogFileDlg::vEnableDisableControls void CExportLogFileDlg::vEnableDisableControls()    —      ¯      •ÿÿÿÿ   ­ÿÿÿÿCExportLogFileDlg::vPopulateAvailableList void CExportLogFileDlg::vPopulateAvailableList()    ·      Á      µÿÿÿÿ   ¿ÿÿÿÿCExportLogFileDlg::OnBnClickedButtonSelectall void CExportLogFileDlg::OnBnClickedButtonSelectall()    É      ã      Çÿÿÿÿ   áÿÿÿÿCExportLogFileDlg::OnInitDialog BOOL CExportLogFileDlg::OnInitDialog()    ë      ü      éÿÿÿÿ   úÿÿÿÿCExportLogFileDlg::OnBnClickedConvert void CExportLogFileDlg::OnBnClickedConvert()        ,     ÿÿÿÿ  *ÿÿÿÿCExportLogFileDlg::OnLbnSelchangeLstAvailable void CExportLogFileDlg::OnLbnSelchangeLstAvailable()   5     8     3ÿÿÿÿ  6ÿÿÿÿCExportLogFileDlg::OnLbnSelchangeLstSelected void CExportLogFileDlg::OnLbnSelchangeLstSelected()   @     B     >ÿÿÿÿ  @ÿÿÿÿCExportLogFileDlg::OnBnClickedButtonSelectone void CExportLogFileDlg::OnBnClickedButtonSelectone()   J     l     Hÿÿÿÿ  jÿÿÿÿCExportLogFileDlg::OnBnClickedButtonRemoveone void CExportLogFileDlg::OnBnClickedButtonRemoveone()   t     ¦     rÿÿÿÿ  ¤ÿÿÿÿCExportLogFileDlg::OnBnClickedButtonRemoveall void CExportLogFileDlg::OnBnClickedButtonRemoveall()   ®     ß     ¬ÿÿÿÿ  İÿÿÿÿCExportLogFileDlg::OnCbnSelchangeComboBustype void CExportLogFileDlg::OnCbnSelchangeComboBustype()   ç          åÿÿÿÿ  ÿÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ExportLogFileDlg.cpp
 * \brief     Definition of CExportLogFileDlg class
 * \authors   Pradeep Kadoor, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the CExportLogFileDlg class.
 */

/* Project includes */
#include "Defines.h"
#include "ExportLogFileDlg.h"
#include "resource.h"

IMPLEMENT_DYNAMIC(CExportLogFileDlg, CPropertyPage)
CExportLogFileDlg::CExportLogFileDlg(ETYPE_BUS eBus, CWnd* pParent /*=NULL*/)
    : CPropertyPage(CExportLogFileDlg::IDD)
    , m_omStrLogFileName(_T(""))
    , m_omStrCSVFileName(_T(""))
{
    m_eBus = eBus;

    if (m_eBus == CAN)
    {
        m_pacFields = (CHAR_ARRAY_20*) acFields_CAN;
        m_unNoOfFileds = defNO_OF_FIELDS_CAN;
    }
    else if (m_eBus == J1939)
    {
        m_pacFields = (CHAR_ARRAY_20*)acFields_J1939;
        m_unNoOfFileds = defNO_OF_FIELDS_J1939;
    }
}

CExportLogFileDlg::~CExportLogFileDlg()
{
}

void CExportLogFileDlg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    DDX_Text(pDX, IDC_EDIT_LOG_FILE_NAME, m_omStrLogFileName);
    DDX_Text(pDX, IDC_EDIT_CSV_FILE_NAME, m_omStrCSVFileName);
    DDX_Control(pDX, IDC_LST_AVAILABLE, m_omAvailableList);
    DDX_Control(pDX, IDC_LST_SELECTED, m_omSelectedList);
    DDX_Control(pDX, IDC_BUTTON_SELECTALL, m_omSelectAllFields);
    DDX_Control(pDX, IDC_BUTTON_SELECTONE, m_omSelectOneField);
    DDX_Control(pDX, IDC_BUTTON_REMOVEONE, m_omRemoveOneField);
    DDX_Control(pDX, IDC_BUTTON_REMOVEALL, m_omRemoveAllFields);
    DDX_Control(pDX, IDC_COMBO_BUSTYPE, m_omBusType);
}

BEGIN_MESSAGE_MAP(CExportLogFileDlg, CPropertyPage)
    ON_BN_CLICKED(IDC_BTN_LOG_BROWSE, OnBnClickedBtnLogBrowse)
    ON_BN_CLICKED(IDC_BTN_CSV_BROWSE, OnBnClickedBtnCsvBrowse)
    ON_BN_CLICKED(IDC_BUTTON_SELECTALL, OnBnClickedButtonSelectall)
    ON_BN_CLICKED(ID_CONVERT, OnBnClickedConvert)
    ON_LBN_SELCHANGE(IDC_LST_AVAILABLE, OnLbnSelchangeLstAvailable)
    ON_LBN_SELCHANGE(IDC_LST_SELECTED, OnLbnSelchangeLstSelected)
    ON_BN_CLICKED(IDC_BUTTON_SELECTONE, OnBnClickedButtonSelectone)
    ON_BN_CLICKED(IDC_BUTTON_REMOVEONE, OnBnClickedButtonRemoveone)
    ON_BN_CLICKED(IDC_BUTTON_REMOVEALL, OnBnClickedButtonRemoveall)
    ON_CBN_SELCHANGE(IDC_COMBO_BUSTYPE, OnCbnSelchangeComboBustype)
END_MESSAGE_MAP()


/**
 * \brief On Button Clicked Button Log Browse
 *
 * To show file selection dialog for log File
 */
void CExportLogFileDlg::OnBnClickedBtnLogBrowse()
{
    UpdateData( TRUE );
    // Create Save File Dialog with overwrite warning
    CFileDialog omSaveAsDlg( TRUE ,                 // Save File dialog
                             defSTR_LOG_FORMAT,     // Default Extension,
                             NULL,
                             OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
                             defSTR_LOG_FORMAT_SPECIFIER,
                             NULL );
    // Set Title to Export
    omSaveAsDlg.m_ofn.lpstrTitle  = defSTR_LOG_DIALOG_CAPTION;

    // Show file save dialog
    if ( omSaveAsDlg.DoModal() == IDOK )
    {
        // Save the selected path
        m_omStrLogFileName = omSaveAsDlg.GetPathName();
        INT nIndex = m_omStrLogFileName.ReverseFind('.');

        if ( nIndex >= 0)
        {
            CString omStrOutputFile = m_omStrLogFileName.Left(nIndex);
            omStrOutputFile += ".xls";
            m_omStrCSVFileName = omStrOutputFile;
        }

        UpdateData( FALSE );
    }
}

/**
 * \brief On Button Clicked Button CSV Browse
 *
 * To show file selection dialog for CSV File
 */
void CExportLogFileDlg::OnBnClickedBtnCsvBrowse()
{
    UpdateData( TRUE );
    // Create Save File Dialog with overwrite warning
    CFileDialog omSaveAsDlg( FALSE,                 // Save File dialog
                             defSTR_XLS_FORMAT,     // Default Extension,
                             NULL,
                             OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
                             defSTR_XLS_FORMAT_SPECIFIER,
                             NULL );
    // Set Title to Export
    omSaveAsDlg.m_ofn.lpstrTitle  = defSTR_CSV_DIALOG_CAPTION;

    // Show file save dialog
    if ( omSaveAsDlg.DoModal() == IDOK )
    {
        // Save the selected path
        m_omStrCSVFileName = omSaveAsDlg.GetPathName();
        UpdateData( FALSE );
    }
}

/**
 * \brief Enable/Disable Controls
 *
 * Enable/Disable Controls
 */
void CExportLogFileDlg::vEnableDisableControls()
{
    BOOL bSelectAllButtonEnable = FALSE;
    BOOL bRemoveAllButtonEnable = FALSE;
    BOOL bSelectOneButtonEnable = FALSE;
    BOOL bRemoveOneButtonEnable = FALSE;

    // Select Button
    if( m_omAvailableList.GetCount() != 0 && m_omAvailableList.GetCurSel() != -1 )
    {
        bSelectAllButtonEnable = TRUE;
        bSelectOneButtonEnable = TRUE;
    }

    if( m_omSelectedList.GetCount() != 0 && m_omSelectedList.GetCurSel() != -1 )
    {
        bRemoveAllButtonEnable = TRUE;
        bRemoveOneButtonEnable = TRUE;
    }

    // update Button Status
    m_omSelectAllFields.EnableWindow( bSelectAllButtonEnable );
    m_omSelectOneField.EnableWindow( bSelectOneButtonEnable );
    m_omRemoveOneField.EnableWindow( bRemoveOneButtonEnable );
    m_omRemoveAllFields.EnableWindow( bRemoveAllButtonEnable );
}

/**
 * \brief Populate Available List
 *
 * Populate Available List
 */
void CExportLogFileDlg::vPopulateAvailableList()
{
    // Insert filed text
    m_omAvailableList.ResetContent();
    m_omSelectedList.ResetContent();

    for( UINT unIndex = 0; unIndex < m_unNoOfFileds; unIndex++)
    {
        m_omAvailableList.InsertString( unIndex, m_pacFields[unIndex]);
        m_omAvailableList.SetItemData( unIndex, unIndex );
    }
}

/**
 * \brief On Button Clicked Button Select All
 *
 * Message handler for select all button
 */
void CExportLogFileDlg::OnBnClickedButtonSelectall()
{
    int nSelectedItem = m_omAvailableList.GetCurSel();
    DWORD_PTR nFieldIndex;

    if( nSelectedItem != -1 )
    {
        nSelectedItem=0;

        while(m_omAvailableList.GetCount()!=0)
        {
            nFieldIndex = m_omAvailableList.GetItemData( nSelectedItem );
            m_omAvailableList.DeleteString( nSelectedItem );
            m_omAvailableList.SetCurSel( nSelectedItem );
            // Add it in to the selected list
            int nNewItemIndex = m_omSelectedList.InsertString(
                                    m_omSelectedList.GetCount(),
                                    m_pacFields[ nFieldIndex ] );
            // Set Field index as item data
            m_omSelectedList.SetItemData( nNewItemIndex, nFieldIndex );
            // Set the selection
            m_omSelectedList.SetCurSel( nNewItemIndex );
        }
    }

    // Update UI buttons status
    vEnableDisableControls();
}

/**
 * \brief On Init Dialog
 *
 * Init dialog
 */
BOOL CExportLogFileDlg::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    CString omStrBus;

    if (m_eBus == CAN)
    {
        omStrBus = "CAN";
    }
    else if (m_eBus == J1939)
    {
        omStrBus = "J1939";
    }

    m_omBusType.SelectString(0, omStrBus);
    vPopulateAvailableList();
    vEnableDisableControls();
    return TRUE;
}

/**
 * \brief On Button Clicked Convert
 *
 * Message handler for convert button
 */
void CExportLogFileDlg::OnBnClickedConvert()
{
    // Log File name and Excel File name
    CString strLogFileName = m_omStrLogFileName;
    CString strCSVFileName = m_omStrCSVFileName;

    // filename have been entered

    if( strLogFileName != "" && strCSVFileName != "" )
    {
        if( m_omSelectedList.GetCount() != 0 )
        {
            //fields have been selected
            //open the files
            CLogToExcel oExport( strLogFileName.GetBuffer(MAX_PATH),strCSVFileName.GetBuffer(MAX_PATH), m_unNoOfFileds, m_pacFields);
            //set the selected fields
            oExport.fnSetSelectedFields( &(this->m_omSelectedList) );

            //convert log file to excel file
			HRESULT hResult = oExport.bConvert();
            if( S_OK != hResult )
            {
				string omStrError;
				oExport.GetErrorString( hResult, omStrError);
                MessageBox(omStrError.c_str(),APPLICATION_NAME,MB_OK);
            }
            else
            {
				MessageBox(EXPORTTOEXCEL_SUCCESSMSG,APPLICATION_NAME,MB_OK);
                //OnOK();
            }
        }
        else
        {
            MessageBox(EXPORTTOEXCEL_FIELDSELECTIONERROR,APPLICATION_NAME,MB_OK);
        }
    }
    else
    {
        MessageBox(EXPORTTOEXCEL_FILEERROR,APPLICATION_NAME,MB_OK);
    }
}


/**
 * \brief On Listbutton Select Change List Available
 *
 * Message handler for selection change on availbale list
 */
void CExportLogFileDlg::OnLbnSelchangeLstAvailable()
{
    // TODO: Add your control notification handler code here
    vEnableDisableControls();
}

/**
 * \brief On Listbutton Select Change List Selected
 *
 * Message handler for selection change
 */
void CExportLogFileDlg::OnLbnSelchangeLstSelected()
{
    vEnableDisableControls();
}

/**
 * \brief On Button Clicked Button Select One
 *
 * Message handler for select one button
 */
void CExportLogFileDlg::OnBnClickedButtonSelectone()
{
    // Get the selected item index
    int nSelectedItem = m_omAvailableList.GetCurSel();

    // If it is valid
    if( nSelectedItem != -1 )
    {
        // Get the filed index
        DWORD_PTR nFieldIndex = m_omAvailableList.GetItemData( nSelectedItem );

        if( nFieldIndex >= 0 && nFieldIndex < m_unNoOfFileds )
        {
            // Remove that item
            m_omAvailableList.DeleteString( nSelectedItem );

            // Set the focus to the next item
            if( nSelectedItem == m_omAvailableList.GetCount() )
            {
                nSelectedItem--;
            }

            m_omAvailableList.SetCurSel( nSelectedItem );
            // Add it in to the selected list
            int nNewItemIndex = m_omSelectedList.InsertString(
                                    m_omSelectedList.GetCount(),
                                    m_pacFields[ nFieldIndex ] );
            // Set Field index as item data
            m_omSelectedList.SetItemData( nNewItemIndex, nFieldIndex );
            // Set the selection
            m_omSelectedList.SetCurSel( nNewItemIndex );
            // Update UI buttons status
            vEnableDisableControls();
        }
    }
}

/**
 * \brief On Button Clicked Button Remove One
 *
 * Message handler for remove one button
 */
void CExportLogFileDlg::OnBnClickedButtonRemoveone()
{
    // Get the selected item index
    int nSelectedItem = m_omSelectedList.GetCurSel();

    // If it is a valid index
    if( nSelectedItem != -1 )
    {
        // Get the selected item data. That is index of fields array
        DWORD_PTR nFieldIndex = m_omSelectedList.GetItemData( nSelectedItem );
        // Remove the item fr the selected list
        m_omSelectedList.DeleteString( nSelectedItem );

        // Set the item selection to next
        if( nSelectedItem == m_omSelectedList.GetCount() )
        {
            nSelectedItem--;
        }

        m_omSelectedList.SetCurSel( nSelectedItem );
        // Insert this item in to the available list
        int nNewItemIndex = m_omAvailableList.GetCount();

        for( int nIndex = 0; nIndex < m_omAvailableList.GetCount(); nIndex++ )
        {
            if( m_omAvailableList.GetItemData( nIndex ) > nFieldIndex )
            {
                nNewItemIndex = nIndex;
                // Break the loop
                nIndex = m_omAvailableList.GetCount();
            }
        }

        if( nNewItemIndex != -1 )
        {
            m_omAvailableList.InsertString( nNewItemIndex,
                                            m_pacFields[ nFieldIndex ] );
        }
        else
        {
            nNewItemIndex = m_omAvailableList.AddString(
                                m_pacFields[ nFieldIndex ] );
        }

        // Set item data
        m_omAvailableList.SetItemData( nNewItemIndex, nFieldIndex );
        // Set the new item as selected
        m_omAvailableList.SetCurSel( nNewItemIndex );
        // Update UI Controls
        vEnableDisableControls();
    }
}

/**
 * \brief On Button Clicked Button Remove All
 *
 * Message handler for remove all button
 */
void CExportLogFileDlg::OnBnClickedButtonRemoveall()
{
    int nSelectedItem = m_omSelectedList.GetCurSel();
    DWORD_PTR nFieldIndex;

    if( nSelectedItem != -1 )
    {
        nSelectedItem=0;

        while(m_omSelectedList.GetCount()!=0)
        {
            // Get the selected item data. That is index of fields array
            nFieldIndex = m_omSelectedList.GetItemData( nSelectedItem );
            // Remove the item fr the selected list
            m_omSelectedList.DeleteString( nSelectedItem );
            // Set the item selection to next
            m_omSelectedList.SetCurSel( nSelectedItem );
            // Insert this item in to the available list
            int nNewItemIndex = m_omAvailableList.GetCount();

            for( int nIndex = 0; nIndex < m_omAvailableList.GetCount(); nIndex++ )
            {
                if( m_omAvailableList.GetItemData( nIndex ) > nFieldIndex )
                {
                    nNewItemIndex = nIndex;
                    // Break the loop
                    nIndex = m_omAvailableList.GetCount();
                }
            }

            if( nNewItemIndex != -1 )
            {
                m_omAvailableList.InsertString( nNewItemIndex,
                                                m_pacFields[ nFieldIndex ] );
            }
            else
            {
                nNewItemIndex = m_omAvailableList.AddString(
                                    m_pacFields[ nFieldIndex ] );
            }

            // Set item data
            m_omAvailableList.SetItemData( nNewItemIndex, nFieldIndex );
            // Set the new item as selected
            m_omAvailableList.SetCurSel( nNewItemIndex );
            // Update UI Controls
        }
    }

    vEnableDisableControls();
}

/**
 * \brief On ComboBox Selection Change Combo Bus Type
 *
 * Message handler for selection change in bus type combo box.
 */
void CExportLogFileDlg::OnCbnSelchangeComboBustype()
{
    CString omStrBus;
    m_omBusType.GetWindowText(omStrBus);
    CString omTitle("Export Log File - ");

    if( omStrBus == "CAN")
    {
        omTitle += _T("CAN");
        m_eBus = CAN;
        m_pacFields = (CHAR_ARRAY_20*) acFields_CAN;
        m_unNoOfFileds = defNO_OF_FIELDS_CAN;
    }
    else if ( omStrBus == "J1939")
    {
        omTitle += _T("J1939");
        m_eBus = J1939;
        m_pacFields = (CHAR_ARRAY_20*)acFields_J1939;
        m_unNoOfFileds = defNO_OF_FIELDS_J1939;
    }

    SetWindowText(omTitle);
    vPopulateAvailableList();
    vEnableDisableControls();
	m_omStrLogFileName = "";
	m_omStrCSVFileName = "";
	UpdateData(FALSE);
}































void CLogToExcel::fnSetFields()
{
    for(UINT unIndex = 0; unIndex < m_unNumOfFields; unIndex++)
    {
        pFieldMapTbl[m_pacFields[unIndex]] = unIndex;
    }
}






void CLogToExcel::fnSetSelectedFields(CListBox* omSelectedList)
{
    DWORD unMaxIndex = omSelectedList->GetCount();
    
    UINT unIndex;   

    for( unIndex = 0; unIndex < m_unNumOfFields; unIndex++)
    {
        unSelectedField[unIndex] = (UINT)-1;
    }

    
    for(unIndex = 0; unIndex < unMaxIndex; unIndex++)
    {
        string strFieldName;
        CString omFieldName;
        omSelectedList->GetText( unIndex,omFieldName);
        strFieldName = omFieldName.GetBuffer(260);
        pMapValue = pFieldMapTbl.find(strFieldName);
        unSelectedField[pMapValue->second] = pMapValue->second;
    }
}






CLogToExcel::CLogToExcel(string strLogFileName, string strExcelFileName, UINT unNoOfFields, CHAR_ARRAY_20* pacFields)
{
    m_pacFields = pacFields;
    m_strLogFileName = strLogFileName;
    m_strExcelFileName = strExcelFileName;
	m_unNumOfFields = unNoOfFields;
	m_bFilesOpened = 0;
	fnSetFields();
}






CLogToExcel::~CLogToExcel()
{
}






UINT CLogToExcel::unGetLine()
{
    UINT unBufferIndex = 0;  
    char ch;               

    
    while ( (ch = (char)m_pLogFile.get()) != '\n' )
    {
        
        m_strBuffer.append(1,ch);

        if( ch == (-1) )
        {
            m_strBuffer.append(1,'\0');
            return 1;
        }

        unBufferIndex++;
    }

    m_strBuffer.append(1,'\0');
    return 0;
}






void CLogToExcel::vPrintFields()
{
    
    if( (m_strBuffer.empty() ) ||(m_strBuffer[0] == '*') ||(m_strBuffer[0] == ' ')  )
    {
        return;
    }

    

    UINT unBufferIndex = 0;     
    UINT unFieldBufferIndex=0;  
    UINT unFieldIndex = 0;      
    bool bFieldIndexExists  = false;
    m_pExcelFile << "<TR>";

    while( unFieldIndex != m_unNumOfFields && m_strBuffer[unBufferIndex] != '\0' )
    {
        unFieldBufferIndex = 0;
        m_strFieldBuffer.clear();

        if( unFieldIndex != m_unNumOfFields-1 )
        {
            
            while( m_strBuffer[unBufferIndex] != ' ' && m_strBuffer[unBufferIndex] != '\0')
            {
                m_strFieldBuffer.append(1,m_strBuffer[unBufferIndex]);
                unFieldBufferIndex++;
                unBufferIndex++;
            }

            if( m_strBuffer.length() != unBufferIndex && m_strBuffer[unBufferIndex] == ' ')
            {
                unBufferIndex++;
            }

            if( m_strBuffer.length() != unBufferIndex && m_strBuffer[unBufferIndex] == ' ')
            {
                unBufferIndex++;
            }
        }
        else
        {
            
            unFieldBufferIndex = 0;

            while((m_strBuffer[unBufferIndex] != '\0') && (m_strBuffer[unBufferIndex] != '\n'))
            {
                m_strFieldBuffer.append(1,m_strBuffer[unBufferIndex]);
                unFieldBufferIndex++;
                unBufferIndex++;
            }
        } 

        m_strFieldBuffer.append(1,'\0');

        
        for(UINT nIndex = 0; nIndex < m_unNumOfFields; nIndex++)
        {
            if ( unSelectedField[nIndex] == unFieldIndex )
            {
                bFieldIndexExists = true;
                break;
            } 
        }

        if ( bFieldIndexExists )
        {
            m_pExcelFile << "<TD>" << m_strFieldBuffer.c_str() << "</TD>";
            bFieldIndexExists = false;
        }
        else
        {
            m_strFieldBuffer="";
        }

        unFieldIndex++;
    }

    m_strFieldBuffer.clear();
    m_pExcelFile << "</TR>";
}






HRESULT CLogToExcel::bConvert()
{
	HRESULT hRetVal = ((HRESULT)0L);
	 
    m_pLogFile.open(m_strLogFileName.c_str(), fstream::in);

    if(!m_pLogFile.is_open())
    {
        
		hRetVal = 0xF000 + 6;
        
        m_bFilesOpened = 0;
    }
    else
    {
        
        m_pExcelFile.open(m_strExcelFileName.c_str(), fstream::out);

        if(!m_pExcelFile.is_open())
        {
            
			hRetVal = 0xF000 + 7;
			
            m_bFilesOpened = 0;
        }
        else
        {
            m_bFilesOpened = 1;
			
        }
    }
	
    if(m_bFilesOpened == 1)
    {
        m_pExcelFile << "<HTML><HEAD></HEAD><BODY>" << endl;
        m_pExcelFile << "<FONT COLOR =\"GREEN\"><CENTER><B>BUSMASTER - Exported Log File Report</B></CENTER>";
        m_pExcelFile << "<BR><BR>";
        m_pExcelFile << "<TABLE BORDER COLOR=\"BLACK\"><TR>";

        
        for( UINT unIndex = 0; unIndex < m_unNumOfFields; unIndex++)
            if(unSelectedField[unIndex]!=-1)
            {
                m_pExcelFile << "<TD><FONT COLOR=\"Green\"><B> " << m_pacFields[unIndex] << " </B></TD>";
            }

        m_pExcelFile << "</TR>";

        
        while(!unGetLine())
        {
            vPrintFields();
            m_strBuffer.clear();
        }

        m_pExcelFile << "</TABLE></BODY></HTML>" << endl;
        
        m_pExcelFile.close();
        m_pLogFile.close();
		hRetVal =((HRESULT)0L);
    }
	else
	{
		if(m_pLogFile.is_open())
		{
			m_pLogFile.close();
		}
		if(m_pExcelFile.is_open())
		{
			m_pExcelFile.close();
		}
	}

    return hRetVal;
}
void CLogToExcel::GetErrorString(HRESULT hResult, string& omStrErrorString)
{
	switch(hResult)
	{
		case 0xF000:
			omStrErrorString = "Could not convert!";
			break;
		case 0xF000 + 1:
			omStrErrorString = "Error in Opening Input Files";;
			break;
		case 0xF000 + 2:
			omStrErrorString = "No fields selected!";
			break;
		case 0xF000 + 3:
			omStrErrorString = "Enter Log file details!";
			break;
		case 0xF000 + 4:	
			omStrErrorString = "Enter CSV file details!";
			break;
		case 0xF000 + 5:		
			omStrErrorString = "Enter Log and CSV file details!";
			break;
		case 0xF000 + 6:
			omStrErrorString = "Log File doesnot Exist!";
			break;
		case 0xF000 + 7:
			omStrErrorString = "CSV File doesnot Exist!";
			break;
		default:
			omStrErrorString = "Invalid Error";
			break;
	}
}
          ˜      ˜   5   –ÿÿÿÿ   –ÿÿÿÿ    6ÂH      expression was true       m_strBuffer[unBufferIndex] != ' '    ˜ÿÿÿÿ   –      ˜ÿÿÿÿ   –   5   expression was false       m_strBuffer[unBufferIndex] != ' '    ˜ÿÿÿÿ   –      ˜ÿÿÿÿ   –   5               6ÀP            /      Q   ÿÿÿÿ   ÿÿÿÿ    1Éø      expression was true       m_strBuffer[unBufferIndex] != '\0'    ÿÿÿÿ      /   ÿÿÿÿ      Q   expression was false       m_strBuffer[unBufferIndex] != '\0'    ÿÿÿÿ      /   ÿÿÿÿ      Q               1È8                  +   ÿÿÿÿ   ÿÿÿÿ    1É      expression was true       unFieldIndex != m_unNumOfFields    ÿÿÿÿ         ÿÿÿÿ      +   expression was false       unFieldIndex != m_unNumOfFields    ÿÿÿÿ         ÿÿÿÿ      +               1Ç         ƒ   <   ƒ   S   ÿÿÿÿ   ÿÿÿÿ    89      expression was true       (m_strBuffer[0] == ' ')    ƒÿÿÿÿ      <   ƒÿÿÿÿ      S   expression was false       (m_strBuffer[0] == ' ')    ƒÿÿÿÿ      <   ƒÿÿÿÿ      S               87H         ƒ   "   ƒ   9   ÿÿÿÿ   ÿÿÿÿ    84X      expression was true       (m_strBuffer[0] == '*')    ƒÿÿÿÿ      "   ƒÿÿÿÿ      9   expression was false       (m_strBuffer[0] == '*')    ƒÿÿÿÿ      "   ƒÿÿÿÿ      9               :îĞ   
      ƒ   	   ƒ      ÿÿÿÿ   ÿÿÿÿ    83¸      expression was true       (m_strBuffer.empty() )    ƒÿÿÿÿ      	   ƒÿÿÿÿ         expression was false       (m_strBuffer.empty() )    ƒÿÿÿÿ      	   ƒÿÿÿÿ                     :ìØ         ˜   9   ˜   [   –ÿÿÿÿ   –ÿÿÿÿ    6Ã0      expression was true       m_strBuffer[unBufferIndex] != '\0'    ˜ÿÿÿÿ   –   9   ˜ÿÿÿÿ   –   [   expression was false       m_strBuffer[unBufferIndex] != '\0'    ˜ÿÿÿÿ   –   9   ˜ÿÿÿÿ   –   [               6Áp                   9   şÿÿÿÿ   şÿÿÿÿ    ÀXÀ      expression was false       unIndex < m_unNumOfFields    ÿÿÿÿ   ş       ÿÿÿÿ   ş   9                 ¹      ¹   6   ·ÿÿÿÿ   ·ÿÿÿÿ    À˜      expression was false       nIndex < m_unNumOfFields    ¹ÿÿÿÿ   ·      ¹ÿÿÿÿ   ·   6                 ;      ;   *   9ÿÿÿÿ   9ÿÿÿÿ    EÈˆ      expression was false       unIndex < unMaxIndex    ;ÿÿÿÿ   9      ;ÿÿÿÿ   9   *                 5      5   0   3ÿÿÿÿ   3ÿÿÿÿ     ç%      expression was false       unIndex < m_unNumOfFields    5ÿÿÿÿ   3      5ÿÿÿÿ   3   0                 $      $   4   "ÿÿÿÿ   "ÿÿÿÿ     , ¨      expression was false       unIndex < m_unNumOfFields    $ÿÿÿÿ   "      $ÿÿÿÿ   "   4                	     	     ÿÿÿÿ  ÿÿÿÿ    À\¨      expression was false       !unGetLine()   	ÿÿÿÿ       	ÿÿÿÿ                    ÀZ         Ÿ      Ÿ   6   ÿÿÿÿ   ÿÿÿÿ    6Êp      expression was true       m_strBuffer.length() != unBufferIndex    Ÿÿÿÿÿ         Ÿÿÿÿÿ      6   expression was false       m_strBuffer.length() != unBufferIndex    Ÿÿÿÿÿ         Ÿÿÿÿÿ      6               6Èx         Ÿ   :   Ÿ   [   ÿÿÿÿ   ÿÿÿÿ    6ËX      expression was true       m_strBuffer[unBufferIndex] == ' '    Ÿÿÿÿÿ      :   Ÿÿÿÿÿ      [   expression was false       m_strBuffer[unBufferIndex] == ' '    Ÿÿÿÿÿ      :   Ÿÿÿÿÿ      [               6É˜         ¤      ¤   6   ¢ÿÿÿÿ   ¢ÿÿÿÿ    ¿Tğ      expression was true       m_strBuffer.length() != unBufferIndex    ¤ÿÿÿÿ   ¢      ¤ÿÿÿÿ   ¢   6   expression was false       m_strBuffer.length() != unBufferIndex    ¤ÿÿÿÿ   ¢      ¤ÿÿÿÿ   ¢   6               ¿Rø         i      i   2   gÿÿÿÿ   gÿÿÿÿ    :é      expression was false       (ch = (char)m_pLogFile.get()) != '\n'    iÿÿÿÿ   g      iÿÿÿÿ   g   2               @ùÈ                  ÿÿÿÿ  ÿÿÿÿ     îHx      expression was false       m_pExcelFile.is_open()   ÿÿÿÿ       ÿÿÿÿ                               ÿÿÿÿ  ÿÿÿÿ     îEø      expression was false       m_pLogFile.is_open()   ÿÿÿÿ       ÿÿÿÿ                             ,   ÿÿÿÿÿ   ÿÿÿÿÿ    ÀW       expression was false       unSelectedField[unIndex]!=-1   ÿÿÿÿ   ÿ     ÿÿÿÿ   ÿ   ,               ÀT¨         »      »   9   ¹ÿÿÿÿ   ¹ÿÿÿÿ     ç`      expression was false       unSelectedField[nIndex] == unFieldIndex    »ÿÿÿÿ   ¹      »ÿÿÿÿ   ¹   9                ç0         ¤   :   ¤   [   ¢ÿÿÿÿ   ¢ÿÿÿÿ    ¿UØ      expression was true       m_strBuffer[unBufferIndex] == ' '    ¤ÿÿÿÿ   ¢   :   ¤ÿÿÿÿ   ¢   [   expression was false       m_strBuffer[unBufferIndex] == ' '    ¤ÿÿÿÿ   ¢   :   ¤ÿÿÿÿ   ¢   [               ¿T   !      ®      ®   7   ¬ÿÿÿÿ   ¬ÿÿÿÿ     çp      expression was true       (m_strBuffer[unBufferIndex] != '\0')    ®ÿÿÿÿ   ¬      ®ÿÿÿÿ   ¬   7   expression was false       (m_strBuffer[unBufferIndex] != '\0')    ®ÿÿÿÿ   ¬      ®ÿÿÿÿ   ¬   7               ¿\È   #      ®   ;   ®   _   ¬ÿÿÿÿ   ¬ÿÿÿÿ     çX      expression was true       (m_strBuffer[unBufferIndex] != '\n')    ®ÿÿÿÿ   ¬   ;   ®ÿÿÿÿ   ¬   _   expression was false       (m_strBuffer[unBufferIndex] != '\n')    ®ÿÿÿÿ   ¬   ;   ®ÿÿÿÿ   ¬   _                ç˜   %      n      n      lÿÿÿÿ   lÿÿÿÿ    :ç       expression was false       ch == (-1)    nÿÿÿÿ   l      nÿÿÿÿ   l                  :äĞ   &     C     C     Aÿÿÿÿ  Aÿÿÿÿ    :b0       statement executed        }   Cÿÿÿÿ  A     Cÿÿÿÿ  A              '     A     A   
  ?ÿÿÿÿ  ?ÿÿÿÿ    :aX       statement executed        break;   Aÿÿÿÿ  ?     Aÿÿÿÿ  ?   
           (     >     >   
  <ÿÿÿÿ  <ÿÿÿÿ     ñ^        statement executed        break;   >ÿÿÿÿ  <     >ÿÿÿÿ  <   
           )     ;     ;   
  9ÿÿÿÿ  9ÿÿÿÿ     ñ\        statement executed        break;   ;ÿÿÿÿ  9     ;ÿÿÿÿ  9   
           *     8     8   
  6ÿÿÿÿ  6ÿÿÿÿ     ñZ        statement executed        break;   8ÿÿÿÿ  6     8ÿÿÿÿ  6   
           +     5     5   
  3ÿÿÿÿ  3ÿÿÿÿ     ñX        statement executed        break;   5ÿÿÿÿ  3     5ÿÿÿÿ  3   
           ,     2     2   
  0ÿÿÿÿ  0ÿÿÿÿ     ñV        statement executed        break;   2ÿÿÿÿ  0     2ÿÿÿÿ  0   
           -     /     /   
  -ÿÿÿÿ  -ÿÿÿÿ     ñT        statement executed        break;   /ÿÿÿÿ  -     /ÿÿÿÿ  -   
           .     ,     ,   
  *ÿÿÿÿ  *ÿÿÿÿ     ñR        statement executed        break;   ,ÿÿÿÿ  *     ,ÿÿÿÿ  *   
           /     )     )   
  'ÿÿÿÿ  'ÿÿÿÿ     ñQ       statement executed        break;   )ÿÿÿÿ  '     )ÿÿÿÿ  '   
           0     !     !     ÿÿÿÿ  ÿÿÿÿ     îK       statement executed        return hRetVal;   !ÿÿÿÿ       !ÿÿÿÿ                1               ÿÿÿÿ  ÿÿÿÿ     îIP       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                2      '      '      %ÿÿÿÿ   %ÿÿÿÿ    ,æ        statement executed        }    'ÿÿÿÿ   %      'ÿÿÿÿ   %              3      (      (      &ÿÿÿÿ   &ÿÿÿÿ     ,¡8       statement executed        }    (ÿÿÿÿ   &      (ÿÿÿÿ   &              4      8      8      6ÿÿÿÿ   6ÿÿÿÿ     ç$¸       statement executed        }    8ÿÿÿÿ   6      8ÿÿÿÿ   6              5      C      C      Aÿÿÿÿ   Aÿÿÿÿ    EÇ°       statement executed        }    Cÿÿÿÿ   A      Cÿÿÿÿ   A              6      D      D      Bÿÿÿÿ   Bÿÿÿÿ    EÉ`       statement executed        }    Dÿÿÿÿ   B      Dÿÿÿÿ   B              7      S      S      Qÿÿÿÿ   Qÿÿÿÿ    @ñ¸       statement executed        }    Sÿÿÿÿ   Q      Sÿÿÿÿ   Q              8      \      \      Zÿÿÿÿ   Zÿÿÿÿ    @óÈ       statement executed        }    \ÿÿÿÿ   Z      \ÿÿÿÿ   Z              9      q      q      oÿÿÿÿ   oÿÿÿÿ    :æH       statement executed        return 1;    qÿÿÿÿ   o      qÿÿÿÿ   o              :      u      u      sÿÿÿÿ   sÿÿÿÿ    :è8       statement executed        }    uÿÿÿÿ   s      uÿÿÿÿ   s              ;      x      x      vÿÿÿÿ   vÿÿÿÿ    :êh       statement executed        return 0;    xÿÿÿÿ   v      xÿÿÿÿ   v              <      …   	   …      ƒÿÿÿÿ   ƒÿÿÿÿ    8;       statement executed        return;    …ÿÿÿÿ   ƒ   	   …ÿÿÿÿ   ƒ              =                  ›ÿÿÿÿ   ›ÿÿÿÿ    6Æ@       statement executed        }    ÿÿÿÿ   ›      ÿÿÿÿ   ›              >      ¢      ¢       ÿÿÿÿ    ÿÿÿÿ    ¿PÀ       statement executed        }    ¢ÿÿÿÿ          ¢ÿÿÿÿ                  ?      §      §      ¥ÿÿÿÿ   ¥ÿÿÿÿ    ¿X       statement executed        }    §ÿÿÿÿ   ¥      §ÿÿÿÿ   ¥              @      ¨   	   ¨   
   ¦ÿÿÿÿ   ¦ÿÿÿÿ    ¿YÈ       statement executed        }    ¨ÿÿÿÿ   ¦   	   ¨ÿÿÿÿ   ¦   
           A      ³      ³      ±ÿÿÿÿ   ±ÿÿÿÿ     çh       statement executed        }    ³ÿÿÿÿ   ±      ³ÿÿÿÿ   ±              B      ´   	   ´   
   ²ÿÿÿÿ   ²ÿÿÿÿ     ç(       statement executed        }    ´ÿÿÿÿ   ²   	   ´ÿÿÿÿ   ²   
           C      ¾      ¾      ¼ÿÿÿÿ   ¼ÿÿÿÿ     çˆ       statement executed        break;    ¾ÿÿÿÿ   ¼      ¾ÿÿÿÿ   ¼              D      À   	   À   
   ¾ÿÿÿÿ   ¾ÿÿÿÿ    À       statement executed        }    Àÿÿÿÿ   ¾   	   Àÿÿÿÿ   ¾   
           E      Æ   	   Æ   
   Äÿÿÿÿ   Äÿÿÿÿ    Àè       statement executed        }    Æÿÿÿÿ   Ä   	   Æÿÿÿÿ   Ä   
           F      Ê   	   Ê   
   Èÿÿÿÿ   Èÿÿÿÿ    Àè       statement executed        }    Êÿÿÿÿ   È   	   Êÿÿÿÿ   È   
           G      Í      Í      Ëÿÿÿÿ   Ëÿÿÿÿ    ÀÈ       statement executed        }    Íÿÿÿÿ   Ë      Íÿÿÿÿ   Ë              H      Ñ      Ñ      Ïÿÿÿÿ   Ïÿÿÿÿ    ÀH       statement executed        }    Ñÿÿÿÿ   Ï      Ñÿÿÿÿ   Ï              I      ä      ä      âÿÿÿÿ   âÿÿÿÿ    0—X       statement executed        }    äÿÿÿÿ   â      äÿÿÿÿ   â              J      ğ   	   ğ   
   îÿÿÿÿ   îÿÿÿÿ    0       statement executed        }    ğÿÿÿÿ   î   	   ğÿÿÿÿ   î   
           K      õ   	   õ   
   óÿÿÿÿ   óÿÿÿÿ    0Ÿ       statement executed        }    õÿÿÿÿ   ó   	   õÿÿÿÿ   ó   
           L               ÿÿÿÿ  ÿÿÿÿ    ÀV(       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                M        	     
  ÿÿÿÿ  ÿÿÿÿ    À[Ğ       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           N               ÿÿÿÿ  ÿÿÿÿ     îC`       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                O               ÿÿÿÿ  ÿÿÿÿ     îE        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                P               ÿÿÿÿ  ÿÿÿÿ     îG        statement executed        }   ÿÿÿÿ       ÿÿÿÿ             CLogToExcel::fnSetFields void CLogToExcel::fnSetFields()    #      (      !ÿÿÿÿ   &ÿÿÿÿCLogToExcel::fnSetSelectedFields void CLogToExcel::fnSetSelectedFields(CListBox* omSelectedList)    0      D      .ÿÿÿÿ   BÿÿÿÿCLogToExcel::CLogToExcel CLogToExcel::CLogToExcel(string strLogFileName, string strExcelFileName, UINT unNoOfFields, CHAR_ARRAY_20* pacFields)    L      S      Jÿÿÿÿ   QÿÿÿÿCLogToExcel::~CLogToExcel CLogToExcel::~CLogToExcel()    [      \      Yÿÿÿÿ   ZÿÿÿÿCLogToExcel::unGetLine UINT CLogToExcel::unGetLine()    d      y      bÿÿÿÿ   wÿÿÿÿCLogToExcel::vPrintFields void CLogToExcel::vPrintFields()          Ñ      ÿÿÿÿ   ÏÿÿÿÿCLogToExcel::bConvert HRESULT CLogToExcel::bConvert()    Ù     "      ×ÿÿÿÿ   ÿÿÿÿCLogToExcel::GetErrorString void CLogToExcel::GetErrorString(HRESULT hResult, string& omStrErrorString)   $     C     "ÿÿÿÿ  Aÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      LogToExcel.cpp
 * \brief     Definition of CLogToExcel class
 * \authors   Pradeep Kadoor, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Definition of the CLogToExcel class.
 */

/* Project includes */
#include "Defines.h"
#include "LogToExcel.h"

/**
 * \brief Initializing the Column fields map table
 *
 * Initializing the Column fields map table
 */
void CLogToExcel::fnSetFields()
{
    for(UINT unIndex = 0; unIndex < m_unNumOfFields; unIndex++)
    {
        pFieldMapTbl[m_pacFields[unIndex]] = unIndex;
    }
}

/**
 * \brief set the fields which are selected by the user
 *
 * set the fields which are selected by the user
 */
void CLogToExcel::fnSetSelectedFields(CListBox* omSelectedList)
{
    DWORD unMaxIndex = omSelectedList->GetCount();
    //initialising the SelectedField array to -1
    UINT unIndex;   //unIndex declared outside for loop

    for( unIndex = 0; unIndex < m_unNumOfFields; unIndex++)
    {
        unSelectedField[unIndex] = (UINT)-1;
    }

    //setting the appropriate value for each field
    for(unIndex = 0; unIndex < unMaxIndex; unIndex++)
    {
        string strFieldName;
        CString omFieldName;
        omSelectedList->GetText( unIndex,omFieldName);
        strFieldName = omFieldName.GetBuffer(MAX_PATH);
        pMapValue = pFieldMapTbl.find(strFieldName);
        unSelectedField[pMapValue->second] = pMapValue->second;
    }
}

/**
 * \brief opens the log file for reading and excel file for writing
 *
 * opens the log file for reading and excel file for writing
 */
CLogToExcel::CLogToExcel(string strLogFileName, string strExcelFileName, UINT unNoOfFields, CHAR_ARRAY_20* pacFields)
{
    m_pacFields = pacFields;
    m_strLogFileName = strLogFileName;
    m_strExcelFileName = strExcelFileName;
	m_unNumOfFields = unNoOfFields;
	m_bFilesOpened = FALSE;
	fnSetFields();
}

/**
 * \brief Destructor
 *
 * Destructor of CLogToExcel
 */
CLogToExcel::~CLogToExcel()
{
}

/**
 * \brief Retrieves each line from the file and stores it in m_strBuffer
 *
 * Retrieves each line from the file and stores it in m_strBuffer
 */
UINT CLogToExcel::unGetLine()
{
    UINT unBufferIndex = 0;  //index to traverse m_strBuffer string
    char ch;               // stores each character read from the file

    //reads log file till end of line is not reached
    while ( (ch = (char)m_pLogFile.get()) != '\n' )
    {
        //m_strBuffer contains each line read from log file
        m_strBuffer.append(1,ch);

        if( ch == EOF )
        {
            m_strBuffer.append(1,'\0');
            return 1;
        }

        unBufferIndex++;
    }

    m_strBuffer.append(1,'\0');
    return 0;
}

/**
 * \brief Retrieves each field from m_strBuffer and writes it into Excel file.
 *
 * Retrieves each field from m_strBuffer and writes it into Excel file.
 */
void CLogToExcel::vPrintFields()
{
    // ignore the headers in log file
    if( (m_strBuffer.empty() ) ||(m_strBuffer[0] == '*') ||(m_strBuffer[0] == ' ')  )
    {
        return;
    }

    /*if(m_strBuffer[0] != '<')
       return;*/
    UINT unBufferIndex = 0;     //index to traverse m_strBuffer string
    UINT unFieldBufferIndex=0;  //index to traverse m_strFieldBuffer string
    UINT unFieldIndex = 0;      // field index
    bool bFieldIndexExists  = false;
    m_pExcelFile << "<TR>";

    while( unFieldIndex != m_unNumOfFields && m_strBuffer[unBufferIndex] != '\0' )
    {
        unFieldBufferIndex = 0;
        m_strFieldBuffer.clear();

        if( unFieldIndex != m_unNumOfFields-1 )
        {
            //reading each field from m_strBuffer
            while( m_strBuffer[unBufferIndex] != ' ' && m_strBuffer[unBufferIndex] != '\0')
            {
                m_strFieldBuffer.append(1,m_strBuffer[unBufferIndex]);
                unFieldBufferIndex++;
                unBufferIndex++;
            }// while - m_strBuffer[unBufferIndex] != _T(" ")

            if( m_strBuffer.length() != unBufferIndex && m_strBuffer[unBufferIndex] == ' ')
            {
                unBufferIndex++;
            }

            if( m_strBuffer.length() != unBufferIndex && m_strBuffer[unBufferIndex] == ' ')
            {
                unBufferIndex++;
            }
        }// unFieldIndex != m_unNumOfFields-1
        else
        {
            // reading the data bytes field from m_strBuffer
            unFieldBufferIndex = 0;

            while((m_strBuffer[unBufferIndex] != '\0') && (m_strBuffer[unBufferIndex] != '\n'))
            {
                m_strFieldBuffer.append(1,m_strBuffer[unBufferIndex]);
                unFieldBufferIndex++;
                unBufferIndex++;
            }
        } // else

        m_strFieldBuffer.append(1,'\0');

        //writing the field into excel file
        for(UINT nIndex = 0; nIndex < m_unNumOfFields; nIndex++)
        {
            if ( unSelectedField[nIndex] == unFieldIndex )
            {
                bFieldIndexExists = true;
                break;
            } // if unSelectedField[nIndex] == unFieldIndex
        }// for loop - unSelectedField

        if ( bFieldIndexExists )
        {
            m_pExcelFile << "<TD>" << m_strFieldBuffer.c_str() << "</TD>";
            bFieldIndexExists = false;
        }
        else
        {
            m_strFieldBuffer="";
        }

        unFieldIndex++;
    }// While - field navigation

    m_strFieldBuffer.clear();
    m_pExcelFile << "</TR>";
}

/**
 * \brief Converts the .log file to .xls file
 *
 * Converts the .log file to .xls file
 */
HRESULT CLogToExcel::bConvert()
{
	HRESULT hRetVal = S_OK;
	 //open log file in read mode
    m_pLogFile.open(m_strLogFileName.c_str(), fstream::in);

    if(!m_pLogFile.is_open())
    {
        //log file could not be opened
		hRetVal = ERR_EXPORTTOEXCEL_LOGFILEOPENERROR;
        //MessageBox(NULL,EXPORTTOEXCEL_LOGFILEOPENERROR,APPLICATION_NAME,MB_OK);
        m_bFilesOpened = FALSE;
    }
    else
    {
        //open Excel file in write
        m_pExcelFile.open(m_strExcelFileName.c_str(), fstream::out);

        if(!m_pExcelFile.is_open())
        {
            //Excel file could not be opened
			hRetVal = ERR_EXPORTTOEXCEL_CSVFILEOPENERROR;
			//MessageBox(NULL,EXPORTTOEXCEL_CSVFILEOPENERROR,APPLICATION_NAME,MB_OK);
            m_bFilesOpened = FALSE;
        }
        else
        {
            m_bFilesOpened = TRUE;
			
        }
    }
	
    if(m_bFilesOpened == TRUE)
    {
        m_pExcelFile << "<HTML><HEAD></HEAD><BODY>" << endl;
        m_pExcelFile << "<FONT COLOR =\"GREEN\"><CENTER><B>BUSMASTER - Exported Log File Report</B></CENTER>";
        m_pExcelFile << "<BR><BR>";
        m_pExcelFile << "<TABLE BORDER COLOR=\"BLACK\"><TR>";

        // write column headers
        for( UINT unIndex = 0; unIndex < m_unNumOfFields; unIndex++)
            if(unSelectedField[unIndex]!=-1)
            {
                m_pExcelFile << "<TD><FONT COLOR=\"Green\"><B> " << m_pacFields[unIndex] << " </B></TD>";
            }

        m_pExcelFile << "</TR>";

        // write each column
        while(!unGetLine())
        {
            vPrintFields();
            m_strBuffer.clear();
        }

        m_pExcelFile << "</TABLE></BODY></HTML>" << endl;
        //close file
        m_pExcelFile.close();
        m_pLogFile.close();
		hRetVal =S_OK;
    }
	else
	{
		if(m_pLogFile.is_open())
		{
			m_pLogFile.close();
		}
		if(m_pExcelFile.is_open())
		{
			m_pExcelFile.close();
		}
	}

    return hRetVal;
}
void CLogToExcel::GetErrorString(HRESULT hResult, string& omStrErrorString)
{
	switch(hResult)
	{
		case ERR_EXPORTTOEXCEL_SYNTAXERROR:
			omStrErrorString = EXPORTTOEXCEL_SYNTAXERROR;
			break;
		case ERR_EXPORTTOEXCEL_FILESNOTOPEN:
			omStrErrorString = EXPORTTOEXCEL_FILESNOTOPEN;
			break;
		case ERR_EXPORTTOEXCEL_FIELDSELECTIONERROR:
			omStrErrorString = EXPORTTOEXCEL_FIELDSELECTIONERROR;
			break;
		case ERR_EXPORTTOEXCEL_LOGFILEERROR:
			omStrErrorString = EXPORTTOEXCEL_LOGFILEERROR;
			break;
		case ERR_EXPORTTOEXCEL_CSVFILEERROR:	
			omStrErrorString = EXPORTTOEXCEL_CSVFILEERROR;
			break;
		case ERR_EXPORTTOEXCEL_FILEERROR:		
			omStrErrorString = EXPORTTOEXCEL_FILEERROR;
			break;
		case ERR_EXPORTTOEXCEL_LOGFILEOPENERROR:
			omStrErrorString = EXPORTTOEXCEL_LOGFILEOPENERROR;
			break;
		case ERR_EXPORTTOEXCEL_CSVFILEOPENERROR:
			omStrErrorString = EXPORTTOEXCEL_CSVFILEOPENERROR;
			break;
		default:
			omStrErrorString = "Invalid Error";
			break;
	}
}



































static AFX_EXTENSION_MODULE LogToExcelConverterDLL = { 0, 0 };





extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
    (lpReserved);

    if (dwReason == 1)
    {
        ;

        
        if (!AfxInitExtensionModule(LogToExcelConverterDLL, hInstance))
        {
            return 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        new CDynLinkLibrary(LogToExcelConverterDLL);
    }
    else if (dwReason == 0)
    {
        ;
        
        AfxTermExtensionModule(LogToExcelConverterDLL);
    }

    return 1;   
}





extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CLogToExcelConverter();
    return ((HRESULT)0L);
}

CLogToExcelConverter::CLogToExcelConverter(void)
{
}

CLogToExcelConverter::~CLogToExcelConverter(void)
{
};

HRESULT CLogToExcelConverter::GetHelpText(string&)
{
    return ((HRESULT)1L);
}
HRESULT CLogToExcelConverter::GetConverterName(string&)
{
    return ((HRESULT)1L);
}
HRESULT CLogToExcelConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    return ((HRESULT)1L);
}
HRESULT CLogToExcelConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    return ((HRESULT)1L);
}
HRESULT CLogToExcelConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    return ((HRESULT)1L);
}

HRESULT CLogToExcelConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    return ((HRESULT)1L);
}
HRESULT CLogToExcelConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    return ((HRESULT)1L);
}
BOOL CLogToExcelConverter::bHaveOwnWindow()
{
    return 1;
}

HRESULT CLogToExcelConverter::GetPropertyPage(CPropertyPage*& pPage)
{
    pPage = new CExportLogFileDlg();
    return ((HRESULT)1L);
};
          J      J      Hÿÿÿÿ   Hÿÿÿÿ    -)¨      expression was false       dwReason == 0    Jÿÿÿÿ   H      Jÿÿÿÿ   H                  -'         8      8   G   6ÿÿÿÿ   6ÿÿÿÿ    -%@      expression was false       !AfxInitExtensionModule(LogToExcelConverterDLL, hInstance)    8ÿÿÿÿ   6      8ÿÿÿÿ   6   G               -$         :      :      8ÿÿÿÿ   8ÿÿÿÿ    -$°       statement executed        return 0;    :ÿÿÿÿ   8      :ÿÿÿÿ   8                    I      I      Gÿÿÿÿ   Gÿÿÿÿ    -&ˆ       statement executed        }    Iÿÿÿÿ   G      Iÿÿÿÿ   G                    O      O      Mÿÿÿÿ   Mÿÿÿÿ    -(Ğ       statement executed        }    Oÿÿÿÿ   M      Oÿÿÿÿ   M                    Q      Q      Oÿÿÿÿ   Oÿÿÿÿ    ,æè       statement executed        return 1;    Qÿÿÿÿ   O      Qÿÿÿÿ   O                    [      [      Yÿÿÿÿ   Yÿÿÿÿ    ,é¨       statement executed        return ((HRESULT)0L);    [ÿÿÿÿ   Y      [ÿÿÿÿ   Y                    `      `      ^ÿÿÿÿ   ^ÿÿÿÿ    ,ì       statement executed        }    `ÿÿÿÿ   ^      `ÿÿÿÿ   ^                    d      d      bÿÿÿÿ   bÿÿÿÿ    ,îH       statement executed        }    dÿÿÿÿ   b      dÿÿÿÿ   b              	      h      h      fÿÿÿÿ   fÿÿÿÿ             statement executed        return ((HRESULT)1L);    hÿÿÿÿ   f      hÿÿÿÿ   f              
      l      l      jÿÿÿÿ   jÿÿÿÿ    #0       statement executed        return ((HRESULT)1L);    lÿÿÿÿ   j      lÿÿÿÿ   j                    p      p      nÿÿÿÿ   nÿÿÿÿ    %x       statement executed        return ((HRESULT)1L);    pÿÿÿÿ   n      pÿÿÿÿ   n                    t      t      rÿÿÿÿ   rÿÿÿÿ    (       statement executed        return ((HRESULT)1L);    tÿÿÿÿ   r      tÿÿÿÿ   r                    x      x      vÿÿÿÿ   vÿÿÿÿ    *ˆ       statement executed        return ((HRESULT)1L);    xÿÿÿÿ   v      xÿÿÿÿ   v                    }      }      {ÿÿÿÿ   {ÿÿÿÿ     ò ¨       statement executed        return ((HRESULT)1L);    }ÿÿÿÿ   {      }ÿÿÿÿ   {                                ÿÿÿÿ   ÿÿÿÿ     ò#        statement executed        return ((HRESULT)1L);    ÿÿÿÿ         ÿÿÿÿ                       …      …      ƒÿÿÿÿ   ƒÿÿÿÿ     ò%h       statement executed        return 1;    …ÿÿÿÿ   ƒ      …ÿÿÿÿ   ƒ                    ‹      ‹      ‰ÿÿÿÿ   ‰ÿÿÿÿ     ò(Ø       statement executed        return ((HRESULT)1L);    ‹ÿÿÿÿ   ‰      ‹ÿÿÿÿ   ‰           DllMain extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)    /      R      -ÿÿÿÿ   PÿÿÿÿGetBaseConverter extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)    Y      \      Wÿÿÿÿ   ZÿÿÿÿCLogToExcelConverter::CLogToExcelConverter CLogToExcelConverter::CLogToExcelConverter(void)    _      `      ]ÿÿÿÿ   ^ÿÿÿÿCLogToExcelConverter::~CLogToExcelConverter CLogToExcelConverter::~CLogToExcelConverter(void)    c      d      aÿÿÿÿ   bÿÿÿÿCLogToExcelConverter::GetHelpText HRESULT CLogToExcelConverter::GetHelpText(string&)    g      i      eÿÿÿÿ   gÿÿÿÿCLogToExcelConverter::GetConverterName HRESULT CLogToExcelConverter::GetConverterName(string&)    k      m      iÿÿÿÿ   kÿÿÿÿCLogToExcelConverter::GetErrorStatus HRESULT CLogToExcelConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)    o      q      mÿÿÿÿ   oÿÿÿÿCLogToExcelConverter::GetInputFileFilters HRESULT CLogToExcelConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)    s      u      qÿÿÿÿ   sÿÿÿÿCLogToExcelConverter::GetLastConversionStatus HRESULT CLogToExcelConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)    w      y      uÿÿÿÿ   wÿÿÿÿCLogToExcelConverter::GetOutputFileFilters HRESULT CLogToExcelConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)    |      ~      zÿÿÿÿ   |ÿÿÿÿCLogToExcelConverter::ConvertFile HRESULT CLogToExcelConverter::ConvertFile(string& chInputFile, string& chOutputFile)    €      ‚      ~ÿÿÿÿ   €ÿÿÿÿCLogToExcelConverter::bHaveOwnWindow BOOL CLogToExcelConverter::bHaveOwnWindow()    „      †      ‚ÿÿÿÿ   „ÿÿÿÿCLogToExcelConverter::GetPropertyPage HRESULT CLogToExcelConverter::GetPropertyPage(CPropertyPage*& pPage)    ‰      Œ      ‡ÿÿÿÿ   Šÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      LogToExcelConverter.cpp
 * \brief     Definition of CLogToExcelConverter class
 * \authors   Pradeep Kadoor, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines the initialization routines for the DLL.
 */

/* Project includes */
#include "ExportLogFileDlg.h"
#include "LogToExcelConverter.h"

#ifdef _MANAGED
#error Please read instructions in LogToExcelConverter.cpp to compile with /clr
// If you want to add /clr to your project you must do the following:
//  1. Remove the above include for afxdllx.h
//  2. Add a .cpp file to your project that does not have /clr thrown and has
//     Precompiled headers disabled, with the following text:
//          #include <afxwin.h>
//          #include <afxdllx.h>
#endif

static AFX_EXTENSION_MODULE LogToExcelConverterDLL = { NULL, NULL };

#ifdef _MANAGED
#pragma managed(push, off)
#endif

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("LogToExcelConverter.DLL Initializing!\n");

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(LogToExcelConverterDLL, hInstance))
        {
            return 0;
        }

        // Insert this DLL into the resource chain
        // NOTE: If this Extension DLL is being implicitly linked to by
        //  an MFC Regular DLL (such as an ActiveX Control)
        //  instead of an MFC application, then you will want to
        //  remove this line from DllMain and put it in a separate
        //  function exported from this Extension DLL.  The Regular DLL
        //  that uses this Extension DLL should then explicitly call that
        //  function to initialize this Extension DLL.  Otherwise,
        //  the CDynLinkLibrary object will not be attached to the
        //  Regular DLL's resource chain, and serious problems will
        //  result.
        new CDynLinkLibrary(LogToExcelConverterDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("LogToExcelConverter.DLL Terminating!\n");
        // Terminate the library before destructors are called
        AfxTermExtensionModule(LogToExcelConverterDLL);
    }

    return 1;   // ok
}

#ifdef _MANAGED
#pragma managed(pop)
#endif

extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CLogToExcelConverter();
    return S_OK;
}

CLogToExcelConverter::CLogToExcelConverter(void)
{
}

CLogToExcelConverter::~CLogToExcelConverter(void)
{
};

HRESULT CLogToExcelConverter::GetHelpText(string&)
{
    return S_FALSE;
}
HRESULT CLogToExcelConverter::GetConverterName(string&)
{
    return S_FALSE;
}
HRESULT CLogToExcelConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    return S_FALSE;
}
HRESULT CLogToExcelConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    return S_FALSE;
}
HRESULT CLogToExcelConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    return S_FALSE;
}

HRESULT CLogToExcelConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    return S_FALSE;
}
HRESULT CLogToExcelConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    return S_FALSE;
}
BOOL CLogToExcelConverter::bHaveOwnWindow()
{
    return TRUE;
}

HRESULT CLogToExcelConverter::GetPropertyPage(CPropertyPage*& pPage)
{
    pPage = new CExportLogFileDlg();
    return S_FALSE;
};


























extern "C" int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile);






CAscLogConverter::CAscLogConverter(void)
{
}






CAscLogConverter::~CAscLogConverter(void)
{
}








HRESULT CAscLogConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the CANoe CAN log file(.asc) to BUSMASTER CAN log file(.log)";
    return ((HRESULT)0L);
}








HRESULT CAscLogConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "ASC TO LOG Conversion";
    return ((HRESULT)0L);
}









HRESULT CAscLogConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case ((HRESULT)0L):
            m_omstrConversionStatus = "Conversion success";
            break;

        case ((HRESULT)1L):
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return ((HRESULT)0L);
}










HRESULT CAscLogConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "asc";
    pchInputFilters = "CANoe Log File(s) (*.asc)|*.asc||";
    return ((HRESULT)0L);
}









HRESULT CAscLogConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return ((HRESULT)0L);
}










HRESULT CAscLogConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "log";
    pchOutputFilters = "BUSMASTER Log File(s) (*.log)|*.log||";
    return ((HRESULT)0L);
}









HRESULT CAscLogConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = ((HRESULT)0L);
    FILE* fpInputFile = 0;
    FILE* fpOutputFile = 0;
    fopen_s(&fpInputFile, chInputFile.c_str(), "r");

    if(0 != fpInputFile)
    {
        fopen_s(&fpOutputFile, chOutputFile.c_str(), "w");

        if(0 != fpOutputFile)
        {
            
			
			
           



			
            nConvertFile(fpInputFile, fpOutputFile);
            m_omstrConversionStatus = "Conversion Completed Successfully";
            fclose(fpInputFile);
            fclose(fpOutputFile);
        }
        else
        {
            m_omstrConversionStatus = "Output File path is not found";
            hResult = (-2);
        }
    }
    else
    {
        m_omstrConversionStatus = "Input File path is not found";
        hResult = (-1);
    }

    m_hResult = hResult;
    return hResult;
}







BOOL CAscLogConverter::bHaveOwnWindow()
{
    return 0;
}
























#pragma once





using namespace std;




class CAscLogConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CAscLogConverter(void);
    ~CAscLogConverter(void);
    virtual HRESULT GetInputFileFilters(string&, string& );
    virtual HRESULT GetOutputFileFilters(string&, string& );
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return ((HRESULT)1L);
    };
};
          Ï      Ï      Îÿÿÿÿ   Îÿÿÿÿ    0W0       statement executed        return 0;    Ïÿÿÿÿ   Î      Ïÿÿÿÿ   Î                    Ä      Ä      Ãÿÿÿÿ   Ãÿÿÿÿ    0Tğ       statement executed        return hResult;    Äÿÿÿÿ   Ã      Äÿÿÿÿ   Ã                    Á      Á      Àÿÿÿÿ   Àÿÿÿÿ    0Qè       statement executed        }    Áÿÿÿÿ   À      Áÿÿÿÿ   À                    »   	   »   
   ºÿÿÿÿ   ºÿÿÿÿ    ((       statement executed        }    »ÿÿÿÿ   º   	   »ÿÿÿÿ   º   
                 ¶   	   ¶   
   µÿÿÿÿ   µÿÿÿÿ    ((       statement executed        }    ¶ÿÿÿÿ   µ   	   ¶ÿÿÿÿ   µ   
                 ’      ’      ‘ÿÿÿÿ   ‘ÿÿÿÿ    1‡(       statement executed        return ((HRESULT)0L);    ’ÿÿÿÿ   ‘      ’ÿÿÿÿ   ‘                    ‚      ‚      ÿÿÿÿ   ÿÿÿÿ    1‚X       statement executed        return ((HRESULT)0L);    ‚ÿÿÿÿ         ‚ÿÿÿÿ                       s      s      rÿÿÿÿ   rÿÿÿÿ    "-¨       statement executed        return ((HRESULT)0L);    sÿÿÿÿ   r      sÿÿÿÿ   r                    c      c      bÿÿÿÿ   bÿÿÿÿ    ")ˆ       statement executed        return ((HRESULT)0L);    cÿÿÿÿ   b      cÿÿÿÿ   b              	      `      `      _ÿÿÿÿ   _ÿÿÿÿ    "(°       statement executed        break;    `ÿÿÿÿ   _      `ÿÿÿÿ   _              
      \      \      [ÿÿÿÿ   [ÿÿÿÿ    CUX       statement executed        break;    \ÿÿÿÿ   [      \ÿÿÿÿ   [                    X      X      Wÿÿÿÿ   Wÿÿÿÿ    CSX       statement executed        break;    Xÿÿÿÿ   W      Xÿÿÿÿ   W                    G      G      Fÿÿÿÿ   Fÿÿÿÿ    CPP       statement executed        return ((HRESULT)0L);    Gÿÿÿÿ   F      Gÿÿÿÿ   F                    :      :      9ÿÿÿÿ   9ÿÿÿÿ     üÀ       statement executed        return ((HRESULT)0L);    :ÿÿÿÿ   9      :ÿÿÿÿ   9                    .      .      -ÿÿÿÿ   -ÿÿÿÿ     ô³        statement executed        }    .ÿÿÿÿ   -      .ÿÿÿÿ   -                    %      %      $ÿÿÿÿ   $ÿÿÿÿ    3Ã0       statement executed        }    %ÿÿÿÿ   $      %ÿÿÿÿ   $                    7   	   7      5ÿÿÿÿ   5ÿÿÿÿ    =äÈ       statement executed        return ((HRESULT)1L);    7ÿÿÿÿ   5   	   7ÿÿÿÿ   5           CAscLogConverter::CAscLogConverter CAscLogConverter::CAscLogConverter(void)    $      %      #ÿÿÿÿ   $ÿÿÿÿCAscLogConverter::~CAscLogConverter CAscLogConverter::~CAscLogConverter(void)    -      .      ,ÿÿÿÿ   -ÿÿÿÿCAscLogConverter::GetHelpText HRESULT CAscLogConverter::GetHelpText(string& pchHelpText)    8      ;      7ÿÿÿÿ   :ÿÿÿÿCAscLogConverter::GetConverterName HRESULT CAscLogConverter::GetConverterName(string& strConverterName)    E      H      Dÿÿÿÿ   GÿÿÿÿCAscLogConverter::GetErrorStatus HRESULT CAscLogConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)    S      d      Rÿÿÿÿ   cÿÿÿÿCAscLogConverter::GetInputFileFilters HRESULT CAscLogConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)    p      t      oÿÿÿÿ   sÿÿÿÿCAscLogConverter::GetLastConversionStatus HRESULT CAscLogConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)          ƒ      ~ÿÿÿÿ   ‚ÿÿÿÿCAscLogConverter::GetOutputFileFilters HRESULT CAscLogConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)          “      ÿÿÿÿ   ’ÿÿÿÿCAscLogConverter::ConvertFile HRESULT CAscLogConverter::ConvertFile(string& chInputFile, string& chOutputFile)          Å      ÿÿÿÿ   ÄÿÿÿÿCAscLogConverter::bHaveOwnWindow BOOL CAscLogConverter::bHaveOwnWindow()    Î      Ğ      Íÿÿÿÿ   Ïÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿCAscLogConverter::GetPropertyPage HRESULT GetPropertyPage(CPropertyPage*& pPage)    6      8      4ÿÿÿÿ   6ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      AscLogConverter.cpp
 * \brief     Implementation of the AscLogConverter class and DLLMain Function.
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the AscLogConverter class.
 */

/* Project includes */
#include "AscLogConverter.h"

extern "C" int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile);

/**
 * \brief Constructor
 *
 * Constructor of CAscLogConverter
 */
CAscLogConverter::CAscLogConverter(void)
{
}

/**
 * \brief Destructor
 *
 * Destructor of CAscLogConverter
 */
CAscLogConverter::~CAscLogConverter(void)
{
}

/**
 * \brief      Get help text
 * \param[out] pchHelpText Help Text
 * \return     Result code
 *
 * Returns pchHelpText containing the help text.
 */
HRESULT CAscLogConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the CANoe CAN log file(.asc) to BUSMASTER CAN log file(.log)";
    return S_OK;
}

/**
 * \brief      Get converter name
 * \param[out] strConverterName Converter Name
 * \return     Result code
 *
 * Returns strConverterName containing the converter name.
 */
HRESULT CAscLogConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "ASC TO LOG Conversion";
    return S_OK;
}

/**
 * \brief      Get error status string
 * \param[in]  hResult Error code
 * \param[out] omstrStatus Corresponding error string
 * \return     Result code
 *
 * Returns omstrStatus containing the error string depending on hResult.
 */
HRESULT CAscLogConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case S_OK:
            m_omstrConversionStatus = "Conversion success";
            break;

        case S_FALSE:
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return S_OK;
}

/**
 * \brief      Get input file filter type and name
 * \param[out] pchInputDefFilters file filter types
 * \param[out] pchInputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CAscLogConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "asc";
    pchInputFilters = "CANoe Log File(s) (*.asc)|*.asc||";
    return S_OK;
}

/**
 * \brief      Get last conversion status
 * \param[out] hResult Last conversion status.
 * \param[out] omstrStatus String describing the last conversion status.
 * \return     Result code
 *
 * Returns a string containing the last conversion status.
 */
HRESULT CAscLogConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return S_OK;
}

/**
 * \brief      Get output file filter type and name
 * \param[out] pchOutputDefFilters file filter types
 * \param[out] pchOutputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CAscLogConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "log";
    pchOutputFilters = "BUSMASTER Log File(s) (*.log)|*.log||";
    return S_OK;
}

/**
 * \brief     Conversion function
 * \param[in] chInputFile Input file name to convert from
 * \param[in] chOutputFile Output file name to convert to
 * \return    Result code
 *
 * This is the actual conversion function with input and output file name.
 */
HRESULT CAscLogConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = S_OK;
    FILE* fpInputFile = NULL;
    FILE* fpOutputFile = NULL;
    fopen_s(&fpInputFile, chInputFile.c_str(), _T("r"));

    if(NULL != fpInputFile)
    {
        fopen_s(&fpOutputFile, chOutputFile.c_str(), _T("w"));

        if(NULL != fpOutputFile)
        {
            //yydebug = 1;
			// PTV[1.6.4]
			// Removed here and added at the start of every block
           /* fprintf(fpOutputFile, "***BUSMASTER Ver 1.6.3***\n");
            fprintf(fpOutputFile, "***NOTE: PLEASE DO NOT EDIT THIS DOCUMENT***\n");
            fprintf(fpOutputFile, "***[START LOGGING SESSION]***\n");
            fprintf(fpOutputFile, "***START DATE AND TIME ");*/
			// PTV[1.6.4]
            nConvertFile(fpInputFile, fpOutputFile);
            m_omstrConversionStatus = "Conversion Completed Successfully";
            fclose(fpInputFile);
            fclose(fpOutputFile);
        }
        else
        {
            m_omstrConversionStatus = "Output File path is not found";
            hResult = ERR_OUTPUT_FILE_NOTFOUND;
        }
    }
    else
    {
        m_omstrConversionStatus = "Input File path is not found";
        hResult = ERR_INPUT_FILE_NOTFOUND;
    }

    m_hResult = hResult;
    return hResult;
}

/**
 * \brief     Returns if it has an own window
 * \return    True, if it has an own window.
 *
 * This returns true, if the converter has an own window, false otherwise.
 */
BOOL CAscLogConverter::bHaveOwnWindow()
{
    return FALSE;
}
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      AscLogConverter.h
 * \brief     Descripton of the AscLogConverter class and DLLMain Function.
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Description of the AscLogConverter class.
 */

#pragma once

/* C++ includes */
#include <string>

/* Project includes */
#include "../FormatConverterApp/BaseConverter.h"

using namespace std;

#define ERR_INPUT_FILE_NOTFOUND          (-1)
#define ERR_OUTPUT_FILE_NOTFOUND         (-2)

class CAscLogConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CAscLogConverter(void);
    ~CAscLogConverter(void);
    virtual HRESULT GetInputFileFilters(string&, string& );
    virtual HRESULT GetOutputFileFilters(string&, string& );
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return S_FALSE;
    };
};










































static AFX_EXTENSION_MODULE AscLogConverterDLL = { 0, 0 };





extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
    (lpReserved);

    if (dwReason == 1)
    {
        ;

        
        if (!AfxInitExtensionModule(AscLogConverterDLL, hInstance))
        {
            return 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        new CDynLinkLibrary(AscLogConverterDLL);
    }
    else if (dwReason == 0)
    {
        ;
        
        AfxTermExtensionModule(AscLogConverterDLL);
    }

    return 1;   
}





extern "C" int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile);
extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CAscLogConverter();
    return ((HRESULT)0L);
}
          T      T      Nÿÿÿÿ   Nÿÿÿÿ     ïÈ      expression was false       dwReason == 0    Tÿÿÿÿ   N      Tÿÿÿÿ   N                   ïÆ          D      D      >ÿÿÿÿ   >ÿÿÿÿ    3Äè       statement executed        return 0;    Dÿÿÿÿ   >      Dÿÿÿÿ   >                    S      S      Mÿÿÿÿ   Mÿÿÿÿ     ïÄø       statement executed        }    Sÿÿÿÿ   M      Sÿÿÿÿ   M                    Y      Y      Sÿÿÿÿ   Sÿÿÿÿ     ïÇ@       statement executed        }    Yÿÿÿÿ   S      Yÿÿÿÿ   S                    [      [      Uÿÿÿÿ   Uÿÿÿÿ     ô°       statement executed        return 1;    [ÿÿÿÿ   U      [ÿÿÿÿ   U                    f      f      `ÿÿÿÿ   `ÿÿÿÿ     ô³Ø       statement executed        return ((HRESULT)0L);    fÿÿÿÿ   `      fÿÿÿÿ   `                    B      B   C   <ÿÿÿÿ   <ÿÿÿÿ     ïÃ°      expression was false       !AfxInitExtensionModule(AscLogConverterDLL, hInstance)    Bÿÿÿÿ   <      Bÿÿÿÿ   <   C               3Ä@         7   	   7      5ÿÿÿÿ   5ÿÿÿÿ     (Ş(       statement executed        return ((HRESULT)1L);    7ÿÿÿÿ   5   	   7ÿÿÿÿ   5           DllMain extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)    9      \      3ÿÿÿÿ   VÿÿÿÿGetBaseConverter extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)    d      g      ^ÿÿÿÿ   aÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      AscLogConverterDLL.cpp
 * \brief     Implementation of the AscLogConverter class and DLLMain Function.
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines the initialization routines for the DLL.
 */

/* MFC includes */
#define VC_EXTRALEAN        /* Exclude rarely-used stuff from Windows headers */

#include <afxwin.h>         /* MFC core and standard components */
#include <afxext.h>         /* MFC extensions */

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         /* MFC support for Windows Common Controls */
#endif /* _AFX_NO_AFXCMN_SUPPORT */
#include <afxdllx.h>

/* Project includes */
#include "AscLogConverter.h"

#ifdef _MANAGED
#error Please read instructions in AscLogConverter.cpp to compile with /clr
// If you want to add /clr to your project you must do the following:
//  1. Remove the above include for afxdllx.h
//  2. Add a .cpp file to your project that does not have /clr thrown and has
//     Precompiled headers disabled, with the following text:
//          #include <afxwin.h>
//          #include <afxdllx.h>
#endif

static AFX_EXTENSION_MODULE AscLogConverterDLL = { NULL, NULL };

#ifdef _MANAGED
#pragma managed(push, off)
#endif

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("AscLogConverter.DLL Initializing!\n");

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(AscLogConverterDLL, hInstance))
        {
            return 0;
        }

        // Insert this DLL into the resource chain
        // NOTE: If this Extension DLL is being implicitly linked to by
        //  an MFC Regular DLL (such as an ActiveX Control)
        //  instead of an MFC application, then you will want to
        //  remove this line from DllMain and put it in a separate
        //  function exported from this Extension DLL.  The Regular DLL
        //  that uses this Extension DLL should then explicitly call that
        //  function to initialize this Extension DLL.  Otherwise,
        //  the CDynLinkLibrary object will not be attached to the
        //  Regular DLL's resource chain, and serious problems will
        //  result.
        new CDynLinkLibrary(AscLogConverterDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("AscLogConverter.DLL Terminating!\n");
        // Terminate the library before destructors are called
        AfxTermExtensionModule(AscLogConverterDLL);
    }

    return 1;   // ok
}

#ifdef _MANAGED
#pragma managed(pop)
#endif

extern "C" int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile);
extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CAscLogConverter();
    return S_OK;
}




























































































typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;





































typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		
	char *yy_buf_pos;		

	


	yy_size_t yy_buf_size;

	


	int yy_n_chars;

	



	int yy_is_our_buffer;

	




	int yy_is_interactive;

	



	int yy_at_bol;

	


	int yy_fill_buffer;

	int yy_buffer_status;


	










	};

static YY_BUFFER_STATE yy_current_buffer = 0;









static char yy_hold_char;

static int yy_n_chars;		


int yyleng;


static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		
static int yy_start = 0;	




static int yy_did_buffer_switch_on_eof;

void yyrestart ();

void yy_switch_to_buffer ();
void yy_load_buffer_state ();
YY_BUFFER_STATE yy_create_buffer ();
void yy_delete_buffer ();
void yy_init_buffer ();
void yy_flush_buffer ();


YY_BUFFER_STATE yy_scan_buffer ();
YY_BUFFER_STATE yy_scan_string ();
YY_BUFFER_STATE yy_scan_bytes ();

static void *yy_flex_alloc ();
static void *yy_flex_realloc ();
static void yy_flex_free ();



















typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;


static yy_state_type yy_get_previous_state ();
static yy_state_type yy_try_NUL_trans ();
static int yy_get_next_buffer ();
static void yy_fatal_error ();













static  short int yy_accept[137] =
    {   0,
        0,    0,   27,   25,   24,   23,   15,   20,   15,   15,
       15,   15,   15,   15,   25,   25,   25,   25,   25,   25,
       25,   18,   25,   25,   25,   24,   16,   15,    0,   15,
       17,   15,   14,    0,    0,   15,   15,    0,   15,   15,
        0,   15,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   19,    0,    0,    0,    0,    0,    0,    0,
       16,    0,    0,    4,    5,    0,    0,    0,    0,    6,
        0,    4,    8,   10,    0,    7,    6,    0,    0,    0,
        0,   11,    0,    0,    3,    0,    0,    0,    0,    9,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,   21,    0,    0,    0,    0,    0,    0,    0,    0,
       13,    0,   22,    0,    0,    0,    0,    0,    0,    0,
       12,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    2,    0,    1,    0
    } ;

static  int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    5,    1,    6,    6,    6,
        6,    6,    6,    6,    6,    6,    6,    7,    1,    1,
        8,    1,    1,    1,    9,   10,   11,   12,   13,   14,
       15,   16,   17,   18,   19,   20,   21,   22,   23,   24,
        1,   25,   26,   27,   28,   29,   30,   31,   32,    1,
        1,    1,    1,    1,    1,    1,    9,   10,   11,   12,

       13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
       23,   24,    1,   25,   26,   27,   28,   29,   30,   31,
       32,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static  int yy_meta[33] =
    {   0,
        1,    1,    1,    1,    2,    2,    2,    1,    2,    2,
        2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        2,    1
    } ;

static  short int yy_base[138] =
    {   0,
        0,    0,  183,  184,   31,  184,   31,  184,   57,   83,
       34,   31,  160,   21,  168,   33,  167,   34,  156,  167,
      156,   41,   36,   59,  163,   46,  169,   46,  168,    0,
      184,  147,  184,  147,  156,  144,  154,  141,  140,  155,
      153,  154,  146,  131,  139,   36,  138,   48,  137,  129,
      130,  136,  184,  128,  130,  131,  124,  130,  137,  137,
      142,   53,  124,  184,  184,  133,  128,  133,  130,    0,
      138,    0,  184,  184,  126,  184,  184,  131,  126,  132,
      117,  184,  114,  112,  184,  107,  106,  105,  105,  124,
      101,  124,   99,  101,  109,  107,   96,   95,   94,   98,

      102,  184,   89,  108,  103,   90,   86,   97,   98,   89,
      184,   92,  184,   93,   83,   91,   92,   78,   88,   77,
      184,   88,   89,   73,   71,   76,   61,   63,   71,   56,
       58,   63,  184,   36,  184,  184,   45
    } ;

static  short int yy_def[138] =
    {   0,
      136,    1,  136,  136,  136,  136,  137,  136,  136,  136,
      137,   11,   11,   11,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,   11,  136,   11,
      136,   11,  136,  136,  136,   11,   11,  136,   11,   11,
      136,   11,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,   11,
      136,   11,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,

      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,    0,  136
    } ;

static  short int yy_nxt[217] =
    {   0,
        4,    5,    6,    5,    4,    7,    4,    8,    9,   10,
       11,   12,   13,   14,    4,   15,    4,   16,    4,   17,
       18,   19,   20,   21,   22,   23,   24,    4,    4,   25,
        4,    4,   26,   42,   26,   27,   28,   29,  136,   39,
      136,   45,   48,   40,   54,   43,   30,   26,   55,   26,
       27,   28,   29,   52,  135,   65,   49,   65,   62,   80,
       46,   31,   30,   56,   31,   30,   32,   30,   30,   30,
       30,   53,   64,  134,   57,   58,  133,   33,  132,   65,
       34,  131,  130,  129,   35,  128,   59,   31,   30,   53,
      127,   36,   30,   30,   30,   37,   30,  126,  125,   38,

      124,  123,  122,  121,  120,  119,  118,  117,  116,  115,
      111,  114,  113,   31,  112,  111,  110,  109,  108,  107,
      106,  105,  104,  103,  102,  101,  100,   99,   98,   90,
       97,   96,   95,   94,   93,   92,   91,   90,   89,   88,
       87,   86,   85,   84,   83,   82,   81,   61,   73,   76,
       79,   73,   76,   77,   76,   78,   77,   77,   76,   75,
       64,   74,   73,   72,   71,   70,   69,   68,   67,   66,
       65,   64,   63,   62,   61,   60,   33,   51,   50,   47,
       44,   41,  136,    3,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,

      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136
    } ;

static  short int yy_chk[217] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    5,   14,    5,    7,    7,    7,   11,   12,
       11,   16,   18,   12,   23,   14,  137,   26,   23,   26,
       28,   28,   28,   22,  134,   46,   18,   46,   62,   62,
       16,    7,    9,   23,   11,    9,    9,    9,    9,    9,
        9,   22,   48,  132,   24,   24,  131,    9,  130,   48,
        9,  129,  128,  127,    9,  126,   24,    9,   10,   24,
      125,   10,   10,   10,   10,   10,   10,  124,  123,   10,

      122,  120,  119,  118,  117,  116,  115,  114,  112,  110,
      109,  108,  107,   10,  106,  105,  104,  103,  101,  100,
       99,   98,   97,   96,   95,   94,   93,   92,   91,   90,
       89,   88,   87,   86,   84,   83,   81,   80,   79,   78,
       75,   71,   69,   68,   67,   66,   63,   61,   60,   59,
       58,   57,   56,   55,   54,   52,   51,   50,   49,   47,
       45,   44,   43,   42,   41,   40,   39,   38,   37,   36,
       35,   34,   32,   29,   27,   25,   21,   20,   19,   17,
       15,   13,    3,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,

      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;







char *yytext;












extern int yywrap ();


static void yyunput ();









static int input ();


































































































int yylex ()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;





		if ( ! yy_start )
			yy_start = 1;	

		if ( ! yyin )
			yyin = (&__iob_func()[0]);

		if ( ! yyout )
			yyout = (&__iob_func()[1]);

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, 16384 );

		yy_load_buffer_state();
		}

	while ( 1 )		
		{
		yy_cp = yy_c_buf_p;

		
		*yy_cp = yy_hold_char;

		


		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[((unsigned int) (unsigned char) *yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 137 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 184 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ 
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		yytext = yy_bp; yyleng = (int) (yy_cp - yy_bp); yy_hold_char = *yy_cp; *yy_cp = '\0'; yy_c_buf_p = yy_cp;;


do_action:	


		switch ( yy_act )
	{ 
			case 0: 
			
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:

yylval = (int)_strdup(yytext);return 284;
	break;
case 2:

yylval = (int)_strdup(yytext);return 286;
	break;
case 3:

yylval = (int)_strdup(yytext);return 274;
	break;
case 4:

yylval = (int)_strdup(yytext); return 271;
	break;
case 5:

yylval = (int)_strdup(yytext); return 271; 
	break;
case 6:

yylval = (int)_strdup(yytext); return 271;
	break;
case 7:

yylval = (int)_strdup(yytext); return 272;
	break;
case 8:

yylval = (int)_strdup(yytext); return 272;
	break;
case 9:

yylval = (int)_strdup(yytext);return 273;
	break;
case 10:

yylval = (int)_strdup(yytext);return 281;
	break;
case 11:

yylval = (int)_strdup(yytext);return 280;
	break;
case 12:

yylval = (int)_strdup(yytext);return 282;
	break;
case 13:

yylval = (int)_strdup(yytext);return 283;
	break;
case 14:

yylval = (int)_strdup(yytext); return 279;
	break;
case 15:

yylval =(int)_strdup(yytext);return 259;
	break;
case 16:

yylval =(int)_strdup(yytext);return 264;
	break;
case 17:

yylval =(int)_strdup(yytext);return 270;
	break;
case 18:

yylval =(int)_strdup(yytext);return 275;
	break;
case 19:

yylval =(int)_strdup(yytext);return 265;
	break;
case 20:

return 269;
	break;
case 21:

return 267;
	break;
case 22:

return 268;
	break;
case 23:

return 285;
	break;
case 24:

;
	break;
case 25:

;
	break;
case 26:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case (27 + 0 + 1):
	return 0;

	case 27:
		{
		
		int yy_amount_of_matched_text = (int) (yy_cp - yytext) - 1;

		
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == 0 )
			{
			








			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = 1;
			}

		






		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ 
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			








			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext + 0;

			if ( yy_next_state )
				{
				
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case 1:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					








					yy_c_buf_p = yytext + 0;

					yy_act = (27 + ((yy_start - 1) / 2) + 1);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );
					}
				break;
				}

			case 0:
				yy_c_buf_p =
					yytext + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_match;

			case 2:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_find_action;
			}
		break;
		}

	default:
		yy_fatal_error( "fatal flex scanner internal error--no action found" );
	} 
		} 
	} 










static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ 
		if ( yy_c_buf_p - yytext - 0 == 1 )
			{
			


			return 1;
			}

		else
			{
			


			return 2;
			}
		}

	

	
	number_to_move = (int) (yy_c_buf_p - yytext) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == 2 )
		


		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ 





			
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				yy_fatal_error( "fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
			}

		if ( num_to_read > 8192 )
			num_to_read = 8192;

		
		if ( yy_current_buffer->yy_is_interactive ) { int c = '*', n; for ( n = 0; n < num_to_read && (c = getc( yyin )) != (-1) && c != '\n'; ++n ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c; if ( c == '\n' ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c; if ( c == (-1) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" ); yy_n_chars = n; } else if ( ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" );;
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == 0 )
			{
			ret_val = 1;
			yyrestart( yyin );
			}

		else
			{
			ret_val = 2;
			yy_current_buffer->yy_buffer_status =
				2;
			}
		}

	else
		ret_val = 0;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = 0;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = 0;

	yytext = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}




static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext + 0; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[((unsigned int) (unsigned char) *yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 137 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}











static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 137 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 136);

	return yy_is_jam ? 0 : yy_current_state;
	}






static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
	{
	register char *yy_cp = yy_c_buf_p;

	
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ 
		
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			yy_fatal_error( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}





static int input()
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == 0 )
		{
		



		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			
			*yy_c_buf_p = '\0';

		else
			{ 
			yytext = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case 1:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext + 0;
						return (-1);
						}

					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );



					return input();
					}

				case 0:
					yy_c_buf_p = yytext + 0;
					break;

				case 2:




					yy_fatal_error( "unexpected last match in input()" );
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	
	*yy_c_buf_p = '\0';	
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}





void yyrestart( input_file )
FILE *input_file;
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, 16384 );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}





void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	




	yy_did_buffer_switch_on_eof = 1;
	}





void yy_load_buffer_state()
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}





YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	


	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}





void yy_delete_buffer( b )
YY_BUFFER_STATE b;
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}




extern int isatty ();




void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;





	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
	}





void yy_flush_buffer( b )
YY_BUFFER_STATE b;

	{
	b->yy_n_chars = 0;

	



	b->yy_ch_buf[0] = 0;
	b->yy_ch_buf[1] = 0;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = 0;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}






YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != 0 ||
	     base[size-1] != 0 )
		
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = 0;

	yy_switch_to_buffer( b );

	return b;
	}






YY_BUFFER_STATE yy_scan_string( str )
 char *str;
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}






YY_BUFFER_STATE yy_scan_bytes( bytes, len )
 char *bytes;
int len;
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = 0;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		yy_fatal_error( "bad buffer in yy_scan_bytes()" );

	


	b->yy_is_our_buffer = 1;

	return b;
	}




























































static void yy_fatal_error( msg )
char msg[];
	{
	(void) fprintf( (&__iob_func()[2]), "%s\n", msg );
	exit( 2 );
	}









































static void *yy_flex_alloc( size )
yy_size_t size;
	{
	return (void *) malloc( size );
	}




static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
	{
	






	return (void *) realloc( (char *) ptr, size );
	}




static void yy_flex_free( ptr )
void *ptr;
	{
	free( ptr );
	}









         ş  ú  ş    àÿÿÿÿ  àÿÿÿÿ     â™€      expression was true       ferror( yyin )   şÿÿÿÿ  à  ú  şÿÿÿÿ  à     expression was false       ferror( yyin )   şÿÿÿÿ  à  ú  şÿÿÿÿ  à                  ş  ’  ş  ö  àÿÿÿÿ  àÿÿÿÿ     â˜˜      expression was true       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   şÿÿÿÿ  à  ’  şÿÿÿÿ  à  ö   expression was false       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   şÿÿÿÿ  à  ’  şÿÿÿÿ  à  ö                â—p        ş  3  ş  A  àÿÿÿÿ  àÿÿÿÿ     â@      expression was true       ferror( yyin )   şÿÿÿÿ  à  3  şÿÿÿÿ  à  A   expression was false       ferror( yyin )   şÿÿÿÿ  à  3  şÿÿÿÿ  à  A                ş  &  ş  /  àÿÿÿÿ  àÿÿÿÿ     âX      expression was true       c == (-1)   şÿÿÿÿ  à  &  şÿÿÿÿ  à  /   expression was false       c == (-1)   şÿÿÿÿ  à  &  şÿÿÿÿ  à  /                â0        ş     ş   ˆ  àÿÿÿÿ  àÿÿÿÿ     1	à      expression was true       c != '\n'   şÿÿÿÿ  à     şÿÿÿÿ  à   ˆ   expression was false       c != '\n'   şÿÿÿÿ  à     şÿÿÿÿ  à   ˆ                1    
     ş   a  ş   {  àÿÿÿÿ  àÿÿÿÿ     1       expression was true       (c = getc( yyin )) != (-1)   şÿÿÿÿ  à   a  şÿÿÿÿ  à   {   expression was false       (c = getc( yyin )) != (-1)   şÿÿÿÿ  à   a  şÿÿÿÿ  à   {                1P        ş   N  ş   ]  àÿÿÿÿ  àÿÿÿÿ     1H      expression was true       n < num_to_read   şÿÿÿÿ  à   N  şÿÿÿÿ  à   ]   expression was false       n < num_to_read   şÿÿÿÿ  à   N  şÿÿÿÿ  à   ]                *     *   "  ÿÿÿÿ  ÿÿÿÿ     +FĞ      expression was true       *yy_cp   *ÿÿÿÿ       *ÿÿÿÿ     "   expression was false       *yy_cp   *ÿÿÿÿ       *ÿÿÿÿ     "                Æ     Æ     ÿÿÿÿ  ÿÿÿÿ     ,/à      expression was false       i < len   Æÿÿÿÿ       Æÿÿÿÿ                     ª     ª     tÿÿÿÿ  tÿÿÿÿ     , ˜      expression was false       str[len]   ªÿÿÿÿ  t     ªÿÿÿÿ  t                   (     (   .  	ÿÿÿÿ  	ÿÿÿÿ     +Z`      expression was false       yy_cp < yy_c_buf_p   (ÿÿÿÿ  	     (ÿÿÿÿ  	   .                Z     Z     *ÿÿÿÿ  *ÿÿÿÿ     +õ(      expression was true       file   Zÿÿÿÿ  *     Zÿÿÿÿ  *      expression was false       file   Zÿÿÿÿ  *     Zÿÿÿÿ  *                   Â     Â   !  ¦ÿÿÿÿ  ¦ÿÿÿÿ     5        expression was false       i < number_to_move   Âÿÿÿÿ  ¦     Âÿÿÿÿ  ¦   !                w     w   0  Vÿÿÿÿ  Vÿÿÿÿ     +„(      expression was false       source > yy_current_buffer->yy_ch_buf   wÿÿÿÿ  V     wÿÿÿÿ  V   0                S   
  S   F  3ÿÿÿÿ  3ÿÿÿÿ     +o      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   Sÿÿÿÿ  3   
  Sÿÿÿÿ  3   F                +fÈ        0     0   G  ÿÿÿÿ  ÿÿÿÿ     +W8      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   0ÿÿÿÿ       0ÿÿÿÿ     G                +Nø        Ğ     Ğ     ´ÿÿÿÿ  ´ÿÿÿÿ     0ü       expression was false       num_to_read <= 0   Ğÿÿÿÿ  ´     Ğÿÿÿÿ  ´                   5¨        ˆ     ˆ   H  nÿÿÿÿ  nÿÿÿÿ     5      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   ˆÿÿÿÿ  n     ˆÿÿÿÿ  n   H                5°        r   
  r     Xÿÿÿÿ  Xÿÿÿÿ     4&ø      expression was false       1   rÿÿÿÿ  X   
  rÿÿÿÿ  X                   ‘     ‘   +  wÿÿÿÿ  wÿÿÿÿ     4ş       expression was true       yy_base[yy_current_state] != 184   ‘ÿÿÿÿ  w     ‘ÿÿÿÿ  w   +   expression was false       yy_base[yy_current_state] != 184   ‘ÿÿÿÿ  w     ‘ÿÿÿÿ  w   +                5H        Ì     Ì   
  ”ÿÿÿÿ  ”ÿÿÿÿ     ,5¨      expression was false       ! b   Ìÿÿÿÿ  ”     Ìÿÿÿÿ  ”   
                ,3°        Ã     Ã     ‹ÿÿÿÿ  ‹ÿÿÿÿ     ,,ˆ      expression was false       ! buf   Ãÿÿÿÿ  ‹     Ãÿÿÿÿ  ‹                   ,*                 
  Yÿÿÿÿ  Yÿÿÿÿ     ,Ø      expression was false       ! b   ÿÿÿÿ  Y     ÿÿÿÿ  Y   
                ,
à   !     †     †     Rÿÿÿÿ  Rÿÿÿÿ     , ˜      expression was true       size < 2   †ÿÿÿÿ  R     †ÿÿÿÿ  R      expression was false       size < 2   †ÿÿÿÿ  R     †ÿÿÿÿ  R              #     v     v     Cÿÿÿÿ  Cÿÿÿÿ     ä*       expression was false       b == yy_current_buffer   vÿÿÿÿ  C     vÿÿÿÿ  C                   ä(    $     8     8     ÿÿÿÿ  ÿÿÿÿ     +ë       expression was false       b->yy_is_our_buffer   8ÿÿÿÿ       8ÿÿÿÿ                %     5     5     
ÿÿÿÿ  
ÿÿÿÿ     +éX      expression was false       b == yy_current_buffer   5ÿÿÿÿ  
     5ÿÿÿÿ  
                   +åP   &     2     2   
  ÿÿÿÿ  ÿÿÿÿ     +ä      expression was false       ! b   2ÿÿÿÿ       2ÿÿÿÿ     
                +âø   '                 öÿÿÿÿ  öÿÿÿÿ     +İ      expression was false       ! b->yy_ch_buf    ÿÿÿÿ  ö      ÿÿÿÿ  ö                   +Û    (             
  íÿÿÿÿ  íÿÿÿÿ     +ÕĞ      expression was false       ! b   ÿÿÿÿ  í     ÿÿÿÿ  í   
                +ÓØ   )     ë     ë     Ãÿÿÿÿ  Ãÿÿÿÿ     +Âà      expression was false       yy_current_buffer   ëÿÿÿÿ  Ã     ëÿÿÿÿ  Ã              *     è     è   &  Àÿÿÿÿ  Àÿÿÿÿ     +»à      expression was false       yy_current_buffer == new_buffer   èÿÿÿÿ  À     èÿÿÿÿ  À   &                +ºÀ   +     Ù     Ù     ²ÿÿÿÿ  ²ÿÿÿÿ     +µØ      expression was false       ! yy_current_buffer   Ùÿÿÿÿ  ²     Ùÿÿÿÿ  ²                   +³`   ,     °     °   (  ÿÿÿÿ  ÿÿÿÿ     +¥0      expression was false       ! yy_did_buffer_switch_on_eof   °ÿÿÿÿ       °ÿÿÿÿ     (                +£P   -     ©     ©     †ÿÿÿÿ  †ÿÿÿÿ     +¢H      expression was false       yywrap()   ©ÿÿÿÿ  †     ©ÿÿÿÿ  †              .     –     –     sÿÿÿÿ  sÿÿÿÿ     +¬P      expression was false       *yy_c_buf_p == 0   –ÿÿÿÿ  s     –ÿÿÿÿ  s                   +™¨   /     ~     ~   0  ]ÿÿÿÿ  ]ÿÿÿÿ     +(      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   ~ÿÿÿÿ  ]     ~ÿÿÿÿ  ]   0                +‹0   0     n     n   /  Mÿÿÿÿ  Mÿÿÿÿ     +è      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   nÿÿÿÿ  M     nÿÿÿÿ  M   /                +zğ   1     V     V     6ÿÿÿÿ  6ÿÿÿÿ     +mH      expression was false       yy_current_state >= 137   Vÿÿÿÿ  6     Vÿÿÿÿ  6                   +j@   2     N     N   "  .ÿÿÿÿ  .ÿÿÿÿ     +e`      expression was false       yy_accept[yy_current_state]   Nÿÿÿÿ  .     Nÿÿÿÿ  .   "           3     3   	  3      ÿÿÿÿ  ÿÿÿÿ     +Ux      expression was false       yy_current_state >= 137   3ÿÿÿÿ     	  3ÿÿÿÿ                      +Rp   4     +     +   #  ÿÿÿÿ  ÿÿÿÿ     +M      expression was false       yy_accept[yy_current_state]   +ÿÿÿÿ       +ÿÿÿÿ     #           5     ‡     ‡     Sÿÿÿÿ  Sÿÿÿÿ     ,(      expression was true       base[size-2] != 0   ‡ÿÿÿÿ  S     ‡ÿÿÿÿ  S      expression was false       base[size-2] != 0   ‡ÿÿÿÿ  S     ‡ÿÿÿÿ  S                   ,    7     ˆ     ˆ     Tÿÿÿÿ  Tÿÿÿÿ     ,È      expression was true       base[size-1] != 0   ˆÿÿÿÿ  T     ˆÿÿÿÿ  T      expression was false       base[size-1] != 0   ˆÿÿÿÿ  T     ˆÿÿÿÿ  T                   ,   9     ş   Ô  ş   İ  àÿÿÿÿ  àÿÿÿÿ     â‹0      expression was false       c == '\n'   şÿÿÿÿ  à   Ô  şÿÿÿÿ  à   İ                â‰€   :     ú     ú     Üÿÿÿÿ  Üÿÿÿÿ     0ÿ(      expression was false       num_to_read > 8192   úÿÿÿÿ  Ü     úÿÿÿÿ  Ü              ;     ï   	  ï     Óÿÿÿÿ  Óÿÿÿÿ     +/       expression was false       ! b->yy_ch_buf   ïÿÿÿÿ  Ó   	  ïÿÿÿÿ  Ó                   +,8   <     ª     ª   -  ÿÿÿÿ  ÿÿÿÿ     ò*      expression was false       yy_current_buffer->yy_fill_buffer == 0   ªÿÿÿÿ       ªÿÿÿÿ     -                ò#    =     ¦     ¦   A  ‹ÿÿÿÿ  ‹ÿÿÿÿ     ò#       expression was false       yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1]   ¦ÿÿÿÿ  ‹     ¦ÿÿÿÿ  ‹   A           >     r     r   (  Xÿÿÿÿ  Xÿÿÿÿ     4Mh      expression was false       ! yy_did_buffer_switch_on_eof   rÿÿÿÿ  X     rÿÿÿÿ  X   (                4Hà   ?             0  ÿÿÿÿ  ÿÿÿÿ     4•@      expression was false       yy_current_buffer->yy_buffer_status == 0   ÿÿÿÿ       ÿÿÿÿ     0                4İ8   @     •     •     {ÿÿÿÿ  {ÿÿÿÿ     4‚0      expression was false       yy_act == 0   •ÿÿÿÿ  {     •ÿÿÿÿ  {                   4ì@   A     ‹   
  ‹   !  qÿÿÿÿ  qÿÿÿÿ     5       expression was false       yy_current_state >= 137   ‹ÿÿÿÿ  q   
  ‹ÿÿÿÿ  q   !                5#°   B     ƒ   	  ƒ   $  iÿÿÿÿ  iÿÿÿÿ     5/Ğ      expression was false       yy_accept[yy_current_state]   ƒÿÿÿÿ  i   	  ƒÿÿÿÿ  i   $           C     k     k     Qÿÿÿÿ  Qÿÿÿÿ     5ˆ      expression was false       ! yy_current_buffer   kÿÿÿÿ  Q     kÿÿÿÿ  Q                   4¿    D     h     h     Nÿÿÿÿ  Nÿÿÿÿ     5]ø      expression was false       ! yyout   hÿÿÿÿ  N     hÿÿÿÿ  N                   5–Ø   E     e     e     Kÿÿÿÿ  Kÿÿÿÿ     5€Ğ      expression was false       ! yyin   eÿÿÿÿ  K     eÿÿÿÿ  K                   4©   F     b     b     Hÿÿÿÿ  Hÿÿÿÿ     4.¨      expression was false       ! yy_start   bÿÿÿÿ  H     bÿÿÿÿ  H                   5ˆ    G     Z     Z     @ÿÿÿÿ  @ÿÿÿÿ     5F       expression was false       yy_init   Zÿÿÿÿ  @     Zÿÿÿÿ  @              H     e     e     'ÿÿÿÿ  'ÿÿÿÿ     ,BĞ       statement executed        }   eÿÿÿÿ  '     eÿÿÿÿ  '              I     Z     Z   0  ÿÿÿÿ  ÿÿÿÿ     ,@P       statement executed        return (void *) realloc( (char *) ptr, size );   Zÿÿÿÿ       Zÿÿÿÿ     0           J     H     H   !  ÿÿÿÿ  ÿÿÿÿ     ,=˜       statement executed        return (void *) malloc( size );   Hÿÿÿÿ       Hÿÿÿÿ     !           K               Şÿÿÿÿ  Şÿÿÿÿ     ,;`       statement executed        exit( 2 );   ÿÿÿÿ  Ş     ÿÿÿÿ  Ş              L     Ô     Ô     œÿÿÿÿ  œÿÿÿÿ     ,7ø       statement executed        return b;   Ôÿÿÿÿ  œ     Ôÿÿÿÿ  œ              M     Í     Í   5  •ÿÿÿÿ  •ÿÿÿÿ     ,4Ğ       statement executed        yy_fatal_error( "bad buffer in yy_scan_bytes()" );   Íÿÿÿÿ  •     Íÿÿÿÿ  •   5           N     Ç     Ç     ÿÿÿÿ  ÿÿÿÿ     ,/       statement executed        buf[i] = bytes[i];   Çÿÿÿÿ       Çÿÿÿÿ                O     Ä     Ä   @  Œÿÿÿÿ  Œÿÿÿÿ     ,+°       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );   Äÿÿÿÿ  Œ     Äÿÿÿÿ  Œ   @           P     ­     ­   #  wÿÿÿÿ  wÿÿÿÿ     ,!(       statement executed        return yy_scan_bytes( str, len );   ­ÿÿÿÿ  w     ­ÿÿÿÿ  w   #           Q     «     «     uÿÿÿÿ  uÿÿÿÿ     ,        statement executed        ;   «ÿÿÿÿ  u     «ÿÿÿÿ  u              R     œ     œ     hÿÿÿÿ  hÿÿÿÿ     ,p       statement executed        return b;   œÿÿÿÿ  h     œÿÿÿÿ  h              S             A  Zÿÿÿÿ  Zÿÿÿÿ     ,        statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );   ÿÿÿÿ  Z     ÿÿÿÿ  Z   A           T     Š     Š     Vÿÿÿÿ  Vÿÿÿÿ     ,¨       statement executed        return 0;   Šÿÿÿÿ  V     Šÿÿÿÿ  V              U     x     x     Eÿÿÿÿ  Eÿÿÿÿ     ä+ˆ       statement executed        }   xÿÿÿÿ  E     xÿÿÿÿ  E              V     w     w     Dÿÿÿÿ  Dÿÿÿÿ     ä)È       statement executed        yy_load_buffer_state();   wÿÿÿÿ  D     wÿÿÿÿ  D              W     ]     ]     +ÿÿÿÿ  +ÿÿÿÿ     +÷       statement executed        }   ]ÿÿÿÿ  +     ]ÿÿÿÿ  +              X     <     <     ÿÿÿÿ  ÿÿÿÿ     +ìÀ       statement executed        }   <ÿÿÿÿ       <ÿÿÿÿ                Y     9     9   )  ÿÿÿÿ  ÿÿÿÿ     +êÈ       statement executed        yy_flex_free( (void *) b->yy_ch_buf );   9ÿÿÿÿ       9ÿÿÿÿ     )           Z     6     6   +  ÿÿÿÿ  ÿÿÿÿ     +è€       statement executed        yy_current_buffer = (YY_BUFFER_STATE) 0;   6ÿÿÿÿ       6ÿÿÿÿ     +           [     3     3   
  ÿÿÿÿ  ÿÿÿÿ     +ãˆ       statement executed        return;   3ÿÿÿÿ       3ÿÿÿÿ     
           \     '     '     ıÿÿÿÿ  ıÿÿÿÿ     +ß°       statement executed        return b;   'ÿÿÿÿ  ı     'ÿÿÿÿ  ı              ]     !     !   C  ÷ÿÿÿÿ  ÷ÿÿÿÿ     +Ü@       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   !ÿÿÿÿ  ÷     !ÿÿÿÿ  ÷   C           ^             C  îÿÿÿÿ  îÿÿÿÿ     +Ôø       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   ÿÿÿÿ  î     ÿÿÿÿ  î   C           _     	     	     àÿÿÿÿ  àÿÿÿÿ     +ÍÀ       statement executed        }   	ÿÿÿÿ  à     	ÿÿÿÿ  à              `     ü     ü     Ôÿÿÿÿ  Ôÿÿÿÿ     +Æh       statement executed        }   üÿÿÿÿ  Ô     üÿÿÿÿ  Ô              a     ñ     ñ     Éÿÿÿÿ  Éÿÿÿÿ     +Â       statement executed        }   ñÿÿÿÿ  É     ñÿÿÿÿ  É              b     é     é   
  Áÿÿÿÿ  Áÿÿÿÿ     +»P       statement executed        return;   éÿÿÿÿ  Á     éÿÿÿÿ  Á   
           c     Ş     Ş     ·ÿÿÿÿ  ·ÿÿÿÿ     +·X       statement executed        }   Şÿÿÿÿ  ·     Şÿÿÿÿ  ·              d     Ú     Ú   7  ³ÿÿÿÿ  ³ÿÿÿÿ     +µ        statement executed        yy_current_buffer = yy_create_buffer( yyin, 16384 );   Úÿÿÿÿ  ³     Úÿÿÿÿ  ³   7           e     Î     Î     ¨ÿÿÿÿ  ¨ÿÿÿÿ     +°       statement executed        return c;   Îÿÿÿÿ  ¨     Îÿÿÿÿ  ¨              f     Æ     Æ      ÿÿÿÿ   ÿÿÿÿ     +«0       statement executed        }   Æÿÿÿÿ        Æÿÿÿÿ                 g     »     »     —ÿÿÿÿ  —ÿÿÿÿ     +©@       statement executed        break;   »ÿÿÿÿ  —     »ÿÿÿÿ  —              h     µ     µ     ’ÿÿÿÿ  ’ÿÿÿÿ     +¦       statement executed        return input();   µÿÿÿÿ  ’     µÿÿÿÿ  ’              i     ±     ±     ÿÿÿÿ  ÿÿÿÿ     +¤X       statement executed        yyrestart( yyin );   ±ÿÿÿÿ       ±ÿÿÿÿ                j     ­     ­     Šÿÿÿÿ  Šÿÿÿÿ     +¡p       statement executed        return (-1);   ­ÿÿÿÿ  Š     ­ÿÿÿÿ  Š              k               {ÿÿÿÿ  {ÿÿÿÿ     +›¸       statement executed        *yy_c_buf_p = '\0';   ÿÿÿÿ  {     ÿÿÿÿ  {              l     ˆ     ˆ     gÿÿÿÿ  gÿÿÿÿ     +•Ø       statement executed        }   ˆÿÿÿÿ  g     ˆÿÿÿÿ  g              m     €     €     _ÿÿÿÿ  _ÿÿÿÿ     +       statement executed        }   €ÿÿÿÿ  _     €ÿÿÿÿ  _              n             8  ^ÿÿÿÿ  ^ÿÿÿÿ     +ŒP       statement executed        yy_fatal_error( "flex scanner push-back overflow" );   ÿÿÿÿ  ^     ÿÿÿÿ  ^   8           o     x     x     Wÿÿÿÿ  Wÿÿÿÿ     +ƒP       statement executed        *--dest = *--source;   xÿÿÿÿ  W     xÿÿÿÿ  W              p     \     \   *  <ÿÿÿÿ  <ÿÿÿÿ     +t€       statement executed        return yy_is_jam ? 0 : yy_current_state;   \ÿÿÿÿ  <     \ÿÿÿÿ  <   *           q     X     X     8ÿÿÿÿ  8ÿÿÿÿ     +n0       statement executed        }   Xÿÿÿÿ  8     Xÿÿÿÿ  8              r     W     W   (  7ÿÿÿÿ  7ÿÿÿÿ     +lp       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   Wÿÿÿÿ  7     Wÿÿÿÿ  7   (           s     R     R     2ÿÿÿÿ  2ÿÿÿÿ     +dˆ       statement executed        }   Rÿÿÿÿ  2     Rÿÿÿÿ  2              t     9     9     ÿÿÿÿ  ÿÿÿÿ     +[8       statement executed        return yy_current_state;   9ÿÿÿÿ       9ÿÿÿÿ                u     7     7     ÿÿÿÿ  ÿÿÿÿ     +Yˆ       statement executed        }   7ÿÿÿÿ       7ÿÿÿÿ                v     5     5     ÿÿÿÿ  ÿÿÿÿ     +V`       statement executed        }   5ÿÿÿÿ       5ÿÿÿÿ                w     4     4   )  ÿÿÿÿ  ÿÿÿÿ     +T        statement executed        yy_c = yy_meta[(unsigned int) yy_c];   4ÿÿÿÿ       4ÿÿÿÿ     )           x     /     /     ÿÿÿÿ  ÿÿÿÿ     +L¸       statement executed        }   /ÿÿÿÿ       /ÿÿÿÿ                y               üÿÿÿÿ  üÿÿÿÿ     +@È       statement executed        return ret_val;   ÿÿÿÿ  ü     ÿÿÿÿ  ü              z               ôÿÿÿÿ  ôÿÿÿÿ     +9Ø       statement executed        ret_val = 0;   ÿÿÿÿ  ô     ÿÿÿÿ  ô              {               ğÿÿÿÿ  ğÿÿÿÿ     +7        statement executed        }   ÿÿÿÿ  ğ     ÿÿÿÿ  ğ              |               éÿÿÿÿ  éÿÿÿÿ     +3˜       statement executed        }   ÿÿÿÿ  é     ÿÿÿÿ  é              }     ş    ş  <  àÿÿÿÿ  àÿÿÿÿ     â›ˆ       statement executed        yy_fatal_error( "input in flex scanner failed" );   şÿÿÿÿ  à    şÿÿÿÿ  à  <           ~     ş  †  ş  ‡  àÿÿÿÿ  àÿÿÿÿ     â”h       statement executed        }   şÿÿÿÿ  à  †  şÿÿÿÿ  à  ‡                ş  D  ş  u  àÿÿÿÿ  àÿÿÿÿ     â‘H       statement executed        yy_fatal_error( "input in flex scanner failed" );   şÿÿÿÿ  à  D  şÿÿÿÿ  à  u           €     ş   à  ş     àÿÿÿÿ  àÿÿÿÿ     âŠX       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c;   şÿÿÿÿ  à   à  şÿÿÿÿ  à                   ş     ş   Î  àÿÿÿÿ  àÿÿÿÿ     â‡       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c;   şÿÿÿÿ  à     şÿÿÿÿ  à   Î           ‚     û     û     İÿÿÿÿ  İÿÿÿÿ     0şP       statement executed        num_to_read = 8192;   ûÿÿÿÿ  İ     ûÿÿÿÿ  İ              ƒ     ø     ø     Úÿÿÿÿ  Úÿÿÿÿ     0ü       statement executed        }   øÿÿÿÿ  Ú     øÿÿÿÿ  Ú              „     ğ     ğ   E  Ôÿÿÿÿ  Ôÿÿÿÿ     +-X       statement executed        yy_fatal_error( "fatal error - scanner input buffer overflow" );   ğÿÿÿÿ  Ô     ğÿÿÿÿ  Ô   E           …     í     í     Ñÿÿÿÿ  Ñÿÿÿÿ     +*H       statement executed        b->yy_ch_buf = 0;   íÿÿÿÿ  Ñ     íÿÿÿÿ  Ñ              †     ê     ê     Îÿÿÿÿ  Îÿÿÿÿ     +((       statement executed        }   êÿÿÿÿ  Î     êÿÿÿÿ  Î              ‡     ä     ä     Èÿÿÿÿ  Èÿÿÿÿ     +#à       statement executed        b->yy_buf_size *= 2;   äÿÿÿÿ  È     äÿÿÿÿ  È              ˆ     â     â   +  Æÿÿÿÿ  Æÿÿÿÿ     +!¨       statement executed        b->yy_buf_size += b->yy_buf_size / 8;   âÿÿÿÿ  Æ     âÿÿÿÿ  Æ   +           ‰     É     É     ­ÿÿÿÿ  ­ÿÿÿÿ     5£       statement executed        yy_n_chars = 0;   Éÿÿÿÿ  ­     Éÿÿÿÿ  ­              Š     Ã     Ã     §ÿÿÿÿ  §ÿÿÿÿ     ò/        statement executed        *(dest++) = *(source++);   Ãÿÿÿÿ  §     Ãÿÿÿÿ  §              ‹     ¹     ¹     ÿÿÿÿ  ÿÿÿÿ     ò(H       statement executed        return 2;   ¹ÿÿÿÿ       ¹ÿÿÿÿ                Œ     ±     ±     •ÿÿÿÿ  •ÿÿÿÿ     ò'p       statement executed        return 1;   ±ÿÿÿÿ  •     ±ÿÿÿÿ  •                   §     §   O  Œÿÿÿÿ  Œÿÿÿÿ     ò!8       statement executed        yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );   §ÿÿÿÿ  Œ     §ÿÿÿÿ  Œ   O                ”     ”     yÿÿÿÿ  yÿÿÿÿ     4'ˆ       statement executed        }   ”ÿÿÿÿ  y     ”ÿÿÿÿ  y                   “     “     xÿÿÿÿ  xÿÿÿÿ     4&h       statement executed        }   “ÿÿÿÿ  x     “ÿÿÿÿ  x                   Œ     Œ   	  rÿÿÿÿ  rÿÿÿÿ     4$p       statement executed        break;   Œÿÿÿÿ  r     Œÿÿÿÿ  r   	           ‘     ‹     ‹     qÿÿÿÿ  qÿÿÿÿ     4"°       statement executed        }   ‹ÿÿÿÿ  q     ‹ÿÿÿÿ  q              ’     Š     Š     pÿÿÿÿ  pÿÿÿÿ     4!Ø       statement executed        goto yy_find_action;   Šÿÿÿÿ  p     Šÿÿÿÿ  p              “     €     €     fÿÿÿÿ  fÿÿÿÿ     2šÀ       statement executed        goto yy_match;   €ÿÿÿÿ  f     €ÿÿÿÿ  f              ”     u     u     [ÿÿÿÿ  [ÿÿÿÿ     4™        statement executed        break;   uÿÿÿÿ  [     uÿÿÿÿ  [              •     t     t     Zÿÿÿÿ  Zÿÿÿÿ     4–˜       statement executed        }   tÿÿÿÿ  Z     tÿÿÿÿ  Z              –     s     s     Yÿÿÿÿ  Yÿÿÿÿ     4L       statement executed        yyrestart( yyin );   sÿÿÿÿ  Y     sÿÿÿÿ  Y              —     m     m     Sÿÿÿÿ  Sÿÿÿÿ     4 p       statement executed        goto do_action;   mÿÿÿÿ  S     mÿÿÿÿ  S              ˜     U     U     ;ÿÿÿÿ  ;ÿÿÿÿ     5O       statement executed        goto yy_find_action;   Uÿÿÿÿ  ;     Uÿÿÿÿ  ;              ™     O     O     5ÿÿÿÿ  5ÿÿÿÿ     54@       statement executed        goto yy_match;   Oÿÿÿÿ  5     Oÿÿÿÿ  5              š     ,     ,     ÿÿÿÿ  ÿÿÿÿ     4”h       statement executed        }   ,ÿÿÿÿ       ,ÿÿÿÿ                ›               úÿÿÿÿ  úÿÿÿÿ     5s        statement executed        return 0;   ÿÿÿÿ  ú     ÿÿÿÿ  ú              œ               øÿÿÿÿ  øÿÿÿÿ     5‚8       statement executed        break;   ÿÿÿÿ  ø     ÿÿÿÿ  ø                             ôÿÿÿÿ  ôÿÿÿÿ     5¨       statement executed        break;   ÿÿÿÿ  ô     ÿÿÿÿ  ô                   
     
     ğÿÿÿÿ  ğÿÿÿÿ     4Âh       statement executed        break;   
ÿÿÿÿ  ğ     
ÿÿÿÿ  ğ              Ÿ               ëÿÿÿÿ  ëÿÿÿÿ     4·0       statement executed        return 285;   ÿÿÿÿ  ë     ÿÿÿÿ  ë                              çÿÿÿÿ  çÿÿÿÿ     41p       statement executed        return 268;   ÿÿÿÿ  ç     ÿÿÿÿ  ç              ¡     ı     ı     ãÿÿÿÿ  ãÿÿÿÿ     5¸       statement executed        return 267;   ıÿÿÿÿ  ã     ıÿÿÿÿ  ã              ¢     ù     ù     ßÿÿÿÿ  ßÿÿÿÿ     5‹À       statement executed        return 269;   ùÿÿÿÿ  ß     ùÿÿÿÿ  ß              £     õ     õ   )  Ûÿÿÿÿ  Ûÿÿÿÿ     5gè       statement executed        return 265;   õÿÿÿÿ  Û     õÿÿÿÿ  Û   )           ¤     ñ     ñ   )  ×ÿÿÿÿ  ×ÿÿÿÿ     4çP       statement executed        return 275;   ñÿÿÿÿ  ×     ñÿÿÿÿ  ×   )           ¥     í     í   )  Óÿÿÿÿ  Óÿÿÿÿ     58       statement executed        return 270;   íÿÿÿÿ  Ó     íÿÿÿÿ  Ó   )           ¦     é     é   )  Ïÿÿÿÿ  Ïÿÿÿÿ     5<        statement executed        return 264;   éÿÿÿÿ  Ï     éÿÿÿÿ  Ï   )           §     å     å   )  Ëÿÿÿÿ  Ëÿÿÿÿ     5™È       statement executed        return 259;   åÿÿÿÿ  Ë     åÿÿÿÿ  Ë   )           ¨     á      á   +  Çÿÿÿÿ  Çÿÿÿÿ     5uØ       statement executed        return 279;   áÿÿÿÿ  Ç      áÿÿÿÿ  Ç   +           ©     İ     İ   *  Ãÿÿÿÿ  Ãÿÿÿÿ     5Q       statement executed        return 283;   İÿÿÿÿ  Ã     İÿÿÿÿ  Ã   *           ª     Ù     Ù   *  ¿ÿÿÿÿ  ¿ÿÿÿÿ     5'Ø       statement executed        return 282;   Ùÿÿÿÿ  ¿     Ùÿÿÿÿ  ¿   *           «     Õ     Õ   *  »ÿÿÿÿ  »ÿÿÿÿ     5p       statement executed        return 280;   Õÿÿÿÿ  »     Õÿÿÿÿ  »   *           ¬     Ñ     Ñ   *  ·ÿÿÿÿ  ·ÿÿÿÿ     5	        statement executed        return 281;   Ñÿÿÿÿ  ·     Ñÿÿÿÿ  ·   *           ­     Í     Í   *  ³ÿÿÿÿ  ³ÿÿÿÿ     4ü        statement executed        return 273;   Íÿÿÿÿ  ³     Íÿÿÿÿ  ³   *           ®     É      É   +  ¯ÿÿÿÿ  ¯ÿÿÿÿ     4í       statement executed        return 272;   Éÿÿÿÿ  ¯      Éÿÿÿÿ  ¯   +           ¯     Å      Å   +  «ÿÿÿÿ  «ÿÿÿÿ     4F@       statement executed        return 272;   Åÿÿÿÿ  «      Åÿÿÿÿ  «   +           °     Á      Á   +  §ÿÿÿÿ  §ÿÿÿÿ     4½è       statement executed        return 271;   Áÿÿÿÿ  §      Áÿÿÿÿ  §   +           ±     ½      ½   +  £ÿÿÿÿ  £ÿÿÿÿ     4êè       statement executed        return 271;   ½ÿÿÿÿ  £      ½ÿÿÿÿ  £   +           ²     ¹      ¹   +  Ÿÿÿÿÿ  Ÿÿÿÿÿ     5(¨       statement executed        return 271;   ¹ÿÿÿÿ  Ÿ      ¹ÿÿÿÿ  Ÿ   +           ³     µ     µ   *  ›ÿÿÿÿ  ›ÿÿÿÿ     5x       statement executed        return 274;   µÿÿÿÿ  ›     µÿÿÿÿ  ›   *           ´     ±     ±   *  —ÿÿÿÿ  —ÿÿÿÿ     4Ò°       statement executed        return 286;   ±ÿÿÿÿ  —     ±ÿÿÿÿ  —   *           µ     ­     ­   *  “ÿÿÿÿ  “ÿÿÿÿ     5U       statement executed        return 284;   ­ÿÿÿÿ  “     ­ÿÿÿÿ  “   *           ¶     ©     ©     ÿÿÿÿ  ÿÿÿÿ     4¤€       statement executed        goto yy_find_action;   ©ÿÿÿÿ       ©ÿÿÿÿ                ·     š     š     €ÿÿÿÿ  €ÿÿÿÿ     4ğ        statement executed        }   šÿÿÿÿ  €     šÿÿÿÿ  €              ¸     c     c     Iÿÿÿÿ  Iÿÿÿÿ     4W       statement executed        yy_start = 1;   cÿÿÿÿ  I     cÿÿÿÿ  I              ¹     f     f     Lÿÿÿÿ  Lÿÿÿÿ     5qà       statement executed        yyin = (&__iob_func()[0]);   fÿÿÿÿ  L     fÿÿÿÿ  L              º     i     i     Oÿÿÿÿ  Oÿÿÿÿ     4¸Ğ       statement executed        yyout = (&__iob_func()[1]);   iÿÿÿÿ  O     iÿÿÿÿ  O              »     l     m   %  Rÿÿÿÿ  Sÿÿÿÿ     5]       statement executed        yy_current_buffer =
				yy_create_buffer( yyin, 16384 );   lÿÿÿÿ  R     mÿÿÿÿ  S   %           ¼     p     p     Vÿÿÿÿ  Vÿÿÿÿ     5DÈ       statement executed        }   pÿÿÿÿ  V     pÿÿÿÿ  V              ½     ‡     ‡     mÿÿÿÿ  mÿÿÿÿ     5,È       statement executed        }   ‡ÿÿÿÿ  m     ‡ÿÿÿÿ  m              ¾     Œ     Œ   *  rÿÿÿÿ  rÿÿÿÿ     5˜       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   Œÿÿÿÿ  r     Œÿÿÿÿ  r   *           ¿               sÿÿÿÿ  sÿÿÿÿ     5b°       statement executed        }   ÿÿÿÿ  s     ÿÿÿÿ  s              À               vÿÿÿÿ  vÿÿÿÿ     5(       statement executed        }   ÿÿÿÿ  v     ÿÿÿÿ  v           yylex int yylex ()   S     ”     9ÿÿÿÿ  yÿÿÿÿyy_get_next_buffer static int yy_get_next_buffer()              …ÿÿÿÿ  ıÿÿÿÿyy_get_previous_state static yy_state_type yy_get_previous_state()   "     :     ÿÿÿÿ  ÿÿÿÿyy_try_NUL_trans static yy_state_type yy_try_NUL_trans( yy_current_state )   I     ]     )ÿÿÿÿ  =ÿÿÿÿyyunput static void yyunput( c, yy_bp )   h     ˆ     Gÿÿÿÿ  gÿÿÿÿinput static int input()   ‘     Ï     nÿÿÿÿ  ©ÿÿÿÿyyrestart void yyrestart( input_file )   Ø     Ş     ±ÿÿÿÿ  ·ÿÿÿÿyy_switch_to_buffer void yy_switch_to_buffer( new_buffer )   ç     ü     ¿ÿÿÿÿ  Ôÿÿÿÿyy_load_buffer_state void yy_load_buffer_state()        	     Ûÿÿÿÿ  àÿÿÿÿyy_create_buffer YY_BUFFER_STATE yy_create_buffer( file, size )        (     éÿÿÿÿ  şÿÿÿÿyy_delete_buffer void yy_delete_buffer( b )   1     <     ÿÿÿÿ  ÿÿÿÿyy_init_buffer void yy_init_buffer( b, file )   N     ]      ÿÿÿÿ  +ÿÿÿÿyy_flush_buffer void yy_flush_buffer( b )   g     x     4ÿÿÿÿ  Eÿÿÿÿyy_scan_buffer YY_BUFFER_STATE yy_scan_buffer( base, size )   ƒ          Oÿÿÿÿ  iÿÿÿÿyy_scan_string YY_BUFFER_STATE yy_scan_string( str )   ¨     ®     rÿÿÿÿ  xÿÿÿÿyy_scan_bytes YY_BUFFER_STATE yy_scan_bytes( bytes, len )   º     Õ     ‚ÿÿÿÿ  ÿÿÿÿyy_fatal_error static void yy_fatal_error( msg )             Üÿÿÿÿ  ßÿÿÿÿyy_flex_alloc static void *yy_flex_alloc( size )   G     I     ÿÿÿÿ  ÿÿÿÿyy_flex_realloc static void *yy_flex_realloc( ptr, size )   R     [     ÿÿÿÿ  ÿÿÿÿyy_flex_free static void yy_flex_free( ptr )   c     e     %ÿÿÿÿ  'ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 26
#define YY_END_OF_BUFFER 27
static yyconst short int yy_accept[137] =
    {   0,
        0,    0,   27,   25,   24,   23,   15,   20,   15,   15,
       15,   15,   15,   15,   25,   25,   25,   25,   25,   25,
       25,   18,   25,   25,   25,   24,   16,   15,    0,   15,
       17,   15,   14,    0,    0,   15,   15,    0,   15,   15,
        0,   15,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   19,    0,    0,    0,    0,    0,    0,    0,
       16,    0,    0,    4,    5,    0,    0,    0,    0,    6,
        0,    4,    8,   10,    0,    7,    6,    0,    0,    0,
        0,   11,    0,    0,    3,    0,    0,    0,    0,    9,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,   21,    0,    0,    0,    0,    0,    0,    0,    0,
       13,    0,   22,    0,    0,    0,    0,    0,    0,    0,
       12,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    2,    0,    1,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    5,    1,    6,    6,    6,
        6,    6,    6,    6,    6,    6,    6,    7,    1,    1,
        8,    1,    1,    1,    9,   10,   11,   12,   13,   14,
       15,   16,   17,   18,   19,   20,   21,   22,   23,   24,
        1,   25,   26,   27,   28,   29,   30,   31,   32,    1,
        1,    1,    1,    1,    1,    1,    9,   10,   11,   12,

       13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
       23,   24,    1,   25,   26,   27,   28,   29,   30,   31,
       32,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[33] =
    {   0,
        1,    1,    1,    1,    2,    2,    2,    1,    2,    2,
        2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        2,    1
    } ;

static yyconst short int yy_base[138] =
    {   0,
        0,    0,  183,  184,   31,  184,   31,  184,   57,   83,
       34,   31,  160,   21,  168,   33,  167,   34,  156,  167,
      156,   41,   36,   59,  163,   46,  169,   46,  168,    0,
      184,  147,  184,  147,  156,  144,  154,  141,  140,  155,
      153,  154,  146,  131,  139,   36,  138,   48,  137,  129,
      130,  136,  184,  128,  130,  131,  124,  130,  137,  137,
      142,   53,  124,  184,  184,  133,  128,  133,  130,    0,
      138,    0,  184,  184,  126,  184,  184,  131,  126,  132,
      117,  184,  114,  112,  184,  107,  106,  105,  105,  124,
      101,  124,   99,  101,  109,  107,   96,   95,   94,   98,

      102,  184,   89,  108,  103,   90,   86,   97,   98,   89,
      184,   92,  184,   93,   83,   91,   92,   78,   88,   77,
      184,   88,   89,   73,   71,   76,   61,   63,   71,   56,
       58,   63,  184,   36,  184,  184,   45
    } ;

static yyconst short int yy_def[138] =
    {   0,
      136,    1,  136,  136,  136,  136,  137,  136,  136,  136,
      137,   11,   11,   11,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,   11,  136,   11,
      136,   11,  136,  136,  136,   11,   11,  136,   11,   11,
      136,   11,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,   11,
      136,   11,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,

      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,    0,  136
    } ;

static yyconst short int yy_nxt[217] =
    {   0,
        4,    5,    6,    5,    4,    7,    4,    8,    9,   10,
       11,   12,   13,   14,    4,   15,    4,   16,    4,   17,
       18,   19,   20,   21,   22,   23,   24,    4,    4,   25,
        4,    4,   26,   42,   26,   27,   28,   29,  136,   39,
      136,   45,   48,   40,   54,   43,   30,   26,   55,   26,
       27,   28,   29,   52,  135,   65,   49,   65,   62,   80,
       46,   31,   30,   56,   31,   30,   32,   30,   30,   30,
       30,   53,   64,  134,   57,   58,  133,   33,  132,   65,
       34,  131,  130,  129,   35,  128,   59,   31,   30,   53,
      127,   36,   30,   30,   30,   37,   30,  126,  125,   38,

      124,  123,  122,  121,  120,  119,  118,  117,  116,  115,
      111,  114,  113,   31,  112,  111,  110,  109,  108,  107,
      106,  105,  104,  103,  102,  101,  100,   99,   98,   90,
       97,   96,   95,   94,   93,   92,   91,   90,   89,   88,
       87,   86,   85,   84,   83,   82,   81,   61,   73,   76,
       79,   73,   76,   77,   76,   78,   77,   77,   76,   75,
       64,   74,   73,   72,   71,   70,   69,   68,   67,   66,
       65,   64,   63,   62,   61,   60,   33,   51,   50,   47,
       44,   41,  136,    3,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,

      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136
    } ;

static yyconst short int yy_chk[217] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    5,   14,    5,    7,    7,    7,   11,   12,
       11,   16,   18,   12,   23,   14,  137,   26,   23,   26,
       28,   28,   28,   22,  134,   46,   18,   46,   62,   62,
       16,    7,    9,   23,   11,    9,    9,    9,    9,    9,
        9,   22,   48,  132,   24,   24,  131,    9,  130,   48,
        9,  129,  128,  127,    9,  126,   24,    9,   10,   24,
      125,   10,   10,   10,   10,   10,   10,  124,  123,   10,

      122,  120,  119,  118,  117,  116,  115,  114,  112,  110,
      109,  108,  107,   10,  106,  105,  104,  103,  101,  100,
       99,   98,   97,   96,   95,   94,   93,   92,   91,   90,
       89,   88,   87,   86,   84,   83,   81,   80,   79,   78,
       75,   71,   69,   68,   67,   66,   63,   61,   60,   59,
       58,   57,   56,   55,   54,   52,   51,   50,   49,   47,
       45,   44,   43,   42,   41,   40,   39,   38,   37,   36,
       35,   34,   32,   29,   27,   25,   21,   20,   19,   17,
       15,   13,    3,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,

      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
      136,  136,  136,  136,  136,  136
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0

#include <stdio.h>
#include <string.h>
#include "Asc_Log_Parser.h"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 137 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 184 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return BEGINTRIGGERTOKEN;
	YY_BREAK
case 2:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return ENDTRIGGERTOKEN;
	YY_BREAK
case 3:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return DATETOKEN;
	YY_BREAK
case 4:
YY_RULE_SETUP
yylval = (int)_strdup(yytext); return MONTH;
	YY_BREAK
case 5:
YY_RULE_SETUP
yylval = (int)_strdup(yytext); return MONTH; 
	YY_BREAK
case 6:
YY_RULE_SETUP
yylval = (int)_strdup(yytext); return MONTH;
	YY_BREAK
case 7:
YY_RULE_SETUP
yylval = (int)_strdup(yytext); return DAY;
	YY_BREAK
case 8:
YY_RULE_SETUP
yylval = (int)_strdup(yytext); return DAY;
	YY_BREAK
case 9:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return FULLTIME;
	YY_BREAK
case 10:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return BASE;
	YY_BREAK
case 11:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return BASETOKEN;
	YY_BREAK
case 12:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return TIMESTAMPSTOKEN;
	YY_BREAK
case 13:
YY_RULE_SETUP
yylval = (int)_strdup(yytext);return TIMEMODE;
	YY_BREAK
case 14:
YY_RULE_SETUP
yylval = (int)_strdup(yytext); return AM_PM;
	YY_BREAK
case 15:
YY_RULE_SETUP
yylval =(int)_strdup(yytext);return NUMBER;
	YY_BREAK
case 16:
YY_RULE_SETUP
yylval =(int)_strdup(yytext);return DOUBLEVAL;
	YY_BREAK
case 17:
YY_RULE_SETUP
yylval =(int)_strdup(yytext);return EXTID;
	YY_BREAK
case 18:
YY_RULE_SETUP
yylval =(int)_strdup(yytext);return REMOTE;
	YY_BREAK
case 19:
YY_RULE_SETUP
yylval =(int)_strdup(yytext);return MSGDIR;
	YY_BREAK
case 20:
YY_RULE_SETUP
return EQUAL;
	YY_BREAK
case 21:
YY_RULE_SETUP
return LENGTHTOKEN;
	YY_BREAK
case 22:
YY_RULE_SETUP
return BITCOUNTTOKEN;
	YY_BREAK
case 23:
YY_RULE_SETUP
return LINEEND;
	YY_BREAK
case 24:
YY_RULE_SETUP
/* ignore whitespace */;
	YY_BREAK
case 25:
YY_RULE_SETUP
/* ignore Anything else */;
	YY_BREAK
case 26:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a singled characater, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 137 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 137 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 136);

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yytext_ptr = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext_ptr + YY_MORE_ADJ;
						return EOF;
						}

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
					break;

				case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
					YY_FATAL_ERROR(
					"unexpected last match in yyinput()" );
#else
					YY_FATAL_ERROR(
					"unexpected last match in input()" );
#endif
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *str )
#else
YY_BUFFER_STATE yy_scan_string( str )
yyconst char *str;
#endif
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif

















































int nSize = 0;
int nLen = 0;
int nTimeMode = -1;
int nNumLines = 0;
char data[256];
extern FILE *yyin, *yyout;

void yyerror(const char *str)
{
	
}

int yywrap()
{
	
	
	
	
	return 1;	
				
				
}
int nInitialiseDataBytes()
{
	memset(data, 0, 256);
}
int nSecondToTime(unsigned int nSeconds, int *nHours, int *nMin, int *nSec)
{
	*nHours = nSeconds / 3600; 
	nSeconds = nSeconds -(*nHours * 3600);
	*nMin = nSeconds / 60; 
	*nSec = nSeconds - (*nMin) * 60;
}
int nGetLogTimeStamp(char* pchAscTime, char* pchLogTime)
{
	char chSeparators[] = ".";
	char* pchTemp;
	char chMilliSeconds[5] = {'\0'};
	int nHours, nMin, nSec;
	unsigned int unSeconds;
	
	pchTemp = strtok(pchAscTime, chSeparators);
	unSeconds = strtoul(pchTemp, ((void *)0), 10);
	nSecondToTime(unSeconds, &nHours, &nMin, &nSec);
	
	pchTemp = strtok(((void *)0), chSeparators);
	
	strncpy( chMilliSeconds, pchTemp, 4);
	
	sprintf(pchLogTime, "%u:%u:%u:%s", nHours, nMin, nSec, chMilliSeconds);
}
int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile)
{
	if( (((void *)0) != fpInputFile) && (((void *)0) != fpOutputFile) )
	{ 
		yyin = fpInputFile;
		yyout = fpOutputFile;
		yyparse();
	}
	return 0;
}


typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;



















static  char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    32,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31
};





































static  short yyr1[] = {     0,
    33,    33,    34,    34,    34,    34,    34,    34,    34,    34,
    34,    34,    34,    35,    35,    36,    37,    38,    39,    40,
    41,    42,    43,    44,    45
};

static  short yyr2[] = {     0,
     1,     2,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     0,     2,     3,     3,     7,     7,     5,
     4,     7,     1,     1,     2
};

static  short yydefact[] = {     0,
     3,     0,     0,     0,     0,     0,    23,    24,     0,     1,
    10,    12,     4,     6,     7,     8,    11,    13,     9,     5,
    25,     0,     0,     0,     0,     0,     2,     0,     0,    16,
    17,     0,     0,     0,     0,     0,    21,     0,    20,     0,
     0,    14,    14,     0,    18,    19,    22,    15,     0,     0
};

static  short yydefgoto[] = {     9,
    10,    45,    11,    12,    13,    14,    15,    16,    17,    18,
    19,    20
};

static  short yypact[] = {     2,
   -28,     3,    -8,    -6,    -7,    -9,-32768,-32768,     0,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,     1,    16,    18,     7,    -3,-32768,    19,    24,-32768,
-32768,    22,     8,    -2,    31,    10,-32768,    33,-32768,    34,
    15,-32768,-32768,    36,    37,    37,-32768,-32768,    42,-32768
};

static  short yypgoto[] = {-32768,
    35,     4,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768
};





static  short yytable[] = {    49,
     1,    38,     1,    21,    28,    23,    22,    24,     2,    25,
     2,     3,     4,     3,     4,    29,    26,    39,     5,    30,
     5,    31,    32,    33,     6,    36,     6,    41,    34,     7,
     8,     7,     8,    35,    40,    37,    42,    43,    44,    47,
    48,    50,     0,    27,     0,     0,    46
};

static  short yycheck[] = {     0,
     1,     4,     1,    32,     4,    14,     4,    14,     9,    17,
     9,    12,    13,    12,    13,    15,    26,    20,    19,     4,
    19,     4,    16,    27,    25,     4,    25,    18,    10,    30,
    31,    30,    31,    10,     4,    28,     4,     4,    24,     4,
     4,     0,    -1,     9,    -1,    -1,    43
};


















































































































int	yychar;			
int	yylval;			
				






int yynerrs;			































static void
__yy_memcpy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}































int
yyparse()
     
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register int *yyvsp;
  int yyerrstatus;	
  int yychar1 = 0;		

  short	yyssa[200];	
  int yyvsa[200];	

  short *yyss = yyssa;		
  int *yyvs = yyvsa;	










  int yystacksize = 200;










  int yyval;		
				
				

  int yylen;





  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = -2;		

  




  yyssp = yyss - 1;
  yyvsp = yyvs;







yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      
      
      int *yyvs1 = yyvs;
      short *yyss1 = yyss;




      
      int size = yyssp - yyss + 1;
























      
      if (yystacksize >= 10000)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > 10000)
	yystacksize = 10000;
      yyss = (short *) _alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (int *) _alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));





      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;








      if (yyssp >= yyss + yystacksize - 1)
	return(1);
    }





  goto yybackup;
 yybackup:





  

  yyn = yypact[yystate];
  if (yyn == -32768)
    goto yydefault;

  

  


  if (yychar == -2)
    {



      yychar = yylex();
    }

  

  if (yychar <= 0)		
    {
      yychar1 = 0;
      yychar = 0;		




    }
  else
    {
      yychar1 = ((unsigned)(yychar) <= 286 ? yytranslate[yychar] : 46);












    }

  yyn += yychar1;
  if (yyn < 0 || yyn > 47 || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  






  if (yyn < 0)
    {
      if (yyn == -32768)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == 50)
    return(0);

  





  
  if (yychar != 0)
    yychar = -2;

  *++yyvsp = yylval;




  
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;


yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;


yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; 
















  switch (yyn) {

case 3:
{(yyerrstatus = 0);(yychar = -2); ;
    break;}
case 15:
{
		strcpy((data+nLen) , (char*)yyvsp[0]);
		nLen += strlen((char*)yyvsp[0]);
		data[nLen] = ' ';
		nLen++;
		data[nLen] = '\0';
	;
    break;}
case 16:
{
		yyval = yyvsp[0];
	;
    break;}
case 17:
{
		yyval = yyvsp[0];
	;
    break;}
case 18:
{
		char chLogTime[256] = {'\0'};
		
		nGetLogTimeStamp((char*)yyvsp[-6], chLogTime);
		fprintf(yyout, "\n%s %s %s %s %s %s %s", chLogTime, yyvsp[-3], yyvsp[-5], yyvsp[-4], "s", yyvsp[-1], data);
		nLen = 0;
		nInitialiseDataBytes();
		






	;
    break;}
case 19:
{
		char chLogTime[256] = {'\0'};
		char chId[12] = {'\0'};
		int nStrLen;
		nGetLogTimeStamp((char*)yyvsp[-6], chLogTime);
		strcpy(chId, yyvsp[-4]);
		nStrLen = strlen(chId);
		chId[nStrLen-1] = '\0';
		fprintf(yyout, "\n%s %s %s %s %s %s %s", chLogTime, yyvsp[-3], yyvsp[-5], chId, "x", yyvsp[-1], data);
		nLen = 0;
		nInitialiseDataBytes();
		





	;
    break;}
case 20:
{
		
		char chLogTime[256] = {'\0'};
		
		nGetLogTimeStamp((char*)yyvsp[-4], chLogTime);
		fprintf(yyout,"\n%s %s %s %s %s %s %s", chLogTime, yyvsp[-1], yyvsp[-3], yyvsp[-2], "sr", "0",  "00 00 00 00 00 00 00 00");
		nLen = 0;
		nInitialiseDataBytes();
		




	;
    break;}
case 21:
{
		if(strcmp("dec", (char*)yyvsp[-2]) == 0)
		{
			fprintf(yyout,"\n%s", "***DEC***");
		}
		else
		{
			fprintf(yyout,"\n%s", "***HEX***");
		}
		if(strcmp("relative", (char*)yyvsp[0]) == 0)
		{
			fprintf(yyout,"\n%s", "***RELATIVE MODE***");
			nTimeMode = 1;
		}
		else
		{
			fprintf(yyout,"\n%s", "***ABSOLUTE MODE***");
			nTimeMode = 0;
		}
		fprintf(yyout,"\n%s", "***<Time><Tx/Rx><Channel><CAN ID><Type><DLC><DataBytes>***");
		



	;
    break;}
case 22:
{	
		
		
		
		char chSeparators[]   = " :,\t\n";
		char* chTemp;
		int nMonth;
		int nHour, nMins, nSec;
		
		
		
		 fprintf(yyout, "***BUSMASTER Ver 1.6.3***\n");
		 fprintf(yyout, "***PROTOCOL CAN***\n");
         fprintf(yyout, "***NOTE: PLEASE DO NOT EDIT THIS DOCUMENT***\n");
         fprintf(yyout, "***[START LOGGING SESSION]***\n");
	 
		if( strcmp("Jan", (char*)yyvsp[-4]) == 0 )
			nMonth = 1;
		else if( strcmp("Feb", (char*)yyvsp[-4]) == 0 )
			nMonth = 2; 
		else if( strcmp("Mar", (char*)yyvsp[-4]) == 0 )
			nMonth = 3; 
		else if( strcmp("Apr", (char*)yyvsp[-4]) == 0 )
			nMonth = 4; 
		else if( strcmp("May", (char*)yyvsp[-4]) == 0 )
			nMonth = 5; 
		else if( strcmp("Jun", (char*)yyvsp[-4]) == 0 )
			nMonth = 6; 
		else if( strcmp("Jul", (char*)yyvsp[-4]) == 0 )
			nMonth = 7; 
		else if( strcmp("Aug", (char*)yyvsp[-4]) == 0 )
			nMonth = 8; 
		else if( strcmp("Sep", (char*)yyvsp[-4]) == 0 )
			nMonth = 9; 
		else if( strcmp("Oct", (char*)yyvsp[-4]) == 0 )
			nMonth = 10; 
		else if( strcmp("Nov", (char*)yyvsp[-4]) == 0 )
			nMonth = 11; 
		else if( strcmp("Dec", (char*)yyvsp[-4]) == 0 )
			nMonth = 12; 
		
		
		chTemp = strtok((char*)yyvsp[-2], chSeparators);
		nHour = atoi(chTemp);
		chTemp = strtok( ((void *)0), chSeparators ); 
		nMins = atoi(chTemp);
		chTemp = strtok( ((void *)0), chSeparators ); 
		nSec = atoi(chTemp);
		
		nHour = nHour % 12;
		if( strcmp("pm", (char*)yyvsp[-1]) == 0 )
		{
			nHour = nHour + 12;
		}
		
		
		fprintf(yyout,"***START DATE AND TIME %s:%d:%s %d:%d:%d:%s%s", yyvsp[-3], nMonth, yyvsp[0], nHour, nMins, nSec, "000", "***");
		
		






	;
    break;}
case 23:
{
		nNumLines++;
	;
    break;}
case 24:
{
	fprintf(yyout, "\n***END DATE AND TIME ***");
	fprintf(yyout, "\n***[STOP LOGGING SESSION]***\r\n");
	;
    break;}
}
   


  yyvsp -= yylen;
  yyssp -= yylen;














  *++yyvsp = yyval;


















  




  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - 33] + *yyssp;
  if (yystate >= 0 && yystate <= 47 && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - 33];

  goto yynewstate;

yyerrlab:   

  if (! yyerrstatus)
    
    {
      ++yynerrs;










































	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   

  if (yyerrstatus == 3)
    {
      

      
      if (yychar == 0)
	return(1);





      yychar = -2;
    }

  


  yyerrstatus = 3;		

  goto yyerrhandle;

yyerrdefault:  







yyerrpop:   

  if (yyssp == yyss) return(1);
  yyvsp--;
  yystate = *--yyssp;














yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == -32768)
    goto yyerrdefault;

  yyn += 1;
  if (yyn < 0 || yyn > 47 || yycheck[yyn] != 1)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == -32768)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == 50)
    return(0);





  *++yyvsp = yylval;




  yystate = yyn;
  goto yynewstate;
}

         æ     æ     Çÿÿÿÿ  Çÿÿÿÿ     5]      expression was true       yystate >= 0   æÿÿÿÿ  Ç     æÿÿÿÿ  Ç      expression was false       yystate >= 0   æÿÿÿÿ  Ç     æÿÿÿÿ  Ç                   5[         ³     ³   5  —ÿÿÿÿ  —ÿÿÿÿ     4Ãø      expression was true       yycheck[yyn] != yychar1   ³ÿÿÿÿ  —     ³ÿÿÿÿ  —   5   expression was false       yycheck[yyn] != yychar1   ³ÿÿÿÿ  —     ³ÿÿÿÿ  —   5                4Â8        ³     ³     —ÿÿÿÿ  —ÿÿÿÿ     4¿ø      expression was true       yyn > 47   ³ÿÿÿÿ  —     ³ÿÿÿÿ  —      expression was false       yyn > 47   ³ÿÿÿÿ  —     ³ÿÿÿÿ  —                   ³     ³     —ÿÿÿÿ  —ÿÿÿÿ     4¿       expression was true       yyn < 0   ³ÿÿÿÿ  —     ³ÿÿÿÿ  —      expression was false       yyn < 0   ³ÿÿÿÿ  —     ³ÿÿÿÿ  —                   æ     æ   $  Çÿÿÿÿ  Çÿÿÿÿ     5]ø      expression was true       yystate <= 47   æÿÿÿÿ  Ç     æÿÿÿÿ  Ç   $   expression was false       yystate <= 47   æÿÿÿÿ  Ç     æÿÿÿÿ  Ç   $                5\8   
     ¢     ¢   +  ‡ÿÿÿÿ  ‡ÿÿÿÿ     4¸Ğ      expression was true       (unsigned)(yychar) <= 286   ¢ÿÿÿÿ  ‡     ¢ÿÿÿÿ  ‡   +   expression was false       (unsigned)(yychar) <= 286   ¢ÿÿÿÿ  ‡     ¢ÿÿÿÿ  ‡   +                4·À         j   &   j   C   fÿÿÿÿ   fÿÿÿÿ     4QP      expression was true       (((void *)0) != fpOutputFile)    jÿÿÿÿ   f   &   jÿÿÿÿ   f   C   expression was false       (((void *)0) != fpOutputFile)    jÿÿÿÿ   f   &   jÿÿÿÿ   f   C                4O€         j      j   "   fÿÿÿÿ   fÿÿÿÿ     4Ph      expression was true       (((void *)0) != fpInputFile)    jÿÿÿÿ   f      jÿÿÿÿ   f   "   expression was false       (((void *)0) != fpInputFile)    jÿÿÿÿ   f      jÿÿÿÿ   f   "                4Kh        Á   
  Á     °ÿÿÿÿ  °ÿÿÿÿ     4m       expression was false       i-- > 0   Áÿÿÿÿ  °   
  Áÿÿÿÿ  °                   æ   (  æ   B  Çÿÿÿÿ  Çÿÿÿÿ     5aÈ      expression was true       yycheck[yystate] == *yyssp   æÿÿÿÿ  Ç   (  æÿÿÿÿ  Ç   B   expression was false       yycheck[yystate] == *yyssp   æÿÿÿÿ  Ç   (  æÿÿÿÿ  Ç   B                5`        l     l     Jÿÿÿÿ  Jÿÿÿÿ     5–Ø      expression was false       yyn == 50   lÿÿÿÿ  J     lÿÿÿÿ  J                   5”8        i     i     Gÿÿÿÿ  Gÿÿÿÿ     5‘`      expression was false       yyn == 0   iÿÿÿÿ  G     iÿÿÿÿ  G                   5°        d     d     Bÿÿÿÿ  Bÿÿÿÿ     5Œ˜      expression was false       yyn == -32768   dÿÿÿÿ  B     dÿÿÿÿ  B                   5Šè        ^     ^     <ÿÿÿÿ  <ÿÿÿÿ     5€Ğ      expression was true       yyn < 0   ^ÿÿÿÿ  <     ^ÿÿÿÿ  <      expression was false       yyn < 0   ^ÿÿÿÿ  <     ^ÿÿÿÿ  <                   Z     Z     8ÿÿÿÿ  8ÿÿÿÿ     5~H      expression was false       yyn == -32768   Zÿÿÿÿ  8     Zÿÿÿÿ  8                   5|à        E     E     $ÿÿÿÿ  $ÿÿÿÿ     5xà      expression was false       yyssp == yyss   Eÿÿÿÿ  $     Eÿÿÿÿ  $                   5wÀ        (     (     	ÿÿÿÿ  	ÿÿÿÿ     5qà      expression was false       yychar == 0   (ÿÿÿÿ  	     (ÿÿÿÿ  	                   5o@        #     #     ÿÿÿÿ  ÿÿÿÿ     5t      expression was false       yyerrstatus == 3   #ÿÿÿÿ       #ÿÿÿÿ                     5n        ï     ï     Ğÿÿÿÿ  Ğÿÿÿÿ     5l       expression was false       ! yyerrstatus   ïÿÿÿÿ  Ğ     ïÿÿÿÿ  Ğ                   5iØ        š     š   *  |ÿÿÿÿ  |ÿÿÿÿ     5NØ      expression was false       strcmp("pm", (char*)yyvsp[-1]) == 0   šÿÿÿÿ  |     šÿÿÿÿ  |   *                5JĞ                0  pÿÿÿÿ  pÿÿÿÿ     54ˆ      expression was false       strcmp("Dec", (char*)yyvsp[-4]) == 0   ÿÿÿÿ  p     ÿÿÿÿ  p   0                51À        ì     ì     Ïÿÿÿÿ  Ïÿÿÿÿ     4çà      expression was false       yylen > 0   ìÿÿÿÿ  Ï     ìÿÿÿÿ  Ï                    æ     æ     Éÿÿÿÿ  Éÿÿÿÿ     4â@      expression was false       yyn == 0   æÿÿÿÿ  É     æÿÿÿÿ  É                   4à   !     İ     İ     Àÿÿÿÿ  Àÿÿÿÿ     4Ûà      expression was false       yyerrstatus   İÿÿÿÿ  À     İÿÿÿÿ  À              "     Ô     Ô     ·ÿÿÿÿ  ·ÿÿÿÿ     4Øp      expression was false       yychar != 0   Ôÿÿÿÿ  ·     Ôÿÿÿÿ  ·                   4Ö   #     É     É     ­ÿÿÿÿ  ­ÿÿÿÿ     4ÕP      expression was false       yyn == 50   Éÿÿÿÿ  ­     Éÿÿÿÿ  ­                   4Ò°   $     Æ     Æ     ªÿÿÿÿ  ªÿÿÿÿ     4ÏØ      expression was false       yyn == 0   Æÿÿÿÿ  ª     Æÿÿÿÿ  ª                   4Î(   %     Á     Á     ¥ÿÿÿÿ  ¥ÿÿÿÿ     4Ë      expression was false       yyn == -32768   Áÿÿÿÿ  ¥     Áÿÿÿÿ  ¥                   4É`   &     ^     ^     <ÿÿÿÿ  <ÿÿÿÿ     5¨      expression was true       yyn > 47   ^ÿÿÿÿ  <     ^ÿÿÿÿ  <      expression was false       yyn > 47   ^ÿÿÿÿ  <     ^ÿÿÿÿ  <              (     ‹     ‹     rÿÿÿÿ  rÿÿÿÿ     4±X      expression was false       yychar == -2   ‹ÿÿÿÿ  r     ‹ÿÿÿÿ  r                   4®0   )     ƒ     ƒ     jÿÿÿÿ  jÿÿÿÿ     4­      expression was false       yyn == -32768   ƒÿÿÿÿ  j     ƒÿÿÿÿ  j                   4«X   *     p     p   *  Xÿÿÿÿ  Xÿÿÿÿ     4¦@      expression was false       yyssp >= yyss + yystacksize - 1   pÿÿÿÿ  X     pÿÿÿÿ  X   *                4¤€   +     Y     Y     Cÿÿÿÿ  Cÿÿÿÿ     4•@      expression was false       yystacksize > 10000   Yÿÿÿÿ  C     Yÿÿÿÿ  C              ,     S     S     =ÿÿÿÿ  =ÿÿÿÿ     4‘      expression was false       yystacksize >= 10000   Sÿÿÿÿ  =     Sÿÿÿÿ  =                   4   -     .     .   &  ÿÿÿÿ  ÿÿÿÿ     4¨ğ      expression was false       yyssp >= yyss + yystacksize - 1   .ÿÿÿÿ       .ÿÿÿÿ     &                4†è   .     ^     ^   /  <ÿÿÿÿ  <ÿÿÿÿ     5…h      expression was true       yycheck[yyn] != 1   ^ÿÿÿÿ  <     ^ÿÿÿÿ  <   /   expression was false       yycheck[yyn] != 1   ^ÿÿÿÿ  <     ^ÿÿÿÿ  <   /                5ƒ¨   0     z     z     Wÿÿÿÿ  Wÿÿÿÿ     5™€       statement executed        goto yynewstate;   zÿÿÿÿ  W     zÿÿÿÿ  W              1     m     m     Kÿÿÿÿ  Kÿÿÿÿ     5•       statement executed        return(0);   mÿÿÿÿ  K     mÿÿÿÿ  K              2     j     j     Hÿÿÿÿ  Hÿÿÿÿ     5ˆ       statement executed        goto yyerrpop;   jÿÿÿÿ  H     jÿÿÿÿ  H              3     g     g     Eÿÿÿÿ  Eÿÿÿÿ     5˜       statement executed        goto yyreduce;   gÿÿÿÿ  E     gÿÿÿÿ  E              4     e     e     Cÿÿÿÿ  Cÿÿÿÿ     5‹À       statement executed        goto yyerrpop;   eÿÿÿÿ  C     eÿÿÿÿ  C              5     _     _     =ÿÿÿÿ  =ÿÿÿÿ     5‡H       statement executed        goto yyerrdefault;   _ÿÿÿÿ  =     _ÿÿÿÿ  =              6     [     [     9ÿÿÿÿ  9ÿÿÿÿ     5}p       statement executed        goto yyerrdefault;   [ÿÿÿÿ  9     [ÿÿÿÿ  9              7     E     E      $ÿÿÿÿ  $ÿÿÿÿ     5xP       statement executed        return(1);   Eÿÿÿÿ  $     Eÿÿÿÿ  $               8     8     8     ÿÿÿÿ  ÿÿÿÿ     5uØ       statement executed        goto yyerrhandle;   8ÿÿÿÿ       8ÿÿÿÿ                9     1     1     ÿÿÿÿ  ÿÿÿÿ     5s0       statement executed        }   1ÿÿÿÿ       1ÿÿÿÿ                :     )     )     
ÿÿÿÿ  
ÿÿÿÿ     5p       statement executed        return(1);   )ÿÿÿÿ  
     )ÿÿÿÿ  
              ;                 ÿÿÿÿ  ÿÿÿÿ     5m       statement executed        goto yyerrlab1;    ÿÿÿÿ        ÿÿÿÿ                <               ÿÿÿÿÿ  ÿÿÿÿÿ     5kH       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              =     ë     ë     Ìÿÿÿÿ  Ìÿÿÿÿ     5hĞ       statement executed        goto yynewstate;   ëÿÿÿÿ  Ì     ëÿÿÿÿ  Ì              >     é     é   #  Êÿÿÿÿ  Êÿÿÿÿ     5g       statement executed        yystate = yydefgoto[yyn - 33];   éÿÿÿÿ  Ê     éÿÿÿÿ  Ê   #           ?     ç     ç      Èÿÿÿÿ  Èÿÿÿÿ     5dğ       statement executed        yystate = yytable[yystate];   çÿÿÿÿ  È     çÿÿÿÿ  È               @     µ     µ     —ÿÿÿÿ  —ÿÿÿÿ     5Rh       statement executed        break;   µÿÿÿÿ  —     µÿÿÿÿ  —              A     ¯     ¯     ‘ÿÿÿÿ  ‘ÿÿÿÿ     5Q       statement executed        break;   ¯ÿÿÿÿ  ‘     ¯ÿÿÿÿ  ‘              B     ª     ª     Œÿÿÿÿ  Œÿÿÿÿ     5P       statement executed        break;   ªÿÿÿÿ  Œ     ªÿÿÿÿ  Œ              C               ÿÿÿÿ  ÿÿÿÿ     5N        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                D               qÿÿÿÿ  qÿÿÿÿ     53°       statement executed        nMonth = 12;   ÿÿÿÿ  q     ÿÿÿÿ  q              E               oÿÿÿÿ  oÿÿÿÿ     50¨       statement executed        nMonth = 11;   ÿÿÿÿ  o     ÿÿÿÿ  o              F     ‹     ‹     mÿÿÿÿ  mÿÿÿÿ     5-        statement executed        nMonth = 10;   ‹ÿÿÿÿ  m     ‹ÿÿÿÿ  m              G     ‰     ‰     kÿÿÿÿ  kÿÿÿÿ     5*˜       statement executed        nMonth = 9;   ‰ÿÿÿÿ  k     ‰ÿÿÿÿ  k              H     ‡     ‡     iÿÿÿÿ  iÿÿÿÿ     5'       statement executed        nMonth = 8;   ‡ÿÿÿÿ  i     ‡ÿÿÿÿ  i              I     …     …     gÿÿÿÿ  gÿÿÿÿ     5$ˆ       statement executed        nMonth = 7;   …ÿÿÿÿ  g     …ÿÿÿÿ  g              J     ƒ     ƒ     eÿÿÿÿ  eÿÿÿÿ     5!€       statement executed        nMonth = 6;   ƒÿÿÿÿ  e     ƒÿÿÿÿ  e              K               cÿÿÿÿ  cÿÿÿÿ     5x       statement executed        nMonth = 5;   ÿÿÿÿ  c     ÿÿÿÿ  c              L               aÿÿÿÿ  aÿÿÿÿ     5p       statement executed        nMonth = 4;   ÿÿÿÿ  a     ÿÿÿÿ  a              M     }     }     _ÿÿÿÿ  _ÿÿÿÿ     5h       statement executed        nMonth = 3;   }ÿÿÿÿ  _     }ÿÿÿÿ  _              N     {     {     ]ÿÿÿÿ  ]ÿÿÿÿ     5`       statement executed        nMonth = 2;   {ÿÿÿÿ  ]     {ÿÿÿÿ  ]              O     y     y     [ÿÿÿÿ  [ÿÿÿÿ     5X       statement executed        nMonth = 1;   yÿÿÿÿ  [     yÿÿÿÿ  [              P     f     f     Hÿÿÿÿ  Hÿÿÿÿ     5        statement executed        break;   fÿÿÿÿ  H     fÿÿÿÿ  H              Q     _     _     Aÿÿÿÿ  Aÿÿÿÿ     5	        statement executed        }   _ÿÿÿÿ  A     _ÿÿÿÿ  A              R     Z     Z     <ÿÿÿÿ  <ÿÿÿÿ     5È       statement executed        }   Zÿÿÿÿ  <     Zÿÿÿÿ  <              S     U     U     7ÿÿÿÿ  7ÿÿÿÿ     5       statement executed        }   Uÿÿÿÿ  7     Uÿÿÿÿ  7              T     Q     Q     3ÿÿÿÿ  3ÿÿÿÿ     5x       statement executed        }   Qÿÿÿÿ  3     Qÿÿÿÿ  3              U     K     K     -ÿÿÿÿ  -ÿÿÿÿ     4ÿH       statement executed        break;   Kÿÿÿÿ  -     Kÿÿÿÿ  -              V     ;     ;     ÿÿÿÿ  ÿÿÿÿ     4ûğ       statement executed        break;   ;ÿÿÿÿ       ;ÿÿÿÿ                W     '     '     	ÿÿÿÿ  	ÿÿÿÿ     4ôè       statement executed        break;   'ÿÿÿÿ  	     'ÿÿÿÿ  	              X               øÿÿÿÿ  øÿÿÿÿ     4ñx       statement executed        break;   ÿÿÿÿ  ø     ÿÿÿÿ  ø              Y               óÿÿÿÿ  óÿÿÿÿ     4ïH       statement executed        break;   ÿÿÿÿ  ó     ÿÿÿÿ  ó              Z               îÿÿÿÿ  îÿÿÿÿ     4í       statement executed        break;   ÿÿÿÿ  î     ÿÿÿÿ  î              [               åÿÿÿÿ  åÿÿÿÿ     4èÀ       statement executed        break;   ÿÿÿÿ  å     ÿÿÿÿ  å              \     í     í     Ğÿÿÿÿ  Ğÿÿÿÿ     4æ       statement executed        yyval = yyvsp[1-yylen];   íÿÿÿÿ  Ğ     íÿÿÿÿ  Ğ              ]     ç     ç     Êÿÿÿÿ  Êÿÿÿÿ     4áh       statement executed        goto yyerrlab;   çÿÿÿÿ  Ê     çÿÿÿÿ  Ê              ^     à     à     Ãÿÿÿÿ  Ãÿÿÿÿ     4Ş       statement executed        goto yynewstate;   àÿÿÿÿ  Ã     àÿÿÿÿ  Ã              _     İ     İ   "  Àÿÿÿÿ  Àÿÿÿÿ     4Û       statement executed        yyerrstatus--;   İÿÿÿÿ  À     İÿÿÿÿ  À   "           `     Õ     Õ     ¸ÿÿÿÿ  ¸ÿÿÿÿ     4×˜       statement executed        yychar = -2;   Õÿÿÿÿ  ¸     Õÿÿÿÿ  ¸              a     Ê     Ê     ®ÿÿÿÿ  ®ÿÿÿÿ     4Óˆ       statement executed        return(0);   Êÿÿÿÿ  ®     Êÿÿÿÿ  ®              b     Ç     Ç     «ÿÿÿÿ  «ÿÿÿÿ     4Ï        statement executed        goto yyerrlab;   Çÿÿÿÿ  «     Çÿÿÿÿ  «              c     Ä     Ä     ¨ÿÿÿÿ  ¨ÿÿÿÿ     4Í       statement executed        goto yyreduce;   Äÿÿÿÿ  ¨     Äÿÿÿÿ  ¨              d     Â     Â     ¦ÿÿÿÿ  ¦ÿÿÿÿ     4Ê8       statement executed        goto yyerrlab;   Âÿÿÿÿ  ¦     Âÿÿÿÿ  ¦              e     ´     ´     ˜ÿÿÿÿ  ˜ÿÿÿÿ     4ÅØ       statement executed        goto yydefault;   ´ÿÿÿÿ  ˜     ´ÿÿÿÿ  ˜              f     °     °     ”ÿÿÿÿ  ”ÿÿÿÿ     4¼x       statement executed        }   °ÿÿÿÿ  ”     °ÿÿÿÿ  ”              g     Ÿ     Ÿ     „ÿÿÿÿ  „ÿÿÿÿ     4¶X       statement executed        }   Ÿÿÿÿÿ  „     Ÿÿÿÿÿ  „              h     ’     ’     xÿÿÿÿ  xÿÿÿÿ     4°È       statement executed        }   ’ÿÿÿÿ  x     ’ÿÿÿÿ  x              i     „     „     kÿÿÿÿ  kÿÿÿÿ     4¬0       statement executed        goto yydefault;   „ÿÿÿÿ  k     „ÿÿÿÿ  k              j     y     y     `ÿÿÿÿ  `ÿÿÿÿ     4©       statement executed        goto yybackup;   yÿÿÿÿ  `     yÿÿÿÿ  `              k     r     r     Zÿÿÿÿ  Zÿÿÿÿ     4§(       statement executed        }   rÿÿÿÿ  Z     rÿÿÿÿ  Z              l     q     q     Yÿÿÿÿ  Yÿÿÿÿ     4¥h       statement executed        return(1);   qÿÿÿÿ  Y     qÿÿÿÿ  Y              m      ?      ?      ;ÿÿÿÿ   ;ÿÿÿÿ     (ß8       statement executed        }    ?ÿÿÿÿ   ;      ?ÿÿÿÿ   ;              n      G      G      Cÿÿÿÿ   Cÿÿÿÿ     4,à       statement executed        return 1;    Gÿÿÿÿ   C      Gÿÿÿÿ   C              o      N      N      Jÿÿÿÿ   Jÿÿÿÿ     4.¨       statement executed        }    Nÿÿÿÿ   J      Nÿÿÿÿ   J              p      U      U      Qÿÿÿÿ   Qÿÿÿÿ     4;8       statement executed        }    Uÿÿÿÿ   Q      Uÿÿÿÿ   Q              q      g      g      cÿÿÿÿ   cÿÿÿÿ     4F@       statement executed        }    gÿÿÿÿ   c      gÿÿÿÿ   c              r      o      o      kÿÿÿÿ   kÿÿÿÿ     4V8       statement executed        }    oÿÿÿÿ   k      oÿÿÿÿ   k              s      p      p      lÿÿÿÿ   lÿÿÿÿ     4Wø       statement executed        return 0;    pÿÿÿÿ   l      pÿÿÿÿ   l              t     Â     Â     ±ÿÿÿÿ  ±ÿÿÿÿ     4l(       statement executed        *t++ = *f++;   Âÿÿÿÿ  ±     Âÿÿÿÿ  ±              u     Ã     Ã     ²ÿÿÿÿ  ²ÿÿÿÿ     4mØ       statement executed        }   Ãÿÿÿÿ  ²     Ãÿÿÿÿ  ²              v     V     V     @ÿÿÿÿ  @ÿÿÿÿ     48       statement executed        return 2;   Vÿÿÿÿ  @     Vÿÿÿÿ  @              w     Z     Z     Dÿÿÿÿ  Dÿÿÿÿ     4”h       statement executed        yystacksize = 10000;   Zÿÿÿÿ  D     Zÿÿÿÿ  D           yyerror void yyerror(const char *str)    =      ?      9ÿÿÿÿ   ;ÿÿÿÿyywrap int yywrap()    B      J      >ÿÿÿÿ   FÿÿÿÿnInitialiseDataBytes int nInitialiseDataBytes()    L      N      Hÿÿÿÿ   JÿÿÿÿnSecondToTime int nSecondToTime(unsigned int nSeconds, int *nHours, int *nMin, int *nSec)    P      U      Lÿÿÿÿ   QÿÿÿÿnGetLogTimeStamp int nGetLogTimeStamp(char* pchAscTime, char* pchLogTime)    W      g      Sÿÿÿÿ   cÿÿÿÿnConvertFile int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile)    i      q      eÿÿÿÿ   mÿÿÿÿ__yy_memcpy static void
__yy_memcpy (from, to, count)   ¼     Ã     «ÿÿÿÿ  ²ÿÿÿÿyyparse int
yyparse()   é     {     Õÿÿÿÿ  Xÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
/*  A Bison parser, made from d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.y with Bison version GNU Bison version 1.24
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	HEXNUMBER	258
#define	NUMBER	259
#define	TOKHEAT	260
#define	STATE	261
#define	TOKTARGET	262
#define	TOKTEMPERATURE	263
#define	DOUBLEVAL	264
#define	MSGDIR	265
#define	DATAMSG	266
#define	LENGTHTOKEN	267
#define	BITCOUNTTOKEN	268
#define	EQUAL	269
#define	EXTID	270
#define	MONTH	271
#define	DAY	272
#define	FULLTIME	273
#define	DATETOKEN	274
#define	REMOTE	275
#define	IGNORE	276
#define	TEXT	277
#define	COLON	278
#define	AM_PM	279
#define	BASETOKEN	280
#define	BASE	281
#define	TIMESTAMPSTOKEN	282
#define	TIMEMODE	283
#define	BEGINTRIGGERTOKEN	284
#define	LINEEND	285
#define	ENDTRIGGERTOKEN	286



#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>

#define TIME_MODE_ABSOLUTE			 0
#define TIME_MODE_RELATIVE			 1
#define	TIME_MODE_UNDEFINED			-1
#define DEF_LOG_END_TEXT			"\n***END DATE AND TIME ***"
// PTV[1.6.4]
// Added new line
#define	DEF_LOG_STOP_TEXT			"\n***[STOP LOGGING SESSION]***\r\n"


int nSize = 0;
int nLen = 0;
int nTimeMode = TIME_MODE_UNDEFINED;
int nNumLines = 0;
char data[256];
extern FILE *yyin, *yyout;

void yyerror(const char *str)
{
	//fprintf(stderr,"error: %s\n",str);
}

int yywrap()
{
	// PTV[1.6.4]
	//fprintf(yyout, DEF_LOG_END_TEXT);
	//fprintf(yyout, DEF_LOG_STOP_TEXT);
	// PTV[1.6.4]
	return 1;	//1 Sepcifies conversion is over.
				//0 specifies the parser start the conversion from different
				//Input
}
int nInitialiseDataBytes()
{
	memset(data, 0, 256);
}
int nSecondToTime(unsigned int nSeconds, int *nHours, int *nMin, int *nSec)
{
	*nHours = nSeconds / 3600; 
	nSeconds = nSeconds -(*nHours * 3600);
	*nMin = nSeconds / 60; 
	*nSec = nSeconds - (*nMin) * 60;
}
int nGetLogTimeStamp(char* pchAscTime, char* pchLogTime)
{
	char chSeparators[] = ".";
	char* pchTemp;
	char chMilliSeconds[5] = {'\0'};
	int nHours, nMin, nSec;
	unsigned int unSeconds;
	
	pchTemp = strtok(pchAscTime, chSeparators);
	unSeconds = strtoul(pchTemp, NULL, 10);
	nSecondToTime(unSeconds, &nHours, &nMin, &nSec);
	
	pchTemp = strtok(NULL, chSeparators);
	
	strncpy( chMilliSeconds, pchTemp, 4);
	
	sprintf(pchLogTime, "%u:%u:%u:%s", nHours, nMin, nSec, chMilliSeconds);
}
int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile)
{
	if( (NULL != fpInputFile) && (NULL != fpOutputFile) )
	{ 
		yyin = fpInputFile;
		yyout = fpOutputFile;
		yyparse();
	}
	return 0;
}

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#ifndef YYSTYPE
#define YYSTYPE int
#endif
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		50
#define	YYFLAG		-32768
#define	YYNTBASE	33

#define YYTRANSLATE(x) ((unsigned)(x) <= 286 ? yytranslate[x] : 46)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    32,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     5,     7,     9,    11,    13,    15,    17,    19,
    21,    23,    25,    27,    28,    31,    35,    39,    47,    55,
    61,    66,    74,    76,    78
};

static const short yyrhs[] = {    34,
     0,    33,    34,     0,     1,     0,    38,     0,    45,     0,
    39,     0,    40,     0,    41,     0,    44,     0,    36,     0,
    42,     0,    37,     0,    43,     0,     0,    35,     4,     0,
    12,    14,     4,     0,    13,    14,     4,     0,     9,     4,
     4,    10,     4,     4,    35,     0,     9,     4,    15,    10,
     4,     4,    35,     0,     9,     4,     4,    10,    20,     0,
    25,    26,    27,    28,     0,    19,    17,    16,     4,    18,
    24,     4,     0,    30,     0,    31,     0,     1,    32,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
    84,    85,    88,    90,    92,    94,    96,    98,   100,   103,
   105,   107,   109,   113,   114,   122,   127,   133,   151,   171,
   188,   215,   284,   291,   298
};

static const char * const yytname[] = {   "$","error","$undefined.","HEXNUMBER",
"NUMBER","TOKHEAT","STATE","TOKTARGET","TOKTEMPERATURE","DOUBLEVAL","MSGDIR",
"DATAMSG","LENGTHTOKEN","BITCOUNTTOKEN","EQUAL","EXTID","MONTH","DAY","FULLTIME",
"DATETOKEN","REMOTE","IGNORE","TEXT","COLON","AM_PM","BASETOKEN","BASE","TIMESTAMPSTOKEN",
"TIMEMODE","BEGINTRIGGERTOKEN","LINEEND","ENDTRIGGERTOKEN","';'","commands",
"command","Can_Data_Bytes","Msg_Len","Bit_Count","Standard_Msg","Extended_Msg",
"RemoteFrame","Base_TimeStamps","Log_Creation_Time","Line_End","End_Statement",
"stmnt",""
};
#endif

static const short yyr1[] = {     0,
    33,    33,    34,    34,    34,    34,    34,    34,    34,    34,
    34,    34,    34,    35,    35,    36,    37,    38,    39,    40,
    41,    42,    43,    44,    45
};

static const short yyr2[] = {     0,
     1,     2,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     0,     2,     3,     3,     7,     7,     5,
     4,     7,     1,     1,     2
};

static const short yydefact[] = {     0,
     3,     0,     0,     0,     0,     0,    23,    24,     0,     1,
    10,    12,     4,     6,     7,     8,    11,    13,     9,     5,
    25,     0,     0,     0,     0,     0,     2,     0,     0,    16,
    17,     0,     0,     0,     0,     0,    21,     0,    20,     0,
     0,    14,    14,     0,    18,    19,    22,    15,     0,     0
};

static const short yydefgoto[] = {     9,
    10,    45,    11,    12,    13,    14,    15,    16,    17,    18,
    19,    20
};

static const short yypact[] = {     2,
   -28,     3,    -8,    -6,    -7,    -9,-32768,-32768,     0,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,     1,    16,    18,     7,    -3,-32768,    19,    24,-32768,
-32768,    22,     8,    -2,    31,    10,-32768,    33,-32768,    34,
    15,-32768,-32768,    36,    37,    37,-32768,-32768,    42,-32768
};

static const short yypgoto[] = {-32768,
    35,     4,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768
};


#define	YYLAST		47


static const short yytable[] = {    49,
     1,    38,     1,    21,    28,    23,    22,    24,     2,    25,
     2,     3,     4,     3,     4,    29,    26,    39,     5,    30,
     5,    31,    32,    33,     6,    36,     6,    41,    34,     7,
     8,     7,     8,    35,    40,    37,    42,    43,    44,    47,
    48,    50,     0,    27,     0,     0,    46
};

static const short yycheck[] = {     0,
     1,     4,     1,    32,     4,    14,     4,    14,     9,    17,
     9,    12,    13,    12,    13,    15,    26,    20,    19,     4,
    19,     4,    16,    27,    25,     4,    25,    18,    10,    30,
    31,    30,    31,    10,     4,    28,     4,     4,    24,     4,
     4,     0,    -1,     9,    -1,    -1,    43
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */


/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif



/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#else
#define YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#endif

int
yyparse(YYPARSE_PARAM)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 3:
{yyerrok;yyclearin; ;
    break;}
case 15:
{
		strcpy((data+nLen) , (char*)yyvsp[0]);
		nLen += strlen((char*)yyvsp[0]);
		data[nLen] = ' ';
		nLen++;
		data[nLen] = '\0';
	;
    break;}
case 16:
{
		yyval = yyvsp[0];
	;
    break;}
case 17:
{
		yyval = yyvsp[0];
	;
    break;}
case 18:
{
		char chLogTime[256] = {'\0'};
		
		nGetLogTimeStamp((char*)yyvsp[-6], chLogTime);
		fprintf(yyout, "\n%s %s %s %s %s %s %s", chLogTime, yyvsp[-3], yyvsp[-5], yyvsp[-4], "s", yyvsp[-1], data);
		nLen = 0;
		nInitialiseDataBytes();
		/*free($1);
		free($2);
		free($3);
		free($4);
		free($5);
		free($6);
		free($7);*/
	;
    break;}
case 19:
{
		char chLogTime[256] = {'\0'};
		char chId[12] = {'\0'};
		int nStrLen;
		nGetLogTimeStamp((char*)yyvsp[-6], chLogTime);
		strcpy(chId, yyvsp[-4]);
		nStrLen = strlen(chId);
		chId[nStrLen-1] = '\0';
		fprintf(yyout, "\n%s %s %s %s %s %s %s", chLogTime, yyvsp[-3], yyvsp[-5], chId, "x", yyvsp[-1], data);
		nLen = 0;
		nInitialiseDataBytes();
		/*free($1);
		free($2);
		free($3);
		free($4);
		free($5);
		free($6);*/
	;
    break;}
case 20:
{
		
		char chLogTime[256] = {'\0'};
		
		nGetLogTimeStamp((char*)yyvsp[-4], chLogTime);
		fprintf(yyout,"\n%s %s %s %s %s %s %s", chLogTime, yyvsp[-1], yyvsp[-3], yyvsp[-2], "sr", "0",  "00 00 00 00 00 00 00 00");
		nLen = 0;
		nInitialiseDataBytes();
		/*free($1);
		free($2);
		free($3);
		free($4);
		free($5);*/
	;
    break;}
case 21:
{
		if(strcmp("dec", (char*)yyvsp[-2]) == 0)
		{
			fprintf(yyout,"\n%s", "***DEC***");
		}
		else
		{
			fprintf(yyout,"\n%s", "***HEX***");
		}
		if(strcmp("relative", (char*)yyvsp[0]) == 0)
		{
			fprintf(yyout,"\n%s", "***RELATIVE MODE***");
			nTimeMode = TIME_MODE_RELATIVE;
		}
		else
		{
			fprintf(yyout,"\n%s", "***ABSOLUTE MODE***");
			nTimeMode = TIME_MODE_ABSOLUTE;
		}
		fprintf(yyout,"\n%s", "***<Time><Tx/Rx><Channel><CAN ID><Type><DLC><DataBytes>***");
		/*free($1);
		free($2);
		free($3);
		free($4);*/
	;
    break;}
case 22:
{	
		/*date Wed Dec 7 12:23:39 pm 2011*/
		
		
		char chSeparators[]   = " :,\t\n";
		char* chTemp;
		int nMonth;
		int nHour, nMins, nSec;
		
		// PTV[1.6.4]
		// Added required headers at the start of the file
		 fprintf(yyout, "***BUSMASTER Ver 1.6.3***\n");
		 fprintf(yyout, "***PROTOCOL CAN***\n");
         fprintf(yyout, "***NOTE: PLEASE DO NOT EDIT THIS DOCUMENT***\n");
         fprintf(yyout, "***[START LOGGING SESSION]***\n");
	 // PTV[1.6.4]
		if( strcmp("Jan", (char*)yyvsp[-4]) == 0 )
			nMonth = 1;
		else if( strcmp("Feb", (char*)yyvsp[-4]) == 0 )
			nMonth = 2; 
		else if( strcmp("Mar", (char*)yyvsp[-4]) == 0 )
			nMonth = 3; 
		else if( strcmp("Apr", (char*)yyvsp[-4]) == 0 )
			nMonth = 4; 
		else if( strcmp("May", (char*)yyvsp[-4]) == 0 )
			nMonth = 5; 
		else if( strcmp("Jun", (char*)yyvsp[-4]) == 0 )
			nMonth = 6; 
		else if( strcmp("Jul", (char*)yyvsp[-4]) == 0 )
			nMonth = 7; 
		else if( strcmp("Aug", (char*)yyvsp[-4]) == 0 )
			nMonth = 8; 
		else if( strcmp("Sep", (char*)yyvsp[-4]) == 0 )
			nMonth = 9; 
		else if( strcmp("Oct", (char*)yyvsp[-4]) == 0 )
			nMonth = 10; 
		else if( strcmp("Nov", (char*)yyvsp[-4]) == 0 )
			nMonth = 11; 
		else if( strcmp("Dec", (char*)yyvsp[-4]) == 0 )
			nMonth = 12; 
		/*8:12:2011 20:15:28:553****/
		
		chTemp = strtok((char*)yyvsp[-2], chSeparators);
		nHour = atoi(chTemp);
		chTemp = strtok( NULL, chSeparators ); 
		nMins = atoi(chTemp);
		chTemp = strtok( NULL, chSeparators ); 
		nSec = atoi(chTemp);
		
		nHour = nHour % 12;
		if( strcmp("pm", (char*)yyvsp[-1]) == 0 )
		{
			nHour = nHour + 12;
		}
		// PTV[1.6.4]
		// Added Start date and Time text
		fprintf(yyout,"***START DATE AND TIME %s:%d:%s %d:%d:%d:%s%s", yyvsp[-3], nMonth, yyvsp[0], nHour, nMins, nSec, "000", "***");
		// PTV[1.6.4]
		/*free($1);
		free($2);
		free($3);
		free($4);
		free($5);
		free($6);
		free($7);*/
	;
    break;}
case 23:
{
		nNumLines++;
	;
    break;}
case 24:
{
	fprintf(yyout, DEF_LOG_END_TEXT);
	fprintf(yyout, DEF_LOG_STOP_TEXT);
	;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */


  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}


























using namespace std;






CComment::CComment()
{
    m_msgType = '\0';
    m_elementName = "";
    m_comment = "";
    m_msgID = 0;
}








CComment& CComment::operator=(CComment& tCmt)
{
    
    m_elementName=tCmt.m_elementName;
    m_comment=tCmt.m_comment;
    m_msgID=tCmt.m_msgID;
    m_msgType=tCmt.m_msgType;
    return(*this);
}






CComment::~CComment()
{
}








void CComment::Format_netComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken, *pcLine;
    char acLine[1026];
    string comment;

    
    while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_DESC_NET]")!=0)
    {
        pcLine=acLine;
        m_elementName="";
        pcToken=pcLine;
        comment = pcToken;

        
        while(strstr(pcToken,"\";") == 0)
        {
            fileInput.getline(acLine,1026);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        
        m_listComment.push_back(*this);
    }
}








void CComment::Format_nodeComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acLine[1026];
    string comment;

    
    while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_DESC_NODE]")!=0)
    {
        pcLine=acLine;
        
        pcToken=strtok_s(pcLine, " ", &pcNextToken);
        m_elementName=pcToken;
        
        
        pcToken = strtok_s(0, "", &pcNextToken);
        comment = pcToken;

        while(strstr(pcToken,"\";") == 0)
        {
            
            fileInput.getline(acLine,1026);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        
        m_listComment.push_back(*this);
    }
}








void CComment::Format_msgComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acLine[1026];
    string comment;

    
    while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_DESC_MSG]")!=0)
    {
        pcLine=acLine;
        
        pcToken=strtok_s(pcLine, " ", &pcNextToken);
        m_msgID=unsigned int(atoi(pcToken));
        
        pcToken=strtok_s(0, " ", &pcNextToken);
        m_msgType=*pcToken;

        if(m_msgType =='X')
        {
            m_msgID -=2147483648;
        }

        
        pcToken = strtok_s(0, "", &pcNextToken);
        comment = pcToken;

        while(strstr(pcToken,"\";") == 0)
        {
            
            fileInput.getline(acLine,1026);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        
        m_listComment.push_back(*this);
    }
}








void CComment::Format_sigComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acLine[1026];
    string comment;

    
    while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_DESC_SIG]")!=0)
    {
        pcLine=acLine;
        
        pcToken = strtok_s(pcLine, " ", &pcNextToken);
        m_msgID=unsigned int(atoi(pcToken));
        
        pcToken = strtok_s(0, " ", &pcNextToken);
        m_msgType=*pcToken;

        if(m_msgType =='X')
        {
            m_msgID -=2147483648;
        }

        
        pcToken = strtok_s(0, " ", &pcNextToken);
        m_elementName=pcToken;
        
        
        pcToken = strtok_s(0, "", &pcNextToken);
        comment = pcToken;

        while(strstr(pcToken,"\";") == 0)
        {
            fileInput.getline(acLine,1026);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        
        m_listComment.push_back(*this);
    }
}
          y   .   y   R   wÿÿÿÿ   wÿÿÿÿ    r©€      expression was true       strcmp(acLine, "[END_DESC_NODE]")!=0    yÿÿÿÿ   w   .   yÿÿÿÿ   w   R   expression was false       strcmp(acLine, "[END_DESC_NODE]")!=0    yÿÿÿÿ   w   .   yÿÿÿÿ   w   R               r«P         y      y   *   wÿÿÿÿ   wÿÿÿÿ    rªh      expression was true       fileInput.getline(acLine, 1026)    yÿÿÿÿ   w      yÿÿÿÿ   w   *   expression was false       fileInput.getline(acLine, 1026)    yÿÿÿÿ   w      yÿÿÿÿ   w   *                 T   .   T   Q   Rÿÿÿÿ   Rÿÿÿÿ     ô/      expression was true       strcmp(acLine, "[END_DESC_NET]")!=0    Tÿÿÿÿ   R   .   Tÿÿÿÿ   R   Q   expression was false       strcmp(acLine, "[END_DESC_NET]")!=0    Tÿÿÿÿ   R   .   Tÿÿÿÿ   R   Q                ûX         T      T   *   Rÿÿÿÿ   Rÿÿÿÿ     û®      expression was true       fileInput.getline(acLine, 1026)    Tÿÿÿÿ   R      Tÿÿÿÿ   R   *   expression was false       fileInput.getline(acLine, 1026)    Tÿÿÿÿ   R      Tÿÿÿÿ   R   *                 ê      ê   )   èÿÿÿÿ   èÿÿÿÿ     û{p      expression was false       strstr(pcToken,"\";") == 0    êÿÿÿÿ   è      êÿÿÿÿ   è   )                ô&H   	      ¢      ¢   *    ÿÿÿÿ    ÿÿÿÿ     ôè      expression was true       fileInput.getline(acLine, 1026)    ¢ÿÿÿÿ          ¢ÿÿÿÿ       *   expression was false       fileInput.getline(acLine, 1026)    ¢ÿÿÿÿ          ¢ÿÿÿÿ       *                 µ      µ   )   ³ÿÿÿÿ   ³ÿÿÿÿ    8ìà      expression was false       strstr(pcToken,"\";") == 0    µÿÿÿÿ   ³      µÿÿÿÿ   ³   )                È         ¢   .   ¢   Q    ÿÿÿÿ    ÿÿÿÿ     ÷êP      expression was true       strcmp(acLine, "[END_DESC_MSG]")!=0    ¢ÿÿÿÿ       .   ¢ÿÿÿÿ       Q   expression was false       strcmp(acLine, "[END_DESC_MSG]")!=0    ¢ÿÿÿÿ       .   ¢ÿÿÿÿ       Q                ô&Ø         „      „   )   ‚ÿÿÿÿ   ‚ÿÿÿÿ     „¸      expression was false       strstr(pcToken,"\";") == 0    „ÿÿÿÿ   ‚      „ÿÿÿÿ   ‚   )               8æø         Ó      Ó   *   Ñÿÿÿÿ   Ñÿÿÿÿ    WSp      expression was true       fileInput.getline(acLine, 1026)    Óÿÿÿÿ   Ñ      Óÿÿÿÿ   Ñ   *   expression was false       fileInput.getline(acLine, 1026)    Óÿÿÿÿ   Ñ      Óÿÿÿÿ   Ñ   *                 \      \   )   Zÿÿÿÿ   Zÿÿÿÿ    8÷°      expression was false       strstr(pcToken,"\";") == 0    \ÿÿÿÿ   Z      \ÿÿÿÿ   Z   )               8úh         Ó   .   Ó   Q   Ñÿÿÿÿ   Ñÿÿÿÿ    pX      expression was true       strcmp(acLine, "[END_DESC_SIG]")!=0    Óÿÿÿÿ   Ñ   .   Óÿÿÿÿ   Ñ   Q   expression was false       strcmp(acLine, "[END_DESC_SIG]")!=0    Óÿÿÿÿ   Ñ   .   Óÿÿÿÿ   Ñ   Q               W]          İ      İ      Ûÿÿÿÿ   Ûÿÿÿÿ    )ø      expression was false       m_msgType =='X'    İÿÿÿÿ   Û      İÿÿÿÿ   Û                   4+°         ¬      ¬      ªÿÿÿÿ   ªÿÿÿÿ     ¨h      expression was false       m_msgType =='X'    ¬ÿÿÿÿ   ª      ¬ÿÿÿÿ   ª                  `Ğà         õ      õ      óÿÿÿÿ   óÿÿÿÿ     ÷şp       statement executed        }    õÿÿÿÿ   ó      õÿÿÿÿ   ó                    ô      ô      òÿÿÿÿ   òÿÿÿÿ    =¹`       statement executed        }    ôÿÿÿÿ   ò      ôÿÿÿÿ   ò                    ï   	   ï   
   íÿÿÿÿ   íÿÿÿÿ     û¾0       statement executed        }    ïÿÿÿÿ   í   	   ïÿÿÿÿ   í   
                 à   	   à   
   Şÿÿÿÿ   Şÿÿÿÿ    &Ê        statement executed        }    àÿÿÿÿ   Ş   	   àÿÿÿÿ   Ş   
                 Á      Á      ¿ÿÿÿÿ   ¿ÿÿÿÿ    2       statement executed        }    Áÿÿÿÿ   ¿      Áÿÿÿÿ   ¿                    À      À      ¾ÿÿÿÿ   ¾ÿÿÿÿ    f”¸       statement executed        }    Àÿÿÿÿ   ¾      Àÿÿÿÿ   ¾                    »   	   »   
   ¹ÿÿÿÿ   ¹ÿÿÿÿ    Õåˆ       statement executed        }    »ÿÿÿÿ   ¹   	   »ÿÿÿÿ   ¹   
                 ¯   	   ¯   
   ­ÿÿÿÿ   ­ÿÿÿÿ     ªX       statement executed        }    ¯ÿÿÿÿ   ­   	   ¯ÿÿÿÿ   ­   
                             ÿÿÿÿ   ÿÿÿÿ     4È       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                                   ÿÿÿÿ   ÿÿÿÿ     ôÀ       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                        Š   	   Š   
   ˆÿÿÿÿ   ˆÿÿÿÿ    8ò@       statement executed        }    Šÿÿÿÿ   ˆ   	   Šÿÿÿÿ   ˆ   
           !      g      g      eÿÿÿÿ   eÿÿÿÿ    r¬8       statement executed        }    gÿÿÿÿ   e      gÿÿÿÿ   e              "      f      f      dÿÿÿÿ   dÿÿÿÿ    8õà       statement executed        }    fÿÿÿÿ   d      fÿÿÿÿ   d              #      a   	   a   
   _ÿÿÿÿ   _ÿÿÿÿ     40˜       statement executed        }    aÿÿÿÿ   _   	   aÿÿÿÿ   _   
           $      D      D      Bÿÿÿÿ   Bÿÿÿÿ    =¼P       statement executed        }    Dÿÿÿÿ   B      Dÿÿÿÿ   B              %      :      :      8ÿÿÿÿ   8ÿÿÿÿ     ø(0       statement executed        return(*this);    :ÿÿÿÿ   8      :ÿÿÿÿ   8              &      *      *      (ÿÿÿÿ   (ÿÿÿÿ    p@       statement executed        }    *ÿÿÿÿ   (      *ÿÿÿÿ   (           CComment::CComment CComment::CComment()    %      *      #ÿÿÿÿ   (ÿÿÿÿCComment::operator= CComment& CComment::operator=(CComment& tCmt)    4      ;      2ÿÿÿÿ   9ÿÿÿÿCComment::~CComment CComment::~CComment()    C      D      Aÿÿÿÿ   BÿÿÿÿCComment::Format_netComment void CComment::Format_netComment(fstream& fileInput, list<CComment>& m_listComment)    N      g      Lÿÿÿÿ   eÿÿÿÿCComment::Format_nodeComment void CComment::Format_nodeComment(fstream& fileInput, list<CComment>& m_listComment)    q            oÿÿÿÿ   ÿÿÿÿCComment::Format_msgComment void CComment::Format_msgComment(fstream& fileInput, list<CComment>& m_listComment)    š      Á      ˜ÿÿÿÿ   ¿ÿÿÿÿCComment::Format_sigComment void CComment::Format_sigComment(fstream& fileInput, list<CComment>& m_listComment)    Ë      õ      Éÿÿÿÿ   óÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Comment.cpp
 * \brief     Implementation file for the Comment class.
 * \authors   Padmaja A, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for the Comment class.
 */

/* Project includes */
#include "Comment.h"
#include "Definitions.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CComment
 */
CComment::CComment()
{
    m_msgType = '\0';
    m_elementName = "";
    m_comment = "";
    m_msgID = 0;
}

/**
 * \brief     operator= overloading
 * \param[in] tCmt Comment to copy content from
 * \return    Local comment with new content
 *
 * Copies the content from tCmt into the local object.
 */
CComment& CComment::operator=(CComment& tCmt)
{
    //copies all members of tCmt object to this object.
    m_elementName=tCmt.m_elementName;
    m_comment=tCmt.m_comment;
    m_msgID=tCmt.m_msgID;
    m_msgType=tCmt.m_msgType;
    return(*this);
}

/**
 * \brief Destrutor
 *
 * Destructor of CComment
 */
CComment::~CComment()
{
}

/**
 * \brief     Format the net comment
 * \param[in] fileInput Input file
 * \param[in] m_listComment list of CComments
 *
 * Parses the net comments.
 */
void CComment::Format_netComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken, *pcLine;
    char acLine[defCON_MAX_LINE_LEN];
    string comment;

    //Reads all the net comments,parses the comments and stores them to a list.
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_DESC_NET]")!=0)
    {
        pcLine=acLine;
        m_elementName="";
        pcToken=pcLine;
        comment = pcToken;

        //parses net comment.
        while(strstr(pcToken,"\";") == NULL)
        {
            fileInput.getline(acLine,defCON_MAX_LINE_LEN);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        //adds the comment to the list.
        m_listComment.push_back(*this);
    }
}

/**
 * \brief     Format the node comments
 * \param[in] fileInput Input file
 * \param[in] m_listComment List of CComments
 *
 * Parses the node comments.
 */
void CComment::Format_nodeComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acLine[defCON_MAX_LINE_LEN];
    string comment;

    //Reads all the node comments,parses the comments and stores them to a list.
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_DESC_NODE]")!=0)
    {
        pcLine=acLine;
        //reads the node name.
        pcToken=strtok_s(pcLine, " ", &pcNextToken);
        m_elementName=pcToken;
        //m_elementName = m_elementName.Left(defCON_MAX_MSGN_LEN);
        //get the comment.
        pcToken = strtok_s(NULL, "", &pcNextToken);
        comment = pcToken;

        while(strstr(pcToken,"\";") == NULL)
        {
            //parses the comment.
            fileInput.getline(acLine,defCON_MAX_LINE_LEN);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        //adds the comment to the list.
        m_listComment.push_back(*this);
    }
}

/**
 * \brief     Format message comments
 * \param[in] fileInput Input file
 * \param[in] m_listComment List of CComments
 *
 * Parses the message comments.
 */
void CComment::Format_msgComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acLine[defCON_MAX_LINE_LEN];
    string comment;

    //Reads all the mesg comments,parses the comments and stores them to a list.
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_DESC_MSG]")!=0)
    {
        pcLine=acLine;
        //get msgid
        pcToken=strtok_s(pcLine, " ", &pcNextToken);
        m_msgID=unsigned int(atoi(pcToken));
        //get the message type and validates the message.
        pcToken=strtok_s(NULL, " ", &pcNextToken);
        m_msgType=*pcToken;

        if(m_msgType =='X')
        {
            m_msgID -=2147483648;
        }

        //get the comment
        pcToken = strtok_s(NULL, "", &pcNextToken);
        comment = pcToken;

        while(strstr(pcToken,"\";") == NULL)
        {
            //parses the comment
            fileInput.getline(acLine,defCON_MAX_LINE_LEN);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        //adds the comment to the list.
        m_listComment.push_back(*this);
    }
}

/**
 * \brief     Format signal comments
 * \param[in] fileInput Input file
 * \param[in] m_listComment List of CComments
 *
 * Parses the signal comments.
 */
void CComment::Format_sigComment(fstream& fileInput, list<CComment>& m_listComment)
{
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acLine[defCON_MAX_LINE_LEN];
    string comment;

    //Reads all the signal comments,parses the comments and stores them to a list.
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_DESC_SIG]")!=0)
    {
        pcLine=acLine;
        //get the mesgid.
        pcToken = strtok_s(pcLine, " ", &pcNextToken);
        m_msgID=unsigned int(atoi(pcToken));
        //get the mesg type and validates.
        pcToken = strtok_s(NULL, " ", &pcNextToken);
        m_msgType=*pcToken;

        if(m_msgType =='X')
        {
            m_msgID -=2147483648;
        }

        //get signal name.
        pcToken = strtok_s(NULL, " ", &pcNextToken);
        m_elementName=pcToken;
        //  m_elementName = m_elementName.Left(defCON_MAX_MSGN_LEN);
        //get comment.
        pcToken = strtok_s(NULL, "", &pcNextToken);
        comment = pcToken;

        while(strstr(pcToken,"\";") == NULL)
        {
            fileInput.getline(acLine,defCON_MAX_LINE_LEN);
            pcToken = acLine;
            comment += pcToken;
        }

        m_comment= comment;
        //adds the comment to list.
        m_listComment.push_back(*this);
    }
}




























using namespace std;

fstream CConverter::fileLog;
bool CConverter::bLOG_ENTERED = false;
unsigned int CConverter::ucMsg_DLC = 8;






CConverter::CConverter()
{
    m_uiResultCode = CON_RC_NOERROR;
}






CConverter::~CConverter()
{
}










unsigned int CConverter::Convert(string sCanMonFile, string sCanoeFile)
{
    fstream fileInput, fileOutput;
    char acLine[1026]; 
    fileInput.open(sCanMonFile.c_str(), fstream::in);

    if(!fileInput.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);
    }

    
    if(fileInput.getline(acLine,1026) == 0)
    {
        
        fileInput.close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
    }
    else 
    {
        fileInput.getline(acLine,1026);
        fileInput.getline(acLine,1026);
        
        




    }

    
    CConverter::bLOG_ENTERED = false;
    string sLogFile = sCanoeFile.substr(0, sCanoeFile.length()-4);
    sLogFile += ".log";
    m_omLogFilePath = sLogFile;
    fileLog.open(sLogFile.c_str(), fstream::out);

    if(!fileLog.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);
    }

    
    GenerateMessageList(fileInput);
    DecryptData(m_notProcessed);
    
    
    ValidateMessageList();
    
    fileOutput.open(sCanoeFile.c_str(), fstream::out);

    if(!fileOutput.is_open())
    {
        
        
        fileInput.close();
        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);
    }

    bool bRes = WriteToOutputFile(fileOutput);
    fileInput.close();
    fileOutput.close();

    
    if(!bRes)
    {
        CreateLogFile(fileLog);
        fileLog.close();
        CConverter::bLOG_ENTERED = true;
        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
    }

    fileLog.close();

    
    if(!CConverter::bLOG_ENTERED)
    {
        remove(sLogFile.c_str());
    }
    else
    {
        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
    }

    return m_uiResultCode;
}









unsigned int CConverter::SetResultCode(unsigned int uiCode)
{
    return (m_uiResultCode = uiCode);
}







void CConverter::GetResultString(string& str)
{
    switch(m_uiResultCode)
    {
        case 0:
            str = "Conversion completed.";
            break;

        case 1:
            str = "Conversion completed with warnings. See log file.";
            break;

        case 2:
            str = "Conversion aborted. Error opening input file.";
            break;

        case 3:
            str = "Conversion aborted. Error creating output file.";
            break;

        case 4:
            str = "Conversion aborted. Error with input file format.";
            break;

        case 5:
            str = "Conversion aborted. Error creating log file.";
            break;

        default:
            str = "Unknown";
            break;
    }
}








void CConverter::GenerateMessageList(fstream& fileInput)
{
    char acLine[1026]; 
    bool valTab = false;
    list<CMessage>::iterator posMsg;
    list<CSignal>::iterator posSig;
    

    while(fileInput.getline(acLine,1026))
    {
        char* pcToken;
        char* pcNextToken;
        char* pcLine;
        
        
        
        pcLine = acLine;

        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        pcToken = strtok_s(pcLine, " ", &pcNextToken);

        if(pcToken)
        {
            

            
            if(strcmp(pcToken,"\n") == 0)
            {
                continue;
            }
            
            else if(strcmp(pcToken,"[START_MSG]") == 0)
            {
                bool found = false;
                CMessage msg;
                msg.Format(pcLine + strlen(pcToken)+1);

                
                for(posMsg=m_listMessages.begin(); posMsg!=m_listMessages.end(); ++posMsg)
                {
                    if((posMsg->m_uiMsgID == msg.m_uiMsgID) && (posMsg->m_cFrameFormat == msg.m_cFrameFormat))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    m_listMessages.push_back(msg);
                    posMsg = m_listMessages.end();
                    --posMsg;
                }
            }
            else if(strcmp(pcToken,"[START_SIG_LIST]") == 0)
            {
                CMessage msg;
                msg.m_sName = "VECTOR__INDEPENDENT_SIG_MSG";
                msg.m_sTxNode = "Vector__XXX";
                msg.m_ucLength = 0;
                msg.m_uiMsgID = 3221225472;
                CConverter::ucMsg_DLC = 8;
                m_listMessages.push_front(msg);
                posMsg = m_listMessages.begin();
                fileInput.getline(acLine,1026);
                pcToken = strtok_s(pcLine, " ", &pcNextToken);

                while(strcmp(acLine,"[END_SIG_LIST]") != 0)
                {
                    pcToken = strtok_s(pcLine, " ", &pcNextToken);

                    if(strcmp(pcToken,"[START_SIGNALS]") == 0)
                    {
                        CSignal sig;
                        sig.Format(pcLine + strlen(pcToken)+1);
                        sig.m_ucStartBit = 0;
                        posMsg->m_listSignals.push_front(sig);
                        posSig = posMsg->m_listSignals.begin();
                    }
                    else if(strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0)
                    {
                        CValueDescriptor val;
                        val.Format(pcLine + strlen(pcToken)+1);
                        posSig->m_listValueDescriptor.push_front(val);
                    }

                    fileInput.getline(acLine,1026);
                }
            }
            else if(strcmp(pcToken,"[START_SIGNALS]") == 0)
            {
                CSignal sig;
                sig.Format(pcLine + strlen(pcToken)+1);
                posMsg->m_listSignals.push_front(sig);
                posSig = posMsg->m_listSignals.begin();
            }
            else if(strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0 && valTab == false)
            {
                CValueDescriptor val;
                val.Format(pcLine + strlen(pcToken)+1);
                posSig->m_listValueDescriptor.push_front(val);
            }
            else if(strcmp(pcToken,"[START_NOT_SUPPORTED]") == 0)
            {
            }
            
            else if(strcmp(pcToken,"[NODE]") == 0)
            {
                create_Node_List(pcLine + strlen(pcToken)+1);
            }
            else if(strcmp(pcToken,"[START_VALUE_TABLE]")==0)
            {
                while(fileInput.getline(acLine,1026) && strcmp(acLine, "[END_VALUE_TABLE]")!=0)
                {
                    pcLine = acLine;
                    pcToken=strtok_s(pcLine, " ", &pcNextToken);

                    if(strcmp(pcToken,"[START_TABLE]")==0)
                    {
                        CValueTable vTab;
                        vTab.Format_ValueTable(pcLine + strlen(pcToken)+1,fileInput);
                        m_vTab.push_back(vTab);
                    }
                }
            }
            else if(strcmp(pcToken,"[START_PARAM]")==0)
            {
                while(fileInput.getline(acLine,1026) && strcmp(acLine, "[END_PARAM]")!=0)
                {
                    pcLine = acLine;
                    CParameter rParam;

                    if(strcmp(pcLine,"[START_PARAM_NET]")==0)
                    {
                        while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_NET]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,0);
                            m_listParameterArray[0].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_NODE]")==0)
                    {
                        while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_NODE]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,1);
                            m_listParameterArray[1].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_MSG]")==0)
                    {
                        while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_MSG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,2);
                            m_listParameterArray[2].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_SIG]")==0)
                    {
                        while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_SIG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,3);
                            m_listParameterArray[3].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_NODE_RX_SIG]")==0)
                    {
                        while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_NODE_RX_SIG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,4);
                            m_listParameterArray[4].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_NODE_TX_MSG]")==0)
                    {
                        while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_NODE_TX_MSG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,5);
                            m_listParameterArray[5].push_back(rParam);
                        }
                    }
                }
            }
            else if(strcmp(pcToken,"[START_PARAM_VAL]")==0)
            {
                while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_VAL]")!=0)
                {
                    pcLine = acLine;
                    CParameter tParam;

                    if(strcmp(pcLine,"[START_PARAM_NET_VAL]")==0)
                    {
                        tParam.Format_NetParam_Value(fileInput,m_listParameterArray[0]);
                    }
                    else if(strcmp(pcLine,"[START_PARAM_NODE_VAL]")==0)
                    {
                        tParam.Format_NodeParam_Value(fileInput,m_listParameterArray[1]);
                    }
                    else if(strcmp(pcLine,"[START_PARAM_MSG_VAL]")==0)
                    {
                        tParam.Format_MesgParam_Value(fileInput,m_listParameterArray[2]);
                    }
                    else if(strcmp(pcLine,"[START_PARAM_SIG_VAL]")==0)
                    {
                        tParam.Format_SigParam_Value(fileInput,m_listParameterArray[3]);
                    }
                }
            }
            else if(strcmp(pcToken,"[START_DESC]")==0)
            {
                while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_DESC]")!=0)
                {
                    pcLine = acLine;
                    CComment tCmt;

                    if(strcmp(pcLine,"[START_DESC_NET]")==0)
                    {
                        tCmt.Format_netComment(fileInput, m_listComments[0]);
                    }
                    else if(strcmp(pcLine,"[START_DESC_NODE]")==0)
                    {
                        tCmt.Format_nodeComment(fileInput, m_listComments[1]);
                    }
                    else if(strcmp(pcLine,"[START_DESC_MSG]")==0)
                    {
                        tCmt.Format_msgComment(fileInput, m_listComments[2]);
                    }
                    else if(strcmp(pcLine,"[START_DESC_SIG]")==0)
                    {
                        tCmt.Format_sigComment(fileInput, m_listComments[3]);
                    }
                }
            }
            else if(strcmp(pcToken,"[START_NOT_PROCESSED]") == 0)
            {
                fileInput.getline(acLine,1026);

                while(strcmp(pcToken,"[END_NOT_PROCESSED]") != 0)
                {
                    string str = acLine;
                    m_notProcessed.push_back(str);
                    fileInput.getline(acLine, 1026);
                }

                continue;
            }
            
            else
            {
                continue;
            }
        }
    }

    return ;
}







void CConverter::ValidateMessageList(void)
{
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            sig->Validate();
        }
    }
}








bool CConverter::WriteToOutputFile(fstream& fileOutput)
{
    bool bResult = true;
    
    
    fileOutput << "VERSION \"\"" << endl;
    fileOutput << endl;
    fileOutput << endl;
    fileOutput << "BS_:" << endl;
    fileOutput << endl;
    fileOutput << "BU_:";
    
    list<string>::iterator node;

    for(node = m_listNode.begin(); node != m_listNode.end(); ++node)
    {
        fileOutput << " " << node->c_str();
    }

    fileOutput << endl;
    fileOutput << endl;
    
    CValueTable temp_vtab;
    temp_vtab.writeValueTabToFile(fileOutput, m_vTab);
    fileOutput << endl;
    
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        bResult &= msg->writeMessageToFile(fileOutput);
    }

    
    list<string>::iterator str;

    for(str=m_notProcessed.begin(); str!=m_notProcessed.end(); ++str)
    {
        if(strcmp(str->substr(0, 3).c_str(), "EV_") == 0)
        {
            fileOutput << str->c_str() << endl;
        }
    }

    
    list<CComment>::iterator cmt;

    for(cmt=m_listComments[0].begin(); cmt!=m_listComments[0].end(); ++cmt)
    {
        fileOutput << "CM_ " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    
    for (cmt=m_listComments[1].begin(); cmt!=m_listComments[1].end(); ++cmt)
    {
        fileOutput << "CM_ BU_ " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    
    for (cmt=m_listComments[2].begin(); cmt!=m_listComments[2].end(); ++cmt)
    {
        fileOutput << "CM_ BO_ " << dec << cmt->m_msgID;
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    
    for (cmt=m_listComments[3].begin(); cmt!=m_listComments[3].end(); ++cmt)
    {
        fileOutput << "CM_ SG_ " << dec << cmt->m_msgID;
        fileOutput << " " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    
    WriteParamToFile(fileOutput, m_listParameterArray[0]);
    WriteParamToFile(fileOutput, m_listParameterArray[1]);
    WriteParamToFile(fileOutput, m_listParameterArray[2]);
    WriteParamToFile(fileOutput, m_listParameterArray[3]);
    WriteParamToFile(fileOutput, m_listParameterArray[4]);
    WriteParamToFile(fileOutput, m_listParameterArray[5]);
    
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[0]);
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[1]);
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[2]);
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[3]);
    
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameterArray[0].begin(); rParam!=m_listParameterArray[0].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[0].begin(); vParam!=rParam->m_listParamValues[0].end(); ++vParam)
        {
            vParam->WriteNetValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    for(rParam=m_listParameterArray[1].begin(); rParam!=m_listParameterArray[1].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[1].begin(); vParam!=rParam->m_listParamValues[1].end(); ++vParam)
        {
            vParam->WriteNodeValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    for(rParam=m_listParameterArray[2].begin(); rParam!=m_listParameterArray[2].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[2].begin(); vParam!=rParam->m_listParamValues[2].end(); ++vParam)
        {
            vParam->WriteMesgValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    for(rParam=m_listParameterArray[3].begin(); rParam!=m_listParameterArray[3].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[3].begin(); vParam!=rParam->m_listParamValues[3].end(); ++vParam)
        {
            list<CMessage>::iterator msg;

            for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
            {
                if(msg->m_uiMsgID == vParam->m_MsgId)
                {
                    list<CSignal>::iterator sig;

                    for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
                    {
                        if((sig->m_sName == vParam->m_SignalName) && (sig->m_uiError == CSignal::SIG_EC_NO_ERR))
                        {
                            vParam->WriteSigValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
                            break;
                        }
                    }
                }
            }
        }
    }

    fileOutput << endl;
    fileOutput << endl;

    
    for(str = m_notProcessed.begin(); str != m_notProcessed.end(); ++str)
    {
        if(strcmp(str->substr(0, 3).c_str(), "BA_") == 0)
        {
            fileOutput << str->c_str() << endl;
        }
    }

    
    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            if(sig->m_listValueDescriptor.empty() == 0 && sig->m_uiError == CSignal::SIG_EC_NO_ERR)
            {
                fileOutput << " VAL_ " << dec << msg->m_uiMsgID;
                fileOutput << " " << sig->m_sName.c_str();
                fileOutput << " ";
                CValueDescriptor temp;
                temp.writeValueDescToFile(fileOutput, sig->m_ucType, sig->m_listValueDescriptor);
            }
        }
    }

    
    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            if(sig->m_ucType == 'F')
            {
                fileOutput << "SIG_VALTYPE_ " << dec << msg->m_uiMsgID;
                fileOutput << " " << sig->m_sName.c_str();
                fileOutput << " : 1;" << endl;
            }
            else if(sig->m_ucType == 'D')
            {
                fileOutput << "SIG_VALTYPE_ " << dec << msg->m_uiMsgID;
                fileOutput << " " << sig->m_sName.c_str();
                fileOutput << " : 2;" << endl;
            }
        }
    }

    fileOutput << endl;
    return bResult;
}







void CConverter::CreateLogFile(fstream& fileLog)
{
    
    bool first_sig = true;
    fileLog << "Conversion Error Log" << endl;
    fileLog << endl;
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        first_sig = true;
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            
            if(sig->m_uiError != CSignal::SIG_EC_NO_ERR)
            {
                string str;

                
                if(first_sig == true)
                {
                    fileLog << endl;
                    fileLog << "MSG_ID: " << dec << msg->m_uiMsgID;
                    fileLog << " \tMSG_NAME: " << msg->m_sName.c_str() << endl;
                    first_sig = false;
                }

                sig->GetErrorString(str);
                fileLog << "\tSignal Discarded SIG_NAME: " << sig->m_sName.c_str();
                fileLog << ", Reason: " << str.c_str() << endl;
            }
        }
    }
}







void CConverter::create_Node_List(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    
    pcToken = strtok_s(pcLine, ",", &pcNextToken);

    while(pcToken)
    {
        string str = pcToken;
        m_listNode.push_back(str);
        pcToken = strtok_s(0, ",", &pcNextToken);
    }
}








void CConverter::DecryptData(list<string> &m_notProcessed)
{
    list<string>::iterator str;

    for(str=m_notProcessed.begin(); str!=m_notProcessed.end(); ++str)
    {
        
        string::iterator ch;

        for(ch=str->begin(); ch<str->end(); ++ch)
        {
            if ((*ch >= 'a' && *ch <= 'm') || (*ch >= 'A' && *ch <= 'M'))
            {
                *ch = *ch + 13;
            }
            else if ((*ch >= 'n' && *ch <= 'z') || (*ch >= 'N' && *ch <= 'Z'))
            {
                *ch = *ch - 13;
            }
        }
    }
}
         ‹     ‹   >  ‰ÿÿÿÿ  ‰ÿÿÿÿ    2      expression was true       fileInput.getline(acLine, 1026)   ‹ÿÿÿÿ  ‰     ‹ÿÿÿÿ  ‰   >   expression was false       fileInput.getline(acLine, 1026)   ‹ÿÿÿÿ  ‰     ‹ÿÿÿÿ  ‰   >                ‚   B  ‚   n  €ÿÿÿÿ  €ÿÿÿÿ    2°      expression was true       strcmp(acLine, "[END_PARAM_NODE_RX_SIG]")!=0   ‚ÿÿÿÿ  €   B  ‚ÿÿÿÿ  €   n   expression was false       strcmp(acLine, "[END_PARAM_NODE_RX_SIG]")!=0   ‚ÿÿÿÿ  €   B  ‚ÿÿÿÿ  €   n               2         ‚     ‚   >  €ÿÿÿÿ  €ÿÿÿÿ    2Ø      expression was true       fileInput.getline(acLine, 1026)   ‚ÿÿÿÿ  €     ‚ÿÿÿÿ  €   >   expression was false       fileInput.getline(acLine, 1026)   ‚ÿÿÿÿ  €     ‚ÿÿÿÿ  €   >                y   B  y   f  wÿÿÿÿ  wÿÿÿÿ    W[8      expression was true       strcmp(acLine, "[END_PARAM_SIG]")!=0   yÿÿÿÿ  w   B  yÿÿÿÿ  w   f   expression was false       strcmp(acLine, "[END_PARAM_SIG]")!=0   yÿÿÿÿ  w   B  yÿÿÿÿ  w   f               WYˆ        y     y   >  wÿÿÿÿ  wÿÿÿÿ    WZ`      expression was true       fileInput.getline(acLine, 1026)   yÿÿÿÿ  w     yÿÿÿÿ  w   >   expression was false       fileInput.getline(acLine, 1026)   yÿÿÿÿ  w     yÿÿÿÿ  w   >           
     p   B  p   f  nÿÿÿÿ  nÿÿÿÿ    WQ(      expression was true       strcmp(acLine, "[END_PARAM_MSG]")!=0   pÿÿÿÿ  n   B  pÿÿÿÿ  n   f   expression was false       strcmp(acLine, "[END_PARAM_MSG]")!=0   pÿÿÿÿ  n   B  pÿÿÿÿ  n   f               pp        p     p   >  nÿÿÿÿ  nÿÿÿÿ    WPP      expression was true       fileInput.getline(acLine, 1026)   pÿÿÿÿ  n     pÿÿÿÿ  n   >   expression was false       fileInput.getline(acLine, 1026)   pÿÿÿÿ  n     pÿÿÿÿ  n   >                g   B  g   g  eÿÿÿÿ  eÿÿÿÿ    pğ      expression was true       strcmp(acLine, "[END_PARAM_NODE]")!=0   gÿÿÿÿ  e   B  gÿÿÿÿ  e   g   expression was false       strcmp(acLine, "[END_PARAM_NODE]")!=0   gÿÿÿÿ  e   B  gÿÿÿÿ  e   g               p@        g     g   >  eÿÿÿÿ  eÿÿÿÿ    p      expression was true       fileInput.getline(acLine, 1026)   gÿÿÿÿ  e     gÿÿÿÿ  e   >   expression was false       fileInput.getline(acLine, 1026)   gÿÿÿÿ  e     gÿÿÿÿ  e   >                ^   B  ^   f  \ÿÿÿÿ  \ÿÿÿÿ     íËÀ      expression was true       strcmp(acLine, "[END_PARAM_NET]")!=0   ^ÿÿÿÿ  \   B  ^ÿÿÿÿ  \   f   expression was false       strcmp(acLine, "[END_PARAM_NET]")!=0   ^ÿÿÿÿ  \   B  ^ÿÿÿÿ  \   f                íÊ        ^     ^   >  \ÿÿÿÿ  \ÿÿÿÿ     íÊè      expression was true       fileInput.getline(acLine, 1026)   ^ÿÿÿÿ  \     ^ÿÿÿÿ  \   >   expression was false       fileInput.getline(acLine, 1026)   ^ÿÿÿÿ  \     ^ÿÿÿÿ  \   >                W   9  W   Y  Uÿÿÿÿ  Uÿÿÿÿ     ÷ùh      expression was true       strcmp(acLine, "[END_PARAM]")!=0   Wÿÿÿÿ  U   9  Wÿÿÿÿ  U   Y   expression was false       strcmp(acLine, "[END_PARAM]")!=0   Wÿÿÿÿ  U   9  Wÿÿÿÿ  U   Y                ø(        W     W   5  Uÿÿÿÿ  Uÿÿÿÿ     øH      expression was true       fileInput.getline(acLine,1026)   Wÿÿÿÿ  U     Wÿÿÿÿ  U   5   expression was false       fileInput.getline(acLine,1026)   Wÿÿÿÿ  U     Wÿÿÿÿ  U   5                H   9  H   _  Fÿÿÿÿ  Fÿÿÿÿ     ëp      expression was true       strcmp(acLine, "[END_VALUE_TABLE]")!=0   Hÿÿÿÿ  F   9  Hÿÿÿÿ  F   _   expression was false       strcmp(acLine, "[END_VALUE_TABLE]")!=0   Hÿÿÿÿ  F   9  Hÿÿÿÿ  F   _                ûX        H     H   5  Fÿÿÿÿ  Fÿÿÿÿ     û‡À      expression was true       fileInput.getline(acLine,1026)   Hÿÿÿÿ  F     Hÿÿÿÿ  F   5   expression was false       fileInput.getline(acLine,1026)   Hÿÿÿÿ  F     Hÿÿÿÿ  F   5                8   C  8   R  6ÿÿÿÿ  6ÿÿÿÿ     ô`¨      expression was true       valTab == false   8ÿÿÿÿ  6   C  8ÿÿÿÿ  6   R   expression was false       valTab == false   8ÿÿÿÿ  6   C  8ÿÿÿÿ  6   R                40˜         8     8   ?  6ÿÿÿÿ  6ÿÿÿÿ     ôC¸      expression was true       strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0   8ÿÿÿÿ  6     8ÿÿÿÿ  6   ?   expression was false       strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0   8ÿÿÿÿ  6     8ÿÿÿÿ  6   ?                3õ°   "         @      n   şÿÿÿÿ   şÿÿÿÿ     ÷ç˜      expression was true       (posMsg->m_cFrameFormat == msg.m_cFrameFormat)    ÿÿÿÿ   ş   @   ÿÿÿÿ   ş   n   expression was false       (posMsg->m_cFrameFormat == msg.m_cFrameFormat)    ÿÿÿÿ   ş   @   ÿÿÿÿ   ş   n                ÷éh   $               <   şÿÿÿÿ   şÿÿÿÿ     ÷è€      expression was true       (posMsg->m_uiMsgID == msg.m_uiMsgID)    ÿÿÿÿ   ş      ÿÿÿÿ   ş   <   expression was false       (posMsg->m_uiMsgID == msg.m_uiMsgID)    ÿÿÿÿ   ş      ÿÿÿÿ   ş   <                û¼`   &      æ      æ   (   äÿÿÿÿ   äÿÿÿÿ     ô*°      expression was true       *pcLine == ' '    æÿÿÿÿ   ä      æÿÿÿÿ   ä   (   expression was false       *pcLine == ' '    æÿÿÿÿ   ä      æÿÿÿÿ   ä   (                û©   (      æ      æ      äÿÿÿÿ   äÿÿÿÿ     6à       expression was true       *pcLine    æÿÿÿÿ   ä      æÿÿÿÿ   ä      expression was false       *pcLine    æÿÿÿÿ   ä      æÿÿÿÿ   ä              *             +  ÿÿÿÿ  ÿÿÿÿ    `Õ(      expression was false       ch<str->end()   ÿÿÿÿ       ÿÿÿÿ     +           +        %     >  ÿÿÿÿ  ÿÿÿÿ    `ÖØ      expression was false       str!=m_notProcessed.end()   ÿÿÿÿ     %  ÿÿÿÿ     >                °   ,     Ø   -  Ø   J  Öÿÿÿÿ  Öÿÿÿÿ      ğ      expression was false       sig!=msg->m_listSignals.end()   Øÿÿÿÿ  Ö   -  Øÿÿÿÿ  Ö   J                ’(   -     Ó   %  Ó   >  Ñÿÿÿÿ  Ñÿÿÿÿ     ¢°      expression was false       msg!=m_listMessages.end()   Óÿÿÿÿ  Ñ   %  Óÿÿÿÿ  Ñ   >                P   .     °   -  °   J  ®ÿÿÿÿ  ®ÿÿÿÿ     …       expression was false       sig!=msg->m_listSignals.end()   °ÿÿÿÿ  ®   -  °ÿÿÿÿ  ®   J               "Ç    /     ¬   %  ¬   >  ªÿÿÿÿ  ªÿÿÿÿ     ‡`      expression was false       msg!=m_listMessages.end()   ¬ÿÿÿÿ  ª   %  ¬ÿÿÿÿ  ª   >               "ÄØ   0        -     J  œÿÿÿÿ  œÿÿÿÿ    "ÁÀ      expression was false       sig!=msg->m_listSignals.end()   ÿÿÿÿ  œ   -  ÿÿÿÿ  œ   J               "µx   1     š   %  š   >  ˜ÿÿÿÿ  ˜ÿÿÿÿ    "Ã€      expression was false       msg!=m_listMessages.end()   šÿÿÿÿ  ˜   %  šÿÿÿÿ  ˜   >               "³   2     ‘   '  ‘   B  ÿÿÿÿ  ÿÿÿÿ    "±À      expression was false       str != m_notProcessed.end()   ‘ÿÿÿÿ     '  ‘ÿÿÿÿ     B               "¬ˆ   3     €   9  €   V  ~ÿÿÿÿ  ~ÿÿÿÿ    "£P      expression was false       sig!=msg->m_listSignals.end()   €ÿÿÿÿ  ~   9  €ÿÿÿÿ  ~   V               "—è   4     z   -  z   F  xÿÿÿÿ  xÿÿÿÿ    "¦Ğ      expression was false       msg!=m_listMessages.end()   zÿÿÿÿ  x   -  zÿÿÿÿ  x   F               "”    5     v   :  v   d  tÿÿÿÿ  tÿÿÿÿ    "¨      expression was false       vParam!=rParam->m_listParamValues[3].end()   vÿÿÿÿ  t   :  vÿÿÿÿ  t   d               "‘x   6     r   1  r   V  pÿÿÿÿ  pÿÿÿÿ    "ªP      expression was false       rParam!=m_listParameterArray[3].end()   rÿÿÿÿ  p   1  rÿÿÿÿ  p   V               "    7     l   :  l   d  jÿÿÿÿ  jÿÿÿÿ    "‹è      expression was false       vParam!=rParam->m_listParamValues[2].end()   lÿÿÿÿ  j   :  lÿÿÿÿ  j   d               "‰   8     h   1  h   V  fÿÿÿÿ  fÿÿÿÿ    "¨      expression was false       rParam!=m_listParameterArray[2].end()   hÿÿÿÿ  f   1  hÿÿÿÿ  f   V               "‡8   9     b   :  b   d  `ÿÿÿÿ  `ÿÿÿÿ    WMP      expression was false       vParam!=rParam->m_listParamValues[1].end()   bÿÿÿÿ  `   :  bÿÿÿÿ  `   d               WJø   :     ^   1  ^   V  \ÿÿÿÿ  \ÿÿÿÿ    WO      expression was false       rParam!=m_listParameterArray[1].end()   ^ÿÿÿÿ  \   1  ^ÿÿÿÿ  \   V               WH    ;     X   :  X   d  Vÿÿÿÿ  Vÿÿÿÿ    WEh      expression was false       vParam!=rParam->m_listParamValues[0].end()   Xÿÿÿÿ  V   :  Xÿÿÿÿ  V   d               WC   <     T   1  T   V  Rÿÿÿÿ  Rÿÿÿÿ    WG(      expression was false       rParam!=m_listParameterArray[0].end()   Tÿÿÿÿ  R   1  Tÿÿÿÿ  R   V               W@ˆ   =     >   )  >   E  <ÿÿÿÿ  <ÿÿÿÿ    W:ø      expression was false       cmt!=m_listComments[3].end()   >ÿÿÿÿ  <   )  >ÿÿÿÿ  <   E               W6   >     7   )  7   E  5ÿÿÿÿ  5ÿÿÿÿ    W4°      expression was false       cmt!=m_listComments[2].end()   7ÿÿÿÿ  5   )  7ÿÿÿÿ  5   E               W0Ğ   ?     0   )  0   E  .ÿÿÿÿ  .ÿÿÿÿ    W/x      expression was false       cmt!=m_listComments[1].end()   0ÿÿÿÿ  .   )  0ÿÿÿÿ  .   E               W+   @     )   (  )   D  'ÿÿÿÿ  'ÿÿÿÿ    W*8      expression was false       cmt!=m_listComments[0].end()   )ÿÿÿÿ  '   (  )ÿÿÿÿ  '   D               W&˜   A        %     >  ÿÿÿÿ  ÿÿÿÿ    Õıh      expression was false       str!=m_notProcessed.end()   ÿÿÿÿ     %  ÿÿÿÿ     >               Õ÷è   B        %     >  ÿÿÿÿ  ÿÿÿÿ    Õõˆ      expression was false       msg!=m_listMessages.end()   ÿÿÿÿ     %  ÿÿÿÿ     >               Õòh   C        $     <  ÿÿÿÿ  ÿÿÿÿ    Õí@      expression was false       node != m_listNode.end()   ÿÿÿÿ     $  ÿÿÿÿ     <               Õê°   D     ì   -  ì   J  êÿÿÿÿ  êÿÿÿÿ    Õàˆ      expression was false       sig!=msg->m_listSignals.end()   ìÿÿÿÿ  ê   -  ìÿÿÿÿ  ê   J               9ğ   E     è   %  è   >  æÿÿÿÿ  æÿÿÿÿ    ÕâH      expression was false       msg!=m_listMessages.end()   èÿÿÿÿ  æ   %  èÿÿÿÿ  æ   >               9   F      ş   4   ş   P   üÿÿÿÿ   üÿÿÿÿ     4       expression was false       posMsg!=m_listMessages.end()    şÿÿÿÿ   ü   4   şÿÿÿÿ   ü   P                û½H   G     ı     ı     ûÿÿÿÿ  ûÿÿÿÿ     ¬      expression was false       pcToken   ıÿÿÿÿ  û     ıÿÿÿÿ  û              H     Ê     Ê   A  Èÿÿÿÿ  Èÿÿÿÿ    8ï¨      expression was false       strcmp(pcToken,"[END_NOT_PROCESSED]") != 0   Êÿÿÿÿ  È     Êÿÿÿÿ  È   A               8ëH   I     ‹   B  ‹   n  ‰ÿÿÿÿ  ‰ÿÿÿÿ    r       expression was true       strcmp(acLine, "[END_PARAM_NODE_TX_MSG]")!=0   ‹ÿÿÿÿ  ‰   B  ‹ÿÿÿÿ  ‰   n   expression was false       strcmp(acLine, "[END_PARAM_NODE_TX_MSG]")!=0   ‹ÿÿÿÿ  ‰   B  ‹ÿÿÿÿ  ‰   n               20   K      -      -      +ÿÿÿÿ   +ÿÿÿÿ    fs@       statement executed        }    -ÿÿÿÿ   +      -ÿÿÿÿ   +              L      6      6      4ÿÿÿÿ   4ÿÿÿÿ     ô"Ø       statement executed        }    6ÿÿÿÿ   4      6ÿÿÿÿ   4              M      I   	   I   <   Gÿÿÿÿ   Gÿÿÿÿ     ôŠà       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);    Iÿÿÿÿ   G   	   Iÿÿÿÿ   G   <           N      Q   	   Q   :   Oÿÿÿÿ   Oÿÿÿÿ    fƒ       statement executed        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);    Qÿÿÿÿ   O   	   Qÿÿÿÿ   O   :           O      ]      ]      [ÿÿÿÿ   [ÿÿÿÿ     x@       statement executed        }    ]ÿÿÿÿ   [      ]ÿÿÿÿ   [              P      h   	   h   =   fÿÿÿÿ   fÿÿÿÿ     6õ¸       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);    hÿÿÿÿ   f   	   hÿÿÿÿ   f   =           Q      y   	   y   =   wÿÿÿÿ   wÿÿÿÿ    (y8       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);    yÿÿÿÿ   w   	   yÿÿÿÿ   w   =           R      †   	   †   ;   „ÿÿÿÿ   „ÿÿÿÿ     û…¨       statement executed        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);    †ÿÿÿÿ   „   	   †ÿÿÿÿ   „   ;           S                  ÿÿÿÿ   ÿÿÿÿ     ÷ÙX       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                 T      ’   	   ’   ;   ÿÿÿÿ   ÿÿÿÿ     6ÿh       statement executed        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);    ’ÿÿÿÿ      	   ’ÿÿÿÿ      ;           U      •      •      “ÿÿÿÿ   “ÿÿÿÿ     ôe˜       statement executed        return m_uiResultCode;    •ÿÿÿÿ   “      •ÿÿÿÿ   “              V      ¢      ¢   &    ÿÿÿÿ    ÿÿÿÿ    (k@       statement executed        return (m_uiResultCode = uiCode);    ¢ÿÿÿÿ          ¢ÿÿÿÿ       &           W      ±      ±      ¯ÿÿÿÿ   ¯ÿÿÿÿ     ø°       statement executed        break;    ±ÿÿÿÿ   ¯      ±ÿÿÿÿ   ¯              X      µ      µ      ³ÿÿÿÿ   ³ÿÿÿÿ     ÷ûX       statement executed        break;    µÿÿÿÿ   ³      µÿÿÿÿ   ³              Y      ¹      ¹      ·ÿÿÿÿ   ·ÿÿÿÿ     ÷âğ       statement executed        break;    ¹ÿÿÿÿ   ·      ¹ÿÿÿÿ   ·              Z      ½      ½      »ÿÿÿÿ   »ÿÿÿÿ     ÷ÓÈ       statement executed        break;    ½ÿÿÿÿ   »      ½ÿÿÿÿ   »              [      Á      Á      ¿ÿÿÿÿ   ¿ÿÿÿÿ     û©à       statement executed        break;    Áÿÿÿÿ   ¿      Áÿÿÿÿ   ¿              \      Å      Å      Ãÿÿÿÿ   Ãÿÿÿÿ     øP       statement executed        break;    Åÿÿÿÿ   Ã      Åÿÿÿÿ   Ã              ]      É      É      Çÿÿÿÿ   Çÿÿÿÿ    )Ø       statement executed        break;    Éÿÿÿÿ   Ç      Éÿÿÿÿ   Ç              ^      Ë      Ë      Éÿÿÿÿ   Éÿÿÿÿ     4$¨       statement executed        }    Ëÿÿÿÿ   É      Ëÿÿÿÿ   É              _      é   	   é   
   çÿÿÿÿ   çÿÿÿÿ     û£°       statement executed        }    éÿÿÿÿ   ç   	   éÿÿÿÿ   ç   
           `      ô      ô      òÿÿÿÿ   òÿÿÿÿ     ûy        statement executed        continue;    ôÿÿÿÿ   ò      ôÿÿÿÿ   ò              a               ÿÿÿÿ  ÿÿÿÿ     ø(       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                b               ÿÿÿÿ  ÿÿÿÿ    fp@       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                c               
ÿÿÿÿ  
ÿÿÿÿ     6è0       statement executed        }   ÿÿÿÿ  
     ÿÿÿÿ  
              d               ÿÿÿÿ  ÿÿÿÿ     ô•H       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                e     &     &     $ÿÿÿÿ  $ÿÿÿÿ     4Ğ       statement executed        }   &ÿÿÿÿ  $     &ÿÿÿÿ  $              f     ,     ,     *ÿÿÿÿ  *ÿÿÿÿ     6øP       statement executed        }   ,ÿÿÿÿ  *     ,ÿÿÿÿ  *              g     /     /     -ÿÿÿÿ  -ÿÿÿÿ    (f        statement executed        }   /ÿÿÿÿ  -     /ÿÿÿÿ  -              h     0     0     .ÿÿÿÿ  .ÿÿÿÿ     è°P       statement executed        }   0ÿÿÿÿ  .     0ÿÿÿÿ  .              i     7     7     5ÿÿÿÿ  5ÿÿÿÿ     ôfø       statement executed        }   7ÿÿÿÿ  5     7ÿÿÿÿ  5              j     =     =     ;ÿÿÿÿ  ;ÿÿÿÿ     ô~ğ       statement executed        }   =ÿÿÿÿ  ;     =ÿÿÿÿ  ;              k     @     @     >ÿÿÿÿ  >ÿÿÿÿ     40       statement executed        }   @ÿÿÿÿ  >     @ÿÿÿÿ  >              l     E     E     Cÿÿÿÿ  Cÿÿÿÿ     û´è       statement executed        }   Eÿÿÿÿ  C     Eÿÿÿÿ  C              m     R     R     Pÿÿÿÿ  Pÿÿÿÿ     ^¨       statement executed        }   Rÿÿÿÿ  P     Rÿÿÿÿ  P              n     S     S     Qÿÿÿÿ  Qÿÿÿÿ     ô|(       statement executed        }   Sÿÿÿÿ  Q     Sÿÿÿÿ  Q              o     T     T     Rÿÿÿÿ  Rÿÿÿÿ    fzH       statement executed        }   Tÿÿÿÿ  R     Tÿÿÿÿ  R              p     c     c     aÿÿÿÿ  aÿÿÿÿ    p         statement executed        }   cÿÿÿÿ  a     cÿÿÿÿ  a              q     d     d     bÿÿÿÿ  bÿÿÿÿ    pà       statement executed        }   dÿÿÿÿ  b     dÿÿÿÿ  b              r     l     l     jÿÿÿÿ  jÿÿÿÿ    p
P       statement executed        }   lÿÿÿÿ  j     lÿÿÿÿ  j              s     m     m     kÿÿÿÿ  kÿÿÿÿ    p       statement executed        }   mÿÿÿÿ  k     mÿÿÿÿ  k              t     u     u     sÿÿÿÿ  sÿÿÿÿ    WUh       statement executed        }   uÿÿÿÿ  s     uÿÿÿÿ  s              u     v     v     tÿÿÿÿ  tÿÿÿÿ    WW(       statement executed        }   vÿÿÿÿ  t     vÿÿÿÿ  t              v     ~     ~     |ÿÿÿÿ  |ÿÿÿÿ    2 H       statement executed        }   ~ÿÿÿÿ  |     ~ÿÿÿÿ  |              w               }ÿÿÿÿ  }ÿÿÿÿ    2°       statement executed        }   ÿÿÿÿ  }     ÿÿÿÿ  }              x     ‡     ‡     …ÿÿÿÿ  …ÿÿÿÿ    2
       statement executed        }   ‡ÿÿÿÿ  …     ‡ÿÿÿÿ  …              y     ˆ     ˆ     †ÿÿÿÿ  †ÿÿÿÿ    2Ğ       statement executed        }   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †              z               ÿÿÿÿ  ÿÿÿÿ    r¤@       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                {     ‘     ‘     ÿÿÿÿ  ÿÿÿÿ    r¦        statement executed        }   ‘ÿÿÿÿ       ‘ÿÿÿÿ                |     “     “     ‘ÿÿÿÿ  ‘ÿÿÿÿ    r®       statement executed        }   “ÿÿÿÿ  ‘     “ÿÿÿÿ  ‘              }               œÿÿÿÿ  œÿÿÿÿ    f—À       statement executed        }   ÿÿÿÿ  œ     ÿÿÿÿ  œ              ~     ¢     ¢      ÿÿÿÿ   ÿÿÿÿ    fš@       statement executed        }   ¢ÿÿÿÿ        ¢ÿÿÿÿ                      ¦     ¦     ¤ÿÿÿÿ  ¤ÿÿÿÿ    fœÀ       statement executed        }   ¦ÿÿÿÿ  ¤     ¦ÿÿÿÿ  ¤              €     ª     ª     ¨ÿÿÿÿ  ¨ÿÿÿÿ    fŸ@       statement executed        }   ªÿÿÿÿ  ¨     ªÿÿÿÿ  ¨                   ¬     ¬     ªÿÿÿÿ  ªÿÿÿÿ     íK       statement executed        }   ¬ÿÿÿÿ  ª     ¬ÿÿÿÿ  ª              ‚     ·     ·     µÿÿÿÿ  µÿÿÿÿ     íTˆ       statement executed        }   ·ÿÿÿÿ  µ     ·ÿÿÿÿ  µ              ƒ     »     »     ¹ÿÿÿÿ  ¹ÿÿÿÿ     íW       statement executed        }   »ÿÿÿÿ  ¹     »ÿÿÿÿ  ¹              „     ¿     ¿     ½ÿÿÿÿ  ½ÿÿÿÿ     íYˆ       statement executed        }   ¿ÿÿÿÿ  ½     ¿ÿÿÿÿ  ½              …     Ã     Ã     Áÿÿÿÿ  Áÿÿÿÿ     í\       statement executed        }   Ãÿÿÿÿ  Á     Ãÿÿÿÿ  Á              †     Å     Å     Ãÿÿÿÿ  Ãÿÿÿÿ    8è¨       statement executed        }   Åÿÿÿÿ  Ã     Åÿÿÿÿ  Ã              ‡     Ï     Ï     Íÿÿÿÿ  Íÿÿÿÿ    8îĞ       statement executed        }   Ïÿÿÿÿ  Í     Ïÿÿÿÿ  Í              ˆ     Ñ     Ñ     Ïÿÿÿÿ  Ïÿÿÿÿ    8ğ       statement executed        continue;   Ñÿÿÿÿ  Ï     Ñÿÿÿÿ  Ï              ‰     Ö     Ö     Ôÿÿÿÿ  Ôÿÿÿÿ    8ñh       statement executed        continue;   Öÿÿÿÿ  Ô     Öÿÿÿÿ  Ô              Š     Ù     Ù     ×ÿÿÿÿ  ×ÿÿÿÿ    8ıø       statement executed        }   Ùÿÿÿÿ  ×     Ùÿÿÿÿ  ×              ‹     Û     Û     Ùÿÿÿÿ  Ùÿÿÿÿ    8ÿ¨       statement executed        return ;   Ûÿÿÿÿ  Ù     Ûÿÿÿÿ  Ù              Œ     ï   	  ï   
  íÿÿÿÿ  íÿÿÿÿ    Õßø       statement executed        }   ïÿÿÿÿ  í   	  ïÿÿÿÿ  í   
                ğ     ğ     îÿÿÿÿ  îÿÿÿÿ    Õáp       statement executed        }   ğÿÿÿÿ  î     ğÿÿÿÿ  î                   ñ     ñ     ïÿÿÿÿ  ïÿÿÿÿ    Õã0       statement executed        }   ñÿÿÿÿ  ï     ñÿÿÿÿ  ï                             	ÿÿÿÿ  	ÿÿÿÿ    Õìh       statement executed        }   ÿÿÿÿ  	     ÿÿÿÿ  	                             ÿÿÿÿ  ÿÿÿÿ    Õô°       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ‘     #   	  #   
  !ÿÿÿÿ  !ÿÿÿÿ    ÕúĞ       statement executed        }   #ÿÿÿÿ  !   	  #ÿÿÿÿ  !   
           ’     $     $     "ÿÿÿÿ  "ÿÿÿÿ    Õü       statement executed        }   $ÿÿÿÿ  "     $ÿÿÿÿ  "              “     -     -     +ÿÿÿÿ  +ÿÿÿÿ    W)`       statement executed        }   -ÿÿÿÿ  +     -ÿÿÿÿ  +              ”     4     4     2ÿÿÿÿ  2ÿÿÿÿ    W.        statement executed        }   4ÿÿÿÿ  2     4ÿÿÿÿ  2              •     ;     ;     9ÿÿÿÿ  9ÿÿÿÿ    W3Ø       statement executed        }   ;ÿÿÿÿ  9     ;ÿÿÿÿ  9              –     C     C     Aÿÿÿÿ  Aÿÿÿÿ    W:        statement executed        }   Cÿÿÿÿ  A     Cÿÿÿÿ  A              —     [   	  [   
  Yÿÿÿÿ  Yÿÿÿÿ    WD       statement executed        }   [ÿÿÿÿ  Y   	  [ÿÿÿÿ  Y   
           ˜     \     \     Zÿÿÿÿ  Zÿÿÿÿ    WFP       statement executed        }   \ÿÿÿÿ  Z     \ÿÿÿÿ  Z              ™     e   	  e   
  cÿÿÿÿ  cÿÿÿÿ    WLx       statement executed        }   eÿÿÿÿ  c   	  eÿÿÿÿ  c   
           š     f     f     dÿÿÿÿ  dÿÿÿÿ    WN8       statement executed        }   fÿÿÿÿ  d     fÿÿÿÿ  d              ›     o   	  o   
  mÿÿÿÿ  mÿÿÿÿ    "‹       statement executed        }   oÿÿÿÿ  m   	  oÿÿÿÿ  m   
           œ     p     p     nÿÿÿÿ  nÿÿÿÿ    "ŒĞ       statement executed        }   pÿÿÿÿ  n     pÿÿÿÿ  n                   …     …   #  ƒÿÿÿÿ  ƒÿÿÿÿ    " ¸       statement executed        break;   …ÿÿÿÿ  ƒ     …ÿÿÿÿ  ƒ   #                ‡     ‡     …ÿÿÿÿ  …ÿÿÿÿ    "¢x       statement executed        }   ‡ÿÿÿÿ  …     ‡ÿÿÿÿ  …              Ÿ     ˆ     ˆ     †ÿÿÿÿ  †ÿÿÿÿ    "¤8       statement executed        }   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †                    ‰     ‰     ‡ÿÿÿÿ  ‡ÿÿÿÿ    "¥ø       statement executed        }   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡              ¡     Š   	  Š   
  ˆÿÿÿÿ  ˆÿÿÿÿ    "§¸       statement executed        }   Šÿÿÿÿ  ˆ   	  Šÿÿÿÿ  ˆ   
           ¢     ‹     ‹     ‰ÿÿÿÿ  ‰ÿÿÿÿ    "©x       statement executed        }   ‹ÿÿÿÿ  ‰     ‹ÿÿÿÿ  ‰              £     –   	  –   
  ”ÿÿÿÿ  ”ÿÿÿÿ    "¯(       statement executed        }   –ÿÿÿÿ  ”   	  –ÿÿÿÿ  ”   
           ¤     —     —     •ÿÿÿÿ  •ÿÿÿÿ    "°è       statement executed        }   —ÿÿÿÿ  •     —ÿÿÿÿ  •              ¥     §     §     ¥ÿÿÿÿ  ¥ÿÿÿÿ    "¿(       statement executed        }   §ÿÿÿÿ  ¥     §ÿÿÿÿ  ¥              ¦     ¨   	  ¨   
  ¦ÿÿÿÿ  ¦ÿÿÿÿ    "Àè       statement executed        }   ¨ÿÿÿÿ  ¦   	  ¨ÿÿÿÿ  ¦   
           §     ©     ©     §ÿÿÿÿ  §ÿÿÿÿ    "Â¨       statement executed        }   ©ÿÿÿÿ  §     ©ÿÿÿÿ  §              ¨     ·     ·     µÿÿÿÿ  µÿÿÿÿ    "Ëà       statement executed        }   ·ÿÿÿÿ  µ     ·ÿÿÿÿ  µ              ©     ½     ½     »ÿÿÿÿ  »ÿÿÿÿ     ‚        statement executed        }   ½ÿÿÿÿ  »     ½ÿÿÿÿ  »              ª     ¿     ¿     ½ÿÿÿÿ  ½ÿÿÿÿ     †ˆ       statement executed        }   ¿ÿÿÿÿ  ½     ¿ÿÿÿÿ  ½              «     Â     Â     Àÿÿÿÿ  Àÿÿÿÿ     ˆ¸       statement executed        return bResult;   Âÿÿÿÿ  À     Âÿÿÿÿ  À              ¬     æ     æ     äÿÿÿÿ  äÿÿÿÿ     šh       statement executed        }   æÿÿÿÿ  ä     æÿÿÿÿ  ä              ­     ë     ë     éÿÿÿÿ  éÿÿÿÿ     X       statement executed        }   ëÿÿÿÿ  é     ëÿÿÿÿ  é              ®     ì   	  ì   
  êÿÿÿÿ  êÿÿÿÿ             statement executed        }   ìÿÿÿÿ  ê   	  ìÿÿÿÿ  ê   
           ¯     í     í     ëÿÿÿÿ  ëÿÿÿÿ     ¡Ø       statement executed        }   íÿÿÿÿ  ë     íÿÿÿÿ  ë              °     î     î     ìÿÿÿÿ  ìÿÿÿÿ     £˜       statement executed        }   îÿÿÿÿ  ì     îÿÿÿÿ  ì              ±                ÿÿÿÿ   ÿÿÿÿ     «0       statement executed        }   ÿÿÿÿ        ÿÿÿÿ                 ²               ÿÿÿÿ  ÿÿÿÿ     ¬à       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ³               ÿÿÿÿ  ÿÿÿÿ     Áˆ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ´               ÿÿÿÿ  ÿÿÿÿ    `Ñ¸       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                µ                 ÿÿÿÿ  ÿÿÿÿ    `Ö        statement executed        }    ÿÿÿÿ        ÿÿÿÿ                ¶     !     !     ÿÿÿÿ  ÿÿÿÿ    `×À       statement executed        }   !ÿÿÿÿ       !ÿÿÿÿ                ·     –     –   6  ”ÿÿÿÿ  ”ÿÿÿÿ    f‘      expression was true       fileInput.getline(acLine, 1026)   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”   6   expression was false       fileInput.getline(acLine, 1026)   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”   6           ¹     –   :  –   ^  ”ÿÿÿÿ  ”ÿÿÿÿ    f’h      expression was true       strcmp(acLine, "[END_PARAM_VAL]")!=0   –ÿÿÿÿ  ”   :  –ÿÿÿÿ  ”   ^   expression was false       strcmp(acLine, "[END_PARAM_VAL]")!=0   –ÿÿÿÿ  ”   :  –ÿÿÿÿ  ”   ^               f¸   »     ¯     ¯   6  ­ÿÿÿÿ  ­ÿÿÿÿ     íN@      expression was true       fileInput.getline(acLine, 1026)   ¯ÿÿÿÿ  ­     ¯ÿÿÿÿ  ­   6   expression was false       fileInput.getline(acLine, 1026)   ¯ÿÿÿÿ  ­     ¯ÿÿÿÿ  ­   6           ½     ¯   :  ¯   Y  ­ÿÿÿÿ  ­ÿÿÿÿ     íO      expression was true       strcmp(acLine, "[END_DESC]")!=0   ¯ÿÿÿÿ  ­   :  ¯ÿÿÿÿ  ­   Y   expression was false       strcmp(acLine, "[END_DESC]")!=0   ¯ÿÿÿÿ  ­   :  ¯ÿÿÿÿ  ­   Y                íMh   ¿     ‚     ‚   B  €ÿÿÿÿ  €ÿÿÿÿ    "X      expression was true       (sig->m_sName == vParam->m_SignalName)   ‚ÿÿÿÿ  €     ‚ÿÿÿÿ  €   B   expression was false       (sig->m_sName == vParam->m_SignalName)   ‚ÿÿÿÿ  €     ‚ÿÿÿÿ  €   B               "š0   Á     ‚   F  ‚   p  €ÿÿÿÿ  €ÿÿÿÿ    "@      expression was true       (sig->m_uiError == CSignal::SIG_EC_NO_ERR)   ‚ÿÿÿÿ  €   F  ‚ÿÿÿÿ  €   p   expression was false       (sig->m_uiError == CSignal::SIG_EC_NO_ERR)   ‚ÿÿÿÿ  €   F  ‚ÿÿÿÿ  €   p               "œp   Ã               7  ÿÿÿÿ  ÿÿÿÿ    "¸Ø      expression was true       sig->m_listValueDescriptor.empty() == 0    ÿÿÿÿ        ÿÿÿÿ     7   expression was false       sig->m_listValueDescriptor.empty() == 0    ÿÿÿÿ        ÿÿÿÿ     7               "¶¨   Å         ;      c  ÿÿÿÿ  ÿÿÿÿ    "¹À      expression was true       sig->m_uiError == CSignal::SIG_EC_NO_ERR    ÿÿÿÿ     ;   ÿÿÿÿ     c   expression was false       sig->m_uiError == CSignal::SIG_EC_NO_ERR    ÿÿÿÿ     ;   ÿÿÿÿ     c               "¸    Ç               ÿÿÿÿ  ÿÿÿÿ     ³È      expression was true       *ch >= 'a'   ÿÿÿÿ       ÿÿÿÿ        expression was false       *ch >= 'a'   ÿÿÿÿ       ÿÿÿÿ                     ²   É             ;  ÿÿÿÿ  ÿÿÿÿ     ôƒ¸      expression was false       strcmp(acLine,"[END_SIG_LIST]") != 0   ÿÿÿÿ       ÿÿÿÿ     ;                ô&Ø   Ê              *  ÿÿÿÿ  ÿÿÿÿ     ´°      expression was true       *ch <= 'm'   ÿÿÿÿ        ÿÿÿÿ     *   expression was false       *ch <= 'm'   ÿÿÿÿ        ÿÿÿÿ     *                ²ğ   Ì      Ü      Ü   )   Úÿÿÿÿ   Úÿÿÿÿ    8şĞ      expression was false       fileInput.getline(acLine,1026)    Üÿÿÿÿ   Ú      Üÿÿÿÿ   Ú   )           Í        0     :  ÿÿÿÿ  ÿÿÿÿ     ¹      expression was true       *ch >= 'A'   ÿÿÿÿ     0  ÿÿÿÿ     :   expression was false       *ch >= 'A'   ÿÿÿÿ     0  ÿÿÿÿ     :                ·h   Ï        >     H  ÿÿÿÿ  ÿÿÿÿ     º       expression was true       *ch <= 'M'   ÿÿÿÿ     >  ÿÿÿÿ     H   expression was false       *ch <= 'M'   ÿÿÿÿ     >  ÿÿÿÿ     H                ¸@   Ñ             !  ÿÿÿÿ  ÿÿÿÿ     Ä      expression was true       *ch >= 'n'   ÿÿÿÿ       ÿÿÿÿ     !   expression was false       *ch >= 'n'   ÿÿÿÿ       ÿÿÿÿ     !                Â`   Ó     à     à   %  Şÿÿÿÿ  Şÿÿÿÿ     ›@      expression was false       first_sig == true   àÿÿÿÿ  Ş     àÿÿÿÿ  Ş   %                •   Ô     Û     Û   8  Ùÿÿÿÿ  Ùÿÿÿÿ     Ÿ0      expression was false       sig->m_uiError != CSignal::SIG_EC_NO_ERR   Ûÿÿÿÿ  Ù     Ûÿÿÿÿ  Ù   8                “˜   Õ     ¸     ¸   )  ¶ÿÿÿÿ  ¶ÿÿÿÿ     ‚ø      expression was false       sig->m_ucType == 'D'   ¸ÿÿÿÿ  ¶     ¸ÿÿÿÿ  ¶   )               "Ìø   Ö        %     /  ÿÿÿÿ  ÿÿÿÿ     Äø      expression was true       *ch <= 'z'   ÿÿÿÿ     %  ÿÿÿÿ     /   expression was false       *ch <= 'z'   ÿÿÿÿ     %  ÿÿÿÿ     /                Ã8   Ø     “     “   9  ‘ÿÿÿÿ  ‘ÿÿÿÿ    "°       expression was false       strcmp(str->substr(0, 3).c_str(), "BA_") == 0   “ÿÿÿÿ  ‘     “ÿÿÿÿ  ‘   9               "­    Ù        5     ?  ÿÿÿÿ  ÿÿÿÿ     É`      expression was true       *ch >= 'N'   ÿÿÿÿ     5  ÿÿÿÿ     ?   expression was false       *ch >= 'N'   ÿÿÿÿ     5  ÿÿÿÿ     ?                Ç°   Û     |     |   5  zÿÿÿÿ  zÿÿÿÿ    "¥      expression was false       msg->m_uiMsgID == vParam->m_MsgId   |ÿÿÿÿ  z     |ÿÿÿÿ  z   5               "•p   Ü               9  ÿÿÿÿ  ÿÿÿÿ    Õû¨      expression was false       strcmp(str->substr(0, 3).c_str(), "EV_") == 0    ÿÿÿÿ        ÿÿÿÿ     9               Õù   İ     À     À   A  ¾ÿÿÿÿ  ¾ÿÿÿÿ     í\à      expression was false       strcmp(pcLine,"[START_DESC_SIG]")==0   Àÿÿÿÿ  ¾     Àÿÿÿÿ  ¾   A                íZ    Ş     §     §   F  ¥ÿÿÿÿ  ¥ÿÿÿÿ     íEØ      expression was false       strcmp(pcLine,"[START_PARAM_SIG_VAL]")==0   §ÿÿÿÿ  ¥     §ÿÿÿÿ  ¥   F               fØ   ß     ‰     ‰   K  ‡ÿÿÿÿ  ‡ÿÿÿÿ    r¦Ø      expression was false       strcmp(pcToken,"[START_PARAM_NODE_TX_MSG]")==0   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡   K               2è   à     M     M   :  Kÿÿÿÿ  Kÿÿÿÿ    )¸      expression was false       strcmp(pcToken,"[START_TABLE]")==0   Mÿÿÿÿ  K     Mÿÿÿÿ  K   :               =¼P   á     '     '   G  %ÿÿÿÿ  %ÿÿÿÿ     6ïà      expression was false       strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0   'ÿÿÿÿ  %     'ÿÿÿÿ  %   G                6üÀ   â               ÿÿÿÿ  ÿÿÿÿ     ô<      expression was false       !found   ÿÿÿÿ       ÿÿÿÿ                     4   ã        C     M  ÿÿÿÿ  ÿÿÿÿ     ÊH      expression was true       *ch <= 'Z'   ÿÿÿÿ     C  ÿÿÿÿ     M   expression was false       *ch <= 'Z'   ÿÿÿÿ     C  ÿÿÿÿ     M                Èˆ   å      í      í      ëÿÿÿÿ   ëÿÿÿÿ    8ı       expression was false       pcToken    íÿÿÿÿ   ë      íÿÿÿÿ   ë              æ                  ÿÿÿÿ   ÿÿÿÿ    &®0      expression was false       !bRes    ÿÿÿÿ         ÿÿÿÿ                      û²   ç      t      t      rÿÿÿÿ   rÿÿÿÿ     6ş€      expression was false       !fileOutput.is_open()    tÿÿÿÿ   r      tÿÿÿÿ   r                   hÈ   è      f      f      dÿÿÿÿ   dÿÿÿÿ     ôp      expression was false       !fileLog.is_open()    fÿÿÿÿ   d      fÿÿÿÿ   d                   ø8   é      G      G      Eÿÿÿÿ   Eÿÿÿÿ     ÷Ü°      expression was false       !fileInput.is_open()    Gÿÿÿÿ   E      Gÿÿÿÿ   E                   4-pCConverter::CConverter CConverter::CConverter()    +      -      )ÿÿÿÿ   +ÿÿÿÿCConverter::~CConverter CConverter::~CConverter()    5      6      3ÿÿÿÿ   4ÿÿÿÿCConverter::Convert unsigned int CConverter::Convert(string sCanMonFile, string sCanoeFile)    B      –      @ÿÿÿÿ   ”ÿÿÿÿCConverter::SetResultCode unsigned int CConverter::SetResultCode(unsigned int uiCode)    ¡      £      Ÿÿÿÿÿ   ¡ÿÿÿÿCConverter::GetResultString void CConverter::GetResultString(string& str)    ¬      Ë      ªÿÿÿÿ   ÉÿÿÿÿCConverter::GenerateMessageList void CConverter::GenerateMessageList(fstream& fileInput)    Õ     Ü      Óÿÿÿÿ  ÚÿÿÿÿCConverter::ValidateMessageList void CConverter::ValidateMessageList(void)   å     ñ     ãÿÿÿÿ  ïÿÿÿÿCConverter::WriteToOutputFile bool CConverter::WriteToOutputFile(fstream& fileOutput)   û     Ã     ùÿÿÿÿ  ÁÿÿÿÿCConverter::CreateLogFile void CConverter::CreateLogFile(fstream& fileLog)   Ì     î     Êÿÿÿÿ  ìÿÿÿÿCConverter::create_Node_List void CConverter::create_Node_List(char* pcLine)   ÷          õÿÿÿÿ  ÿÿÿÿCConverter::DecryptData void CConverter::DecryptData(list<string> &m_notProcessed)        !     ÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Converter.cpp
 * \brief     Implementation of the CConverter class.
 * \authors   Mahesh.B.S, Padmaja.A, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the CConverter class.
 */

/* C includes */
#include <stdio.h>

/* Project includes */
#include "Converter.h"

using namespace std;

fstream CConverter::fileLog;
bool CConverter::bLOG_ENTERED = false;
unsigned int CConverter::ucMsg_DLC = 8;

/**
 * \brief Constructor
 *
 * Constructor of CConverter
 */
CConverter::CConverter()
{
    m_uiResultCode = CON_RC_NOERROR;
}

/**
 * \brief Destructor
 *
 * Destructor of CConverter
 */
CConverter::~CConverter()
{
}

/**
 * \brief     Converter function
 * \param[in] sCanMonFile Input file name
 * \param[in] sCanoeFile Output file name
 * \return    Status code
 *
 * This is the basic function which is to be called
 * to convert any given CANMon file to a CANoe file.
 */
unsigned int CConverter::Convert(string sCanMonFile, string sCanoeFile)
{
    fstream fileInput, fileOutput;
    char acLine[defCON_MAX_LINE_LEN]; // I don't expect one line to be more than this
    fileInput.open(sCanMonFile.c_str(), fstream::in);

    if(!fileInput.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);
    }

    // first line of input file starts with header followed by a version no, else file format error
    if(fileInput.getline(acLine,defCON_MAX_LINE_LEN) == NULL)
    {
        // eof file reached without reading anything
        fileInput.close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
    }
    else // if something was read
    {
        fileInput.getline(acLine,defCON_MAX_LINE_LEN);
        fileInput.getline(acLine,defCON_MAX_LINE_LEN);
        // verify the format
        /*if(strncmp(acLine,"[DATABASE_VERSION] ",19) != 0)
        {
        fileInput.Close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
        }*/
    }

    //Create log file
    CConverter::bLOG_ENTERED = false;
    string sLogFile = sCanoeFile.substr(0, sCanoeFile.length()-4);
    sLogFile += ".log";
    m_omLogFilePath = sLogFile;
    fileLog.open(sLogFile.c_str(), fstream::out);

    if(!fileLog.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);
    }

    // Generate the list of messages
    GenerateMessageList(fileInput);
    DecryptData(m_notProcessed);
    // All information gathered, validate and update if necessary
    // Make appropriate changes in the contents of the list
    ValidateMessageList();
    // the format is OK then open the output file
    fileOutput.open(sCanoeFile.c_str(), fstream::out);

    if(!fileOutput.is_open())
    {
        // if output file cannot be opened the close the input file
        // and return the error code
        fileInput.close();
        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);
    }

    bool bRes = WriteToOutputFile(fileOutput);
    fileInput.close();
    fileOutput.close();

    //If any error log it in the log file.
    if(!bRes)
    {
        CreateLogFile(fileLog);
        fileLog.close();
        CConverter::bLOG_ENTERED = true;
        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
    }

    fileLog.close();

    //If log file is empty delete it
    if(!CConverter::bLOG_ENTERED)
    {
        remove(sLogFile.c_str());
    }
    else
    {
        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
    }

    return m_uiResultCode;
}

/**
 * \brief     Set Result Code
 * \param[in] uiCode Result code
 * \return    Result code
 *
 * Set the result code for the convertor class.This function
 * is called only on error
 */
unsigned int CConverter::SetResultCode(unsigned int uiCode)
{
    return (m_uiResultCode = uiCode);
}

/**
 * \brief      Get Result String
 * \param[out] str Result String depending on m_uiResultCode
 *
 * Returns the result string.
 */
void CConverter::GetResultString(string& str)
{
    switch(m_uiResultCode)
    {
        case 0:
            str = "Conversion completed.";
            break;

        case 1:
            str = "Conversion completed with warnings. See log file.";
            break;

        case 2:
            str = "Conversion aborted. Error opening input file.";
            break;

        case 3:
            str = "Conversion aborted. Error creating output file.";
            break;

        case 4:
            str = "Conversion aborted. Error with input file format.";
            break;

        case 5:
            str = "Conversion aborted. Error creating log file.";
            break;

        default:
            str = "Unknown";
            break;
    }
}

/**
 * \brief     Generate Message List
 * \param[in] fileInput Input file
 *
 * This function will parse the input file and line by line
 * and generates a list of message,signal,value table,comments,etc
 */
void CConverter::GenerateMessageList(fstream& fileInput)
{
    char acLine[defCON_MAX_LINE_LEN]; // I don't expect one line to be more than this
    bool valTab = false;
    list<CMessage>::iterator posMsg;
    list<CSignal>::iterator posSig;
    // parsing the input file

    while(fileInput.getline(acLine,defCON_MAX_LINE_LEN))
    {
        char* pcToken;
        char* pcNextToken;
        char* pcLine;
        // avoid leading <spaces> before tokenising, so passing the
        // starting point will be correct in each case, when calling
        // msg.Format, sig.Format etc.
        pcLine = acLine;

        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        pcToken = strtok_s(pcLine, " ", &pcNextToken);

        if(pcToken)
        {
            //compare token to known types to interpret the line further

            // new line - skip
            if(strcmp(pcToken,"\n") == 0)
            {
                continue;
            }
            // message
            else if(strcmp(pcToken,"[START_MSG]") == 0)
            {
                bool found = false;
                CMessage msg;
                msg.Format(pcLine + strlen(pcToken)+1);

                // find the message
                for(posMsg=m_listMessages.begin(); posMsg!=m_listMessages.end(); ++posMsg)
                {
                    if((posMsg->m_uiMsgID == msg.m_uiMsgID) && (posMsg->m_cFrameFormat == msg.m_cFrameFormat))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    m_listMessages.push_back(msg);
                    posMsg = m_listMessages.end();
                    --posMsg;
                }
            }
            else if(strcmp(pcToken,"[START_SIG_LIST]") == 0)
            {
                CMessage msg;
                msg.m_sName = "VECTOR__INDEPENDENT_SIG_MSG";
                msg.m_sTxNode = "Vector__XXX";
                msg.m_ucLength = 0;
                msg.m_uiMsgID = 3221225472;
                CConverter::ucMsg_DLC = 8;
                m_listMessages.push_front(msg);
                posMsg = m_listMessages.begin();
                fileInput.getline(acLine,defCON_MAX_LINE_LEN);
                pcToken = strtok_s(pcLine, " ", &pcNextToken);

                while(strcmp(acLine,"[END_SIG_LIST]") != 0)
                {
                    pcToken = strtok_s(pcLine, " ", &pcNextToken);

                    if(strcmp(pcToken,"[START_SIGNALS]") == 0)
                    {
                        CSignal sig;
                        sig.Format(pcLine + strlen(pcToken)+1);
                        sig.m_ucStartBit = 0;
                        posMsg->m_listSignals.push_front(sig);
                        posSig = posMsg->m_listSignals.begin();
                    }
                    else if(strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0)
                    {
                        CValueDescriptor val;
                        val.Format(pcLine + strlen(pcToken)+1);
                        posSig->m_listValueDescriptor.push_front(val);
                    }

                    fileInput.getline(acLine,defCON_MAX_LINE_LEN);
                }
            }
            else if(strcmp(pcToken,"[START_SIGNALS]") == 0)
            {
                CSignal sig;
                sig.Format(pcLine + strlen(pcToken)+1);
                posMsg->m_listSignals.push_front(sig);
                posSig = posMsg->m_listSignals.begin();
            }
            else if(strcmp(pcToken,"[VALUE_DESCRIPTION]") == 0 && valTab == false)
            {
                CValueDescriptor val;
                val.Format(pcLine + strlen(pcToken)+1);
                posSig->m_listValueDescriptor.push_front(val);
            }
            else if(strcmp(pcToken,"[START_NOT_SUPPORTED]") == 0)
            {
            }
            //nodes
            else if(strcmp(pcToken,"[NODE]") == 0)
            {
                create_Node_List(pcLine + strlen(pcToken)+1);
            }
            else if(strcmp(pcToken,"[START_VALUE_TABLE]")==0)
            {
                while(fileInput.getline(acLine,defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_VALUE_TABLE]")!=0)
                {
                    pcLine = acLine;
                    pcToken=strtok_s(pcLine, " ", &pcNextToken);

                    if(strcmp(pcToken,"[START_TABLE]")==0)
                    {
                        CValueTable vTab;
                        vTab.Format_ValueTable(pcLine + strlen(pcToken)+1,fileInput);
                        m_vTab.push_back(vTab);
                    }
                }
            }
            else if(strcmp(pcToken,"[START_PARAM]")==0)
            {
                while(fileInput.getline(acLine,defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM]")!=0)
                {
                    pcLine = acLine;
                    CParameter rParam;

                    if(strcmp(pcLine,"[START_PARAM_NET]")==0)
                    {
                        while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_NET]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,0);
                            m_listParameterArray[0].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_NODE]")==0)
                    {
                        while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_NODE]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,1);
                            m_listParameterArray[1].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_MSG]")==0)
                    {
                        while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_MSG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,2);
                            m_listParameterArray[2].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_SIG]")==0)
                    {
                        while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_SIG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,3);
                            m_listParameterArray[3].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_NODE_RX_SIG]")==0)
                    {
                        while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_NODE_RX_SIG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,4);
                            m_listParameterArray[4].push_back(rParam);
                        }
                    }
                    else if(strcmp(pcToken,"[START_PARAM_NODE_TX_MSG]")==0)
                    {
                        while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_NODE_TX_MSG]")!=0)
                        {
                            pcLine = acLine;
                            rParam.Format_ParamDef(pcLine,5);
                            m_listParameterArray[5].push_back(rParam);
                        }
                    }
                }
            }
            else if(strcmp(pcToken,"[START_PARAM_VAL]")==0)
            {
                while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_VAL]")!=0)
                {
                    pcLine = acLine;
                    CParameter tParam;

                    if(strcmp(pcLine,"[START_PARAM_NET_VAL]")==0)
                    {
                        tParam.Format_NetParam_Value(fileInput,m_listParameterArray[0]);
                    }
                    else if(strcmp(pcLine,"[START_PARAM_NODE_VAL]")==0)
                    {
                        tParam.Format_NodeParam_Value(fileInput,m_listParameterArray[1]);
                    }
                    else if(strcmp(pcLine,"[START_PARAM_MSG_VAL]")==0)
                    {
                        tParam.Format_MesgParam_Value(fileInput,m_listParameterArray[2]);
                    }
                    else if(strcmp(pcLine,"[START_PARAM_SIG_VAL]")==0)
                    {
                        tParam.Format_SigParam_Value(fileInput,m_listParameterArray[3]);
                    }
                }
            }
            else if(strcmp(pcToken,"[START_DESC]")==0)
            {
                while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_DESC]")!=0)
                {
                    pcLine = acLine;
                    CComment tCmt;

                    if(strcmp(pcLine,"[START_DESC_NET]")==0)
                    {
                        tCmt.Format_netComment(fileInput, m_listComments[0]);
                    }
                    else if(strcmp(pcLine,"[START_DESC_NODE]")==0)
                    {
                        tCmt.Format_nodeComment(fileInput, m_listComments[1]);
                    }
                    else if(strcmp(pcLine,"[START_DESC_MSG]")==0)
                    {
                        tCmt.Format_msgComment(fileInput, m_listComments[2]);
                    }
                    else if(strcmp(pcLine,"[START_DESC_SIG]")==0)
                    {
                        tCmt.Format_sigComment(fileInput, m_listComments[3]);
                    }
                }
            }
            else if(strcmp(pcToken,"[START_NOT_PROCESSED]") == 0)
            {
                fileInput.getline(acLine,defCON_MAX_LINE_LEN);

                while(strcmp(pcToken,"[END_NOT_PROCESSED]") != 0)
                {
                    string str = acLine;
                    m_notProcessed.push_back(str);
                    fileInput.getline(acLine, defCON_MAX_LINE_LEN);
                }

                continue;
            }
            //if any other tag continue
            else
            {
                continue;
            }
        }
    }

    return ;
}

/**
 * \brief Validate Message List
 *
 * Validates the message list and set the error in each signal
 * if present.
 */
void CConverter::ValidateMessageList(void)
{
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            sig->Validate();
        }
    }
}

/**
 * \brief     Write to Output File
 * \param[in] fileOutput Output file
 * \return    Status code
 *
 * Writes all the data to the output file in CANoe format
 */
bool CConverter::WriteToOutputFile(fstream& fileOutput)
{
    bool bResult = true;
    // write to the output file
    // write header
    fileOutput << "VERSION \"\"" << endl;
    fileOutput << endl;
    fileOutput << endl;
    fileOutput << "BS_:" << endl;
    fileOutput << endl;
    fileOutput << "BU_:";
    //write all nodes
    list<string>::iterator node;

    for(node = m_listNode.begin(); node != m_listNode.end(); ++node)
    {
        fileOutput << " " << node->c_str();
    }

    fileOutput << endl;
    fileOutput << endl;
    //Value Table
    CValueTable temp_vtab;
    temp_vtab.writeValueTabToFile(fileOutput, m_vTab);
    fileOutput << endl;
    //write messages
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        bResult &= msg->writeMessageToFile(fileOutput);
    }

    //write environment variables if any
    list<string>::iterator str;

    for(str=m_notProcessed.begin(); str!=m_notProcessed.end(); ++str)
    {
        if(strcmp(str->substr(0, 3).c_str(), "EV_") == 0)
        {
            fileOutput << str->c_str() << endl;
        }
    }

    //Comments ----- Net
    list<CComment>::iterator cmt;

    for(cmt=m_listComments[0].begin(); cmt!=m_listComments[0].end(); ++cmt)
    {
        fileOutput << "CM_ " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    //Comments ----- Node
    for (cmt=m_listComments[1].begin(); cmt!=m_listComments[1].end(); ++cmt)
    {
        fileOutput << "CM_ BU_ " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    //Comments ----- Mesg
    for (cmt=m_listComments[2].begin(); cmt!=m_listComments[2].end(); ++cmt)
    {
        fileOutput << "CM_ BO_ " << dec << cmt->m_msgID;
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    //Comments ----- Signal
    for (cmt=m_listComments[3].begin(); cmt!=m_listComments[3].end(); ++cmt)
    {
        fileOutput << "CM_ SG_ " << dec << cmt->m_msgID;
        fileOutput << " " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str()<<endl;
    }

    //Param definition
    WriteParamToFile(fileOutput, m_listParameterArray[0]);
    WriteParamToFile(fileOutput, m_listParameterArray[1]);
    WriteParamToFile(fileOutput, m_listParameterArray[2]);
    WriteParamToFile(fileOutput, m_listParameterArray[3]);
    WriteParamToFile(fileOutput, m_listParameterArray[4]);
    WriteParamToFile(fileOutput, m_listParameterArray[5]);
    //Param Default values
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[0]);
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[1]);
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[2]);
    Write_DefVal_ToFile(fileOutput, m_listParameterArray[3]);
    //Param Other values
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameterArray[0].begin(); rParam!=m_listParameterArray[0].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[0].begin(); vParam!=rParam->m_listParamValues[0].end(); ++vParam)
        {
            vParam->WriteNetValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    for(rParam=m_listParameterArray[1].begin(); rParam!=m_listParameterArray[1].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[1].begin(); vParam!=rParam->m_listParamValues[1].end(); ++vParam)
        {
            vParam->WriteNodeValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    for(rParam=m_listParameterArray[2].begin(); rParam!=m_listParameterArray[2].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[2].begin(); vParam!=rParam->m_listParamValues[2].end(); ++vParam)
        {
            vParam->WriteMesgValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    for(rParam=m_listParameterArray[3].begin(); rParam!=m_listParameterArray[3].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[3].begin(); vParam!=rParam->m_listParamValues[3].end(); ++vParam)
        {
            list<CMessage>::iterator msg;

            for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
            {
                if(msg->m_uiMsgID == vParam->m_MsgId)
                {
                    list<CSignal>::iterator sig;

                    for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
                    {
                        if((sig->m_sName == vParam->m_SignalName) && (sig->m_uiError == CSignal::SIG_EC_NO_ERR))
                        {
                            vParam->WriteSigValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
                            break;
                        }
                    }
                }
            }
        }
    }

    fileOutput << endl;
    fileOutput << endl;

    //BA_
    for(str = m_notProcessed.begin(); str != m_notProcessed.end(); ++str)
    {
        if(strcmp(str->substr(0, 3).c_str(), "BA_") == 0)
        {
            fileOutput << str->c_str() << endl;
        }
    }

    //VAL_
    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            if(sig->m_listValueDescriptor.empty() == 0 && sig->m_uiError == CSignal::SIG_EC_NO_ERR)
            {
                fileOutput << " VAL_ " << dec << msg->m_uiMsgID;
                fileOutput << " " << sig->m_sName.c_str();
                fileOutput << " ";
                CValueDescriptor temp;
                temp.writeValueDescToFile(fileOutput, sig->m_ucType, sig->m_listValueDescriptor);
            }
        }
    }

    //write SIG_VALTYPE_
    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            if(sig->m_ucType == 'F')
            {
                fileOutput << "SIG_VALTYPE_ " << dec << msg->m_uiMsgID;
                fileOutput << " " << sig->m_sName.c_str();
                fileOutput << " : 1;" << endl;
            }
            else if(sig->m_ucType == 'D')
            {
                fileOutput << "SIG_VALTYPE_ " << dec << msg->m_uiMsgID;
                fileOutput << " " << sig->m_sName.c_str();
                fileOutput << " : 2;" << endl;
            }
        }
    }

    fileOutput << endl;
    return bResult;
}

/**
 * \brief     Create Log File
 * \param[in] fileLog Log file
 *
 * Logs the eror info in log file.
 */
void CConverter::CreateLogFile(fstream& fileLog)
{
    // write to the output file
    bool first_sig = true;
    fileLog << "Conversion Error Log" << endl;
    fileLog << endl;
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        first_sig = true;
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            // write signal only if it is not valid
            if(sig->m_uiError != CSignal::SIG_EC_NO_ERR)
            {
                string str;

                // for the first wrong signal, log the message details also
                if(first_sig == true)
                {
                    fileLog << endl;
                    fileLog << "MSG_ID: " << dec << msg->m_uiMsgID;
                    fileLog << " \tMSG_NAME: " << msg->m_sName.c_str() << endl;
                    first_sig = false;
                }

                sig->GetErrorString(str);
                fileLog << "\tSignal Discarded SIG_NAME: " << sig->m_sName.c_str();
                fileLog << ", Reason: " << str.c_str() << endl;
            }
        }
    }
}

/**
 * \brief     Create Node List
 * \param[in] pcLine Input line
 *
 * Creates a list of nodes in the network.
 */
void CConverter::create_Node_List(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    // get the MSG ID
    pcToken = strtok_s(pcLine, ",", &pcNextToken);

    while(pcToken)
    {
        string str = pcToken;
        m_listNode.push_back(str);
        pcToken = strtok_s(NULL, ",", &pcNextToken);
    }
}

/**
 * \brief     Decrypt Data
 * \param[in] m_notProcessed List of not processed strings
 *
 * Decrypts the not processed lines which are read from between
 * the tag START_NOT_PROCESSED and END_NOT_PROCESSED
 */
void CConverter::DecryptData(list<string> &m_notProcessed)
{
    list<string>::iterator str;

    for(str=m_notProcessed.begin(); str!=m_notProcessed.end(); ++str)
    {
        //read the string at the position
        string::iterator ch;

        for(ch=str->begin(); ch<str->end(); ++ch)
        {
            if ((*ch >= 'a' && *ch <= 'm') || (*ch >= 'A' && *ch <= 'M'))
            {
                *ch = *ch + 13;
            }
            else if ((*ch >= 'n' && *ch <= 'z') || (*ch >= 'N' && *ch <= 'Z'))
            {
                *ch = *ch - 13;
            }
        }
    }
}



























using namespace std;






CDBF2DBCConverter::CDBF2DBCConverter(void)
{
}






CDBF2DBCConverter::~CDBF2DBCConverter(void)
{
}









HRESULT CDBF2DBCConverter::GetPropertyPage(CPropertyPage*& pPage )
    {
        return ((HRESULT)1L);
    }
HRESULT CDBF2DBCConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "dbc";
    pchOutputFilters = "CANoe Database File(s) (*.dbc)|*.dbc||";
    return ((HRESULT)0L);
}

HRESULT CDBF2DBCConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the BUSMASTER Database(.dbf) file to CANoe Database(.dbc) file";
    return ((HRESULT)0L);
}








HRESULT CDBF2DBCConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "DBF TO DBC Conversion";
    return ((HRESULT)0L);
}









HRESULT CDBF2DBCConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case ((HRESULT)0L):
            m_omstrConversionStatus = "Conversion success";
            break;

        case ((HRESULT)1L):
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return ((HRESULT)0L);
}










HRESULT CDBF2DBCConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "dbf";
    pchInputFilters = "BUSMASTER Database File(s) (*.dbf)|*.dbf||";
    return ((HRESULT)0L);
}









HRESULT CDBF2DBCConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return ((HRESULT)0L);
}




















HRESULT CDBF2DBCConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = ((HRESULT)0L);
    CConverter ouConverter;
    INT nRetVal = ouConverter.Convert(chInputFile.c_str(), chOutputFile.c_str());
    ouConverter.GetResultString(m_omstrConversionStatus);

    if(nRetVal != 0)
    {
        m_omstrConversionStatus += ouConverter.m_omLogFilePath;
        m_hResult = nRetVal;
    }

    return hResult;
}







BOOL CDBF2DBCConverter::bHaveOwnWindow()
{
    return 0;
}
          ­      ­      «ÿÿÿÿ   «ÿÿÿÿ     6õ¸      expression was false       nRetVal != 0    ­ÿÿÿÿ   «      ­ÿÿÿÿ   «                  (k@         ¾      ¾      ¼ÿÿÿÿ   ¼ÿÿÿÿ     ø8       statement executed        return 0;    ¾ÿÿÿÿ   ¼      ¾ÿÿÿÿ   ¼                    ³      ³      ±ÿÿÿÿ   ±ÿÿÿÿ     øØ       statement executed        return hResult;    ³ÿÿÿÿ   ±      ³ÿÿÿÿ   ±                    ±      ±      ¯ÿÿÿÿ   ¯ÿÿÿÿ    &¬@       statement executed        }    ±ÿÿÿÿ   ¯      ±ÿÿÿÿ   ¯                                ÿÿÿÿ   ÿÿÿÿ     ø!(       statement executed        return ((HRESULT)0L);    ÿÿÿÿ         ÿÿÿÿ                                   ÿÿÿÿ   ÿÿÿÿ     û¬x       statement executed        return ((HRESULT)0L);    ÿÿÿÿ         ÿÿÿÿ                       q      q      oÿÿÿÿ   oÿÿÿÿ     è€       statement executed        return ((HRESULT)0L);    qÿÿÿÿ   o      qÿÿÿÿ   o                    n      n      lÿÿÿÿ   lÿÿÿÿ     x@       statement executed        break;    nÿÿÿÿ   l      nÿÿÿÿ   l                    j      j      hÿÿÿÿ   hÿÿÿÿ    fƒ       statement executed        break;    jÿÿÿÿ   h      jÿÿÿÿ   h              	      f      f      dÿÿÿÿ   dÿÿÿÿ    (h       statement executed        break;    fÿÿÿÿ   d      fÿÿÿÿ   d              
      U      U      Sÿÿÿÿ   Sÿÿÿÿ     ÷Ü°       statement executed        return ((HRESULT)0L);    Uÿÿÿÿ   S      Uÿÿÿÿ   S                    H      H      Fÿÿÿÿ   Fÿÿÿÿ     ôŠà       statement executed        return ((HRESULT)0L);    Hÿÿÿÿ   F      Hÿÿÿÿ   F                    B      B      @ÿÿÿÿ   @ÿÿÿÿ     4-p       statement executed        return ((HRESULT)0L);    Bÿÿÿÿ   @      Bÿÿÿÿ   @                    <   	   <      :ÿÿÿÿ   :ÿÿÿÿ     ô"Ø       statement executed        return ((HRESULT)1L);    <ÿÿÿÿ   :   	   <ÿÿÿÿ   :                    0      0      .ÿÿÿÿ   .ÿÿÿÿ    fs@       statement executed        }    0ÿÿÿÿ   .      0ÿÿÿÿ   .                    '      '      %ÿÿÿÿ   %ÿÿÿÿ     û‡0       statement executed        }    'ÿÿÿÿ   %      'ÿÿÿÿ   %           CDBF2DBCConverter::CDBF2DBCConverter CDBF2DBCConverter::CDBF2DBCConverter(void)    &      '      $ÿÿÿÿ   %ÿÿÿÿCDBF2DBCConverter::~CDBF2DBCConverter CDBF2DBCConverter::~CDBF2DBCConverter(void)    /      0      -ÿÿÿÿ   .ÿÿÿÿCDBF2DBCConverter::GetPropertyPage HRESULT CDBF2DBCConverter::GetPropertyPage(CPropertyPage*& pPage )    ;      =      9ÿÿÿÿ   ;ÿÿÿÿCDBF2DBCConverter::GetOutputFileFilters HRESULT CDBF2DBCConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)    ?      C      =ÿÿÿÿ   AÿÿÿÿCDBF2DBCConverter::GetHelpText HRESULT CDBF2DBCConverter::GetHelpText(string& pchHelpText)    F      I      Dÿÿÿÿ   GÿÿÿÿCDBF2DBCConverter::GetConverterName HRESULT CDBF2DBCConverter::GetConverterName(string& strConverterName)    S      V      Qÿÿÿÿ   TÿÿÿÿCDBF2DBCConverter::GetErrorStatus HRESULT CDBF2DBCConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)    a      r      _ÿÿÿÿ   pÿÿÿÿCDBF2DBCConverter::GetInputFileFilters HRESULT CDBF2DBCConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)    ~      ‚      |ÿÿÿÿ   €ÿÿÿÿCDBF2DBCConverter::GetLastConversionStatus HRESULT CDBF2DBCConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)          ‘      ‹ÿÿÿÿ   ÿÿÿÿCDBF2DBCConverter::ConvertFile HRESULT CDBF2DBCConverter::ConvertFile(string& chInputFile, string& chOutputFile)    §      ´      ¥ÿÿÿÿ   ²ÿÿÿÿCDBF2DBCConverter::bHaveOwnWindow BOOL CDBF2DBCConverter::bHaveOwnWindow()    ½      ¿      »ÿÿÿÿ   ½ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      DBF2DBCConverter.cpp
 * \brief     Implementation of the CDBF2DBCConverter class.
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the CDBF2DBCConverter class.
 */

/* Project includes */
#include "Converter.h"
#include "DBF2DBCConverter.h"
#include "Definitions.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CDBF2DBCConverter
 */
CDBF2DBCConverter::CDBF2DBCConverter(void)
{
}

/**
 * \brief Destructor
 *
 * Destructor of CDBF2DBCConverter
 */
CDBF2DBCConverter::~CDBF2DBCConverter(void)
{
}

/**
 * \brief      Get help text
 * \param[out] pchHelpText Help Text
 * \return     Result code
 *
 * Returns pchHelpText containing the help text.
 */

HRESULT CDBF2DBCConverter::GetPropertyPage(CPropertyPage*& pPage )
    {
        return S_FALSE;
    }
HRESULT CDBF2DBCConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "dbc";
    pchOutputFilters = "CANoe Database File(s) (*.dbc)|*.dbc||";
    return S_OK;
}

HRESULT CDBF2DBCConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the BUSMASTER Database(.dbf) file to CANoe Database(.dbc) file";
    return S_OK;
}

/**
 * \brief      Get converter name
 * \param[out] strConverterName Converter Name
 * \return     Result code
 *
 * Returns strConverterName containing the converter name.
 */
HRESULT CDBF2DBCConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "DBF TO DBC Conversion";
    return S_OK;
}

/**
 * \brief      Get error status string
 * \param[in]  hResult Error code
 * \param[out] omstrStatus Corresponding error string
 * \return     Result code
 *
 * Returns omstrStatus containing the error string depending on hResult.
 */
HRESULT CDBF2DBCConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case S_OK:
            m_omstrConversionStatus = "Conversion success";
            break;

        case S_FALSE:
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return S_OK;
}

/**
 * \brief      Get input file filter type and name
 * \param[out] pchInputDefFilters file filter types
 * \param[out] pchInputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CDBF2DBCConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "dbf";
    pchInputFilters = "BUSMASTER Database File(s) (*.dbf)|*.dbf||";
    return S_OK;
}

/**
 * \brief      Get last conversion status
 * \param[out] hResult Last conversion status.
 * \param[out] omstrStatus String describing the last conversion status.
 * \return     Result code
 *
 * Returns a string containing the last conversion status.
 */
HRESULT CDBF2DBCConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return S_OK;
}

/**
 * \brief      Get output file filter type and name
 * \param[out] pchOutputDefFilters file filter types
 * \param[out] pchOutputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */


/**
 * \brief     Conversion function
 * \param[in] chInputFile Input file name to convert from
 * \param[in] chOutputFile Output file name to convert to
 * \return    Result code
 *
 * This is the actual conversion function with input and output file name.
 */
HRESULT CDBF2DBCConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = S_OK;
    CConverter ouConverter;
    INT nRetVal = ouConverter.Convert(chInputFile.c_str(), chOutputFile.c_str());
    ouConverter.GetResultString(m_omstrConversionStatus);

    if(nRetVal != 0)
    {
        m_omstrConversionStatus += ouConverter.m_omLogFilePath;
        m_hResult = nRetVal;
    }

    return hResult;
}

/**
 * \brief     Returns if it has an own window
 * \return    True, if it has an own window.
 *
 * This returns true, if the converter has an own window, false otherwise.
 */
BOOL CDBF2DBCConverter::bHaveOwnWindow()
{
    return FALSE;
}






























using namespace std;











static AFX_EXTENSION_MODULE DBC2DBFConverterDLL = { 0, 0 };





extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
    (lpReserved);

    if (dwReason == 1)
    {
        ;

        
        if (!AfxInitExtensionModule(DBC2DBFConverterDLL, hInstance))
        {
            return 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        new CDynLinkLibrary(DBC2DBFConverterDLL);
    }
    else if (dwReason == 0)
    {
        ;
        
        AfxTermExtensionModule(DBC2DBFConverterDLL);
    }

    return 1;   
}





extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CDBF2DBCConverter();
    return ((HRESULT)0L);
}
          S      S      Nÿÿÿÿ   Nÿÿÿÿ     ôŠà      expression was false       dwReason == 0    Sÿÿÿÿ   N      Sÿÿÿÿ   N                   6ÿh         C      C      >ÿÿÿÿ   >ÿÿÿÿ    f€°       statement executed        return 0;    Cÿÿÿÿ   >      Cÿÿÿÿ   >                    R      R      Mÿÿÿÿ   Mÿÿÿÿ     4-p       statement executed        }    Rÿÿÿÿ   M      Rÿÿÿÿ   M                    X      X      Sÿÿÿÿ   Sÿÿÿÿ     ôe˜       statement executed        }    Xÿÿÿÿ   S      Xÿÿÿÿ   S                    Z      Z      Uÿÿÿÿ   Uÿÿÿÿ    &©¸       statement executed        return 1;    Zÿÿÿÿ   U      Zÿÿÿÿ   U                    d      d      _ÿÿÿÿ   _ÿÿÿÿ     ô"Ø       statement executed        return ((HRESULT)0L);    dÿÿÿÿ   _      dÿÿÿÿ   _                    A      A   D   <ÿÿÿÿ   <ÿÿÿÿ    fs@      expression was false       !AfxInitExtensionModule(DBC2DBFConverterDLL, hInstance)    Aÿÿÿÿ   <      Aÿÿÿÿ   <   D                ÷Ü°DllMain extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)    8      [      3ÿÿÿÿ   VÿÿÿÿGetBaseConverter extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)    b      e      ]ÿÿÿÿ   `ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      DBF2DBCConverterDLL.cpp
 * \brief     Defines the initialization routines for the DLL.
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines the initialization routines for the DLL.
 */

#define VC_EXTRALEAN        /* Exclude rarely-used stuff from Windows headers */

/* MFC includes */
#include <afxwin.h>         /* MFC core and standard components */
#include <afxdllx.h>        /* MFC dynamic link library extension */

/* Project includes */
#include "DBF2DBCConverter.h"
#include "Definitions.h"
#include "tag.h"

using namespace std;

#ifdef _MANAGED
#error Please read instructions in DBF2DBCConverter.cpp to compile with /clr
// If you want to add /clr to your project you must do the following:
//  1. Remove the above include for afxdllx.h
//  2. Add a .cpp file to your project that does not have /clr thrown and has
//     Precompiled headers disabled, with the following text:
//          #include <afxwin.h>
//          #include <afxdllx.h>
#endif

static AFX_EXTENSION_MODULE DBC2DBFConverterDLL = { NULL, NULL };

#ifdef _MANAGED
#pragma managed(push, off)
#endif

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("DBF2DBCConverter.DLL Initializing!\n");

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(DBC2DBFConverterDLL, hInstance))
        {
            return 0;
        }

        // Insert this DLL into the resource chain
        // NOTE: If this Extension DLL is being implicitly linked to by
        //  an MFC Regular DLL (such as an ActiveX Control)
        //  instead of an MFC application, then you will want to
        //  remove this line from DllMain and put it in a separate
        //  function exported from this Extension DLL.  The Regular DLL
        //  that uses this Extension DLL should then explicitly call that
        //  function to initialize this Extension DLL.  Otherwise,
        //  the CDynLinkLibrary object will not be attached to the
        //  Regular DLL's resource chain, and serious problems will
        //  result.
        new CDynLinkLibrary(DBC2DBFConverterDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("DBF2DBCConverter.DLL Terminating!\n");
        // Terminate the library before destructors are called
        AfxTermExtensionModule(DBC2DBFConverterDLL);
    }

    return 1;   // ok
}

#ifdef _MANAGED
#pragma managed(pop)
#endif

extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CDBF2DBCConverter();
    return S_OK;
}


























using namespace std;






CMessage::CMessage()
{
    m_sName = "";
    m_sTxNode = "";
    m_uiMsgID = 0;
    m_ucLength = 0;
    m_cFrameFormat = MSG_FF_STANDARD;
}






CMessage::~CMessage()
{
}








CMessage& CMessage::operator=(CMessage& message)
{
    
    m_sName = message.m_sName;
    m_sTxNode = message.m_sTxNode;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals = message.m_listSignals;
    return (*this);
}









int CMessage::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    
    pcToken = strtok_s(pcLine, ",", &pcNextToken);
    m_sName = pcToken;
    
    pcToken = strtok_s(0, " ,", &pcNextToken);
    m_uiMsgID = (unsigned int)atoi(pcToken);
    
    pcToken = strtok_s(0, " ,", &pcNextToken);
    m_ucLength = (unsigned int)atoi(pcToken);
    CConverter::ucMsg_DLC = m_ucLength;
    
    pcToken = strtok_s(0, " ,", &pcNextToken);
    
    pcToken = strtok_s(0, " ,", &pcNextToken);
    
    pcToken = strtok_s(0, " ,", &pcNextToken);
    m_cFrameFormat = pcToken[0];

    if(strcmp(pcToken,"X") == 0)
    {
        m_uiMsgID  = m_uiMsgID - 2147483648;
    }

    
    pcToken = strtok_s(0, "\n", &pcNextToken);

    if(pcToken)
    {
        m_sTxNode = pcToken;
    }
    else
    {
        m_sTxNode = "Vector__XXX";
    }

    return 1;
}








int CMessage::operator==(const CMessage& message) const
{
    if (message.m_uiMsgID == m_uiMsgID)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}








int CMessage::operator==(const unsigned int uiMsgID) const
{
    if (uiMsgID == m_uiMsgID)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}









bool CMessage::writeMessageToFile( fstream& fileOutput)
{
    bool bResult = true;
    fileOutput << "BO_ " << dec << m_uiMsgID;
    fileOutput << " " << m_sName.c_str();
    fileOutput << ": " << dec << m_ucLength;
    fileOutput << " " << m_sTxNode.c_str() << endl;
    list<CSignal>::iterator sig;

    for(sig=m_listSignals.begin(); sig!=m_listSignals.end(); ++sig)
    {
        bResult &= sig->WriteSignaltofile(fileOutput);
    }

    fileOutput << endl;
    return bResult;
}
          ²   $   ²   <   ±ÿÿÿÿ   ±ÿÿÿÿ    &®0      expression was false       sig!=m_listSignals.end()    ²ÿÿÿÿ   ±   $   ²ÿÿÿÿ   ±   <                4$¨         g      g       fÿÿÿÿ   fÿÿÿÿ    fƒ      expression was false       strcmp(pcToken,"X") == 0    gÿÿÿÿ   f      gÿÿÿÿ   f                    ÷şp         ¸      ¸      ·ÿÿÿÿ   ·ÿÿÿÿ     ô"Ø       statement executed        return bResult;    ¸ÿÿÿÿ   ·      ¸ÿÿÿÿ   ·                    µ      µ      ´ÿÿÿÿ   ´ÿÿÿÿ    (h       statement executed        }    µÿÿÿÿ   ´      µÿÿÿÿ   ´                       	         œÿÿÿÿ   œÿÿÿÿ    &©¸       statement executed        return 0;    ÿÿÿÿ   œ   	   ÿÿÿÿ   œ                    ™   	   ™      ˜ÿÿÿÿ   ˜ÿÿÿÿ     6ç        statement executed        return 1;    ™ÿÿÿÿ   ˜   	   ™ÿÿÿÿ   ˜                    Š   	   Š      ‰ÿÿÿÿ   ‰ÿÿÿÿ    &¦P       statement executed        return 0;    Šÿÿÿÿ   ‰   	   Šÿÿÿÿ   ‰                    †   	   †      …ÿÿÿÿ   …ÿÿÿÿ     ôŠà       statement executed        return 1;    †ÿÿÿÿ   …   	   †ÿÿÿÿ   …                    x      x      wÿÿÿÿ   wÿÿÿÿ     ôe˜       statement executed        return 1;    xÿÿÿÿ   w      xÿÿÿÿ   w              	      v      v      uÿÿÿÿ   uÿÿÿÿ     6ÿh       statement executed        }    vÿÿÿÿ   u      vÿÿÿÿ   u              
      r      r      qÿÿÿÿ   qÿÿÿÿ     4-p       statement executed        }    rÿÿÿÿ   q      rÿÿÿÿ   q                    j      j      iÿÿÿÿ   iÿÿÿÿ    fs@       statement executed        }    jÿÿÿÿ   i      jÿÿÿÿ   i                    F      F      Eÿÿÿÿ   Eÿÿÿÿ    f€°       statement executed        return (*this);    Fÿÿÿÿ   E      Fÿÿÿÿ   E                    4      4      3ÿÿÿÿ   3ÿÿÿÿ     ÷Ü°       statement executed        }    4ÿÿÿÿ   3      4ÿÿÿÿ   3                    +      +      *ÿÿÿÿ   *ÿÿÿÿ     ÷ÙX       statement executed        }    +ÿÿÿÿ   *      +ÿÿÿÿ   *           CMessage::CMessage CMessage::CMessage()    %      +      $ÿÿÿÿ   *ÿÿÿÿCMessage::~CMessage CMessage::~CMessage()    3      4      2ÿÿÿÿ   3ÿÿÿÿCMessage::operator= CMessage& CMessage::operator=(CMessage& message)    >      G      =ÿÿÿÿ   FÿÿÿÿCMessage::Format int CMessage::Format(char* pcLine)    R      y      Qÿÿÿÿ   xÿÿÿÿCMessage::operator== int CMessage::operator==(const CMessage& message)    ƒ      Œ      ‚ÿÿÿÿ   ‹ÿÿÿÿCMessage::operator== int CMessage::operator==(const unsigned int uiMsgID)    –      Ÿ      •ÿÿÿÿ   ÿÿÿÿCMessage::writeMessageToFile bool CMessage::writeMessageToFile( fstream& fileOutput)    ª      ¹      ©ÿÿÿÿ   ¸ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Message.cpp
 * \brief     Implementation of the CMessage class.
 * \authors   Mahesh.B.S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the CMessage class.
 */

/* Project includes */
#include "Converter.h"
#include "Message.h"

using namespace std;

/**
 * \brief Constructor
 *
 * constructor of CMessage
 */
CMessage::CMessage()
{
    m_sName = "";
    m_sTxNode = "";
    m_uiMsgID = 0;
    m_ucLength = 0;
    m_cFrameFormat = MSG_FF_STANDARD;
}

/**
 * \brief Destructor
 *
 * destructor of CMessage
 */
CMessage::~CMessage()
{
}

/**
 * \brief     operator= overloading
 * \param[in] message Message to copy content from
 * \return    Local object with new content
 *
 * Copy the other elements of the new message to this
 */
CMessage& CMessage::operator=(CMessage& message)
{
    // now copy the other elements of the new message to this
    m_sName = message.m_sName;
    m_sTxNode = message.m_sTxNode;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals = message.m_listSignals;
    return (*this);
}

/**
 * \brief     Extracts the message data from the given Line
 * \param[in] pcLine The given line
 * \return    Status code
 *
 * Extracts the message data from the given Line and populates
 * the message structure.
 */
int CMessage::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    // get the MSG Name
    pcToken = strtok_s(pcLine, ",", &pcNextToken);
    m_sName = pcToken;
    // get the MSG ID
    pcToken = strtok_s(NULL, " ,", &pcNextToken);
    m_uiMsgID = (unsigned int)atoi(pcToken);
    // set the message length
    pcToken = strtok_s(NULL, " ,", &pcNextToken);
    m_ucLength = (unsigned int)atoi(pcToken);
    CConverter::ucMsg_DLC = m_ucLength;
    //no.. of signals.
    pcToken = strtok_s(NULL, " ,", &pcNextToken);
    //data format.
    pcToken = strtok_s(NULL, " ,", &pcNextToken);
    //frame format.
    pcToken = strtok_s(NULL, " ,", &pcNextToken);
    m_cFrameFormat = pcToken[0];

    if(strcmp(pcToken,"X") == 0)
    {
        m_uiMsgID  = m_uiMsgID - 2147483648;
    }

    //get the Tx'ing Node Name
    pcToken = strtok_s(NULL, "\n", &pcNextToken);

    if(pcToken)
    {
        m_sTxNode = pcToken;
    }
    else
    {
        m_sTxNode = "Vector__XXX";
    }

    return 1;
}

/**
 * \brief     Overloading of == operator
 * \param[in] message Reference message to compare with
 * \return    1 if identical, 0 if not.
 *
 * Compares message with local object.
 */
int CMessage::operator==(const CMessage& message) const
{
    if (message.m_uiMsgID == m_uiMsgID)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/**
 * \brief     Overloading of == operator
 * \param[in] uiMsgID Reference message ID to compare with
 * \return    1 if identical, 0 if not.
 *
 * Compares message ID with local object.
 */
int CMessage::operator==(const unsigned int uiMsgID) const
{
    if (uiMsgID == m_uiMsgID)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/**
 * \brief     Writes the message in the CANoe format
 * \param[in] fileOutput Output file
 * \return    Status code
 *
 * Writes the message in the CANoe format and returns false
 * if any of the error signal is not stored in the file
 */
bool CMessage::writeMessageToFile( fstream& fileOutput)
{
    bool bResult = true;
    fileOutput << "BO_ " << dec << m_uiMsgID;
    fileOutput << " " << m_sName.c_str();
    fileOutput << ": " << dec << m_ucLength;
    fileOutput << " " << m_sTxNode.c_str() << endl;
    list<CSignal>::iterator sig;

    for(sig=m_listSignals.begin(); sig!=m_listSignals.end(); ++sig)
    {
        bResult &= sig->WriteSignaltofile(fileOutput);
    }

    fileOutput << endl;
    return bResult;
}


































using namespace std;






CParameter::CParameter()
{
    m_MaxVal.iValue = -1;
    m_MaxVal.uiValue = 0;
    m_MaxVal.fValue = -1;
    m_MaxVal.dValue = -1;
    m_MaxVal.cValue = "";
    m_MaxVal.i64Value = -1;
    m_MaxVal.ui64Value = 0;
    m_MinVal.iValue = -1;
    m_MinVal.uiValue = 0;
    m_MinVal.fValue = -1;
    m_MinVal.dValue = -1;
    m_MinVal.cValue = "";
    m_MinVal.i64Value = -1;
    m_MinVal.ui64Value = 0;
    m_InitVal.iValue = -1;
    m_InitVal.uiValue = 0;
    m_InitVal.fValue = -1;
    m_InitVal.dValue = -1;
    m_InitVal.cValue = "";
    m_InitVal.i64Value = -1;
    m_InitVal.ui64Value = 0;
    m_ValRange = "";
    m_ParamType = "";
    m_ParamName = "";
    m_RangeError = false;
}




CParameter::~CParameter()
{
    
}








CParameter& CParameter::operator=( CParameter& param)
{
    
    m_ObjectId = param.m_ObjectId;
    m_ParamName = param.m_ParamName;
    m_ValRange=param.m_ValRange;
    m_ParamType=param.m_ParamType;
    m_InitVal=param.m_InitVal;
    m_MaxVal=param.m_MaxVal;
    m_MinVal=param.m_MinVal;
    m_RangeError=param.m_RangeError;

    for(int i=0; i<4; i++)
    {
        m_listParamValues[i] = param.m_listParamValues[i];
    }

    return (*this);
}








bool WriteParamToFile(fstream& fileOutput, list<CParameter> &m_listParameter)
{
    bool pResult=true;
    
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameter.begin(); rParam!=m_listParameter.end(); ++rParam)
    {
        if(rParam->m_RangeError)
        {
            pResult=false;
        }

        
        fileOutput << "BA_DEF_ " << rParam->m_ObjectId;
        fileOutput << "  \"" << rParam->m_ParamName << "\"";
        fileOutput << " " << rParam->m_ParamType;

        if(rParam->m_ParamType == "INT")
        {
            fileOutput << " " << dec << rParam->m_MinVal.iValue;
            fileOutput << " " << dec << rParam->m_MaxVal.iValue;
        }
        else if(rParam->m_ParamType == "HEX")
        {
            fileOutput << " " << dec << rParam->m_MinVal.uiValue;
            fileOutput << " " << dec << rParam->m_MaxVal.uiValue;
        }
        else if(rParam->m_ParamType == "FLOAT")
        {
            fileOutput << " " << rParam->m_MinVal.fValue;
            fileOutput << " " << rParam->m_MaxVal.fValue;
        }
        else if(rParam->m_ParamType == "ENUM")
        {
            fileOutput << rParam->m_ValRange;
        }
        else
        {
            fileOutput << " ";
        }

        fileOutput << ";" << endl;
    }

    return pResult;
}








void CParameter::Format_MesgParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[1026];
    char* pcToken;
    char* pcLine;
    char* pcNextToken;
    char acTemp[1024],*pcTemp;
    pcTemp = acTemp;

    
    while(fileInput.getline(acLine,1026) && strcmp(acLine,"[END_PARAM_MSG_VAL]")!=0)
    {
        char type[1024];
        pcLine = acLine;
        
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        UINT msgId=unsigned int(strtoul(pcToken, 0, 10));
        pcLine=pcLine+strlen(pcToken)+1;
        
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(type, pcToken, sizeof(type));

        if(strcmp(type,"X")==0)
        {
            msgId=msgId-2147483648;
        }

        pcLine=pcLine+strlen(pcToken)+1;
        
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        pcLine=pcLine+strlen(pcToken)+1;
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
            
        {
            
            if(strcmp(rParam->m_ParamName.c_str(), acTemp)==0 )
            {
                pVal.Format_Param_Value(rParam->m_ParamType, pcLine, 2, msgId);
                rParam->m_listParamValues[2].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}








void CParameter::Format_SigParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[1026];
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acTemp[1024],*pcTemp;
    pcTemp = acTemp;

    
    while(fileInput.getline(acLine,1026) && strcmp(acLine, "[END_PARAM_SIG_VAL]")!=0)
    {
        char temp[1024],sname[1024];
        pcLine = acLine;
        
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        UINT msgId=unsigned int(strtoul(pcToken, 0, 10));
        pcLine=pcLine+strlen(pcToken)+1;
        
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(temp, pcToken, sizeof(temp));

        if(strcmp(temp,"X")==0)
        {
            msgId=msgId-2147483648;
        }

        pcLine=pcLine+strlen(pcToken)+1;
        
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(sname, pcToken, sizeof(sname));
        pcLine=pcLine+strlen(pcToken)+1;
        
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        pcLine=pcLine+strlen(pcToken)+1;
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
        {
            
            if(strcmp(rParam->m_ParamName.c_str(),acTemp)==0 )
            {
                pVal.Format_Param_Value(rParam->m_ParamType, pcLine, 3, msgId, sname);
                rParam->m_listParamValues[3].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}








void CParameter::Format_NodeParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[1026];
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acTemp[1024],*pcTemp;
    pcTemp = acTemp;

    
    while(fileInput.getline(acLine,1026) && strcmp(acLine, "[END_PARAM_NODE_VAL]")!=0)
    {
        char NodeName[1024];
        pcLine = acLine;
        
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(NodeName, pcToken, sizeof(NodeName));
        pcLine=pcLine+strlen(pcToken)+1;
        
        pcToken = strtok_s(0, ",", &pcNextToken);
        pcLine=pcLine+strlen(pcToken)+1;
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
        {
            
            if(strcmp(rParam->m_ParamName.c_str(), acTemp)==0)
            {
                pVal.Format_Param_Value(rParam->m_ParamType, pcLine, 1, 0, NodeName);
                rParam->m_listParamValues[1].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}








void CParameter::Format_NetParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[1026];
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acTemp[1024],*pcTemp;
    pcTemp = acTemp;

    
    while(fileInput.getline(acLine, 1026) && strcmp(acLine, "[END_PARAM_NET_VAL]")!=0)
    {
        pcLine = acLine;
        
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
        {
            
            if(strcmp(rParam->m_ParamName.c_str(),acTemp)==0 )
            {
                pVal.Format_Param_Value(rParam->m_ParamType, (pcLine+strlen(acTemp)+3), 0);
                rParam->m_listParamValues[0].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}









void CParameter::Format_ParamDef(char* pcLine, int index)
{
    
    switch(index)
    {
        case 0:
            m_ObjectId = "";
            break;

        case 1:
            m_ObjectId = "BU_";
            break;

        case 2:
            m_ObjectId = "BO_";
            break;

        case 3:
            m_ObjectId = "SG_";
            break;

        case 4:
            m_ObjectId = "BU_SG_REL_";
            break;

        case 5:
            m_ObjectId = "BU_BO_REL_";
            break;
    }

    
    GetParam_Def(pcLine);
}







void CParameter::GetParam_Def(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    
    pcToken = strtok_s(pcLine, "\"", &pcNextToken);
    m_ParamName = pcToken;
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_ParamType = pcToken;

    if(m_ParamType == "STRING")
    {
        pcToken = strtok_s(0, "\n", &pcNextToken);
    }
    else
    {
        pcToken = strtok_s(0, ",", &pcNextToken);
    }

    
    ReadDefault_Value(pcToken);

    if(m_ParamType == "ENUM")
    {
        m_ValRange="";

        while(pcToken = strtok_s(0, "\n", &pcNextToken))
        {
            m_ValRange=m_ValRange+" "+pcToken;
        }
    }
    
    else if(m_ParamType == "HEX")
    {
        unsigned int min_val,max_val;
        pcToken = strtok_s(0, ",", &pcNextToken);
        min_val=strtoul(pcToken, 0, 10);
        pcToken = strtok_s(0, " ", &pcNextToken);
        max_val= strtoul(pcToken, 0, 10);
        m_RangeError |= isValid_hexRange(min_val,max_val);
    }
    
    else if(m_ParamType == "FLOAT")
    {
        double min_val,max_val;
        pcToken = strtok_s(0, ",", &pcNextToken);
        min_val= atof(pcToken);
        pcToken = strtok_s(0, " ", &pcNextToken);
        max_val=atof(pcToken);
        m_RangeError |= isValid_floatRange(min_val,max_val);
    }
    
    else if(m_ParamType == "INT")
    {
        LONGLONG min_val,max_val;
        pcToken = strtok_s(0, ",", &pcNextToken);
        min_val=_atoi64(pcToken);
        pcToken = strtok_s(0, " ", &pcNextToken);
        max_val=_atoi64(pcToken);
        m_RangeError |= isValid_intRange(min_val,max_val);
    }

    
    m_RangeError |= Check_Default_Value();
}







void CParameter::ReadDefault_Value(char* pcToken)
{
    char acTemp[1024],*pcTemp;
    pcTemp = acTemp;

    
    if(m_ParamType == "ENUM")
    {
        
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        pcToken++;

        while(*pcToken && *pcToken != '"')
        {
            *pcTemp++ = *pcToken++;
        }

        *pcTemp = '\0';
        
        m_InitVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    
    else if(m_ParamType == "INT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.iValue =atoi(pcToken);
        }
    }
    
    else if(m_ParamType == "HEX")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.uiValue =strtoul(pcToken, 0, 10);
        }
        else
        {
            m_InitVal.uiValue =-1;
        }
    }
    
    else if(m_ParamType == "FLOAT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.fValue=float(atof(pcToken));
        }
    }
    
    else if(m_ParamType == "STRING")
    {
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        while(*pcToken && *pcToken!='\n')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        m_InitVal.cValue = acTemp;
        pcTemp=acTemp;
    }
}










bool Write_DefVal_ToFile(fstream& fileOutput,list<CParameter> &m_listParameter)
{
    bool pResult=true;
    
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameter.begin(); rParam!=m_listParameter.end(); ++rParam)
    {
        
        if(rParam->m_RangeError)
        {
            pResult=false;
        }

        
        fileOutput << "BA_DEF_DEF_";
        fileOutput << "  \"" << rParam->m_ParamName << "\"";

        if(rParam->m_ParamType == "INT")
        {
            fileOutput << " " << dec << rParam->m_InitVal.iValue;
        }
        
        else if(rParam->m_ParamType == "HEX")
        {
            fileOutput << " " << dec << rParam->m_InitVal.uiValue;
        }
        
        else if(rParam->m_ParamType == "FLOAT")
        {
            fileOutput << " " << rParam->m_InitVal.fValue;
        }
        
        else if(rParam->m_ParamType == "ENUM")
        {
            fileOutput << " \"" << rParam->m_InitVal.cValue << "\"";
        }
        
        else
        {
            fileOutput << " " << rParam->m_InitVal.cValue;
        }

        fileOutput << ";" << endl;
    }

    return pResult;
}







bool CParameter::Check_Default_Value(void)
{
    bool cResult=false;

    
    if(m_ParamType == "INT")
    {
        if(m_InitVal.iValue<m_MinVal.iValue || m_InitVal.iValue>m_MaxVal.iValue)
        {
            m_InitVal.iValue=m_MinVal.iValue;
            cResult=true;
        }
    }
    
    else if(m_ParamType == "HEX")
    {
        if(m_InitVal.uiValue<m_MinVal.uiValue || m_InitVal.uiValue>m_MaxVal.uiValue)
        {
            m_InitVal.uiValue=m_MinVal.uiValue;
            cResult= true;
        }
    }
    
    else if(m_ParamType == "FLOAT")
    {
        if(m_InitVal.fValue<m_MinVal.fValue || m_InitVal.fValue>m_MaxVal.fValue)
        {
            m_InitVal.fValue=m_MinVal.fValue;
            cResult=true;
        }
    }

    return cResult;
}









bool CParameter::isValid_intRange(long long int minValue, long long int maxValue)
{
    bool rResult=false;

    
    if(minValue < (-2147483647 - 1) )
    {
        m_MinVal.iValue=(-2147483647 - 1);
        rResult=rResult|true;
    }
    else
    {
        m_MinVal.iValue =int(minValue);
    }

    
    if(maxValue>2147483647 || maxValue<m_MinVal.iValue)
    {
        m_MaxVal.iValue=2147483647;
        rResult=rResult | true;
    }
    else
    {
        m_MaxVal.iValue=int(maxValue);
    }

    return rResult;
}









bool CParameter::isValid_floatRange(double minValue,double maxValue)
{
    bool rResult=false;

    
    if(minValue<1.175494351e-38F)
    {
        m_MinVal.fValue=1.175494351e-38F;
        rResult=rResult | true;
    }
    else
    {
        m_MinVal.fValue= float(minValue);
    }

    
    if(maxValue>3.402823466e+38F || maxValue<m_MinVal.fValue)
    {
        m_MaxVal.fValue=3.402823466e+38F;
        rResult=rResult | true;
    }
    else
    {
        m_MaxVal.fValue =float(maxValue);
    }

    return rResult;
}









bool CParameter::isValid_hexRange(unsigned int minValue, unsigned int maxValue)
{
    bool rResult=false;
    
    m_MinVal.uiValue=minValue;

    
    if(maxValue==0 || maxValue <m_MinVal.uiValue)
    {
        m_MaxVal.uiValue=0xffffffff;
        rResult=true;
    }
    else
    {
        m_MaxVal.uiValue=maxValue;
    }

    return rResult;
}
                 *  ÿÿÿÿ  ÿÿÿÿ     û„À      expression was true       *pcToken == ' '   ÿÿÿÿ       ÿÿÿÿ     *   expression was false       *pcToken == ' '   ÿÿÿÿ       ÿÿÿÿ     *                ûƒ                  ÿÿÿÿ  ÿÿÿÿ     ûƒè      expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                             (  tÿÿÿÿ  tÿÿÿÿ     ç˜      expression was true       *pcToken!='"'   ÿÿÿÿ  t     ÿÿÿÿ  t   (   expression was false       *pcToken!='"'   ÿÿÿÿ  t     ÿÿÿÿ  t   (                åè                  tÿÿÿÿ  tÿÿÿÿ     æÀ      expression was true       *pcToken   ÿÿÿÿ  t     ÿÿÿÿ  t      expression was false       *pcToken   ÿÿÿÿ  t     ÿÿÿÿ  t                   x   .  x   V  mÿÿÿÿ  mÿÿÿÿ     á       expression was true       strcmp(acLine, "[END_PARAM_NET_VAL]")!=0   xÿÿÿÿ  m   .  xÿÿÿÿ  m   V   expression was false       strcmp(acLine, "[END_PARAM_NET_VAL]")!=0   xÿÿÿÿ  m   .  xÿÿÿÿ  m   V                ßp   
     x     x   *  mÿÿÿÿ  mÿÿÿÿ     àH      expression was true       fileInput.getline(acLine, 1026)   xÿÿÿÿ  m     xÿÿÿÿ  m   *   expression was false       fileInput.getline(acLine, 1026)   xÿÿÿÿ  m     xÿÿÿÿ  m   *                O     O   (  Dÿÿÿÿ  Dÿÿÿÿ     wX      expression was true       *pcToken!='"'   Oÿÿÿÿ  D     Oÿÿÿÿ  D   (   expression was false       *pcToken!='"'   Oÿÿÿÿ  D     Oÿÿÿÿ  D   (                u¨        O     O     Dÿÿÿÿ  Dÿÿÿÿ     v€      expression was true       *pcToken   Oÿÿÿÿ  D     Oÿÿÿÿ  D      expression was false       *pcToken   Oÿÿÿÿ  D     Oÿÿÿÿ  D                   B   -  B   V  7ÿÿÿÿ  7ÿÿÿÿ     gà      expression was true       strcmp(acLine, "[END_PARAM_NODE_VAL]")!=0   Bÿÿÿÿ  7   -  Bÿÿÿÿ  7   V   expression was false       strcmp(acLine, "[END_PARAM_NODE_VAL]")!=0   Bÿÿÿÿ  7   -  Bÿÿÿÿ  7   V                f0        B     B   )  7ÿÿÿÿ  7ÿÿÿÿ     g      expression was true       fileInput.getline(acLine,1026)   Bÿÿÿÿ  7     Bÿÿÿÿ  7   )   expression was false       fileInput.getline(acLine,1026)   Bÿÿÿÿ  7     Bÿÿÿÿ  7   )                        (  ÿÿÿÿ  ÿÿÿÿ    =¸x      expression was true       *pcToken!='"'   ÿÿÿÿ       ÿÿÿÿ     (   expression was false       *pcToken!='"'   ÿÿÿÿ       ÿÿÿÿ     (               =¶È                  ÿÿÿÿ  ÿÿÿÿ    =·       expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                      ş   -   ş   U   óÿÿÿÿ   óÿÿÿÿ     ôhH      expression was true       strcmp(acLine, "[END_PARAM_SIG_VAL]")!=0    şÿÿÿÿ   ó   -   şÿÿÿÿ   ó   U   expression was false       strcmp(acLine, "[END_PARAM_SIG_VAL]")!=0    şÿÿÿÿ   ó   -   şÿÿÿÿ   ó   U                ôi          ş      ş   )   óÿÿÿÿ   óÿÿÿÿ     ômˆ      expression was true       fileInput.getline(acLine,1026)    şÿÿÿÿ   ó      şÿÿÿÿ   ó   )   expression was false       fileInput.getline(acLine,1026)    şÿÿÿÿ   ó      şÿÿÿÿ   ó   )                 Õ      Õ   (   Êÿÿÿÿ   Êÿÿÿÿ     4ø      expression was true       *pcToken!='"'    Õÿÿÿÿ   Ê      Õÿÿÿÿ   Ê   (   expression was false       *pcToken!='"'    Õÿÿÿÿ   Ê      Õÿÿÿÿ   Ê   (                6é         Õ      Õ      Êÿÿÿÿ   Êÿÿÿÿ     4ğ      expression was true       *pcToken    Õÿÿÿÿ   Ê      Õÿÿÿÿ   Ê      expression was false       *pcToken    Õÿÿÿÿ   Ê      Õÿÿÿÿ   Ê                     ¾   -   ¾   T   ³ÿÿÿÿ   ³ÿÿÿÿ     6ô€      expression was true       strcmp(acLine,"[END_PARAM_MSG_VAL]")!=0    ¾ÿÿÿÿ   ³   -   ¾ÿÿÿÿ   ³   T   expression was false       strcmp(acLine,"[END_PARAM_MSG_VAL]")!=0    ¾ÿÿÿÿ   ³   -   ¾ÿÿÿÿ   ³   T                6í   "      ¾      ¾   )   ³ÿÿÿÿ   ³ÿÿÿÿ     6ñĞ      expression was true       fileInput.getline(acLine,1026)    ¾ÿÿÿÿ   ³      ¾ÿÿÿÿ   ³   )   expression was false       fileInput.getline(acLine,1026)    ¾ÿÿÿÿ   ³      ¾ÿÿÿÿ   ³   )           $     g   )  g   F  \ÿÿÿÿ  \ÿÿÿÿ     ÷ì€      expression was false       rParam!=m_listParameter.end()   gÿÿÿÿ  \   )  gÿÿÿÿ  \   F                ÷ÓÈ   %     ˆ   )  ˆ   B  }ÿÿÿÿ  }ÿÿÿÿ     öh      expression was false       rParam!=m_listParam.end()   ˆÿÿÿÿ  }   )  ˆÿÿÿÿ  }   B                îğ   &     X   )  X   B  Mÿÿÿÿ  Mÿÿÿÿ     Ö(      expression was false       rParam!=m_listParam.end()   Xÿÿÿÿ  M   )  Xÿÿÿÿ  M   B                ~°   '     "   )  "   B  ÿÿÿÿ  ÿÿÿÿ     \è      expression was false       rParam!=m_listParam.end()   "ÿÿÿÿ     )  "ÿÿÿÿ     B               =¿Ğ   (      İ   )   İ   B   Òÿÿÿÿ   Òÿÿÿÿ     ô+ø      expression was false       rParam!=m_listParam.end()    İÿÿÿÿ   Ò   )   İÿÿÿÿ   Ò   B                ô$¸   )      ‚   )   ‚   F   wÿÿÿÿ   wÿÿÿÿ     â›@      expression was false       rParam!=m_listParameter.end()    ‚ÿÿÿÿ   w   )   ‚ÿÿÿÿ   w   F                4   *      m      m      bÿÿÿÿ   bÿÿÿÿ     ô       expression was false       i<4    mÿÿÿÿ   b      mÿÿÿÿ   b              +               ÿÿÿÿ  ÿÿÿÿ     û‰À      expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                -             *  ÿÿÿÿ  ÿÿÿÿ     ûŠ˜      expression was true       *pcToken != '"'   ÿÿÿÿ       ÿÿÿÿ     *   expression was false       *pcToken != '"'   ÿÿÿÿ       ÿÿÿÿ     *                ûˆè   /     H     H     =ÿÿÿÿ  =ÿÿÿÿ     ûª¸      expression was true       *pcToken   Hÿÿÿÿ  =     Hÿÿÿÿ  =      expression was false       *pcToken   Hÿÿÿÿ  =     Hÿÿÿÿ  =              1     H     H   *  =ÿÿÿÿ  =ÿÿÿÿ     û«      expression was true       *pcToken == ' '   Hÿÿÿÿ  =     Hÿÿÿÿ  =   *   expression was false       *pcToken == ' '   Hÿÿÿÿ  =     Hÿÿÿÿ  =   *                û©à   3     á     á   8  Öÿÿÿÿ  Öÿÿÿÿ     í‘x      expression was false       pcToken = strtok_s(0, "\n", &pcNextToken)   áÿÿÿÿ  Ö     áÿÿÿÿ  Ö   8           4     M     M     Bÿÿÿÿ  Bÿÿÿÿ     û°P      expression was true       *pcToken   Mÿÿÿÿ  B     Mÿÿÿÿ  B      expression was false       *pcToken   Mÿÿÿÿ  B     Mÿÿÿÿ  B              6     M     M   )  Bÿÿÿÿ  Bÿÿÿÿ     û±(      expression was true       *pcToken!='\n'   Mÿÿÿÿ  B     Mÿÿÿÿ  B   )   expression was false       *pcToken!='\n'   Mÿÿÿÿ  B     Mÿÿÿÿ  B   )                û¯x   8     Ÿ     Ÿ   ,  ”ÿÿÿÿ  ”ÿÿÿÿ     ÷òà      expression was true       m_InitVal.iValue<m_MinVal.iValue   Ÿÿÿÿÿ  ”     Ÿÿÿÿÿ  ”   ,   expression was false       m_InitVal.iValue<m_MinVal.iValue   Ÿÿÿÿÿ  ”     Ÿÿÿÿÿ  ”   ,           :     Ÿ   0  Ÿ   P  ”ÿÿÿÿ  ”ÿÿÿÿ     ÷ó¸      expression was true       m_InitVal.iValue>m_MaxVal.iValue   Ÿÿÿÿÿ  ”   0  Ÿÿÿÿÿ  ”   P   expression was false       m_InitVal.iValue>m_MaxVal.iValue   Ÿÿÿÿÿ  ”   0  Ÿÿÿÿÿ  ”   P           <     ¨     ¨   .  ÿÿÿÿ  ÿÿÿÿ     ÷üÀ      expression was true       m_InitVal.uiValue<m_MinVal.uiValue   ¨ÿÿÿÿ       ¨ÿÿÿÿ     .   expression was false       m_InitVal.uiValue<m_MinVal.uiValue   ¨ÿÿÿÿ       ¨ÿÿÿÿ     .           >     ¨   2  ¨   T  ÿÿÿÿ  ÿÿÿÿ     ÷ı˜      expression was true       m_InitVal.uiValue>m_MaxVal.uiValue   ¨ÿÿÿÿ     2  ¨ÿÿÿÿ     T   expression was false       m_InitVal.uiValue>m_MaxVal.uiValue   ¨ÿÿÿÿ     2  ¨ÿÿÿÿ     T           @     ±     ±   ,  ¦ÿÿÿÿ  ¦ÿÿÿÿ     ø       expression was true       m_InitVal.fValue<m_MinVal.fValue   ±ÿÿÿÿ  ¦     ±ÿÿÿÿ  ¦   ,   expression was false       m_InitVal.fValue<m_MinVal.fValue   ±ÿÿÿÿ  ¦     ±ÿÿÿÿ  ¦   ,           B     ±   0  ±   P  ¦ÿÿÿÿ  ¦ÿÿÿÿ     øx      expression was true       m_InitVal.fValue>m_MaxVal.fValue   ±ÿÿÿÿ  ¦   0  ±ÿÿÿÿ  ¦   P   expression was false       m_InitVal.fValue>m_MaxVal.fValue   ±ÿÿÿÿ  ¦   0  ±ÿÿÿÿ  ¦   P           D     Ó     Ó     Èÿÿÿÿ  Èÿÿÿÿ     øx      expression was true       maxValue>2147483647   Óÿÿÿÿ  È     Óÿÿÿÿ  È      expression was false       maxValue>2147483647   Óÿÿÿÿ  È     Óÿÿÿÿ  È              F     Ó     Ó   7  Èÿÿÿÿ  Èÿÿÿÿ     ø P      expression was true       maxValue<m_MinVal.iValue   Óÿÿÿÿ  È     Óÿÿÿÿ  È   7   expression was false       maxValue<m_MinVal.iValue   Óÿÿÿÿ  È     Óÿÿÿÿ  È   7           H     ø     ø   !  íÿÿÿÿ  íÿÿÿÿ    fq      expression was true       maxValue>3.402823466e+38F   øÿÿÿÿ  í     øÿÿÿÿ  í   !   expression was false       maxValue>3.402823466e+38F   øÿÿÿÿ  í     øÿÿÿÿ  í   !           J     ø   %  ø   =  íÿÿÿÿ  íÿÿÿÿ    frh      expression was true       maxValue<m_MinVal.fValue   øÿÿÿÿ  í   %  øÿÿÿÿ  í   =   expression was false       maxValue<m_MinVal.fValue   øÿÿÿÿ  í   %  øÿÿÿÿ  í   =           L     ¯     ¯   #  ¤ÿÿÿÿ  ¤ÿÿÿÿ     øè      expression was false       m_ParamType == "FLOAT"   ¯ÿÿÿÿ  ¤     ¯ÿÿÿÿ  ¤   #                ø8   M               	ÿÿÿÿ  	ÿÿÿÿ    fĞ      expression was true       maxValue==0   ÿÿÿÿ  	     ÿÿÿÿ  	      expression was false       maxValue==0   ÿÿÿÿ  	     ÿÿÿÿ  	                  f€°   O             1  	ÿÿÿÿ  	ÿÿÿÿ    f‚¸      expression was true       maxValue <m_MinVal.uiValue   ÿÿÿÿ  	     ÿÿÿÿ  	   1   expression was false       maxValue <m_MinVal.uiValue   ÿÿÿÿ  	     ÿÿÿÿ  	   1           Q     j     j      _ÿÿÿÿ  _ÿÿÿÿ     ÷×@      expression was false       rParam->m_RangeError   jÿÿÿÿ  _     jÿÿÿÿ  _               R     F     F   $  ;ÿÿÿÿ  ;ÿÿÿÿ     ûº       expression was false       m_ParamType == "STRING"   Fÿÿÿÿ  ;     Fÿÿÿÿ  ;   $                û©   S     @     @   "  5ÿÿÿÿ  5ÿÿÿÿ     û§      expression was false       strcmp(pcToken," ")!=0   @ÿÿÿÿ  5     @ÿÿÿÿ  5   "                û£°   T     ,     ,   "  !ÿÿÿÿ  !ÿÿÿÿ     û˜Ø      expression was false       strcmp(pcToken," ")!=0   ,ÿÿÿÿ  !     ,ÿÿÿÿ  !   "                û•p   U     û     û   !  ğÿÿÿÿ  ğÿÿÿÿ     ûwà      expression was false       m_ParamType == "INT"   ûÿÿÿÿ  ğ     ûÿÿÿÿ  ğ   !                ûnp   V     ‹     ‹   =  €ÿÿÿÿ  €ÿÿÿÿ     ô¨      expression was false       strcmp(rParam->m_ParamName.c_str(),acTemp)==0   ‹ÿÿÿÿ  €     ‹ÿÿÿÿ  €   =                ğ    W     [     [   >  Pÿÿÿÿ  Pÿÿÿÿ     Ôh      expression was false       strcmp(rParam->m_ParamName.c_str(), acTemp)==0   [ÿÿÿÿ  P     [ÿÿÿÿ  P   >                Ğ   X     %     %   =  ÿÿÿÿ  ÿÿÿÿ     [(      expression was false       strcmp(rParam->m_ParamName.c_str(),acTemp)==0   %ÿÿÿÿ       %ÿÿÿÿ     =               =Á    Y     
     
      ÿÿÿÿÿ   ÿÿÿÿÿ     ô>@      expression was false       strcmp(temp,"X")==0   
ÿÿÿÿ   ÿ     
ÿÿÿÿ   ÿ                   ôB    Z      á      á   >   Öÿÿÿÿ   Öÿÿÿÿ     ô4       expression was false       strcmp(rParam->m_ParamName.c_str(), acTemp)==0    áÿÿÿÿ   Ö      áÿÿÿÿ   Ö   >               (şè   [      Ê      Ê      ¿ÿÿÿÿ   ¿ÿÿÿÿ     6ëÀ      expression was false       strcmp(type,"X")==0    Êÿÿÿÿ   ¿      Êÿÿÿÿ   ¿                   4)0   \      „      „       yÿÿÿÿ   yÿÿÿÿ    &ÏP      expression was false       rParam->m_RangeError    „ÿÿÿÿ   y      „ÿÿÿÿ   y               ]               ÿÿÿÿ  ÿÿÿÿ    f‹ˆ       statement executed        return rResult;   ÿÿÿÿ       ÿÿÿÿ                ^               ÿÿÿÿ  ÿÿÿÿ    f‰È       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                _               ÿÿÿÿ  ÿÿÿÿ    f‡H       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                `               ÷ÿÿÿÿ  ÷ÿÿÿÿ    f{0       statement executed        return rResult;   ÿÿÿÿ  ÷     ÿÿÿÿ  ÷              a                 õÿÿÿÿ  õÿÿÿÿ    fyp       statement executed        }    ÿÿÿÿ  õ      ÿÿÿÿ  õ              b     ü     ü     ñÿÿÿÿ  ñÿÿÿÿ    fvø       statement executed        }   üÿÿÿÿ  ñ     üÿÿÿÿ  ñ              c     õ     õ     êÿÿÿÿ  êÿÿÿÿ    foh       statement executed        }   õÿÿÿÿ  ê     õÿÿÿÿ  ê              d     ñ     ñ     æÿÿÿÿ  æÿÿÿÿ    fm8       statement executed        }   ñÿÿÿÿ  æ     ñÿÿÿÿ  æ              e     İ     İ     Òÿÿÿÿ  Òÿÿÿÿ     ø)       statement executed        return rResult;   İÿÿÿÿ  Ò     İÿÿÿÿ  Ò              f     Û     Û     Ğÿÿÿÿ  Ğÿÿÿÿ     ø'X       statement executed        }   Ûÿÿÿÿ  Ğ     Ûÿÿÿÿ  Ğ              g     ×     ×     Ìÿÿÿÿ  Ìÿÿÿÿ     ø$à       statement executed        }   ×ÿÿÿÿ  Ì     ×ÿÿÿÿ  Ì              h     Ğ     Ğ     Åÿÿÿÿ  Åÿÿÿÿ     øP       statement executed        }   Ğÿÿÿÿ  Å     Ğÿÿÿÿ  Å              i     Ì     Ì     Áÿÿÿÿ  Áÿÿÿÿ     øØ       statement executed        }   Ìÿÿÿÿ  Á     Ìÿÿÿÿ  Á              j     ¸     ¸     ­ÿÿÿÿ  ­ÿÿÿÿ     øx       statement executed        return cResult;   ¸ÿÿÿÿ  ­     ¸ÿÿÿÿ  ­              k     ¶     ¶     «ÿÿÿÿ  «ÿÿÿÿ     ø       statement executed        }   ¶ÿÿÿÿ  «     ¶ÿÿÿÿ  «              l     µ   	  µ   
  ªÿÿÿÿ  ªÿÿÿÿ     øP       statement executed        }   µÿÿÿÿ  ª   	  µÿÿÿÿ  ª   
           m     ­     ­     ¢ÿÿÿÿ  ¢ÿÿÿÿ     ø0       statement executed        }   ­ÿÿÿÿ  ¢     ­ÿÿÿÿ  ¢              n     ¬   	  ¬   
  ¡ÿÿÿÿ  ¡ÿÿÿÿ     øp       statement executed        }   ¬ÿÿÿÿ  ¡   	  ¬ÿÿÿÿ  ¡   
           o     ¤     ¤     ™ÿÿÿÿ  ™ÿÿÿÿ     ÷úP       statement executed        }   ¤ÿÿÿÿ  ™     ¤ÿÿÿÿ  ™              p     £   	  £   
  ˜ÿÿÿÿ  ˜ÿÿÿÿ     ÷ø       statement executed        }   £ÿÿÿÿ  ˜   	  £ÿÿÿÿ  ˜   
           q               „ÿÿÿÿ  „ÿÿÿÿ     ÷íh       statement executed        return pResult;   ÿÿÿÿ  „     ÿÿÿÿ  „              r               ‚ÿÿÿÿ  ‚ÿÿÿÿ     ÷ë¨       statement executed        }   ÿÿÿÿ  ‚     ÿÿÿÿ  ‚              s     Š   	  Š   
  ÿÿÿÿ  ÿÿÿÿ     ÷æÀ       statement executed        }   Šÿÿÿÿ     	  Šÿÿÿÿ     
           t     …   	  …   
  zÿÿÿÿ  zÿÿÿÿ     ÷äØ       statement executed        }   …ÿÿÿÿ  z   	  …ÿÿÿÿ  z   
           u     €   	  €   
  uÿÿÿÿ  uÿÿÿÿ     ÷áØ       statement executed        }   €ÿÿÿÿ  u   	  €ÿÿÿÿ  u   
           v     {   	  {   
  pÿÿÿÿ  pÿÿÿÿ     ÷ŞØ       statement executed        }   {ÿÿÿÿ  p   	  {ÿÿÿÿ  p   
           w     v   	  v   
  kÿÿÿÿ  kÿÿÿÿ     ÷Û˜       statement executed        }   vÿÿÿÿ  k   	  vÿÿÿÿ  k   
           x     m   	  m   
  bÿÿÿÿ  bÿÿÿÿ     ÷Öh       statement executed        }   mÿÿÿÿ  b   	  mÿÿÿÿ  b   
           y     U     U     Jÿÿÿÿ  Jÿÿÿÿ     û¹È       statement executed        }   Uÿÿÿÿ  J     Uÿÿÿÿ  J              z     P   	  P   
  Eÿÿÿÿ  Eÿÿÿÿ     û´       statement executed        }   Pÿÿÿÿ  E   	  Pÿÿÿÿ  E   
           {     K   	  K   
  @ÿÿÿÿ  @ÿÿÿÿ     û­¸       statement executed        }   Kÿÿÿÿ  @   	  Kÿÿÿÿ  @   
           |     D     D     9ÿÿÿÿ  9ÿÿÿÿ     û¨        statement executed        }   Dÿÿÿÿ  9     Dÿÿÿÿ  9              }     C   	  C   
  8ÿÿÿÿ  8ÿÿÿÿ     û¦@       statement executed        }   Cÿÿÿÿ  8   	  Cÿÿÿÿ  8   
           ~     ;   	  ;   
  0ÿÿÿÿ  0ÿÿÿÿ     û ¨       statement executed        }   ;ÿÿÿÿ  0   	  ;ÿÿÿÿ  0   
                7   	  7   
  ,ÿÿÿÿ  ,ÿÿÿÿ     ûp       statement executed        }   7ÿÿÿÿ  ,   	  7ÿÿÿÿ  ,   
           €     0     0     %ÿÿÿÿ  %ÿÿÿÿ     û™À       statement executed        }   0ÿÿÿÿ  %     0ÿÿÿÿ  %                   /   	  /   
  $ÿÿÿÿ  $ÿÿÿÿ     û˜        statement executed        }   /ÿÿÿÿ  $   	  /ÿÿÿÿ  $   
           ‚     (     (     ÿÿÿÿ  ÿÿÿÿ     û“8       statement executed        }   (ÿÿÿÿ       (ÿÿÿÿ                ƒ     "   	  "   
  ÿÿÿÿ  ÿÿÿÿ     û€       statement executed        }   "ÿÿÿÿ     	  "ÿÿÿÿ     
           „        	     
  ÿÿÿÿ  ÿÿÿÿ     û†è       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           …               üÿÿÿÿ  üÿÿÿÿ     û}°       statement executed        }   ÿÿÿÿ  ü     ÿÿÿÿ  ü              †               øÿÿÿÿ  øÿÿÿÿ     ûw       statement executed        }   ÿÿÿÿ  ø     ÿÿÿÿ  ø              ‡     ù     ù     îÿÿÿÿ  îÿÿÿÿ     ûmh       statement executed        }   ùÿÿÿÿ  î     ùÿÿÿÿ  î              ˆ     ï     ï     äÿÿÿÿ  äÿÿÿÿ     ûcĞ       statement executed        }   ïÿÿÿÿ  ä     ïÿÿÿÿ  ä              ‰     å     å     Úÿÿÿÿ  Úÿÿÿÿ     í’P       statement executed        }   åÿÿÿÿ  Ú     åÿÿÿÿ  Ú              Š     ä   	  ä   
  Ùÿÿÿÿ  Ùÿÿÿÿ     í        statement executed        }   äÿÿÿÿ  Ù   	  äÿÿÿÿ  Ù   
           ‹     Ø     Ø     Íÿÿÿÿ  Íÿÿÿÿ     íˆ8       statement executed        }   Øÿÿÿÿ  Í     Øÿÿÿÿ  Í              Œ     Ô     Ô     Éÿÿÿÿ  Éÿÿÿÿ     í†        statement executed        }   Ôÿÿÿÿ  É     Ôÿÿÿÿ  É                   ¾     ¾     ³ÿÿÿÿ  ³ÿÿÿÿ     í{P       statement executed        }   ¾ÿÿÿÿ  ³     ¾ÿÿÿÿ  ³                   ¹     ¹     ®ÿÿÿÿ  ®ÿÿÿÿ     ízH       statement executed        break;   ¹ÿÿÿÿ  ®     ¹ÿÿÿÿ  ®                   µ     µ     ªÿÿÿÿ  ªÿÿÿÿ     íxP       statement executed        break;   µÿÿÿÿ  ª     µÿÿÿÿ  ª                   ±     ±     ¦ÿÿÿÿ  ¦ÿÿÿÿ     ívX       statement executed        break;   ±ÿÿÿÿ  ¦     ±ÿÿÿÿ  ¦              ‘     ­     ­     ¢ÿÿÿÿ  ¢ÿÿÿÿ     ít`       statement executed        break;   ­ÿÿÿÿ  ¢     ­ÿÿÿÿ  ¢              ’     ©     ©     ÿÿÿÿ  ÿÿÿÿ     írh       statement executed        break;   ©ÿÿÿÿ       ©ÿÿÿÿ                “     ¥     ¥     šÿÿÿÿ  šÿÿÿÿ     ípp       statement executed        break;   ¥ÿÿÿÿ  š     ¥ÿÿÿÿ  š              ”     ”     ”     ‰ÿÿÿÿ  ‰ÿÿÿÿ     ím°       statement executed        }   ”ÿÿÿÿ  ‰     ”ÿÿÿÿ  ‰              •     “     “     ˆÿÿÿÿ  ˆÿÿÿÿ     ÷P       statement executed        }   “ÿÿÿÿ  ˆ     “ÿÿÿÿ  ˆ              –     ’   	  ’   
  ‡ÿÿÿÿ  ‡ÿÿÿÿ     õ       statement executed        }   ’ÿÿÿÿ  ‡   	  ’ÿÿÿÿ  ‡   
           —               …ÿÿÿÿ  …ÿÿÿÿ     óĞ       statement executed        break;   ÿÿÿÿ  …     ÿÿÿÿ  …              ˜     ‚   	  ‚   
  wÿÿÿÿ  wÿÿÿÿ     ê˜       statement executed        }   ‚ÿÿÿÿ  w   	  ‚ÿÿÿÿ  w   
           ™     d     d     Yÿÿÿÿ  Yÿÿÿÿ     ØĞ       statement executed        }   dÿÿÿÿ  Y     dÿÿÿÿ  Y              š     c     c     Xÿÿÿÿ  Xÿÿÿÿ     ×       statement executed        }   cÿÿÿÿ  X     cÿÿÿÿ  X              ›     b   	  b   
  Wÿÿÿÿ  Wÿÿÿÿ     ÕP       statement executed        }   bÿÿÿÿ  W   	  bÿÿÿÿ  W   
           œ     `     `     Uÿÿÿÿ  Uÿÿÿÿ     Ó       statement executed        break;   `ÿÿÿÿ  U     `ÿÿÿÿ  U                   R   	  R   
  Gÿÿÿÿ  Gÿÿÿÿ     zX       statement executed        }   Rÿÿÿÿ  G   	  Rÿÿÿÿ  G   
                .     .     #ÿÿÿÿ  #ÿÿÿÿ     _       statement executed        }   .ÿÿÿÿ  #     .ÿÿÿÿ  #              Ÿ     -     -     "ÿÿÿÿ  "ÿÿÿÿ     ]Ğ       statement executed        }   -ÿÿÿÿ  "     -ÿÿÿÿ  "                    ,   	  ,   
  !ÿÿÿÿ  !ÿÿÿÿ     \       statement executed        }   ,ÿÿÿÿ  !   	  ,ÿÿÿÿ  !   
           ¡     *     *     ÿÿÿÿ  ÿÿÿÿ     ZP       statement executed        break;   *ÿÿÿÿ       *ÿÿÿÿ                ¢        	     
  ÿÿÿÿ  ÿÿÿÿ    =»x       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           £        	     
  ÿÿÿÿ  ÿÿÿÿ     ôA       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           ¤      ê      ê      ßÿÿÿÿ   ßÿÿÿÿ     ôn°       statement executed        }    êÿÿÿÿ   ß      êÿÿÿÿ   ß              ¥      é      é      Şÿÿÿÿ   Şÿÿÿÿ     ô†       statement executed        }    éÿÿÿÿ   Ş      éÿÿÿÿ   Ş              ¦      è   	   è   
   İÿÿÿÿ   İÿÿÿÿ     4 ø       statement executed        }    èÿÿÿÿ   İ   	   èÿÿÿÿ   İ   
           §      æ      æ      Ûÿÿÿÿ   Ûÿÿÿÿ    &Î0       statement executed        break;    æÿÿÿÿ   Û      æÿÿÿÿ   Û              ¨      Ø   	   Ø   
   Íÿÿÿÿ   Íÿÿÿÿ    )
˜       statement executed        }    Øÿÿÿÿ   Í   	   Øÿÿÿÿ   Í   
           ©      Í   	   Í   
   Âÿÿÿÿ   Âÿÿÿÿ    &­0       statement executed        }    Íÿÿÿÿ   Â   	   Íÿÿÿÿ   Â   
           ª      ©      ©      ÿÿÿÿ   ÿÿÿÿ     6æ(       statement executed        return pResult;    ©ÿÿÿÿ         ©ÿÿÿÿ                 «      §      §      œÿÿÿÿ   œÿÿÿÿ     â–¸       statement executed        }    §ÿÿÿÿ   œ      §ÿÿÿÿ   œ              ¬      ¤   	   ¤   
   ™ÿÿÿÿ   ™ÿÿÿÿ     ôF0       statement executed        }    ¤ÿÿÿÿ   ™   	   ¤ÿÿÿÿ   ™   
           ­          	       
   •ÿÿÿÿ   •ÿÿÿÿ     ôu¨       statement executed        }     ÿÿÿÿ   •   	    ÿÿÿÿ   •   
           ®      œ   	   œ   
   ‘ÿÿÿÿ   ‘ÿÿÿÿ     3ñè       statement executed        }    œÿÿÿÿ   ‘   	   œÿÿÿÿ   ‘   
           ¯      —   	   —   
   Œÿÿÿÿ   Œÿÿÿÿ     ô8       statement executed        }    —ÿÿÿÿ   Œ   	   —ÿÿÿÿ   Œ   
           °      ’   	   ’   
   ‡ÿÿÿÿ   ‡ÿÿÿÿ    &‘È       statement executed        }    ’ÿÿÿÿ   ‡   	   ’ÿÿÿÿ   ‡   
           ±      ‡   	   ‡   
   |ÿÿÿÿ   |ÿÿÿÿ    (°       statement executed        }    ‡ÿÿÿÿ   |   	   ‡ÿÿÿÿ   |   
           ²      r      r      gÿÿÿÿ   gÿÿÿÿ     ôˆ       statement executed        return (*this);    rÿÿÿÿ   g      rÿÿÿÿ   g              ³      p      p      eÿÿÿÿ   eÿÿÿÿ     ôà       statement executed        }    pÿÿÿÿ   e      pÿÿÿÿ   e              ´      X      X      Mÿÿÿÿ   Mÿÿÿÿ     6éğ       statement executed        }    Xÿÿÿÿ   M      Xÿÿÿÿ   M              µ      P      P      Eÿÿÿÿ   Eÿÿÿÿ     6êØ       statement executed        }    Pÿÿÿÿ   E      Pÿÿÿÿ   E           CParameter::CParameter CParameter::CParameter()    6      P      +ÿÿÿÿ   EÿÿÿÿCParameter::~CParameter CParameter::~CParameter()    V      X      Kÿÿÿÿ   MÿÿÿÿCParameter::operator= CParameter& CParameter::operator=( CParameter& param)    b      s      Wÿÿÿÿ   hÿÿÿÿWriteParamToFile bool WriteParamToFile(fstream& fileOutput, list<CParameter> &m_listParameter)    }      ª      rÿÿÿÿ   ŸÿÿÿÿCParameter::Format_MesgParam_Value void CParameter::Format_MesgParam_Value(fstream& fileInput, list<CParameter>& m_listParam)    ´      ê      ©ÿÿÿÿ   ßÿÿÿÿCParameter::Format_SigParam_Value void CParameter::Format_SigParam_Value(fstream& fileInput, list<CParameter>& m_listParam)    ô     .      éÿÿÿÿ  #ÿÿÿÿCParameter::Format_NodeParam_Value void CParameter::Format_NodeParam_Value(fstream& fileInput, list<CParameter>& m_listParam)   8     d     -ÿÿÿÿ  YÿÿÿÿCParameter::Format_NetParam_Value void CParameter::Format_NetParam_Value(fstream& fileInput, list<CParameter>& m_listParam)   n     ”     cÿÿÿÿ  ‰ÿÿÿÿCParameter::Format_ParamDef void CParameter::Format_ParamDef(char* pcLine, int index)   Ÿ     ¾     ”ÿÿÿÿ  ³ÿÿÿÿCParameter::GetParam_Def void CParameter::GetParam_Def(char* pcLine)   Ç          ¼ÿÿÿÿ  üÿÿÿÿCParameter::ReadDefault_Value void CParameter::ReadDefault_Value(char* pcToken)        V     ÿÿÿÿ  KÿÿÿÿWrite_DefVal_ToFile bool Write_DefVal_ToFile(fstream& fileOutput,list<CParameter> &m_listParameter)   b          Wÿÿÿÿ  …ÿÿÿÿCParameter::Check_Default_Value bool CParameter::Check_Default_Value(void)   ™     ¹     ÿÿÿÿ  ®ÿÿÿÿCParameter::isValid_intRange bool CParameter::isValid_intRange(long long int minValue, long long int maxValue)   Ä     Ş     ¹ÿÿÿÿ  ÓÿÿÿÿCParameter::isValid_floatRange bool CParameter::isValid_floatRange(double minValue,double maxValue)   é          Şÿÿÿÿ  øÿÿÿÿCParameter::isValid_hexRange bool CParameter::isValid_hexRange(unsigned int minValue, unsigned int maxValue)             ÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Parameter.cpp
 * \brief     Implementation file for the Parameter class.
 * \authors   Ratnadip Choudhury, Padmaja A, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for the Parameter class.
 */

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers */

/* MFC includes */
#include <afxwin.h>         /* MFC core and standard components */
#include <afxext.h>         /* MFC extensions */
#include <afxdisp.h>        /* MFC Automation classes */
#include <afxdtctl.h>       /* MFC support for Internet Explorer 4 Common Controls */
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         /* MFC support for Windows Common Controls */
#include <afxtempl.h>
#endif /* _AFX_NO_AFXCMN_SUPPORT */

/* C includes */
#include <float.h>
#include <limits.h>

/* Project includes */
#include "Definitions.h"
#include "Parameter.h"
#include "tag.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CParameter
 */
CParameter::CParameter()
{
    m_MaxVal.iValue = -1;
    m_MaxVal.uiValue = 0;
    m_MaxVal.fValue = -1;
    m_MaxVal.dValue = -1;
    m_MaxVal.cValue = "";
    m_MaxVal.i64Value = -1;
    m_MaxVal.ui64Value = 0;
    m_MinVal.iValue = -1;
    m_MinVal.uiValue = 0;
    m_MinVal.fValue = -1;
    m_MinVal.dValue = -1;
    m_MinVal.cValue = "";
    m_MinVal.i64Value = -1;
    m_MinVal.ui64Value = 0;
    m_InitVal.iValue = -1;
    m_InitVal.uiValue = 0;
    m_InitVal.fValue = -1;
    m_InitVal.dValue = -1;
    m_InitVal.cValue = "";
    m_InitVal.i64Value = -1;
    m_InitVal.ui64Value = 0;
    m_ValRange = "";
    m_ParamType = "";
    m_ParamName = "";
    m_RangeError = false;
}

/**
 * Destructor of CParameter
 */
CParameter::~CParameter()
{
    // nothing special to do here
}

/**
 * \brief     overloaded operator =
 * \param[in] param Other element to copy data from
 * \return    Local object with new data
 *
 * Copy the other elements of the new message to this.
 */
CParameter& CParameter::operator=( CParameter& param)
{
    // now copy the other elements of the new message to this
    m_ObjectId = param.m_ObjectId;
    m_ParamName = param.m_ParamName;
    m_ValRange=param.m_ValRange;
    m_ParamType=param.m_ParamType;
    m_InitVal=param.m_InitVal;
    m_MaxVal=param.m_MaxVal;
    m_MinVal=param.m_MinVal;
    m_RangeError=param.m_RangeError;

    for(int i=0; i<4; i++)
    {
        m_listParamValues[i] = param.m_listParamValues[i];
    }

    return (*this);
}

/**
 * \brief      Writes the parameter definition to the specified output file.
 * \param[in]  fileOutput Output File
 * \param[in]  m_listParameter Parameters List
 *
 * Writes the parameter definition to the specified output file.
 */
bool WriteParamToFile(fstream& fileOutput, list<CParameter> &m_listParameter)
{
    bool pResult=true;
    //gets the frst param in the list.
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameter.begin(); rParam!=m_listParameter.end(); ++rParam)
    {
        if(rParam->m_RangeError)
        {
            pResult=false;
        }

        //writes param def to the specified o/p file.
        fileOutput << "BA_DEF_ " << rParam->m_ObjectId;
        fileOutput << "  \"" << rParam->m_ParamName << "\"";
        fileOutput << " " << rParam->m_ParamType;

        if(rParam->m_ParamType == "INT")
        {
            fileOutput << " " << dec << rParam->m_MinVal.iValue;
            fileOutput << " " << dec << rParam->m_MaxVal.iValue;
        }
        else if(rParam->m_ParamType == "HEX")
        {
            fileOutput << " " << dec << rParam->m_MinVal.uiValue;
            fileOutput << " " << dec << rParam->m_MaxVal.uiValue;
        }
        else if(rParam->m_ParamType == "FLOAT")
        {
            fileOutput << " " << rParam->m_MinVal.fValue;
            fileOutput << " " << rParam->m_MaxVal.fValue;
        }
        else if(rParam->m_ParamType == "ENUM")
        {
            fileOutput << rParam->m_ValRange;
        }
        else
        {
            fileOutput << " ";
        }

        fileOutput << ";" << endl;
    }

    return pResult;
}

/**
 * \brief     Format Message Parameter Value
 * \param[in] fileInput Input file
 * \param[in] m_listParam List of CParameter
 *
 * Format the message parameter value and write to output file.
 */
void CParameter::Format_MesgParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[defCON_MAX_LINE_LEN];
    char* pcToken;
    char* pcLine;
    char* pcNextToken;
    char acTemp[defCON_CHAR_LEN],*pcTemp;
    pcTemp = acTemp;

    //parses the mesg pram other values.
    while(fileInput.getline(acLine,defCON_MAX_LINE_LEN) && strcmp(acLine,"[END_PARAM_MSG_VAL]")!=0)
    {
        char type[defCON_CHAR_LEN];
        pcLine = acLine;
        //get mesg id.
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        UINT msgId=unsigned int(strtoul(pcToken, NULL, 10));
        pcLine=pcLine+strlen(pcToken)+1;
        //get message type and validates teh type.
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(type, pcToken, sizeof(type));

        if(strcmp(type,"X")==0)
        {
            msgId=msgId-2147483648;
        }

        pcLine=pcLine+strlen(pcToken)+1;
        //get other param values.
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        pcLine=pcLine+strlen(pcToken)+1;
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
            //assigns other values to the matching param defintion.
        {
            // find matching Parameter from list
            if(strcmp(rParam->m_ParamName.c_str(), acTemp)==0 )
            {
                pVal.Format_Param_Value(rParam->m_ParamType, pcLine, 2, msgId);
                rParam->m_listParamValues[2].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}

/**
 * \brief    Parses the Signal Parameter's Other Values.
 * \param[in] fileInput Input file
 * \param[in] m_listParam List of CParameter
 *
 * Parses the Signal Parameter's Other Values.
 */
void CParameter::Format_SigParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[defCON_MAX_LINE_LEN];
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acTemp[defCON_CHAR_LEN],*pcTemp;
    pcTemp = acTemp;

    //parses the signal pram other values.
    while(fileInput.getline(acLine,defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_SIG_VAL]")!=0)
    {
        char temp[defCON_CHAR_LEN],sname[defCON_CHAR_LEN];
        pcLine = acLine;
        //get mesg id.
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        UINT msgId=unsigned int(strtoul(pcToken, NULL, 10));
        pcLine=pcLine+strlen(pcToken)+1;
        //get message type and validates the mtype.
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(temp, pcToken, sizeof(temp));

        if(strcmp(temp,"X")==0)
        {
            msgId=msgId-2147483648;
        }

        pcLine=pcLine+strlen(pcToken)+1;
        //get signal name.
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(sname, pcToken, sizeof(sname));
        pcLine=pcLine+strlen(pcToken)+1;
        //get other values.
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        pcLine=pcLine+strlen(pcToken)+1;
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        //assigns other values to the matching param.
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
        {
            // find matching Parameter from list
            if(strcmp(rParam->m_ParamName.c_str(),acTemp)==0 )
            {
                pVal.Format_Param_Value(rParam->m_ParamType, pcLine, 3, msgId, sname);
                rParam->m_listParamValues[3].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}

/**
 * \brief     Parses the Node Parameter's Other Values
 * \param[in] fileInput Input file
 * \param[in] m_listParam List of CParameter
 *
 * Parses the Node Parameter's Other Values.
 */
void CParameter::Format_NodeParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[defCON_MAX_LINE_LEN];
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acTemp[defCON_CHAR_LEN],*pcTemp;
    pcTemp = acTemp;

    //parses the node pram other values.
    while(fileInput.getline(acLine,defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_NODE_VAL]")!=0)
    {
        char NodeName[defCON_CHAR_LEN];
        pcLine = acLine;
        //get node name.
        pcToken=strtok_s(pcLine, ",", &pcNextToken);
        strncpy_s(NodeName, pcToken, sizeof(NodeName));
        pcLine=pcLine+strlen(pcToken)+1;
        //get other values.
        pcToken = strtok_s(NULL, ",", &pcNextToken);
        pcLine=pcLine+strlen(pcToken)+1;
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        //assigns other values to the matching param.
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
        {
            // find matching Parameter from list
            if(strcmp(rParam->m_ParamName.c_str(), acTemp)==0)
            {
                pVal.Format_Param_Value(rParam->m_ParamType, pcLine, 1, 0, NodeName);
                rParam->m_listParamValues[1].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}

/**
 * \brief Parses the Net Parameter's Other Values
 * \param[in] fileInput Input file
 * \param[in] m_listParam List of CParameter
 *
 * Parses the Net Parameter's Other Values.
 */
void CParameter::Format_NetParam_Value(fstream& fileInput, list<CParameter>& m_listParam)
{
    CParameterValues pVal;
    char acLine[defCON_MAX_LINE_LEN];
    char* pcToken;
    char* pcNextToken;
    char* pcLine;
    char acTemp[defCON_CHAR_LEN],*pcTemp;
    pcTemp = acTemp;

    //parses the mesg pram other values.
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine, "[END_PARAM_NET_VAL]")!=0)
    {
        pcLine = acLine;
        //get other values.
        pcToken = strtok_s(pcLine, ",", &pcNextToken);
        pcToken++;

        while(*pcToken && *pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        //assigns other values to the matching param.
        list<CParameter>::iterator rParam;

        for(rParam=m_listParam.begin(); rParam!=m_listParam.end(); ++rParam)
        {
            // find matching Parameter from list
            if(strcmp(rParam->m_ParamName.c_str(),acTemp)==0 )
            {
                pVal.Format_Param_Value(rParam->m_ParamType, (pcLine+strlen(acTemp)+3), 0);
                rParam->m_listParamValues[0].push_back(pVal);
                pcTemp=acTemp;
                break;
            }
        }
    }
}


/**
 * \brief     Parses the attribute lines from the given i/p file.
 * \param[in] pcLine Attribute line
 * \param[in] index Index
 *
 * Parses the attribute lines from the given i/p file.
 */
void CParameter::Format_ParamDef(char* pcLine, int index)
{
    //get object id and stores m_object Id with the valid value.
    switch(index)
    {
        case 0:
            m_ObjectId = "";
            break;

        case 1:
            m_ObjectId = "BU_";
            break;

        case 2:
            m_ObjectId = "BO_";
            break;

        case 3:
            m_ObjectId = "SG_";
            break;

        case 4:
            m_ObjectId = "BU_SG_REL_";
            break;

        case 5:
            m_ObjectId = "BU_BO_REL_";
            break;
    }

    //reads the param defintion.
    GetParam_Def(pcLine);
}

/**
 * \brief     Parses the attribute value from the given i/p file
 * \param[in] pcLine Attribute value
 *
 * Parses the attribute value from the given i/p file.
 */
void CParameter::GetParam_Def(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    //get Param name
    pcToken = strtok_s(pcLine, "\"", &pcNextToken);
    m_ParamName = pcToken;
    //get Param type
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_ParamType = pcToken;

    if(m_ParamType == "STRING")
    {
        pcToken = strtok_s(NULL, "\n", &pcNextToken);
    }
    else
    {
        pcToken = strtok_s(NULL, ",", &pcNextToken);
    }

    //get the default value of parameter
    ReadDefault_Value(pcToken);

    if(m_ParamType == "ENUM")
    {
        m_ValRange="";

        while(pcToken = strtok_s(NULL, "\n", &pcNextToken))
        {
            m_ValRange=m_ValRange+" "+pcToken;
        }
    }
    //gets the min/max value and validates the range
    else if(m_ParamType == "HEX")
    {
        unsigned int min_val,max_val;
        pcToken = strtok_s(NULL, ",", &pcNextToken);
        min_val=strtoul(pcToken, NULL, 10);
        pcToken = strtok_s(NULL, " ", &pcNextToken);
        max_val= strtoul(pcToken, NULL, 10);
        m_RangeError |= isValid_hexRange(min_val,max_val);
    }
    //gets the min/max value and validates the range
    else if(m_ParamType == "FLOAT")
    {
        double min_val,max_val;
        pcToken = strtok_s(NULL, ",", &pcNextToken);
        min_val= atof(pcToken);
        pcToken = strtok_s(NULL, " ", &pcNextToken);
        max_val=atof(pcToken);
        m_RangeError |= isValid_floatRange(min_val,max_val);
    }
    //gets the min/max value and validates the range
    else if(m_ParamType == "INT")
    {
        LONGLONG min_val,max_val;
        pcToken = strtok_s(NULL, ",", &pcNextToken);
        min_val=_atoi64(pcToken);
        pcToken = strtok_s(NULL, " ", &pcNextToken);
        max_val=_atoi64(pcToken);
        m_RangeError |= isValid_intRange(min_val,max_val);
    }

    //validates the default value
    m_RangeError |= Check_Default_Value();
}

/**
 * \brief     Reads the default value of attribute from the i/p file
 * \param[in] pcToken Default value of attribute
 *
 * Reads the default value of attribute from the i/p file.
 */
void CParameter::ReadDefault_Value(char* pcToken)
{
    char acTemp[defCON_CHAR_LEN],*pcTemp;
    pcTemp = acTemp;

    //get inital value of type ENUM
    if(m_ParamType == "ENUM")
    {
        //omits all balnk spaces
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        pcToken++;

        while(*pcToken && *pcToken != '"')
        {
            *pcTemp++ = *pcToken++;
        }

        *pcTemp = '\0';
        //copies inital value to the object member.
        m_InitVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    //get inital value of type INT
    else if(m_ParamType == "INT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.iValue =atoi(pcToken);
        }
    }
    //get inital value of type HEX
    else if(m_ParamType == "HEX")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.uiValue =strtoul(pcToken, NULL, 10);
        }
        else
        {
            m_InitVal.uiValue =-1;
        }
    }
    //get inital value of type Float
    else if(m_ParamType == "FLOAT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.fValue=float(atof(pcToken));
        }
    }
    //get inital value of type string
    else if(m_ParamType == "STRING")
    {
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        while(*pcToken && *pcToken!='\n')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        m_InitVal.cValue = acTemp;
        pcTemp=acTemp;
    }
}


/**
 * \brief     Writes the parameter default values to the output file
 * \param[in] fileOutput Output file
 * \param[in] m_listParameter List of CParameter
 * \return    Return code
 *
 * Writes the parameter default values to the output file.
 */
bool Write_DefVal_ToFile(fstream& fileOutput,list<CParameter> &m_listParameter)
{
    bool pResult=true;
    //gets the first param from the list.
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameter.begin(); rParam!=m_listParameter.end(); ++rParam)
    {
        //checks whether def val is with in the range or not.
        if(rParam->m_RangeError)
        {
            pResult=false;
        }

        //writes def val of type int to the o/p file.
        fileOutput << "BA_DEF_DEF_";
        fileOutput << "  \"" << rParam->m_ParamName << "\"";

        if(rParam->m_ParamType == "INT")
        {
            fileOutput << " " << dec << rParam->m_InitVal.iValue;
        }
        //writes def val of type ex to the o/p file.
        else if(rParam->m_ParamType == "HEX")
        {
            fileOutput << " " << dec << rParam->m_InitVal.uiValue;
        }
        //writes def val of type flaot to the o/p file.
        else if(rParam->m_ParamType == "FLOAT")
        {
            fileOutput << " " << rParam->m_InitVal.fValue;
        }
        //writes def val of type enum to the o/p file.
        else if(rParam->m_ParamType == "ENUM")
        {
            fileOutput << " \"" << rParam->m_InitVal.cValue << "\"";
        }
        //writes def val of type string to the o/p file.
        else
        {
            fileOutput << " " << rParam->m_InitVal.cValue;
        }

        fileOutput << ";" << endl;
    }

    return pResult;
}

/**
 * \brief  Validates the default value of an attribute
 * \return Status code
 *
 * Validates the default value of an attribute.
 */
bool CParameter::Check_Default_Value(void)
{
    bool cResult=false;

    //validates def val of type int
    if(m_ParamType == "INT")
    {
        if(m_InitVal.iValue<m_MinVal.iValue || m_InitVal.iValue>m_MaxVal.iValue)
        {
            m_InitVal.iValue=m_MinVal.iValue;
            cResult=true;
        }
    }
    //validates def val of type hex
    else if(m_ParamType == "HEX")
    {
        if(m_InitVal.uiValue<m_MinVal.uiValue || m_InitVal.uiValue>m_MaxVal.uiValue)
        {
            m_InitVal.uiValue=m_MinVal.uiValue;
            cResult= true;
        }
    }
    //validates def val of type float
    else if(m_ParamType == "FLOAT")
    {
        if(m_InitVal.fValue<m_MinVal.fValue || m_InitVal.fValue>m_MaxVal.fValue)
        {
            m_InitVal.fValue=m_MinVal.fValue;
            cResult=true;
        }
    }

    return cResult;
}

/**
 * \brief     Validates the maximum and minimum int values of an attribute
 * \param[in] minValue minimum value of attribute
 * \param[in] maxValue maximum value of attribute
 * \return    Status code
 *
 * Validates the maximum and minimum int values of an attribute.
 */
bool CParameter::isValid_intRange(long long int minValue, long long int maxValue)
{
    bool rResult=false;

    //validates the min value
    if(minValue < INT_MIN )
    {
        m_MinVal.iValue=INT_MIN;
        rResult=rResult|true;
    }
    else
    {
        m_MinVal.iValue =int(minValue);
    }

    //validates the max value
    if(maxValue>INT_MAX || maxValue<m_MinVal.iValue)
    {
        m_MaxVal.iValue=INT_MAX;
        rResult=rResult | true;
    }
    else
    {
        m_MaxVal.iValue=int(maxValue);
    }

    return rResult;
}

/**
 * \brief     Validates the maximum and minimum float values of an attribute
 * \param[in] minValue minimum value of an attribute
 * \param[in] maxValue maximum value of an attribute
 * \return    Status code
 *
 * Validates the maximum and minimum float values of an attribute.
 */
bool CParameter::isValid_floatRange(double minValue,double maxValue)
{
    bool rResult=false;

    //validates the min value
    if(minValue<FLT_MIN)
    {
        m_MinVal.fValue=FLT_MIN;
        rResult=rResult | true;
    }
    else
    {
        m_MinVal.fValue= float(minValue);
    }

    //validates the max value
    if(maxValue>FLT_MAX || maxValue<m_MinVal.fValue)
    {
        m_MaxVal.fValue=FLT_MAX;
        rResult=rResult | true;
    }
    else
    {
        m_MaxVal.fValue =float(maxValue);
    }

    return rResult;
}

/**
 * \brief     Validates the maximum and minimum hex values of an attribute.
 * \param[in] minValue Minimum hex value of an attribute
 * \param[in] maxValue Maximum hex value of an attribute
 * \return    Status code
 *
 * Validates the maximum and minimum hex values of an attribute.
 */
bool CParameter::isValid_hexRange(unsigned int minValue, unsigned int maxValue)
{
    bool rResult=false;
    //validates the min value
    m_MinVal.uiValue=minValue;

    //validates the max value
    if(maxValue==0 || maxValue <m_MinVal.uiValue)
    {
        m_MaxVal.uiValue=0xffffffff;
        rResult=true;
    }
    else
    {
        m_MaxVal.uiValue=maxValue;
    }

    return rResult;
}


























using namespace std;






CParameterValues::CParameterValues()
{
    m_NodeName[0]='\0';
    m_MsgId=0;
    m_ParamVal.dValue =0;
    m_SignalName[0]='\0';
    m_cFrameFormat=MSG_FF_STANDARD;
    m_ParamVal.iValue =-1;
    m_ParamVal.fValue=-1;
    m_ParamVal.uiValue =-1;
}






CParameterValues::~CParameterValues()
{
}








CParameterValues& CParameterValues::operator=(CParameterValues& param)
{
    
    m_NodeName=param.m_NodeName;
    m_SignalName=param.m_SignalName;
    m_MsgId=param.m_MsgId;
    m_ParamVal=param.m_ParamVal;
    m_cFrameFormat=param.m_cFrameFormat;
    return (*this);
}












void CParameterValues::Format_Param_Value(string& paramType, char* pcLine,const int& index,unsigned int msgId,char* Node_Name)
{
    switch(index)
    {
        case 1:
            
            m_NodeName = Node_Name;
            break;

        case 2:
            
            m_MsgId=msgId;
            break;

        case 3:
            
            m_MsgId =msgId;
            m_SignalName = Node_Name;
            break;
    }

    
    ReadParamValue(paramType, pcLine);
}








void CParameterValues::ReadParamValue(string& paramType, char* pcToken)
{
    char acTemp[1024],*pcTemp;
    pcTemp = acTemp;

    
    if(paramType == "STRING")
    {
        pcToken++;

        while(*pcToken != '"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        m_ParamVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    
    else if((paramType == "INT") || (paramType == "HEX"))
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_ParamVal.iValue=atoi(pcToken);
        }
    }
    
    else if (paramType == "ENUM")
    {
        *pcToken++;

        while(*pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        m_ParamVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    
    else if(paramType == "FLOAT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_ParamVal.fValue=float(atof(pcToken));
        }
    }
}









void CParameterValues::WriteNetValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << " " << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        







		fileOutput << " " << m_ParamVal.cValue;
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}









void CParameterValues::WriteNodeValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";
    fileOutput << " BU_ " << m_NodeName.c_str();

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        







		fileOutput << " " << m_ParamVal.cValue;
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}









void CParameterValues::WriteMesgValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";
    fileOutput << " BO_ " << dec << m_MsgId;

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        







		fileOutput << " " << m_ParamVal.cValue;
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << " " << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}









void CParameterValues::WriteSigValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";
    fileOutput << " SG_ " << dec << m_MsgId;
    fileOutput << " " << m_SignalName.c_str();

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        







		fileOutput << " " << m_ParamVal.cValue;
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << " " << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}
          è      è      çÿÿÿÿ   çÿÿÿÿ     ô&H      expression was true       (paramType == "INT")    èÿÿÿÿ   ç      èÿÿÿÿ   ç      expression was false       (paramType == "INT")    èÿÿÿÿ   ç      èÿÿÿÿ   ç                   ôGØ         µ       µ   4   ´ÿÿÿÿ   ´ÿÿÿÿ     ôq(      expression was true       (paramType == "HEX")    µÿÿÿÿ   ´       µÿÿÿÿ   ´   4   expression was false       (paramType == "HEX")    µÿÿÿÿ   ´       µÿÿÿÿ   ´   4                4`         µ      µ      ´ÿÿÿÿ   ´ÿÿÿÿ     ô)H      expression was true       (paramType == "INT")    µÿÿÿÿ   ´      µÿÿÿÿ   ´      expression was false       (paramType == "INT")    µÿÿÿÿ   ´      µÿÿÿÿ   ´                  &©¸         ‰   %   ‰   9   ˆÿÿÿÿ   ˆÿÿÿÿ     3ùè      expression was true       (paramType == "HEX")    ‰ÿÿÿÿ   ˆ   %   ‰ÿÿÿÿ   ˆ   9   expression was false       (paramType == "HEX")    ‰ÿÿÿÿ   ˆ   %   ‰ÿÿÿÿ   ˆ   9                ôœh         ‰      ‰   !   ˆÿÿÿÿ   ˆÿÿÿÿ     3øÈ      expression was true       (paramType == "INT")    ‰ÿÿÿÿ   ˆ      ‰ÿÿÿÿ   ˆ   !   expression was false       (paramType == "INT")    ‰ÿÿÿÿ   ˆ      ‰ÿÿÿÿ   ˆ   !                ô€   
      •      •      ”ÿÿÿÿ   ”ÿÿÿÿ    )ø      expression was false       *pcToken!='"'    •ÿÿÿÿ   ”      •ÿÿÿÿ   ”                  (°                     ~ÿÿÿÿ   ~ÿÿÿÿ    &Ê       expression was false       *pcToken != '"'    ÿÿÿÿ   ~      ÿÿÿÿ   ~                   ô          è       è   4   çÿÿÿÿ   çÿÿÿÿ     ô&Ø      expression was true       (paramType == "HEX")    èÿÿÿÿ   ç       èÿÿÿÿ   ç   4   expression was false       (paramType == "HEX")    èÿÿÿÿ   ç       èÿÿÿÿ   ç   4                ô#h                  ÿÿÿÿ  ÿÿÿÿ     6éğ      expression was true       (paramType == "INT")   ÿÿÿÿ       ÿÿÿÿ        expression was false       (paramType == "INT")   ÿÿÿÿ       ÿÿÿÿ                     6ç                  4  ÿÿÿÿ  ÿÿÿÿ     6êØ      expression was true       (paramType == "HEX")   ÿÿÿÿ        ÿÿÿÿ     4   expression was false       (paramType == "HEX")   ÿÿÿÿ        ÿÿÿÿ     4                6é        O     O     Nÿÿÿÿ  Nÿÿÿÿ     4à      expression was true       (paramType == "INT")   Oÿÿÿÿ  N     Oÿÿÿÿ  N      expression was false       (paramType == "INT")   Oÿÿÿÿ  N     Oÿÿÿÿ  N                   4ğ        O      O   4  Nÿÿÿÿ  Nÿÿÿÿ     4È      expression was true       (paramType == "HEX")   Oÿÿÿÿ  N      Oÿÿÿÿ  N   4   expression was false       (paramType == "HEX")   Oÿÿÿÿ  N      Oÿÿÿÿ  N   4                4ø        l     l   "  kÿÿÿÿ  kÿÿÿÿ     4+°      expression was false       paramType == "STRING"   lÿÿÿÿ  k     lÿÿÿÿ  k   "                4)0        f     f   #  eÿÿÿÿ  eÿÿÿÿ     4'@      expression was false       m_ParamVal.fValue != -1   fÿÿÿÿ  e     fÿÿÿÿ  e   #                4$¨        Q     Q   #  Pÿÿÿÿ  Pÿÿÿÿ     4Ğ      expression was false       m_ParamVal.iValue != -1   Qÿÿÿÿ  P     Qÿÿÿÿ  P   #                4ø        8     8   "  7ÿÿÿÿ  7ÿÿÿÿ     6üÀ      expression was false       paramType == "STRING"   8ÿÿÿÿ  7     8ÿÿÿÿ  7   "                6ú@        2     2   #  1ÿÿÿÿ  1ÿÿÿÿ     6øP      expression was false       m_ParamVal.fValue != -1   2ÿÿÿÿ  1     2ÿÿÿÿ  1   #                6õ¸                #  ÿÿÿÿ  ÿÿÿÿ     6ïà      expression was false       m_ParamVal.iValue != -1   ÿÿÿÿ       ÿÿÿÿ     #                6í                "  ÿÿÿÿ  ÿÿÿÿ     âÀ      expression was false       paramType == "STRING"   ÿÿÿÿ       ÿÿÿÿ     "                â›@         ÿ      ÿ   #   şÿÿÿÿ   şÿÿÿÿ     â™P      expression was false       m_ParamVal.fValue != -1    ÿÿÿÿÿ   ş      ÿÿÿÿÿ   ş   #                â–¸         ê      ê   #   éÿÿÿÿ   éÿÿÿÿ    (f       expression was false       m_ParamVal.iValue != -1    êÿÿÿÿ   é      êÿÿÿÿ   é   #               &®0         Ò      Ò   "   Ñÿÿÿÿ   Ñÿÿÿÿ     ôƒ¸      expression was false       paramType == "STRING"    Òÿÿÿÿ   Ñ      Òÿÿÿÿ   Ñ   "                ôu¨          ¿      ¿   #   ¾ÿÿÿÿ   ¾ÿÿÿÿ     è°P      expression was false       m_ParamVal.fValue != -1    ¿ÿÿÿÿ   ¾      ¿ÿÿÿÿ   ¾   #                3ñè   !      ·      ·   #   ¶ÿÿÿÿ   ¶ÿÿÿÿ     ôÀ      expression was false       m_ParamVal.iValue != -1    ·ÿÿÿÿ   ¶      ·ÿÿÿÿ   ¶   #                ô8   "      ¡      ¡   "    ÿÿÿÿ    ÿÿÿÿ     ô:°      expression was false       strcmp(pcToken," ")!=0    ¡ÿÿÿÿ          ¡ÿÿÿÿ       "                ô   #      Ÿ      Ÿ   !   ÿÿÿÿ   ÿÿÿÿ     ôfø      expression was false       paramType == "FLOAT"    Ÿÿÿÿÿ         Ÿÿÿÿÿ      !               &ÏP   $      ‹      ‹   "   Šÿÿÿÿ   Šÿÿÿÿ     3õ°      expression was false       strcmp(pcToken," ")!=0    ‹ÿÿÿÿ   Š      ‹ÿÿÿÿ   Š   "                4   %     r     r     qÿÿÿÿ  qÿÿÿÿ     40˜       statement executed        }   rÿÿÿÿ  q     rÿÿÿÿ  q              &      -      -      ,ÿÿÿÿ   ,ÿÿÿÿ     ôC¸       statement executed        }    -ÿÿÿÿ   ,      -ÿÿÿÿ   ,              '      6      6      5ÿÿÿÿ   5ÿÿÿÿ     ô`¨       statement executed        }    6ÿÿÿÿ   5      6ÿÿÿÿ   5              (      G      G      Fÿÿÿÿ   Fÿÿÿÿ     ôs       statement executed        return (*this);    Gÿÿÿÿ   F      Gÿÿÿÿ   F              )      \      \      [ÿÿÿÿ   [ÿÿÿÿ     ô~ğ       statement executed        break;    \ÿÿÿÿ   [      \ÿÿÿÿ   [              *      a      a      `ÿÿÿÿ   `ÿÿÿÿ     ô˜       statement executed        break;    aÿÿÿÿ   `      aÿÿÿÿ   `              +      g      g      fÿÿÿÿ   fÿÿÿÿ     40       statement executed        break;    gÿÿÿÿ   f      gÿÿÿÿ   f              ,      l      l      kÿÿÿÿ   kÿÿÿÿ     ô/       statement executed        }    lÿÿÿÿ   k      lÿÿÿÿ   k              -      ‚   	   ‚   
   ÿÿÿÿ   ÿÿÿÿ    &Ë°       statement executed        }    ‚ÿÿÿÿ      	   ‚ÿÿÿÿ      
           .      ‡      ‡      †ÿÿÿÿ   †ÿÿÿÿ     ô?`       statement executed        }    ‡ÿÿÿÿ   †      ‡ÿÿÿÿ   †              /         	      
   ÿÿÿÿ   ÿÿÿÿ     3ö˜       statement executed        }    ÿÿÿÿ      	   ÿÿÿÿ      
           0                  ÿÿÿÿ   ÿÿÿÿ     ô8       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                 1      ˜   	   ˜   
   —ÿÿÿÿ   —ÿÿÿÿ    )X       statement executed        }    ˜ÿÿÿÿ   —   	   ˜ÿÿÿÿ   —   
           2                  œÿÿÿÿ   œÿÿÿÿ    &Â       statement executed        }    ÿÿÿÿ   œ      ÿÿÿÿ   œ              3      ¤   	   ¤   
   £ÿÿÿÿ   £ÿÿÿÿ     ô!X       statement executed        }    ¤ÿÿÿÿ   £   	   ¤ÿÿÿÿ   £   
           4      ¥      ¥      ¤ÿÿÿÿ   ¤ÿÿÿÿ     ôIà       statement executed        }    ¥ÿÿÿÿ   ¤      ¥ÿÿÿÿ   ¤              5      º   	   º   
   ¹ÿÿÿÿ   ¹ÿÿÿÿ     ô       statement executed        }    ºÿÿÿÿ   ¹   	   ºÿÿÿÿ   ¹   
           6      »      »      ºÿÿÿÿ   ºÿÿÿÿ     ô0       statement executed        }    »ÿÿÿÿ   º      »ÿÿÿÿ   º              7      Â   	   Â   
   Áÿÿÿÿ   Áÿÿÿÿ     3ô       statement executed        }    Âÿÿÿÿ   Á   	   Âÿÿÿÿ   Á   
           8      Ã      Ã      Âÿÿÿÿ   Âÿÿÿÿ     ôa€       statement executed        }    Ãÿÿÿÿ   Â      Ãÿÿÿÿ   Â              9      Ğ      Ğ      Ïÿÿÿÿ   Ïÿÿÿÿ     ôt€       statement executed        }    Ğÿÿÿÿ   Ï      Ğÿÿÿÿ   Ï              :      Õ      Õ      Ôÿÿÿÿ   Ôÿÿÿÿ     ô‚à       statement executed        }    Õÿÿÿÿ   Ô      Õÿÿÿÿ   Ô              ;      Ø      Ø      ×ÿÿÿÿ   ×ÿÿÿÿ     ô‘`       statement executed        }    Øÿÿÿÿ   ×      Øÿÿÿÿ   ×              <      í   	   í   
   ìÿÿÿÿ   ìÿÿÿÿ    (eÈ       statement executed        }    íÿÿÿÿ   ì   	   íÿÿÿÿ   ì   
           =      î      î      íÿÿÿÿ   íÿÿÿÿ    (gˆ       statement executed        }    îÿÿÿÿ   í      îÿÿÿÿ   í              >      û      û      úÿÿÿÿ   úÿÿÿÿ    (j8       statement executed        }    ûÿÿÿÿ   ú      ûÿÿÿÿ   ú              ?        	     
  ÿÿÿÿ  ÿÿÿÿ     â˜x       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           @               ÿÿÿÿ  ÿÿÿÿ     âš8       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                A               ÿÿÿÿ  ÿÿÿÿ     âœè       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                B               
ÿÿÿÿ  
ÿÿÿÿ     6â°       statement executed        }   ÿÿÿÿ  
     ÿÿÿÿ  
              C         	      
  ÿÿÿÿ  ÿÿÿÿ     6ï       statement executed        }    ÿÿÿÿ     	   ÿÿÿÿ     
           D     !     !      ÿÿÿÿ   ÿÿÿÿ     6ğÈ       statement executed        }   !ÿÿÿÿ        !ÿÿÿÿ                 E     .     .     -ÿÿÿÿ  -ÿÿÿÿ     6óx       statement executed        }   .ÿÿÿÿ  -     .ÿÿÿÿ  -              F     5   	  5   
  4ÿÿÿÿ  4ÿÿÿÿ     6÷x       statement executed        }   5ÿÿÿÿ  4   	  5ÿÿÿÿ  4   
           G     6     6     5ÿÿÿÿ  5ÿÿÿÿ     6ù8       statement executed        }   6ÿÿÿÿ  5     6ÿÿÿÿ  5              H     ;     ;     :ÿÿÿÿ  :ÿÿÿÿ     6ûè       statement executed        }   ;ÿÿÿÿ  :     ;ÿÿÿÿ  :              I     >     >     =ÿÿÿÿ  =ÿÿÿÿ     4Ğ       statement executed        }   >ÿÿÿÿ  =     >ÿÿÿÿ  =              J     T   	  T   
  Sÿÿÿÿ  Sÿÿÿÿ     4ø       statement executed        }   Tÿÿÿÿ  S   	  Tÿÿÿÿ  S   
           K     U     U     Tÿÿÿÿ  Tÿÿÿÿ     4¸       statement executed        }   Uÿÿÿÿ  T     Uÿÿÿÿ  T              L     b     b     aÿÿÿÿ  aÿÿÿÿ     4"h       statement executed        }   bÿÿÿÿ  a     bÿÿÿÿ  a              M     i   	  i   
  hÿÿÿÿ  hÿÿÿÿ     4&h       statement executed        }   iÿÿÿÿ  h   	  iÿÿÿÿ  h   
           N     j     j     iÿÿÿÿ  iÿÿÿÿ     4((       statement executed        }   jÿÿÿÿ  i     jÿÿÿÿ  i              O     o     o     nÿÿÿÿ  nÿÿÿÿ     4*Ø       statement executed        }   oÿÿÿÿ  n     oÿÿÿÿ  n           CParameterValues::CParameterValues CParameterValues::CParameterValues()    $      -      #ÿÿÿÿ   ,ÿÿÿÿCParameterValues::~CParameterValues CParameterValues::~CParameterValues()    5      6      4ÿÿÿÿ   5ÿÿÿÿCParameterValues::operator= CParameterValues& CParameterValues::operator=(CParameterValues& param)    @      H      ?ÿÿÿÿ   GÿÿÿÿCParameterValues::Format_Param_Value void CParameterValues::Format_Param_Value(string& paramType, char* pcLine,const int& index,unsigned int msgId,char* Node_Name)    V      l      Uÿÿÿÿ   kÿÿÿÿCParameterValues::ReadParamValue void CParameterValues::ReadParamValue(string& paramType, char* pcToken)    v      ¦      uÿÿÿÿ   ¥ÿÿÿÿCParameterValues::WriteNetValuesToFile void CParameterValues::WriteNetValuesToFile(fstream& fileOutput, string& paramType, string& paramName)    ±      Ø      °ÿÿÿÿ   ×ÿÿÿÿCParameterValues::WriteNodeValuesToFile void CParameterValues::WriteNodeValuesToFile(fstream& fileOutput, string& paramType, string& paramName)    ã           âÿÿÿÿ  
ÿÿÿÿCParameterValues::WriteMesgValuesToFile void CParameterValues::WriteMesgValuesToFile(fstream& fileOutput, string& paramType, string& paramName)        >     ÿÿÿÿ  =ÿÿÿÿCParameterValues::WriteSigValuesToFile void CParameterValues::WriteSigValuesToFile(fstream& fileOutput, string& paramType, string& paramName)   I     r     Hÿÿÿÿ  qÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ParameterVal.cpp
 * \brief     Implementation file for the ParameterValues class.
 * \authors   Padmaja A, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for the ParameterValues class.
 */

/* Project includes */
#include "ParameterVal.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CParameterValues
 */
CParameterValues::CParameterValues()
{
    m_NodeName[0]='\0';
    m_MsgId=0;
    m_ParamVal.dValue =0;
    m_SignalName[0]='\0';
    m_cFrameFormat=MSG_FF_STANDARD;
    m_ParamVal.iValue =-1;
    m_ParamVal.fValue=-1;
    m_ParamVal.uiValue =-1;
}

/**
 * \brief Destructor
 *
 * Destructor of CParameterValues
 */
CParameterValues::~CParameterValues()
{
}

/**
 * \brief     overloaded operator =
 * \param[in] param Parameter to copy content from
 * \return    Local parameter with new contents
 *
 * Copies the contents of param to local object.
 */
CParameterValues& CParameterValues::operator=(CParameterValues& param)
{
    // now copy the other elements of the new message to this
    m_NodeName=param.m_NodeName;
    m_SignalName=param.m_SignalName;
    m_MsgId=param.m_MsgId;
    m_ParamVal=param.m_ParamVal;
    m_cFrameFormat=param.m_cFrameFormat;
    return (*this);
}

/**
 * \brief Format Parameter Value
 * \param[in] paramType Parameter Type
 * \param[in] pcLine Input line
 * \param[in] index Index
 * \param[in] msgId Message Identifier
 * \param[in] Node_Name Node Name
 *
 * Parses the Parameter Values other than Default value
 * from the input file.
 */
void CParameterValues::Format_Param_Value(string& paramType, char* pcLine,const int& index,unsigned int msgId,char* Node_Name)
{
    switch(index)
    {
        case 1:
            //copies the node name to the member
            m_NodeName = Node_Name;
            break;

        case 2:
            //copies the message id.
            m_MsgId=msgId;
            break;

        case 3:
            //store the signal name.
            m_MsgId =msgId;
            m_SignalName = Node_Name;
            break;
    }

    //get param value.
    ReadParamValue(paramType, pcLine);
}

/**
 * \brief     Read Parameter Value
 * \param[in] paramType Parameter type
 * \param[in] pcToken   Input token
 *
 * Reads the other value of attributes from i/p file.
 */
void CParameterValues::ReadParamValue(string& paramType, char* pcToken)
{
    char acTemp[defCON_CHAR_LEN],*pcTemp;
    pcTemp = acTemp;

    //get param value of type String
    if(paramType == "STRING")
    {
        pcToken++;

        while(*pcToken != '"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        m_ParamVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    //get param value of type int
    else if((paramType == "INT") || (paramType == "HEX"))
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_ParamVal.iValue=atoi(pcToken);
        }
    }
    //get param value of type enum
    else if (paramType == "ENUM")
    {
        *pcToken++;

        while(*pcToken!='"')
        {
            *pcTemp++=*pcToken++;
        }

        *pcTemp='\0';
        m_ParamVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    //get param value of type float
    else if(paramType == "FLOAT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_ParamVal.fValue=float(atof(pcToken));
        }
    }
}

/**
 * \brief     Write the net values into the file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Write the net values into the file.
 */
void CParameterValues::WriteNetValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";

    //writes net values of type int to o/p file.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    //writes net values of type float to o/p file.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << " " << m_ParamVal.fValue;
        }
    }
    //writes net values of type enum to o/p file.
    else if(paramType == "ENUM")
    {
        /*if(m_ParamVal.cValue.length() == 0)
        {
            fileOutput << " \"\"";
        }
        else
        {
            fileOutput << " " << m_ParamVal.cValue;
        }*/
		fileOutput << " " << m_ParamVal.cValue;
    }
    //writes net values of type string to o/p file.
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}

/**
 * \brief     Write the node values into the file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Write the node values into the file.
 */
void CParameterValues::WriteNodeValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";
    fileOutput << " BU_ " << m_NodeName.c_str();

    //writes node values of type int/hex to o/p file.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    //writes node values of type enum to o/p file.
    else if(paramType == "ENUM")
    {
        /*if(m_ParamVal.cValue.length() == 0)
        {
            fileOutput << " \"\"";
        }
        else
        {
            fileOutput << " \"" << m_ParamVal.cValue << "\"";
        }*/
		fileOutput << " " << m_ParamVal.cValue;
    }
    //writes node values of type float to o/p file.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    //writes node values of type string to o/p file.
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}

/**
 * \brief     Write the Message values into the file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Write the Message values into the file.
 */
void CParameterValues::WriteMesgValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";
    fileOutput << " BO_ " << dec << m_MsgId;

    //writes mesg values of type int/hex to o/p file.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    //writes mesg values of type enum to o/p file.
    else if(paramType == "ENUM")
    {
        /*if(m_ParamVal.cValue.length() == 0)
        {
            fileOutput << " \"\"";
        }
        else
        {
            fileOutput << " " << m_ParamVal.cValue;
        }*/
		fileOutput << " " << m_ParamVal.cValue;
    }
    //writes mesg values of type float to o/p file.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << " " << m_ParamVal.fValue;
        }
    }
    //writes mesg values of type string to o/p file.
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}

/**
 * \brief     Write the Signal values into the file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Write the Signal values into the file.
 */
void CParameterValues::WriteSigValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "BA_ \"" << paramName.c_str() << "\"";
    fileOutput << " SG_ " << dec << m_MsgId;
    fileOutput << " " << m_SignalName.c_str();

    //writes sig values of type int/hex to o/p file.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << " " << dec << m_ParamVal.iValue;
        }
    }
    //writes sig values of type enum to o/p file.
    else if(paramType == "ENUM")
    {
        /*if(m_ParamVal.cValue.length() == 0)
        {
            fileOutput << " \"\"";
        }
        else
        {
            fileOutput << " " << m_ParamVal.cValue;
        }*/
		fileOutput << " " << m_ParamVal.cValue;
    }
    //writes sig values of type flaot to o/p file.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << " " << m_ParamVal.fValue;
        }
    }
    //writes sig values of type string to o/p file.
    else if(paramType == "STRING")
    {
        fileOutput << " \"" << m_ParamVal.cValue << "\"";
    }

    fileOutput << ";" << endl;
}



























using namespace std;






CSignal::CSignal()
{
    m_ucLength = 1; 
    m_ucWhichByte = 1; 
    m_ucStartBit = 0; 
    m_ucType = SIG_TYPE_BOOL; 
    m_MaxValue.uiValue = 1; 
    m_MinValue.uiValue = 0; 
    m_ucDataFormat = SIG_DF_INTEL;
    m_fOffset = 0.0f;
    m_fScaleFactor = 1.0f;
    m_uiError = SIG_EC_NO_ERR;
    m_listValueDescriptor.clear();
}






CSignal::~CSignal()
{
}








CSignal& CSignal::operator=(CSignal& signal)
{
    
    m_sName = signal.m_sName;
    m_sMultiplex = signal.m_sMultiplex;
    m_ucLength = signal.m_ucLength;
    m_ucWhichByte = signal.m_ucWhichByte;
    m_ucStartBit = signal.m_ucStartBit;
    m_ucType = signal.m_ucType;
    m_MaxValue = signal.m_MaxValue;
    m_MinValue = signal.m_MinValue;
    m_ucDataFormat = signal.m_ucDataFormat;
    m_fOffset = signal.m_fOffset;
    m_fScaleFactor = signal.m_fScaleFactor;
    m_sUnit = signal.m_sUnit;
    m_sNode = signal.m_sNode;
    m_uiError = signal.m_uiError;
    
    m_listValueDescriptor = signal.m_listValueDescriptor;
    return (*this);
}








int CSignal::operator==(const CSignal& signal) const
{
    if (m_sName == signal.m_sName)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}









int CSignal::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    char acTemp[1026],*pcTemp;
    pcTemp = acTemp;
    
    pcToken = strtok_s(pcLine, ",", &pcNextToken); 
    
    m_sName = pcToken; 
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_ucLength = atoi(pcToken); 
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_ucWhichByte = atoi(pcToken);
    
    unsigned int ucStartBit;
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_ucStartBit = atoi(pcToken);
    ucStartBit = m_ucStartBit + (m_ucWhichByte - 1) * 8;
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_ucType = *pcToken;
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    
    m_MaxValue.ui64Value = _strtoui64(pcToken, 0, 10);
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    
    m_MinValue.ui64Value = _strtoui64(pcToken, 0, 10);
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_ucDataFormat = *pcToken;

    if(m_ucDataFormat == '0')
    {
        unsigned int nByte = (m_ucLength/8) + ((m_ucLength % 8)?1:0);
        unsigned int nStartBit = (m_ucWhichByte - nByte) * 8;
        unsigned int nBitSize = m_ucLength - (8 * (nByte - 1))+ m_ucStartBit;

        if(nBitSize == 0)
        {
            ucStartBit = ucStartBit + m_ucLength;
        }
        else
        {
            ucStartBit = nStartBit + nBitSize-1;
        }
    }

    m_ucStartBit = ucStartBit;
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_fOffset = (float)atof(pcToken); 
    
    pcToken = strtok_s(0, ",", &pcNextToken);
    m_fScaleFactor = (float)atof(pcToken); 
    
    pcTemp = acTemp;
    pcToken = strtok_s(0, "", &pcNextToken);

    
    
    while(*pcToken && *pcToken != ',' && *pcToken != 0xa)
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    string strUnit_Temp = acTemp;
    m_sUnit = "\"";
    m_sUnit = m_sUnit + acTemp; 
    m_sUnit = m_sUnit + "\"";

    if(strUnit_Temp.length() > 1024 + 2)
    {
        CConverter::fileLog << "unit " << strUnit_Temp;
        CConverter::fileLog << " changed to " << m_sUnit << endl;
        CConverter::bLOG_ENTERED = true;
    }

    
    string strTemp = pcToken;
    int nIndex = strTemp.find(',');

    if(nIndex != -1)
    {
        int nLength = strTemp.length();
        strTemp = strTemp.substr(nLength - nIndex - 1, nIndex);
        nIndex = strTemp.find(',');

        if(nIndex != -1)
        {
            if(nIndex != 0)
            {
                strTemp = strTemp.substr(0, nIndex-1);
            }
            else
            {
                strTemp.empty();
            }

            m_sMultiplex = strTemp;
        }
    }

    
    string strNodes = pcToken;
    nIndex = strNodes.find(",", 0);
    strNodes = strNodes.substr(nIndex+1);
    nIndex = strNodes.find(",", nIndex);
    strNodes = strNodes.substr(nIndex+1);
    m_sNode = strNodes;

    while ((nIndex = m_sNode.find('\n', 0)) != string::npos)
    {
        m_sNode.replace(nIndex, 1, " ");
    }

    if(m_sNode.length() == 0)
    {
        m_sNode = "Vector__XXX";
    }

    return 1;
}








unsigned int CSignal::Validate()
{
    

    
    











    
    if(m_ucLength == 1) 
    {
        m_ucType = SIG_TYPE_BOOL;
    }

    
    switch(m_ucType)
    {
        case SIG_TYPE_BOOL:
        case SIG_TYPE_UINT:
        case SIG_TYPE_UINT64:
            unConvertRawToPhysical(m_MaxValue.ui64Value, m_MinValue.ui64Value, m_fOffset, m_fScaleFactor, m_MaxValue.dValue, m_MinValue.dValue);
            break;

        case SIG_TYPE_INT:
        case SIG_TYPE_INT64:
            nConvertRawToPhysical(m_MaxValue.ui64Value, m_MinValue.ui64Value, m_fOffset, m_fScaleFactor, m_MaxValue.dValue, m_MinValue.dValue);
            break;

        default:
            break;
    }

    
    list<CValueDescriptor>::iterator rValDesc;

    for(rValDesc=m_listValueDescriptor.begin(); rValDesc!=m_listValueDescriptor.end(); ++rValDesc)
    {
        switch(m_ucType)
        {
            case SIG_TYPE_INT:
            case SIG_TYPE_FLOAT:
            case SIG_TYPE_DOUBLE:
            case SIG_TYPE_INT64:
                break;

            case SIG_TYPE_BOOL:
            case SIG_TYPE_UINT:
            case SIG_TYPE_UINT64:
                rValDesc->m_value.ui64Value = (unsigned long long int)rValDesc->m_value.i64Value;
                break;

            default:
                break;
        }
    }

    return (m_uiError = SIG_EC_NO_ERR);
}









bool CSignal::WriteSignaltofile(fstream& fileOutput)
{
    bool bResult = true;

    if(m_uiError == SIG_EC_NO_ERR)
    {
        fileOutput << " SG_ " << m_sName;
        fileOutput << " " << m_sMultiplex;
        fileOutput << ": " << dec << m_ucStartBit;
        fileOutput << "|" << dec << m_ucLength;
        fileOutput << "@" << m_ucDataFormat;

        if ((m_ucType == SIG_TYPE_UINT) || (m_ucType == SIG_TYPE_UINT64))
        {
            fileOutput << "+";
        }
        else
        {
            fileOutput << "-";
        }

        fileOutput << " (" << m_fScaleFactor;
        fileOutput << "," << m_fOffset;
        fileOutput << ") [" << m_MinValue.dValue;
        fileOutput << "|" << m_MaxValue.dValue;
        fileOutput << "] " << m_sUnit;
        fileOutput << " " << m_sNode << endl;
    }
    else
    {
        bResult = false;
    }

    return bResult;
}







void CSignal::GetErrorString(string& str)
{
    switch(m_uiError)
    {
        case 0:
            str = "No error";
            break;

        case 1:
            str = "Invalid signal length";
            break;

        case 2:
            str = "Invalid start bit";
            break;
    }
}
          ¶      ¶   &   ´ÿÿÿÿ   ´ÿÿÿÿ     ô8ˆ      expression was true       *pcToken != ','    ¶ÿÿÿÿ   ´      ¶ÿÿÿÿ   ´   &   expression was false       *pcToken != ','    ¶ÿÿÿÿ   ´      ¶ÿÿÿÿ   ´   &                ô6Ø         ¶      ¶      ´ÿÿÿÿ   ´ÿÿÿÿ     ô7°      expression was true       *pcToken    ¶ÿÿÿÿ   ´      ¶ÿÿÿÿ   ´      expression was false       *pcToken    ¶ÿÿÿÿ   ´      ¶ÿÿÿÿ   ´                    ¶   *   ¶   9   ´ÿÿÿÿ   ´ÿÿÿÿ     ô<      expression was true       *pcToken != 0xa    ¶ÿÿÿÿ   ´   *   ¶ÿÿÿÿ   ´   9   expression was false       *pcToken != 0xa    ¶ÿÿÿÿ   ´   *   ¶ÿÿÿÿ   ´   9                ô:h         ›   0   ›   @   ™ÿÿÿÿ   ™ÿÿÿÿ     ô8      expression was true       (m_ucLength % 8)    ›ÿÿÿÿ   ™   0   ›ÿÿÿÿ   ™   @   expression was false       (m_ucLength % 8)    ›ÿÿÿÿ   ™   0   ›ÿÿÿÿ   ™   @                ôP        )   1  )   V  'ÿÿÿÿ  'ÿÿÿÿ     ô›€      expression was false       rValDesc!=m_listValueDescriptor.end()   )ÿÿÿÿ  '   1  )ÿÿÿÿ  '   V                ô“ø   	      é      é   <   çÿÿÿÿ   çÿÿÿÿ     ôƒ¸      expression was false       (nIndex = m_sNode.find('\n', 0)) != string::npos    éÿÿÿÿ   ç      éÿÿÿÿ   ç   <                ô`   
     U     U   (  Sÿÿÿÿ  Sÿÿÿÿ     3õ°      expression was true       (m_ucType == SIG_TYPE_UINT)   Uÿÿÿÿ  S     Uÿÿÿÿ  S   (   expression was false       (m_ucType == SIG_TYPE_UINT)   Uÿÿÿÿ  S     Uÿÿÿÿ  S   (                3òx        U   ,  U   I  Sÿÿÿÿ  Sÿÿÿÿ     3ö˜      expression was true       (m_ucType == SIG_TYPE_UINT64)   Uÿÿÿÿ  S   ,  Uÿÿÿÿ  S   I   expression was false       (m_ucType == SIG_TYPE_UINT64)   Uÿÿÿÿ  S   ,  Uÿÿÿÿ  S   I                3ôÈ                  ÿÿÿÿ  ÿÿÿÿ     ô       expression was false       m_ucLength == 1   ÿÿÿÿ       ÿÿÿÿ                     ôŠà         î      î      ìÿÿÿÿ   ìÿÿÿÿ     ô‡¨      expression was false       m_sNode.length() == 0    îÿÿÿÿ   ì      îÿÿÿÿ   ì                   ô„à         Ò      Ò      Ğÿÿÿÿ   Ğÿÿÿÿ     ôtÀ      expression was false       nIndex != -1    Òÿÿÿÿ   Ğ      Òÿÿÿÿ   Ğ                   ôl         Ì      Ì      Êÿÿÿÿ   Êÿÿÿÿ     ôv€      expression was false       nIndex != -1    Ìÿÿÿÿ   Ê      Ìÿÿÿÿ   Ê                   ôf°         Á      Á   (   ¿ÿÿÿÿ   ¿ÿÿÿÿ     ôbX      expression was false       strUnit_Temp.length() > 1024 + 2    Áÿÿÿÿ   ¿      Áÿÿÿÿ   ¿   (                ôI˜         ™      ™      —ÿÿÿÿ   —ÿÿÿÿ     ô*°      expression was false       m_ucDataFormat == '0'    ™ÿÿÿÿ   —      ™ÿÿÿÿ   —                  &ÏP        ƒ     ƒ     ÿÿÿÿ  ÿÿÿÿ     4Ğ       statement executed        }   ƒÿÿÿÿ       ƒÿÿÿÿ                               ÿÿÿÿ  ÿÿÿÿ     4
ø       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                     }     }     {ÿÿÿÿ  {ÿÿÿÿ     4	       statement executed        break;   }ÿÿÿÿ  {     }ÿÿÿÿ  {                   y     y     wÿÿÿÿ  wÿÿÿÿ     4       statement executed        break;   yÿÿÿÿ  w     yÿÿÿÿ  w                   j     j     hÿÿÿÿ  hÿÿÿÿ     4       statement executed        return bResult;   jÿÿÿÿ  h     jÿÿÿÿ  h                   h     h     fÿÿÿÿ  fÿÿÿÿ     4Ğ       statement executed        }   hÿÿÿÿ  f     hÿÿÿÿ  f                   d     d     bÿÿÿÿ  bÿÿÿÿ     3ÿ        statement executed        }   dÿÿÿÿ  b     dÿÿÿÿ  b                   \   	  \   
  Zÿÿÿÿ  Zÿÿÿÿ     3ùè       statement executed        }   \ÿÿÿÿ  Z   	  \ÿÿÿÿ  Z   
                X   	  X   
  Vÿÿÿÿ  Vÿÿÿÿ     3øÈ       statement executed        }   Xÿÿÿÿ  V   	  Xÿÿÿÿ  V   
                >     >   (  <ÿÿÿÿ  <ÿÿÿÿ     ôœh       statement executed        return (m_uiError = SIG_EC_NO_ERR);   >ÿÿÿÿ  <     >ÿÿÿÿ  <   (                <     <     :ÿÿÿÿ  :ÿÿÿÿ     ôš¨       statement executed        }   <ÿÿÿÿ  :     <ÿÿÿÿ  :                   :     :     8ÿÿÿÿ  8ÿÿÿÿ     ô™Ğ       statement executed        break;   :ÿÿÿÿ  8     :ÿÿÿÿ  8                    7     7     5ÿÿÿÿ  5ÿÿÿÿ     ô˜ø       statement executed        break;   7ÿÿÿÿ  5     7ÿÿÿÿ  5              !     1     1     /ÿÿÿÿ  /ÿÿÿÿ     ô•H       statement executed        break;   1ÿÿÿÿ  /     1ÿÿÿÿ  /              "     #     #     !ÿÿÿÿ  !ÿÿÿÿ     ô‘€       statement executed        break;   #ÿÿÿÿ  !     #ÿÿÿÿ  !              #                 ÿÿÿÿ  ÿÿÿÿ     ô¨       statement executed        break;    ÿÿÿÿ        ÿÿÿÿ                $               ÿÿÿÿ  ÿÿÿÿ     ô€       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                %               ÿÿÿÿ  ÿÿÿÿ     ô(       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                &      ó      ó      ñÿÿÿÿ   ñÿÿÿÿ     ôˆ       statement executed        return 1;    óÿÿÿÿ   ñ      óÿÿÿÿ   ñ              '      ñ      ñ      ïÿÿÿÿ   ïÿÿÿÿ     ô†Ğ       statement executed        }    ñÿÿÿÿ   ï      ñÿÿÿÿ   ï              (      ì      ì      êÿÿÿÿ   êÿÿÿÿ     ô‚à       statement executed        }    ìÿÿÿÿ   ê      ìÿÿÿÿ   ê              )      ß      ß      İÿÿÿÿ   İÿÿÿÿ     ôu¨       statement executed        }    ßÿÿÿÿ   İ      ßÿÿÿÿ   İ              *      Ş   	   Ş   
   Üÿÿÿÿ   Üÿÿÿÿ     ôsè       statement executed        }    Şÿÿÿÿ   Ü   	   Şÿÿÿÿ   Ü   
           +      Û      Û      Ùÿÿÿÿ   Ùÿÿÿÿ     ôpà       statement executed        }    Ûÿÿÿÿ   Ù      Ûÿÿÿÿ   Ù              ,      ×      ×      Õÿÿÿÿ   Õÿÿÿÿ     ôoˆ       statement executed        }    ×ÿÿÿÿ   Õ      ×ÿÿÿÿ   Õ              -      Æ      Æ      Äÿÿÿÿ   Äÿÿÿÿ     ôa€       statement executed        }    Æÿÿÿÿ   Ä      Æÿÿÿÿ   Ä              .      ¹      ¹      ·ÿÿÿÿ   ·ÿÿÿÿ     ô?       statement executed        }    ¹ÿÿÿÿ   ·      ¹ÿÿÿÿ   ·              /      ¦   	   ¦   
   ¤ÿÿÿÿ   ¤ÿÿÿÿ     ô(ğ       statement executed        }    ¦ÿÿÿÿ   ¤   	   ¦ÿÿÿÿ   ¤   
           0      ¢   	   ¢   
    ÿÿÿÿ    ÿÿÿÿ     ô$˜       statement executed        }    ¢ÿÿÿÿ       	   ¢ÿÿÿÿ       
           1      i   	   i      gÿÿÿÿ   gÿÿÿÿ    &®       statement executed        return 0;    iÿÿÿÿ   g   	   iÿÿÿÿ   g              2      e   	   e      cÿÿÿÿ   cÿÿÿÿ    &­0       statement executed        return 1;    eÿÿÿÿ   c   	   eÿÿÿÿ   c              3      W      W      Uÿÿÿÿ   Uÿÿÿÿ    &©ğ       statement executed        return (*this);    Wÿÿÿÿ   U      Wÿÿÿÿ   U              4      ;      ;      9ÿÿÿÿ   9ÿÿÿÿ    (şè       statement executed        }    ;ÿÿÿÿ   9      ;ÿÿÿÿ   9              5      2      2      0ÿÿÿÿ   0ÿÿÿÿ    (ı       statement executed        }    2ÿÿÿÿ   0      2ÿÿÿÿ   0           CSignal::CSignal CSignal::CSignal()    &      2      $ÿÿÿÿ   0ÿÿÿÿCSignal::~CSignal CSignal::~CSignal()    :      ;      8ÿÿÿÿ   9ÿÿÿÿCSignal::operator= CSignal& CSignal::operator=(CSignal& signal)    E      X      Cÿÿÿÿ   VÿÿÿÿCSignal::operator== int CSignal::operator==(const CSignal& signal)    b      k      `ÿÿÿÿ   iÿÿÿÿCSignal::Format int CSignal::Format(char* pcLine)    v      ô      tÿÿÿÿ   òÿÿÿÿCSignal::Validate unsigned int CSignal::Validate()    ş     ?      üÿÿÿÿ  =ÿÿÿÿCSignal::WriteSignaltofile bool CSignal::WriteSignaltofile(fstream& fileOutput)   J     k     Hÿÿÿÿ  iÿÿÿÿCSignal::GetErrorString void CSignal::GetErrorString(string& str)   t     ƒ     rÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Signal.cpp
 * \brief     Implementation of the CSignal class.
 * \authors   Mahesh.B.S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the CSignal class.
 */

/* Project inclues */
#include "Converter.h"
#include "Signal.h"
#include "Utility.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CSignal
 */
CSignal::CSignal()
{
    m_ucLength = 1; // minimum signal length should be 1 bit
    m_ucWhichByte = 1; // ONE based index
    m_ucStartBit = 0; // ZERO based index
    m_ucType = SIG_TYPE_BOOL; // let default be bool type -- match with default length
    m_MaxValue.uiValue = 1; // use unsigned int field for bool also
    m_MinValue.uiValue = 0; //
    m_ucDataFormat = SIG_DF_INTEL;
    m_fOffset = 0.0f;
    m_fScaleFactor = 1.0f;
    m_uiError = SIG_EC_NO_ERR;
    m_listValueDescriptor.clear();
}

/**
 * \brief Destructor
 *
 * Destructor of CSignal
 */
CSignal::~CSignal()
{
}

/**
 * \brief     Overloaded operator =
 * \param[in] signal Object to copy content from
 * \return    Local object with new contents
 *
 * Copies the contents of signal into the local object.
 */
CSignal& CSignal::operator=(CSignal& signal)
{
    // copy all the data members except the list
    m_sName = signal.m_sName;
    m_sMultiplex = signal.m_sMultiplex;
    m_ucLength = signal.m_ucLength;
    m_ucWhichByte = signal.m_ucWhichByte;
    m_ucStartBit = signal.m_ucStartBit;
    m_ucType = signal.m_ucType;
    m_MaxValue = signal.m_MaxValue;
    m_MinValue = signal.m_MinValue;
    m_ucDataFormat = signal.m_ucDataFormat;
    m_fOffset = signal.m_fOffset;
    m_fScaleFactor = signal.m_fScaleFactor;
    m_sUnit = signal.m_sUnit;
    m_sNode = signal.m_sNode;
    m_uiError = signal.m_uiError;
    //  now copy the list
    m_listValueDescriptor = signal.m_listValueDescriptor;
    return (*this);
}

/**
 * \brief     Operator==
 * \param[in] signal Reference signal
 * \return    1 if identical, 0 if not.
 *
 * Compare content of signal with local object.
 */
int CSignal::operator==(const CSignal& signal) const
{
    if (m_sName == signal.m_sName)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/**
 * \brief     Extracts the signal data from the given Line
 * \param[in] pcLine The given line
 * \return    Return code
 *
 * Extracts the signal data from the given Line and populates
 * message structure.
 */
int CSignal::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    char acTemp[defCON_MAX_TOKN_LEN],*pcTemp;
    pcTemp = acTemp;
    // get signal name
    pcToken = strtok_s(pcLine, ",", &pcNextToken); // get upto colon
    // now get the signal name
    m_sName = pcToken; // copy the name to the signal's data member
    // Signal length
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_ucLength = atoi(pcToken); // store signal length
    // get which byte
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_ucWhichByte = atoi(pcToken);
    // get start bit
    unsigned int ucStartBit;
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_ucStartBit = atoi(pcToken);
    ucStartBit = m_ucStartBit + (m_ucWhichByte - 1) * 8;
    //get Data type
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_ucType = *pcToken;
    // get MAX
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    // now store as double until we parse till SIG_VALTYPE_
    m_MaxValue.ui64Value = _strtoui64(pcToken, NULL, 10);
    // get MIN value
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    //venkat - unsiged __int64 is enough to store any value
    m_MinValue.ui64Value = _strtoui64(pcToken, NULL, 10);
    // get DATA_FORMAT (intel or motorola)
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_ucDataFormat = *pcToken;

    if(m_ucDataFormat == '0')
    {
        unsigned int nByte = (m_ucLength/8) + ((m_ucLength % 8)?1:0);
        unsigned int nStartBit = (m_ucWhichByte - nByte) * 8;
        unsigned int nBitSize = m_ucLength - (8 * (nByte - 1))+ m_ucStartBit;

        if(nBitSize == 0)
        {
            ucStartBit = ucStartBit + m_ucLength;
        }
        else
        {
            ucStartBit = nStartBit + nBitSize-1;
        }
    }

    m_ucStartBit = ucStartBit;
    // next token - (SCALE_FACTOR,OFFSET)
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_fOffset = (float)atof(pcToken); // store scale factor
    // Get offset
    pcToken = strtok_s(NULL, ",", &pcNextToken);
    m_fScaleFactor = (float)atof(pcToken); // store Offset
    // next token -- "UNIT", ""
    pcTemp = acTemp;
    pcToken = strtok_s(NULL, "", &pcNextToken);

    //pcToken++;
    // copy everything, but not including the last <">
    while(*pcToken && *pcToken != ',' && *pcToken != 0xa)
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    string strUnit_Temp = acTemp;
    m_sUnit = "\"";
    m_sUnit = m_sUnit + acTemp; // copy UNIT to corresponding data member.
    m_sUnit = m_sUnit + "\"";

    if(strUnit_Temp.length() > defCON_MAX_MSGN_LEN + 2)
    {
        CConverter::fileLog << "unit " << strUnit_Temp;
        CConverter::fileLog << " changed to " << m_sUnit << endl;
        CConverter::bLOG_ENTERED = true;
    }

    //for multiplexing field
    string strTemp = pcToken;
    int nIndex = strTemp.find(',');

    if(nIndex != -1)
    {
        int nLength = strTemp.length();
        strTemp = strTemp.substr(nLength - nIndex - 1, nIndex);
        nIndex = strTemp.find(',');

        if(nIndex != -1)
        {
            if(nIndex != 0)
            {
                strTemp = strTemp.substr(0, nIndex-1);
            }
            else
            {
                strTemp.empty();
            }

            m_sMultiplex = strTemp;
        }
    }

    //rx'ing nodes
    string strNodes = pcToken;
    nIndex = strNodes.find(",", 0);
    strNodes = strNodes.substr(nIndex+1);
    nIndex = strNodes.find(",", nIndex);
    strNodes = strNodes.substr(nIndex+1);
    m_sNode = strNodes;

    while ((nIndex = m_sNode.find('\n', 0)) != string::npos)
    {
        m_sNode.replace(nIndex, 1, " ");
    }

    if(m_sNode.length() == 0)
    {
        m_sNode = "Vector__XXX";
    }

    return 1;
}

/**
 * \brief  Validates the signal
 * \return Content of m_uiError
 *
 * Validates the signal , sets the Max and Min value to the data type
 * and if any error sets the error variable accordingly.
 */
unsigned int CSignal::Validate()
{
    // data format mismatch with previous signal

    // if more than 64 bits should be discarded
    /*
	if(m_ucLength > 64)
    {
        return (m_uiError = SIG_EC_LENGTH_ERR);
    }

    // validate start bit and byte
    if(m_ucStartBit > 63)
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }*/

    // errors eliminated now do necessary conversions
    if(m_ucLength == 1) // single bit - change type to bool
    {
        m_ucType = SIG_TYPE_BOOL;
    }

    // update MAX value and MIN value based on type
    switch(m_ucType)
    {
        case SIG_TYPE_BOOL:
        case SIG_TYPE_UINT:
        case SIG_TYPE_UINT64:
            unConvertRawToPhysical(m_MaxValue.ui64Value, m_MinValue.ui64Value, m_fOffset, m_fScaleFactor, m_MaxValue.dValue, m_MinValue.dValue);
            break;

        case SIG_TYPE_INT:
        case SIG_TYPE_INT64:
            nConvertRawToPhysical(m_MaxValue.ui64Value, m_MinValue.ui64Value, m_fOffset, m_fScaleFactor, m_MaxValue.dValue, m_MinValue.dValue);
            break;

        default:
            break;
    }

    // correct value descriptors according to type of signal
    list<CValueDescriptor>::iterator rValDesc;

    for(rValDesc=m_listValueDescriptor.begin(); rValDesc!=m_listValueDescriptor.end(); ++rValDesc)
    {
        switch(m_ucType)
        {
            case SIG_TYPE_INT:
            case SIG_TYPE_FLOAT:
            case SIG_TYPE_DOUBLE:
            case SIG_TYPE_INT64:
                break;

            case SIG_TYPE_BOOL:
            case SIG_TYPE_UINT:
            case SIG_TYPE_UINT64:
                rValDesc->m_value.ui64Value = (unsigned long long int)rValDesc->m_value.i64Value;
                break;

            default:
                break;
        }
    }

    return (m_uiError = SIG_EC_NO_ERR);
}

/**
 * \brief     Writes the signal in the CANoe format
 * \param[in] fileOutput Output file
 * \return    Return code
 *
 * Writes the signal in the CANoe format and returns false
 * if any of the error signal is not stored in the file
 */
bool CSignal::WriteSignaltofile(fstream& fileOutput)
{
    bool bResult = true;

    if(m_uiError == SIG_EC_NO_ERR)
    {
        fileOutput << " SG_ " << m_sName;
        fileOutput << " " << m_sMultiplex;
        fileOutput << ": " << dec << m_ucStartBit;
        fileOutput << "|" << dec << m_ucLength;
        fileOutput << "@" << m_ucDataFormat;

        if ((m_ucType == SIG_TYPE_UINT) || (m_ucType == SIG_TYPE_UINT64))
        {
            fileOutput << "+";
        }
        else
        {
            fileOutput << "-";
        }

        fileOutput << " (" << m_fScaleFactor;
        fileOutput << "," << m_fOffset;
        fileOutput << ") [" << m_MinValue.dValue;
        fileOutput << "|" << m_MaxValue.dValue;
        fileOutput << "] " << m_sUnit;
        fileOutput << " " << m_sNode << endl;
    }
    else
    {
        bResult = false;
    }

    return bResult;
}

/**
 * \brief      Returns the error string of the signal
 * \param[out] str Error string depending on m_uiError
 *
 * Returns the error string of the signal.
 */
void CSignal::GetErrorString(string& str)
{
    switch(m_uiError)
    {
        case 0:
            str = "No error";
            break;

        case 1:
            str = "Invalid signal length";
            break;

        case 2:
            str = "Invalid start bit";
            break;
    }
}






































unsigned int unConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, unsigned long long int& unMaxVal, unsigned long long int& unMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    unMaxVal = (unsigned long long int)unRoundOffdoubleValue(dTempMaxVal);
    unMinVal = (unsigned long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}













int nConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, long long int& nMaxVal, long long int& nMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    nMaxVal = (long long int)unRoundOffdoubleValue(dTempMaxVal);
    nMinVal = (long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}













unsigned int unConvertRawToPhysical(unsigned long long int unMaxRawVal, unsigned long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}













int nConvertRawToPhysical(long long int unMaxRawVal, long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}









unsigned long long int unRoundOffdoubleValue(double dValue)
{
    unsigned long long int unVal = (unsigned long long int)dValue;
    double dTempVal = dValue - (double)unVal;

    if(dTempVal >= 0.5)
    {
        unVal++;
    }

    return unVal;
}
          …      …      „ÿÿÿÿ   „ÿÿÿÿ     4mP      expression was false       dTempVal >= 0.5    …ÿÿÿÿ   „      …ÿÿÿÿ   „                   4kH         Š      Š      ‰ÿÿÿÿ   ‰ÿÿÿÿ    &£       statement executed        return unVal;    Šÿÿÿÿ   ‰      Šÿÿÿÿ   ‰                    ˆ      ˆ      ‡ÿÿÿÿ   ‡ÿÿÿÿ     4lx       statement executed        }    ˆÿÿÿÿ   ‡      ˆÿÿÿÿ   ‡                    u      u      tÿÿÿÿ   tÿÿÿÿ     4a°       statement executed        return 0;    uÿÿÿÿ   t      uÿÿÿÿ   t                    \      \      [ÿÿÿÿ   [ÿÿÿÿ    (q       statement executed        return 0;    \ÿÿÿÿ   [      \ÿÿÿÿ   [                    C      C      Bÿÿÿÿ   Bÿÿÿÿ    (‡        statement executed        return 0;    Cÿÿÿÿ   B      Cÿÿÿÿ   B                    .      .      -ÿÿÿÿ   -ÿÿÿÿ    (ŠÀ       statement executed        return 0;    .ÿÿÿÿ   -      .ÿÿÿÿ   -           unConvertPhysicalToRaw unsigned int unConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, unsigned long long int& unMaxVal, unsigned long long int& unMinVal)    )      /      (ÿÿÿÿ   .ÿÿÿÿnConvertPhysicalToRaw int nConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, long long int& nMaxVal, long long int& nMinVal)    >      D      =ÿÿÿÿ   CÿÿÿÿunConvertRawToPhysical unsigned int unConvertRawToPhysical(unsigned long long int unMaxRawVal, unsigned long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)    S      ]      Rÿÿÿÿ   \ÿÿÿÿnConvertRawToPhysical int nConvertRawToPhysical(long long int unMaxRawVal, long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)    l      v      kÿÿÿÿ   uÿÿÿÿunRoundOffdoubleValue unsigned long long int unRoundOffdoubleValue(double dValue)          ‹      €ÿÿÿÿ   Šÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Utility.cpp
 * \brief     Defines Global Utility functions
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines Global Utility functions
 */

/* Project includes */
#include "Utility.h"

/**
 * \brief      Converts the double physical values to unsigned long long int values
 * \param[in]  dMaxVal Maximum physical value
 * \param[in]  dMinVal Minimum physical value
 * \param[in]  dOffset Offset value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] unMaxVal Maximum vlaue
 * \param[out] unMinVal Minimum value
 * \return     Return code
 *
 * Converts the double physical values to unsigned long long int values
 */
unsigned int unConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, unsigned long long int& unMaxVal, unsigned long long int& unMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    unMaxVal = (unsigned long long int)unRoundOffdoubleValue(dTempMaxVal);
    unMinVal = (unsigned long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}

/**
 * \brief      Converts the double physical values to long long int values
 * \param[in]  dMaxVal Maximum physical value
 * \param[in]  dMinVal Minimum physical value
 * \param[in]  dOffset Offset Value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] nMaxVal Maximum value
 * \param[out] nMinVal Minimum value
 * \return     Status code
 *
 * Converts the double physical values to long long int values
 */
int nConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, long long int& nMaxVal, long long int& nMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    nMaxVal = (long long int)unRoundOffdoubleValue(dTempMaxVal);
    nMinVal = (long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}

/**
 * \brief      Converts the double physical values to long long int values
 * \param[in]  unMaxRawVal Maximum raw value
 * \param[in]  unMinRawVal Minimum raw value
 * \param[in]  dOffset Offset Value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] dMaxPhyVal Maximum physical vlaue
 * \param[out] dMinPhyVal Minimum physical vlaue
 * \return     Status code
 *
 * Converts the double physical values to long long int values.
 */
unsigned int unConvertRawToPhysical(unsigned long long int unMaxRawVal, unsigned long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    //Maximum value
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    //Minimum value
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}

/**
 * \brief      Converts the double physical values to long long int raw values
 * \param[in]  unMaxRawVal Maximum raw value
 * \param[in]  unMinRawVal Minimum raw value
 * \param[in]  dOffset Offset Value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] dMaxPhyVal Maximum physical vlaue
 * \param[out] dMinPhyVal Minimum physical vlaue
 * \return     Status code
 *
 * Converts the double physical values to long long int raw values.
 */
int nConvertRawToPhysical(long long int unMaxRawVal, long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    //Maximum value
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    //Minimum value
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}

/**
 * \brief      This function will convert the double value to unsigned long long int.
 * \param[in]  dValue double Value
 * \return     unsigned long long int Value
 *
 * This function will convert the double value to unsigned long long int.
 * If the double value precision is more than 0.5 the unit value will be added 1.
 */
unsigned long long int unRoundOffdoubleValue(double dValue)
{
    unsigned long long int unVal = (unsigned long long int)dValue;
    double dTempVal = dValue - (double)unVal;

    if(dTempVal >= 0.5)
    {
        unVal++;
    }

    return unVal;
}




























using namespace std;






CValueDescriptor::CValueDescriptor()
{
    m_value.iValue = 1;
    m_value.uiValue = 1;
    m_value.fValue = 1;
    m_value.dValue = 1;
    m_value.cValue = "";
    m_value.i64Value = 1;
    m_value.ui64Value = 1;
}






CValueDescriptor::~CValueDescriptor()
{
}









int CValueDescriptor::Format(char* pcLine)
{
    char acValue[256] = {'\0'};
    char acDesc[256] = {'\0'};
    char* pcValue = acValue;
    char* pcDesc = acDesc;
    pcValue = acValue;
    pcDesc = acDesc;

    
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    
    while(*pcLine && *pcLine == '\"')
    {
        if(*pcLine == '\"')
        {
            *pcLine++;
            break;
        }

        *pcLine++;
    }

    if(*pcLine != '\"')
        while(*pcLine && *pcLine != '\"')
        {
            *pcDesc++ = *pcLine;
            pcLine++;
        }

    *pcDesc = '\0';
    pcLine++;

    
    while(*pcLine && *pcLine == ',')
    {
        *pcLine++;
    }

    while(*pcLine && *pcLine != ' ')
    {
        *pcValue++ = *pcLine++; 
    }

    *pcValue = '\0'; 
    
    m_value.i64Value = _atoi64(acValue);
    m_sDescriptor = acDesc;
    return 1;
}









void CValueDescriptor::writeValueDescToFile(fstream& fileOutput,char m_ucType,list<CValueDescriptor> &m_listValueDescriptor)
{
    list<CValueDescriptor>::iterator rValDesc;

    for(rValDesc=m_listValueDescriptor.begin(); rValDesc!=m_listValueDescriptor.end(); ++rValDesc)
    {
        switch(m_ucType)
        {
            case CSignal::SIG_TYPE_INT:
            case CSignal::SIG_TYPE_FLOAT:
            case CSignal::SIG_TYPE_DOUBLE:
            case CSignal::SIG_TYPE_INT64:
                fileOutput << dec << rValDesc->m_value.i64Value;
                fileOutput << " \"" << rValDesc->m_sDescriptor.c_str() << "\" ";
                break;

            case CSignal::SIG_TYPE_BOOL:
            case CSignal::SIG_TYPE_UINT:
            case CSignal::SIG_TYPE_UINT64:
                fileOutput << dec << rValDesc->m_value.ui64Value;
                fileOutput << " \"" << rValDesc->m_sDescriptor.c_str() << "\" ";
                break;

            default:
                break;
        }
    }

    fileOutput << ";" << endl;
    return;
}
          ]      ]      \ÿÿÿÿ   \ÿÿÿÿ    )8      expression was true       *pcLine    ]ÿÿÿÿ   \      ]ÿÿÿÿ   \      expression was false       *pcLine    ]ÿÿÿÿ   \      ]ÿÿÿÿ   \                    Q      Q   %   Pÿÿÿÿ   Pÿÿÿÿ     ô[¨      expression was true       *pcLine == '\"'    Qÿÿÿÿ   P      Qÿÿÿÿ   P   %   expression was false       *pcLine == '\"'    Qÿÿÿÿ   P      Qÿÿÿÿ   P   %                ôYø         Q      Q      Pÿÿÿÿ   Pÿÿÿÿ     ôZĞ      expression was true       *pcLine    Qÿÿÿÿ   P      Qÿÿÿÿ   P      expression was false       *pcLine    Qÿÿÿÿ   P      Qÿÿÿÿ   P                    K      K   $   Jÿÿÿÿ   Jÿÿÿÿ     ôV(      expression was true       *pcLine == ' '    Kÿÿÿÿ   J      Kÿÿÿÿ   J   $   expression was false       *pcLine == ' '    Kÿÿÿÿ   J      Kÿÿÿÿ   J   $                ôTx         K      K      Jÿÿÿÿ   Jÿÿÿÿ     ôUP      expression was true       *pcLine    Kÿÿÿÿ   J      Kÿÿÿÿ   J      expression was false       *pcLine    Kÿÿÿÿ   J      Kÿÿÿÿ   J              
      „   1   „   V   ƒÿÿÿÿ   ƒÿÿÿÿ     6Î(      expression was false       rValDesc!=m_listValueDescriptor.end()    „ÿÿÿÿ   ƒ   1   „ÿÿÿÿ   ƒ   V                6Ä˜         ]      ]   )   \ÿÿÿÿ   \ÿÿÿÿ    )      expression was true       *pcLine != '\"'    ]ÿÿÿÿ   \      ]ÿÿÿÿ   \   )   expression was false       *pcLine != '\"'    ]ÿÿÿÿ   \      ]ÿÿÿÿ   \   )               )`         g      g      fÿÿÿÿ   fÿÿÿÿ    (€      expression was true       *pcLine    gÿÿÿÿ   f      gÿÿÿÿ   f      expression was false       *pcLine    gÿÿÿÿ   f      gÿÿÿÿ   f                    g      g   $   fÿÿÿÿ   fÿÿÿÿ    (‚X      expression was true       *pcLine == ','    gÿÿÿÿ   f      gÿÿÿÿ   f   $   expression was false       *pcLine == ','    gÿÿÿÿ   f      gÿÿÿÿ   f   $               (€¨         l      l      kÿÿÿÿ   kÿÿÿÿ    (‡       expression was true       *pcLine    lÿÿÿÿ   k      lÿÿÿÿ   k      expression was false       *pcLine    lÿÿÿÿ   k      lÿÿÿÿ   k                    l      l   $   kÿÿÿÿ   kÿÿÿÿ    (‡Ø      expression was true       *pcLine != ' '    lÿÿÿÿ   k      lÿÿÿÿ   k   $   expression was false       *pcLine != ' '    lÿÿÿÿ   k      lÿÿÿÿ   k   $               (†(         \      \      [ÿÿÿÿ   [ÿÿÿÿ    )Ğ      expression was false       *pcLine != '\"'    \ÿÿÿÿ   [      \ÿÿÿÿ   [                  )ˆ         S      S      Rÿÿÿÿ   Rÿÿÿÿ    )       expression was false       *pcLine == '\"'    Sÿÿÿÿ   R      Sÿÿÿÿ   R                  )¨                     œÿÿÿÿ   œÿÿÿÿ    &ĞX       statement executed        return;    ÿÿÿÿ   œ      ÿÿÿÿ   œ                    š      š      ™ÿÿÿÿ   ™ÿÿÿÿ     6ÍP       statement executed        }    šÿÿÿÿ   ™      šÿÿÿÿ   ™                    ˜      ˜      —ÿÿÿÿ   —ÿÿÿÿ     6Ìx       statement executed        break;    ˜ÿÿÿÿ   —      ˜ÿÿÿÿ   —                    •      •      ”ÿÿÿÿ   ”ÿÿÿÿ     6Ë        statement executed        break;    •ÿÿÿÿ   ”      •ÿÿÿÿ   ”                    .      .      -ÿÿÿÿ   -ÿÿÿÿ    )š       statement executed        }    .ÿÿÿÿ   -      .ÿÿÿÿ   -                    7      7      6ÿÿÿÿ   6ÿÿÿÿ    )œ       statement executed        }    7ÿÿÿÿ   6      7ÿÿÿÿ   6                    N      N      Mÿÿÿÿ   Mÿÿÿÿ     ôX8       statement executed        }    Nÿÿÿÿ   M      Nÿÿÿÿ   M                    V      V      Uÿÿÿÿ   Uÿÿÿÿ    )È       statement executed        break;    Vÿÿÿÿ   U      Vÿÿÿÿ   U                    Z      Z      Yÿÿÿÿ   Yÿÿÿÿ    )È       statement executed        }    Zÿÿÿÿ   Y      Zÿÿÿÿ   Y                     a   	   a   
   `ÿÿÿÿ   `ÿÿÿÿ    )8       statement executed        }    aÿÿÿÿ   `   	   aÿÿÿÿ   `   
           !      j      j      iÿÿÿÿ   iÿÿÿÿ    („h       statement executed        }    jÿÿÿÿ   i      jÿÿÿÿ   i              "      o      o      nÿÿÿÿ   nÿÿÿÿ    (ŠÀ       statement executed        }    oÿÿÿÿ   n      oÿÿÿÿ   n              #      u      u      tÿÿÿÿ   tÿÿÿÿ     6Á        statement executed        return 1;    uÿÿÿÿ   t      uÿÿÿÿ   t              $                  ÿÿÿÿ   ÿÿÿÿ     6ÈX       statement executed        break;    ÿÿÿÿ         ÿÿÿÿ              CValueDescriptor::CValueDescriptor CValueDescriptor::CValueDescriptor()    &      .      %ÿÿÿÿ   -ÿÿÿÿCValueDescriptor::~CValueDescriptor CValueDescriptor::~CValueDescriptor()    6      7      5ÿÿÿÿ   6ÿÿÿÿCValueDescriptor::Format int CValueDescriptor::Format(char* pcLine)    B      v      Aÿÿÿÿ   uÿÿÿÿCValueDescriptor::writeValueDescToFile void CValueDescriptor::writeValueDescToFile(fstream& fileOutput,char m_ucType,list<CValueDescriptor> &m_listValueDescriptor)                €ÿÿÿÿ   ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ValueDescriptor.cpp
 * \brief     Implementation of the CValueDescriptor class.
 * \authors   Mahesh.B.S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the CValueDescriptor class.
 */

/* Project includes */
#include "Converter.h"
#include "Signal.h"
#include "ValueDescriptor.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CValueDescriptor
 */
CValueDescriptor::CValueDescriptor()
{
    m_value.iValue = 1;
    m_value.uiValue = 1;
    m_value.fValue = 1;
    m_value.dValue = 1;
    m_value.cValue = "";
    m_value.i64Value = 1;
    m_value.ui64Value = 1;
}

/**
 * \brief Destructor
 *
 * Destructor of CValueDescriptor
 */
CValueDescriptor::~CValueDescriptor()
{
}

/**
 * \brief      Extracts the Value Descriptor pair from the given Line
 * \param[in]  pcLine The given line
 * \return     Status code
 *
 * Extracts the Value Descriptor pair from the given Line
 * and creates a list of the same
 */
int CValueDescriptor::Format(char* pcLine)
{
    char acValue[256] = {'\0'};
    char acDesc[256] = {'\0'};
    char* pcValue = acValue;
    char* pcDesc = acDesc;
    pcValue = acValue;
    pcDesc = acDesc;

    // skip leading spaces
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    // skip leading '"'
    while(*pcLine && *pcLine == '\"')
    {
        if(*pcLine == '\"')
        {
            *pcLine++;
            break;
        }

        *pcLine++;
    }

    if(*pcLine != '\"')
        while(*pcLine && *pcLine != '\"')
        {
            *pcDesc++ = *pcLine;
            pcLine++;
        }

    *pcDesc = '\0';
    pcLine++;

    // skip spaces if any before next iteration.
    while(*pcLine && *pcLine == ',')
    {
        *pcLine++;
    }

    while(*pcLine && *pcLine != ' ')
    {
        *pcValue++ = *pcLine++; // copy all but terminating space
    }

    *pcValue = '\0'; // terminate the string
    // if any value read then add it to list
    m_value.i64Value = _atoi64(acValue);
    m_sDescriptor = acDesc;
    return 1;
}

/**
 * \brief     Writes the Value Descriptor in the CANoe format
 * \param[in] fileOutput Output file
 * \param[in] m_ucType Value Descriptor Type
 * \param[in] m_listValueDescriptor List of Value Descriptors
 *
 * Writes the Value Descriptor in the CANoe format in the output file
 */
void CValueDescriptor::writeValueDescToFile(fstream& fileOutput,char m_ucType,list<CValueDescriptor> &m_listValueDescriptor)
{
    list<CValueDescriptor>::iterator rValDesc;

    for(rValDesc=m_listValueDescriptor.begin(); rValDesc!=m_listValueDescriptor.end(); ++rValDesc)
    {
        switch(m_ucType)
        {
            case CSignal::SIG_TYPE_INT:
            case CSignal::SIG_TYPE_FLOAT:
            case CSignal::SIG_TYPE_DOUBLE:
            case CSignal::SIG_TYPE_INT64:
                fileOutput << dec << rValDesc->m_value.i64Value;
                fileOutput << " \"" << rValDesc->m_sDescriptor.c_str() << "\" ";
                break;

            case CSignal::SIG_TYPE_BOOL:
            case CSignal::SIG_TYPE_UINT:
            case CSignal::SIG_TYPE_UINT64:
                fileOutput << dec << rValDesc->m_value.ui64Value;
                fileOutput << " \"" << rValDesc->m_sDescriptor.c_str() << "\" ";
                break;

            default:
                break;
        }
    }

    fileOutput << ";" << endl;
    return;
}




























using namespace std;






CValueTable::CValueTable()
{
    m_TableName[0] = '\0';
}






CValueTable::~CValueTable()
{
}








CValueTable& CValueTable::operator=(CValueTable& Tab)
{
    m_TableName = Tab.m_TableName;
    list<CValueDescriptor>::iterator vDisp;

    for(vDisp=Tab.m_values.begin(); vDisp!=Tab.m_values.end(); ++vDisp)
    {
        m_values.push_back(*vDisp);
    }

    return (*this);
}








void CValueTable::Format_ValueTable(char* pcLine, fstream& fileInput)
{
    char* pcToken;
    char* pcNextToken;
    char acLine[1026] = {'\0'};

    
    while(*pcLine && *pcLine==' ')
    {
        *pcLine++;
    }

    pcToken = strtok_s(pcLine, "\n", &pcNextToken);
    
    m_TableName = pcToken;

    
    while(fileInput.getline(acLine, 1026) && strcmp(acLine,"[END_TABLE]")!=0)
    {
        pcLine=acLine;

        
        while(*pcLine && *pcLine==' ')
        {
            *pcLine++;
        }

        
        pcToken = strtok_s(pcLine, " ", &pcNextToken);

        if(strcmp(pcToken,"[VALUE_DESCRIPTION]")==0)
        {
            pcToken=strtok_s(0, "\"", &pcNextToken);
            CValueDescriptor valDesc;
            
            valDesc.m_sDescriptor =pcToken;
            pcToken = strtok_s(0, ",", &pcNextToken);
            valDesc.m_value.i64Value = atoi(pcToken);
            m_values.push_back(valDesc);
        }
    }
}








void CValueTable::writeValueTabToFile(fstream& fileOutput,list<CValueTable> &vTab)
{
    list<CValueTable>::iterator tab;

    
    
    for(tab = vTab.begin(); tab != vTab.end(); ++tab)
    {
        
        fileOutput << "VAL_TABLE_ " << tab->m_TableName << " ";
        
        CValueDescriptor desc;
        desc.writeValueDescToFile(fileOutput, CSignal::SIG_TYPE_INT64, tab->m_values);
    }
}
          _      _   *   ^ÿÿÿÿ   ^ÿÿÿÿ     íŸ      expression was true       fileInput.getline(acLine, 1026)    _ÿÿÿÿ   ^      _ÿÿÿÿ   ^   *   expression was false       fileInput.getline(acLine, 1026)    _ÿÿÿÿ   ^      _ÿÿÿÿ   ^   *                 U      U   "   Tÿÿÿÿ   Tÿÿÿÿ     4}       expression was true       *pcLine==' '    Uÿÿÿÿ   T      Uÿÿÿÿ   T   "   expression was false       *pcLine==' '    Uÿÿÿÿ   T      Uÿÿÿÿ   T   "                4{P         U      U      Tÿÿÿÿ   Tÿÿÿÿ     4|(      expression was true       *pcLine    Uÿÿÿÿ   T      Uÿÿÿÿ   T      expression was false       *pcLine    Uÿÿÿÿ   T      Uÿÿÿÿ   T                    †      †   .   …ÿÿÿÿ   …ÿÿÿÿ     í½      expression was false       tab != vTab.end()    †ÿÿÿÿ   …      †ÿÿÿÿ   …   .                í¹Ø         ?   %   ?   >   >ÿÿÿÿ   >ÿÿÿÿ     4v°      expression was false       vDisp!=Tab.m_values.end()    ?ÿÿÿÿ   >   %   ?ÿÿÿÿ   >   >                4tX         _   .   _   M   ^ÿÿÿÿ   ^ÿÿÿÿ     íŸè      expression was true       strcmp(acLine,"[END_TABLE]")!=0    _ÿÿÿÿ   ^   .   _ÿÿÿÿ   ^   M   expression was false       strcmp(acLine,"[END_TABLE]")!=0    _ÿÿÿÿ   ^   .   _ÿÿÿÿ   ^   M                í8   
      d      d      cÿÿÿÿ   cÿÿÿÿ     í¤       expression was true       *pcLine    dÿÿÿÿ   c      dÿÿÿÿ   c      expression was false       *pcLine    dÿÿÿÿ   c      dÿÿÿÿ   c                    d      d   &   cÿÿÿÿ   cÿÿÿÿ     í¤Ø      expression was true       *pcLine==' '    dÿÿÿÿ   c      dÿÿÿÿ   c   &   expression was false       *pcLine==' '    dÿÿÿÿ   c      dÿÿÿÿ   c   &                í£(         l      l   4   kÿÿÿÿ   kÿÿÿÿ     í³p      expression was false       strcmp(pcToken,"[VALUE_DESCRIPTION]")==0    lÿÿÿÿ   k      lÿÿÿÿ   k   4                íªH                     ÿÿÿÿ   ÿÿÿÿ     í¾x       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                       (      (      'ÿÿÿÿ   'ÿÿÿÿ     4n        statement executed        }    (ÿÿÿÿ   '      (ÿÿÿÿ   '                    1      1      0ÿÿÿÿ   0ÿÿÿÿ     4oè       statement executed        }    1ÿÿÿÿ   0      1ÿÿÿÿ   0                    B      B      Aÿÿÿÿ   Aÿÿÿÿ     4uØ       statement executed        }    Bÿÿÿÿ   A      Bÿÿÿÿ   A                    D      D      Cÿÿÿÿ   Cÿÿÿÿ     4w˜       statement executed        return (*this);    Dÿÿÿÿ   C      Dÿÿÿÿ   C                    X      X      Wÿÿÿÿ   Wÿÿÿÿ     4       statement executed        }    Xÿÿÿÿ   W      Xÿÿÿÿ   W                    g   	   g   
   fÿÿÿÿ   fÿÿÿÿ     í§        statement executed        }    gÿÿÿÿ   f   	   gÿÿÿÿ   f   
                 u   	   u   
   tÿÿÿÿ   tÿÿÿÿ     í²˜       statement executed        }    uÿÿÿÿ   t   	   uÿÿÿÿ   t   
                 v      v      uÿÿÿÿ   uÿÿÿÿ     í´X       statement executed        }    vÿÿÿÿ   u      vÿÿÿÿ   u                    w      w      vÿÿÿÿ   vÿÿÿÿ     í¶       statement executed        }    wÿÿÿÿ   v      wÿÿÿÿ   v                                Œÿÿÿÿ   Œÿÿÿÿ     í¼¸       statement executed        }    ÿÿÿÿ   Œ      ÿÿÿÿ   Œ           CValueTable::CValueTable CValueTable::CValueTable()    &      (      %ÿÿÿÿ   'ÿÿÿÿCValueTable::~CValueTable CValueTable::~CValueTable()    0      1      /ÿÿÿÿ   0ÿÿÿÿCValueTable::operator= CValueTable& CValueTable::operator=(CValueTable& Tab)    ;      E      :ÿÿÿÿ   DÿÿÿÿCValueTable::Format_ValueTable void CValueTable::Format_ValueTable(char* pcLine, fstream& fileInput)    O      w      Nÿÿÿÿ   vÿÿÿÿCValueTable::writeValueTabToFile void CValueTable::writeValueTabToFile(fstream& fileOutput,list<CValueTable> &vTab)                €ÿÿÿÿ   ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ValueTable.cpp
 * \brief     Implementation file for the value table.This is atable containing value discriptors.
 * \authors   Ratnadip Choudhury, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for the value table.This is atable containing value discriptors.
 */

/* Project inclues */
#include "Converter.h"
#include "Signal.h"
#include "ValueTable.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CValueTable
 */
CValueTable::CValueTable()
{
    m_TableName[0] = '\0';
}

/**
 * \brief Destructor
 *
 * Destructor of CValueTable
 */
CValueTable::~CValueTable()
{
}

/**
 * \brief     overloaded operator =
 * \param[in] Tab Object to copy data from
 * \return    Local object with new contents
 *
 * Copy contents from Tab to local object.
 */
CValueTable& CValueTable::operator=(CValueTable& Tab)
{
    m_TableName = Tab.m_TableName;
    list<CValueDescriptor>::iterator vDisp;

    for(vDisp=Tab.m_values.begin(); vDisp!=Tab.m_values.end(); ++vDisp)
    {
        m_values.push_back(*vDisp);
    }

    return (*this);
}

/**
 * \brief     extracts Values and value descriptors from the line
 * \param[in] pcLine String having the value table name followed by the value, value descriptor as in canoe format
 * \param[in] fileInput Input file
 *
 * extracts Values and value descriptors from the line
 */
void CValueTable::Format_ValueTable(char* pcLine, fstream& fileInput)
{
    char* pcToken;
    char* pcNextToken;
    char acLine[defCON_MAX_LINE_LEN] = {'\0'};

    //skip all balnk spaces.
    while(*pcLine && *pcLine==' ')
    {
        *pcLine++;
    }

    pcToken = strtok_s(pcLine, "\n", &pcNextToken);
    //get value table name.
    m_TableName = pcToken;

    //parses value table.
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN) && strcmp(acLine,"[END_TABLE]")!=0)
    {
        pcLine=acLine;

        //skip white spaces
        while(*pcLine && *pcLine==' ')
        {
            *pcLine++;
        }

        //get value descriptor.
        pcToken = strtok_s(pcLine, " ", &pcNextToken);

        if(strcmp(pcToken,"[VALUE_DESCRIPTION]")==0)
        {
            pcToken=strtok_s(NULL, "\"", &pcNextToken);
            CValueDescriptor valDesc;
            //get the descriptor value.
            valDesc.m_sDescriptor =pcToken;
            pcToken = strtok_s(NULL, ",", &pcNextToken);
            valDesc.m_value.i64Value = atoi(pcToken);
            m_values.push_back(valDesc);
        }
    }
}

/**
 * \brief     writes the value tebles in the given list to the output file.
 * \param[in] fileOutput Pointer to the Output file
 * \param[in] vTab List of Value tables
 *
 * writes the value tebles in the given list to the output file.
 */
void CValueTable::writeValueTabToFile(fstream& fileOutput,list<CValueTable> &vTab)
{
    list<CValueTable>::iterator tab;

    //get value table.
    //repeats till value tables exists in the list.
    for(tab = vTab.begin(); tab != vTab.end(); ++tab)
    {
        //write value table name to the o/p file.
        fileOutput << "VAL_TABLE_ " << tab->m_TableName << " ";
        //writes descriptors values to the o/p file.
        CValueDescriptor desc;
        desc.writeValueDescToFile(fileOutput, CSignal::SIG_TYPE_INT64, tab->m_values);
    }
}


























extern "C" int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile);






CLogAscConverter::CLogAscConverter(void)
{
}






CLogAscConverter::~CLogAscConverter(void)
{
}








HRESULT CLogAscConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the BUSMASTER CAN log file(.log) to CANoe CAN log file(.asc)";
    return ((HRESULT)0L);
}








HRESULT CLogAscConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "LOG TO ASC Conversion";
    return ((HRESULT)0L);
}









HRESULT CLogAscConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case (-2):
            m_omstrConversionStatus = "Output File path is not found";
            break;

        case (-1):
            m_omstrConversionStatus = "Input File path is not found";
            break;

        case ((HRESULT)0L):
            m_omstrConversionStatus = "Conversion success";
            break;

        case ((HRESULT)1L):
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return ((HRESULT)0L);
}










HRESULT CLogAscConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "log";
    pchInputFilters = "BUSMASTER Log File(s) (*.log)|*.log||";
    return ((HRESULT)0L);
}









HRESULT CLogAscConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return ((HRESULT)0L);
}










HRESULT CLogAscConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "asc";
    pchOutputFilters = "CANoe Log File(s) (*.asc)|*.asc||";
    return ((HRESULT)0L);
}









HRESULT CLogAscConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = ((HRESULT)0L);
    FILE* fpInputFile = 0;
    FILE* fpOutputFile = 0;
    fopen_s(&fpInputFile, chInputFile.c_str(), "r");
	
	if(0 != fpInputFile)
    {
        fopen_s(&fpOutputFile, chOutputFile.c_str(), "w");

        if(0 != fpOutputFile)
        {
            
            if (nConvertFile(fpInputFile, fpOutputFile) == -2)
			{
				m_omstrConversionStatus = "Conversion May not be work with CANoe since the input file is logged in system mode";
			}
			else
			{
				m_omstrConversionStatus = "Conversion Completed Successfully";
			}
			if(fpInputFile != 0)
			{
				fclose(fpInputFile);
				fpInputFile = 0;
			}
            if(fpOutputFile != 0)
			{
				fclose(fpOutputFile);
				fpOutputFile = 0;
			}
		}
        else
        {
			if(fpInputFile != 0)
			{
				fclose(fpInputFile);
				fpInputFile = 0;
			}
            m_omstrConversionStatus = "Output File path is not found";
            hResult = (-2);
        }
    }
    else
    {
        m_omstrConversionStatus = "Input File path is not found";
        hResult = (-1);
    }

    m_hResult = hResult;
    return hResult;
}







BOOL CLogAscConverter::bHaveOwnWindow()
{
    return 0;
}
























#pragma once






class CLogAscConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CLogAscConverter(void);
    ~CLogAscConverter(void);
    virtual HRESULT GetInputFileFilters(string&, string& );
    virtual HRESULT GetOutputFileFilters(string&, string& );
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return ((HRESULT)1L);
    };
};
          È      È      Çÿÿÿÿ   Çÿÿÿÿ    î      expression was false       fpInputFile != 0    Èÿÿÿÿ   Ç      Èÿÿÿÿ   Ç                  î›         À      À   !   ¿ÿÿÿÿ   ¿ÿÿÿÿ    î™(      expression was false       fpOutputFile != 0    Àÿÿÿÿ   ¿      Àÿÿÿÿ   ¿   !               î–0         »      »      ºÿÿÿÿ   ºÿÿÿÿ    î•      expression was false       fpInputFile != 0    »ÿÿÿÿ   º      »ÿÿÿÿ   º                  î’          ã      ã      âÿÿÿÿ   âÿÿÿÿ    ‚       statement executed        return 0;    ãÿÿÿÿ   â      ãÿÿÿÿ   â                    Ø      Ø      ×ÿÿÿÿ   ×ÿÿÿÿ    ‚
P       statement executed        return hResult;    Øÿÿÿÿ   ×      Øÿÿÿÿ   ×                    Õ      Õ      Ôÿÿÿÿ   Ôÿÿÿÿ    ‚H       statement executed        }    Õÿÿÿÿ   Ô      Õÿÿÿÿ   Ô                    Ï   	   Ï   
   Îÿÿÿÿ   Îÿÿÿÿ    ‚`       statement executed        }    Ïÿÿÿÿ   Î   	   Ïÿÿÿÿ   Î   
                 Ì      Ì      Ëÿÿÿÿ   Ëÿÿÿÿ    î8       statement executed        }    Ìÿÿÿÿ   Ë      Ìÿÿÿÿ   Ë                    Å      Å      Äÿÿÿÿ   Äÿÿÿÿ    îš       statement executed        }    Åÿÿÿÿ   Ä      Åÿÿÿÿ   Ä              	      Ä      Ä      Ãÿÿÿÿ   Ãÿÿÿÿ    î˜P       statement executed        }    Äÿÿÿÿ   Ã      Äÿÿÿÿ   Ã              
      ¿      ¿      ¾ÿÿÿÿ   ¾ÿÿÿÿ    î”@       statement executed        }    ¿ÿÿÿÿ   ¾      ¿ÿÿÿÿ   ¾                    º      º      ¹ÿÿÿÿ   ¹ÿÿÿÿ    îˆ       statement executed        }    ºÿÿÿÿ   ¹      ºÿÿÿÿ   ¹                    ¶      ¶      µÿÿÿÿ   µÿÿÿÿ     -ı°       statement executed        }    ¶ÿÿÿÿ   µ      ¶ÿÿÿÿ   µ                    š      š      ™ÿÿÿÿ   ™ÿÿÿÿ     -ñH       statement executed        return ((HRESULT)0L);    šÿÿÿÿ   ™      šÿÿÿÿ   ™                    Š      Š      ‰ÿÿÿÿ   ‰ÿÿÿÿ    ÆÈ       statement executed        return ((HRESULT)0L);    Šÿÿÿÿ   ‰      Šÿÿÿÿ   ‰                    {      {      zÿÿÿÿ   zÿÿÿÿ    ÆÃà       statement executed        return ((HRESULT)0L);    {ÿÿÿÿ   z      {ÿÿÿÿ   z                    k      k      jÿÿÿÿ   jÿÿÿÿ    ÆÀ       statement executed        return ((HRESULT)0L);    kÿÿÿÿ   j      kÿÿÿÿ   j                    h      h      gÿÿÿÿ   gÿÿÿÿ    íIÀ       statement executed        break;    hÿÿÿÿ   g      hÿÿÿÿ   g                    d      d      cÿÿÿÿ   cÿÿÿÿ    íGÀ       statement executed        break;    dÿÿÿÿ   c      dÿÿÿÿ   c                    `      `      _ÿÿÿÿ   _ÿÿÿÿ    íEÀ       statement executed        break;    `ÿÿÿÿ   _      `ÿÿÿÿ   _                    \      \      [ÿÿÿÿ   [ÿÿÿÿ    íCÀ       statement executed        break;    \ÿÿÿÿ   [      \ÿÿÿÿ   [                    X      X      Wÿÿÿÿ   Wÿÿÿÿ    íAÀ       statement executed        break;    Xÿÿÿÿ   W      Xÿÿÿÿ   W                    G      G      Fÿÿÿÿ   Fÿÿÿÿ    /7       statement executed        return ((HRESULT)0L);    Gÿÿÿÿ   F      Gÿÿÿÿ   F                    :      :      9ÿÿÿÿ   9ÿÿÿÿ    /3Ø       statement executed        return ((HRESULT)0L);    :ÿÿÿÿ   9      :ÿÿÿÿ   9                    .      .      -ÿÿÿÿ   -ÿÿÿÿ     ûb        statement executed        }    .ÿÿÿÿ   -      .ÿÿÿÿ   -                    %      %      $ÿÿÿÿ   $ÿÿÿÿ     ûep       statement executed        }    %ÿÿÿÿ   $      %ÿÿÿÿ   $                    2   	   2      1ÿÿÿÿ   1ÿÿÿÿ    îø       statement executed        return ((HRESULT)1L);    2ÿÿÿÿ   1   	   2ÿÿÿÿ   1           CLogAscConverter::CLogAscConverter CLogAscConverter::CLogAscConverter(void)    $      %      #ÿÿÿÿ   $ÿÿÿÿCLogAscConverter::~CLogAscConverter CLogAscConverter::~CLogAscConverter(void)    -      .      ,ÿÿÿÿ   -ÿÿÿÿCLogAscConverter::GetHelpText HRESULT CLogAscConverter::GetHelpText(string& pchHelpText)    8      ;      7ÿÿÿÿ   :ÿÿÿÿCLogAscConverter::GetConverterName HRESULT CLogAscConverter::GetConverterName(string& strConverterName)    E      H      Dÿÿÿÿ   GÿÿÿÿCLogAscConverter::GetErrorStatus HRESULT CLogAscConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)    S      l      Rÿÿÿÿ   kÿÿÿÿCLogAscConverter::GetInputFileFilters HRESULT CLogAscConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)    x      |      wÿÿÿÿ   {ÿÿÿÿCLogAscConverter::GetLastConversionStatus HRESULT CLogAscConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)    ‡      ‹      †ÿÿÿÿ   ŠÿÿÿÿCLogAscConverter::GetOutputFileFilters HRESULT CLogAscConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)    —      ›      –ÿÿÿÿ   šÿÿÿÿCLogAscConverter::ConvertFile HRESULT CLogAscConverter::ConvertFile(string& chInputFile, string& chOutputFile)    ¦      Ù      ¥ÿÿÿÿ   ØÿÿÿÿCLogAscConverter::bHaveOwnWindow BOOL CLogAscConverter::bHaveOwnWindow()    â      ä      áÿÿÿÿ   ãÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿCLogAscConverter::GetPropertyPage HRESULT GetPropertyPage(CPropertyPage*& pPage)    1      3      0ÿÿÿÿ   2ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      LogAscConverter.cpp
 * \brief     Implementation of the AscLogConverter class.
 * \authors   Venkatanarayana Makam
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the LogAscConverter class.
 */

/* Project includes */
#include "LogAscConverter.h"

extern "C" int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile);

/**
 * \brief Constructor
 *
 * Constructor of CLogAscConverter
 */
CLogAscConverter::CLogAscConverter(void)
{
}

/**
 * \brief Destructor
 *
 * Destructor of CAscLogConverter
 */
CLogAscConverter::~CLogAscConverter(void)
{
}

/**
 * \brief      Get help text
 * \param[out] pchHelpText Help Text
 * \return     Result code
 *
 * Returns pchHelpText containing the help text.
 */
HRESULT CLogAscConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the BUSMASTER CAN log file(.log) to CANoe CAN log file(.asc)";
    return S_OK;
}

/**
 * \brief      Get converter name
 * \param[out] strConverterName Converter Name
 * \return     Result code
 *
 * Returns strConverterName containing the converter name.
 */
HRESULT CLogAscConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "LOG TO ASC Conversion";
    return S_OK;
}

/**
 * \brief      Get error status string
 * \param[in]  hResult Error code
 * \param[out] omstrStatus Corresponding error string
 * \return     Result code
 *
 * Returns omstrStatus containing the error string depending on hResult.
 */
HRESULT CLogAscConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case ERR_OUTPUT_FILE_NOTFOUND:
            m_omstrConversionStatus = "Output File path is not found";
            break;

        case ERR_INPUT_FILE_NOTFOUND:
            m_omstrConversionStatus = "Input File path is not found";
            break;

        case S_OK:
            m_omstrConversionStatus = "Conversion success";
            break;

        case S_FALSE:
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return S_OK;
}

/**
 * \brief      Get input file filter type and name
 * \param[out] pchInputDefFilters file filter types
 * \param[out] pchInputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CLogAscConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "log";
    pchInputFilters = "BUSMASTER Log File(s) (*.log)|*.log||";
    return S_OK;
}

/**
 * \brief      Get last conversion status
 * \param[out] hResult Last conversion status.
 * \param[out] omstrStatus String describing the last conversion status.
 * \return     Result code
 *
 * Returns a string containing the last conversion status.
 */
HRESULT CLogAscConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return S_OK;
}

/**
 * \brief      Get output file filter type and name
 * \param[out] pchOutputDefFilters file filter types
 * \param[out] pchOutputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CLogAscConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "asc";
    pchOutputFilters = "CANoe Log File(s) (*.asc)|*.asc||";
    return S_OK;
}

/**
 * \brief     Conversion function
 * \param[in] chInputFile Input file name to convert from
 * \param[in] chOutputFile Output file name to convert to
 * \return    Result code
 *
 * This is the actual conversion function with input and output file name.
 */
HRESULT CLogAscConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = S_OK;
    FILE* fpInputFile = NULL;
    FILE* fpOutputFile = NULL;
    fopen_s(&fpInputFile, chInputFile.c_str(), _T("r"));
	
	if(NULL != fpInputFile)
    {
        fopen_s(&fpOutputFile, chOutputFile.c_str(), _T("w"));

        if(NULL != fpOutputFile)
        {
            //yydebug = 1;
            if (nConvertFile(fpInputFile, fpOutputFile) == -2)
			{
				m_omstrConversionStatus = "Conversion May not be work with CANoe since the input file is logged in system mode";
			}
			else
			{
				m_omstrConversionStatus = "Conversion Completed Successfully";
			}
			if(fpInputFile != NULL)
			{
				fclose(fpInputFile);
				fpInputFile = NULL;
			}
            if(fpOutputFile != NULL)
			{
				fclose(fpOutputFile);
				fpOutputFile = NULL;
			}
		}
        else
        {
			if(fpInputFile != NULL)
			{
				fclose(fpInputFile);
				fpInputFile = NULL;
			}
            m_omstrConversionStatus = "Output File path is not found";
            hResult = ERR_OUTPUT_FILE_NOTFOUND;
        }
    }
    else
    {
        m_omstrConversionStatus = "Input File path is not found";
        hResult = ERR_INPUT_FILE_NOTFOUND;
    }

    m_hResult = hResult;
    return hResult;
}

/**
 * \brief     Returns if it has an own window
 * \return    True, if it has an own window.
 *
 * This returns true, if the converter has an own window, false otherwise.
 */
BOOL CLogAscConverter::bHaveOwnWindow()
{
    return FALSE;
}
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      LogAscConverter.cpp
 * \brief     Definition of the LogAscConverter class.
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the LogAscConverter class.
 */

#pragma once

/* Project includes */
#include "../FormatConverterApp/BaseConverter.h"

#define ERR_INPUT_FILE_NOTFOUND          (-1)
#define ERR_OUTPUT_FILE_NOTFOUND         (-2)

class CLogAscConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CLogAscConverter(void);
    ~CLogAscConverter(void);
    virtual HRESULT GetInputFileFilters(string&, string& );
    virtual HRESULT GetOutputFileFilters(string&, string& );
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return S_FALSE;
    };
};









































static AFX_EXTENSION_MODULE LogAscConverterDLL = { 0, 0 };





extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
    (lpReserved);

    if (dwReason == 1)
    {
        ;

        
        if (!AfxInitExtensionModule(LogAscConverterDLL, hInstance))
        {
            return 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        new CDynLinkLibrary(LogAscConverterDLL);
    }
    else if (dwReason == 0)
    {
        ;
        
        AfxTermExtensionModule(LogAscConverterDLL);
    }

    return 1;   
}





extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CLogAscConverter();
    return ((HRESULT)0L);
}
          S      S      Mÿÿÿÿ   Mÿÿÿÿ     û`à      expression was false       dwReason == 0    Sÿÿÿÿ   M      Sÿÿÿÿ   M                   ø:         C      C      =ÿÿÿÿ   =ÿÿÿÿ     ø6ğ       statement executed        return 0;    Cÿÿÿÿ   =      Cÿÿÿÿ   =                    R      R      Lÿÿÿÿ   Lÿÿÿÿ     ø9        statement executed        }    Rÿÿÿÿ   L      Rÿÿÿÿ   L                    X      X      Rÿÿÿÿ   Rÿÿÿÿ     û`       statement executed        }    Xÿÿÿÿ   R      Xÿÿÿÿ   R                    Z      Z      Tÿÿÿÿ   Tÿÿÿÿ     ûcˆ       statement executed        return 1;    Zÿÿÿÿ   T      Zÿÿÿÿ   T                    d      d      ^ÿÿÿÿ   ^ÿÿÿÿ     ûfH       statement executed        return ((HRESULT)0L);    dÿÿÿÿ   ^      dÿÿÿÿ   ^                    A      A   C   ;ÿÿÿÿ   ;ÿÿÿÿ     ø7È      expression was false       !AfxInitExtensionModule(LogAscConverterDLL, hInstance)    Aÿÿÿÿ   ;      Aÿÿÿÿ   ;   C                ø6`         2   	   2      1ÿÿÿÿ   1ÿÿÿÿ     ûjx       statement executed        return ((HRESULT)1L);    2ÿÿÿÿ   1   	   2ÿÿÿÿ   1           DllMain extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)    8      [      2ÿÿÿÿ   UÿÿÿÿGetBaseConverter extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)    b      e      \ÿÿÿÿ   _ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      LogAscConverter.cpp
 * \brief     Defines the initialization routines for the DLL.
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines the initialization routines for the DLL.
 */

#define VC_EXTRALEAN        /* Exclude rarely-used stuff from Windows headers */

#include <afxwin.h>         /* MFC core and standard components */
#include <afxext.h>         /* MFC extensions */

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         /* MFC support for Windows Common Controls */
#endif /* _AFX_NO_AFXCMN_SUPPORT */
#include <afxdllx.h>

/* Project includes */
#include "LogAscConverter.h"

#ifdef _MANAGED
#error Please read instructions in LogAscConverter.cpp to compile with /clr
// If you want to add /clr to your project you must do the following:
//  1. Remove the above include for afxdllx.h
//  2. Add a .cpp file to your project that does not have /clr thrown and has
//     Precompiled headers disabled, with the following text:
//          #include <afxwin.h>
//          #include <afxdllx.h>
#endif

static AFX_EXTENSION_MODULE LogAscConverterDLL = { NULL, NULL };

#ifdef _MANAGED
#pragma managed(push, off)
#endif

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("LogAscConverter.DLL Initializing!\n");

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(LogAscConverterDLL, hInstance))
        {
            return 0;
        }

        // Insert this DLL into the resource chain
        // NOTE: If this Extension DLL is being implicitly linked to by
        //  an MFC Regular DLL (such as an ActiveX Control)
        //  instead of an MFC application, then you will want to
        //  remove this line from DllMain and put it in a separate
        //  function exported from this Extension DLL.  The Regular DLL
        //  that uses this Extension DLL should then explicitly call that
        //  function to initialize this Extension DLL.  Otherwise,
        //  the CDynLinkLibrary object will not be attached to the
        //  Regular DLL's resource chain, and serious problems will
        //  result.
        new CDynLinkLibrary(LogAscConverterDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("LogAscConverter.DLL Terminating!\n");
        // Terminate the library before destructors are called
        AfxTermExtensionModule(LogAscConverterDLL);
    }

    return 1;   // ok
}

#ifdef _MANAGED
#pragma managed(pop)
#endif

extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CLogAscConverter();
    return S_OK;
}



























extern "C" int nGetDayFromDate(char* pchDate, char* pchMonth, char* chWeekDay)
{
    if(pchDate == 0 || chWeekDay == 0 || pchMonth == 0)
    {
        return -1;
    }

    int nDate, nMonth, nYear;
    char chDelim[] = ":. ";
    char* pchTemp = strtok(pchDate, chDelim);
    nDate = atoi(pchTemp);
    pchTemp = strtok(0, chDelim);
    nMonth = atoi(pchTemp);
    pchTemp = strtok(0, chDelim);
    nYear = atoi(pchTemp);
    

    CTime omTime(nYear, nMonth, nDate, 0, 0, 0, 0);
    
    int nDay = omTime.GetDayOfWeek();

    switch(nDay)
    {
        case 1:
            strcpy(chWeekDay, "Sun");
            break;

        case 2:
            strcpy(chWeekDay, "Mon");
            break;

        case 3:
            strcpy(chWeekDay, "Tue");
            break;

        case 4:
            strcpy(chWeekDay, "Wed");
            break;

        case 5:
            strcpy(chWeekDay, "Thu");
            break;

        case 6:
            strcpy(chWeekDay, "Fri");
            break;

        case 7:
            strcpy(chWeekDay, "Sat");
            break;
    }

    
    switch(nMonth)
    {
        case 1:
            strcpy(pchMonth, "Jan");
            break;

        case 2:
            strcpy(pchMonth, "Feb");
            break;

        case 3:
            strcpy(pchMonth, "Mar");
            break;

        case 4:
            strcpy(pchMonth, "Apr");
            break;

        case 5:
            strcpy(pchMonth, "May");
            break;

        case 6:
            strcpy(pchMonth, "Jun");
            break;

        case 7:
            strcpy(pchMonth, "Jul");
            break;

        case 8:
            strcpy(pchMonth, "Aug");
            break;

        case 9:
            strcpy(pchMonth, "Sep");
            break;

        case 10:
            strcpy(pchMonth, "Oct");
            break;

        case 11:
            strcpy(pchMonth, "Nov");
            break;

        case 12:
            strcpy(pchMonth, "Dec");
            break;
    }

    return 0;
}
                      ÿÿÿÿ   ÿÿÿÿ    Ñè      expression was true       pchDate == 0    ÿÿÿÿ         ÿÿÿÿ         expression was false       pchDate == 0    ÿÿÿÿ         ÿÿÿÿ                      'FP                  &   ÿÿÿÿ   ÿÿÿÿ    Òx      expression was true       chWeekDay == 0    ÿÿÿÿ         ÿÿÿÿ      &   expression was false       chWeekDay == 0    ÿÿÿÿ         ÿÿÿÿ      &               ÑX            *      7   ÿÿÿÿ   ÿÿÿÿ     6KH      expression was true       pchMonth == 0    ÿÿÿÿ      *   ÿÿÿÿ      7   expression was false       pchMonth == 0    ÿÿÿÿ      *   ÿÿÿÿ      7               Óà         …      …      „ÿÿÿÿ   „ÿÿÿÿ     ì)°       statement executed        return 0;    …ÿÿÿÿ   „      …ÿÿÿÿ   „                    ‚      ‚      ÿÿÿÿ   ÿÿÿÿ     ì(Ø       statement executed        break;    ‚ÿÿÿÿ         ‚ÿÿÿÿ                       ~      ~      }ÿÿÿÿ   }ÿÿÿÿ     ì'À       statement executed        break;    ~ÿÿÿÿ   }      ~ÿÿÿÿ   }              	      z      z      yÿÿÿÿ   yÿÿÿÿ    ßP       statement executed        break;    zÿÿÿÿ   y      zÿÿÿÿ   y              
      v      v      uÿÿÿÿ   uÿÿÿÿ    Ş8       statement executed        break;    vÿÿÿÿ   u      vÿÿÿÿ   u                    !   	   !       ÿÿÿÿ    ÿÿÿÿ     6Lø       statement executed        return -1;    !ÿÿÿÿ       	   !ÿÿÿÿ                        6      6      5ÿÿÿÿ   5ÿÿÿÿ     ğ¨       statement executed        break;    6ÿÿÿÿ   5      6ÿÿÿÿ   5                    :      :      9ÿÿÿÿ   9ÿÿÿÿ     ğÀ       statement executed        break;    :ÿÿÿÿ   9      :ÿÿÿÿ   9                    >      >      =ÿÿÿÿ   =ÿÿÿÿ    `       statement executed        break;    >ÿÿÿÿ   =      >ÿÿÿÿ   =                    B      B      Aÿÿÿÿ   Aÿÿÿÿ    `ğ       statement executed        break;    Bÿÿÿÿ   A      Bÿÿÿÿ   A                    F      F      Eÿÿÿÿ   Eÿÿÿÿ    b       statement executed        break;    Fÿÿÿÿ   E      Fÿÿÿÿ   E                    J      J      Iÿÿÿÿ   Iÿÿÿÿ    c        statement executed        break;    Jÿÿÿÿ   I      Jÿÿÿÿ   I                    N      N      Mÿÿÿÿ   Mÿÿÿÿ    d8       statement executed        break;    Nÿÿÿÿ   M      Nÿÿÿÿ   M                    V      V      Uÿÿÿÿ   Uÿÿÿÿ    e       statement executed        break;    Vÿÿÿÿ   U      Vÿÿÿÿ   U                    Z      Z      Yÿÿÿÿ   Yÿÿÿÿ    f¨       statement executed        break;    Zÿÿÿÿ   Y      Zÿÿÿÿ   Y                    ^      ^      ]ÿÿÿÿ   ]ÿÿÿÿ    ×¨       statement executed        break;    ^ÿÿÿÿ   ]      ^ÿÿÿÿ   ]                    b      b      aÿÿÿÿ   aÿÿÿÿ    ØÀ       statement executed        break;    bÿÿÿÿ   a      bÿÿÿÿ   a                    f      f      eÿÿÿÿ   eÿÿÿÿ    ÙØ       statement executed        break;    fÿÿÿÿ   e      fÿÿÿÿ   e                    j      j      iÿÿÿÿ   iÿÿÿÿ    Úğ       statement executed        break;    jÿÿÿÿ   i      jÿÿÿÿ   i                    n      n      mÿÿÿÿ   mÿÿÿÿ    Ü       statement executed        break;    nÿÿÿÿ   m      nÿÿÿÿ   m                    r      r      qÿÿÿÿ   qÿÿÿÿ    İ        statement executed        break;    rÿÿÿÿ   q      rÿÿÿÿ   q           nGetDayFromDate extern "C" int nGetDayFromDate(char* pchDate, char* pchMonth, char* chWeekDay)          †      ÿÿÿÿ   …ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Utility.cpp
 * \brief     Definiton of the Utility Functions.
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of utility functions.
 */

/* C includes */
#include <atltime.h>
#include <string.h>

extern "C" int nGetDayFromDate(char* pchDate, char* pchMonth, char* chWeekDay)
{
    if(pchDate == NULL || chWeekDay == NULL || pchMonth == NULL)
    {
        return -1;
    }

    int nDate, nMonth, nYear;
    char chDelim[] = ":. ";
    char* pchTemp = strtok(pchDate, chDelim);
    nDate = atoi(pchTemp);
    pchTemp = strtok(NULL, chDelim);
    nMonth = atoi(pchTemp);
    pchTemp = strtok(NULL, chDelim);
    nYear = atoi(pchTemp);
    /*sscanf(pchDate, "%d%c%d%c%d", &nDate, &chTemp, &nMonth,
        &chTemp, &nYear);*/
    CTime omTime(nYear, nMonth, nDate, 0, 0, 0, 0);
    //Day
    int nDay = omTime.GetDayOfWeek();

    switch(nDay)
    {
        case 1:
            strcpy(chWeekDay, _T("Sun"));
            break;

        case 2:
            strcpy(chWeekDay, _T("Mon"));
            break;

        case 3:
            strcpy(chWeekDay, _T("Tue"));
            break;

        case 4:
            strcpy(chWeekDay, _T("Wed"));
            break;

        case 5:
            strcpy(chWeekDay, _T("Thu"));
            break;

        case 6:
            strcpy(chWeekDay, _T("Fri"));
            break;

        case 7:
            strcpy(chWeekDay, _T("Sat"));
            break;
    }

    //Month
    switch(nMonth)
    {
        case 1:
            strcpy(pchMonth, "Jan");
            break;

        case 2:
            strcpy(pchMonth, "Feb");
            break;

        case 3:
            strcpy(pchMonth, "Mar");
            break;

        case 4:
            strcpy(pchMonth, "Apr");
            break;

        case 5:
            strcpy(pchMonth, "May");
            break;

        case 6:
            strcpy(pchMonth, "Jun");
            break;

        case 7:
            strcpy(pchMonth, "Jul");
            break;

        case 8:
            strcpy(pchMonth, "Aug");
            break;

        case 9:
            strcpy(pchMonth, "Sep");
            break;

        case 10:
            strcpy(pchMonth, "Oct");
            break;

        case 11:
            strcpy(pchMonth, "Nov");
            break;

        case 12:
            strcpy(pchMonth, "Dec");
            break;
    }

    return 0;
}





























































































typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;





































typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		
	char *yy_buf_pos;		

	


	yy_size_t yy_buf_size;

	


	int yy_n_chars;

	



	int yy_is_our_buffer;

	




	int yy_is_interactive;

	



	int yy_at_bol;

	


	int yy_fill_buffer;

	int yy_buffer_status;


	










	};

static YY_BUFFER_STATE yy_current_buffer = 0;









static char yy_hold_char;

static int yy_n_chars;		


int yyleng;


static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		
static int yy_start = 0;	




static int yy_did_buffer_switch_on_eof;

void yyrestart ();

void yy_switch_to_buffer ();
void yy_load_buffer_state ();
YY_BUFFER_STATE yy_create_buffer ();
void yy_delete_buffer ();
void yy_init_buffer ();
void yy_flush_buffer ();


YY_BUFFER_STATE yy_scan_buffer ();
YY_BUFFER_STATE yy_scan_string ();
YY_BUFFER_STATE yy_scan_bytes ();

static void *yy_flex_alloc ();
static void *yy_flex_realloc ();
static void yy_flex_free ();



















typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;


static yy_state_type yy_get_previous_state ();
static yy_state_type yy_try_NUL_trans ();
static int yy_get_next_buffer ();
static void yy_fatal_error ();













static  short int yy_accept[172] =
    {   0,
        0,    0,   26,   24,   23,   22,   24,   10,   10,   13,
       19,   10,   10,   24,   24,   14,   24,   15,   23,    0,
       12,   10,    0,   10,   11,    0,    0,   18,   16,   17,
        0,   12,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   20,    0,    0,    0,    0,    0,    0,
        0,    0,    4,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   21,    0,    0,    0,    6,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    9,    0,    0,
        0,    0,    0,    0,    0,    8,    7,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    3,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    2,    1,
        0
    } ;

static  int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    1,    1,    1,    6,    1,    7,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    9,    1,    1,
       10,    1,    1,    1,   13,   14,   15,   16,   17,   18,
       19,   20,   21,    1,    1,   22,   23,   24,   25,   26,
        1,   27,   28,   29,   30,   31,    1,   32,   33,    1,
       11,    1,   12,    1,    1,    1,   13,   14,   15,   16,

       17,   18,   19,   20,   21,    1,    1,   22,   23,   24,
       25,   26,    1,   27,   28,   29,   30,   31,    1,   32,
       33,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static  int yy_meta[34] =
    {   0,
        1,    1,    1,    1,    1,    1,    2,    2,    1,    1,
        1,    1,    2,    2,    2,    2,    2,    2,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1
    } ;

static  short int yy_base[173] =
    {   0,
        0,    0,  212,  213,   32,  213,  206,   31,  178,  213,
      213,    0,  188,  191,  175,  179,  173,  177,   39,  198,
       43,  170,   45,    0,  213,  172,  176,  213,  213,  213,
       53,   47,   49,  184,  179,  169,  182,  178,  177,  176,
       32,   52,  167,  162,  161,  161,  173,  155,  164,  172,
      156,   63,  153,  162,   49,  156,  175,  174,  165,  150,
      147,   60,  151,  213,  147,  147,  150,  166,  165,  140,
      139,  150,   68,  137,  136,  160,  133,  157,  156,  139,
      155,  135,  213,  153,  134,  126,  213,  123,  137,  148,
      129,  125,  132,  131,  134,  123,  120,  125,  139,  138,

      112,  115,  120,  119,  114,  113,  118,  118,  114,  111,
      106,  105,  125,  111,  106,  102,  109,  108,  110,  117,
       97,  101,  102,  101,   93,  111,   96,  110,  108,  107,
       95,  105,  105,   80,  102,  101,  101,  213,   76,   86,
       97,   96,   71,   82,   70,  213,  213,   76,   68,   67,
       71,   65,   71,   74,   69,   64,  213,   63,   63,   62,
       73,   72,   78,   77,   74,   73,   72,   37,  213,  213,
      213,   33
    } ;

static  short int yy_def[173] =
    {   0,
      171,    1,  171,  171,  171,  171,  171,  171,    8,  171,
      171,  172,  172,  171,  171,  171,  171,  171,  171,  171,
      171,    8,  171,  172,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,

      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
        0,  171
    } ;

static  short int yy_nxt[247] =
    {   0,
        4,    5,    6,    5,    7,    4,    8,    9,   10,   11,
        4,    4,   12,   13,   12,   12,   12,   12,    4,    4,
        4,   14,    4,    4,    4,    4,   15,   16,   17,    4,
        4,   18,    4,   19,   24,   19,   21,   22,   22,   23,
       19,  170,   19,   24,   24,   24,   24,   24,   24,   32,
       32,   33,   33,   32,   32,   33,   33,   42,   52,   52,
       50,   65,   25,   36,   51,   37,   73,   73,   38,   52,
       52,   62,   39,   66,   73,   73,  169,  168,  167,   40,
       41,  166,  165,  164,  163,  162,  161,  160,  159,  158,
      157,  156,  155,  154,  153,  152,  151,  150,  149,  148,

      147,  146,  145,  144,  143,  142,  141,  140,  139,  138,
      137,  136,  135,  134,  133,  132,  131,  130,  129,  128,
      127,  126,  125,  124,  123,  122,  121,  120,  119,  118,
      117,  116,  115,  114,  113,  112,  111,  110,  109,  108,
      107,  106,  105,  104,  103,  102,  101,  100,   99,   98,
       97,   96,   95,   94,   93,   92,   91,   90,   89,   88,
       87,   87,   86,   85,   84,   83,   82,   81,   80,   79,
       78,   77,   76,   75,   74,   72,   71,   70,   69,   68,
       67,   64,   63,   61,   60,   59,   58,   57,   56,   55,
       54,   53,   49,   48,   47,   46,   45,   44,   43,   35,

       34,  171,   31,   30,   28,   29,   28,   27,   26,  171,
       20,  171,    3,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171
    } ;

static  short int yy_chk[247] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    5,  172,    5,    8,    8,    8,    8,
       19,  168,   19,    8,    8,    8,    8,    8,    8,   21,
       21,   23,   23,   32,   32,   33,   33,   33,   42,   42,
       41,   55,    8,   31,   41,   31,   62,   62,   31,   52,
       52,   52,   31,   55,   73,   73,  167,  166,  165,   31,
       31,  164,  163,  162,  161,  160,  159,  158,  156,  155,
      154,  153,  152,  151,  150,  149,  148,  145,  144,  143,

      142,  141,  140,  139,  137,  136,  135,  134,  133,  132,
      131,  130,  129,  128,  127,  126,  125,  124,  123,  122,
      121,  120,  119,  118,  117,  116,  115,  114,  113,  112,
      111,  110,  109,  108,  107,  106,  105,  104,  103,  102,
      101,  100,   99,   98,   97,   96,   95,   94,   93,   92,
       91,   90,   89,   88,   86,   85,   84,   82,   81,   80,
       79,   78,   77,   76,   75,   74,   72,   71,   70,   69,
       68,   67,   66,   65,   63,   61,   60,   59,   58,   57,
       56,   54,   53,   51,   50,   49,   48,   47,   46,   45,
       44,   43,   40,   39,   38,   37,   36,   35,   34,   27,

       26,   22,   20,   18,   17,   16,   15,   14,   13,    9,
        7,    3,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;







char *yytext;



char x[5] = "Hi";









extern int yywrap ();


static void yyunput ();









static int input ();


































































































int yylex ()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;





		if ( ! yy_start )
			yy_start = 1;	

		if ( ! yyin )
			yyin = (&__iob_func()[0]);

		if ( ! yyout )
			yyout = (&__iob_func()[1]);

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, 16384 );

		yy_load_buffer_state();
		}

	while ( 1 )		
		{
		yy_cp = yy_c_buf_p;

		
		*yy_cp = yy_hold_char;

		


		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[((unsigned int) (unsigned char) *yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 172 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 213 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ 
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		yytext = yy_bp; yyleng = (int) (yy_cp - yy_bp); yy_hold_char = *yy_cp; *yy_cp = '\0'; yy_c_buf_p = yy_cp;;


do_action:	


		switch ( yy_act )
	{ 
			case 0: 
			
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:

yylval = _strdup(yytext); return 258;
	break;
case 2:

yylval = _strdup(yytext);return 259;
	break;
case 3:

yylval = _strdup(yytext); return 260;
	break;
case 4:

yylval = _strdup(yytext);return 267;
	break;
case 5:

yylval = _strdup(yytext);return 266;
	break;
case 6:

yylval = _strdup(yytext);return 262;
	break;
case 7:

yylval = _strdup(yytext);return 263;
	break;
case 8:

yylval = _strdup(yytext);return 263;
	break;
case 9:

yylval = _strdup(yytext);return 263;
	break;
case 10:

yylval =_strdup(yytext);return 264;
	break;
case 11:

;
	break;
case 12:

yylval =_strdup(yytext);return 265;
	break;
case 13:

yylval =_strdup(yytext);return 277;
	break;
case 14:

yylval =_strdup(yytext);return 268;
	break;
case 15:

yylval =_strdup(yytext);return 269;
	break;
case 16:

yylval =_strdup(yytext);return 270;
	break;
case 17:

yylval =_strdup(yytext);return 271;
	break;
case 18:

yylval =_strdup(yytext);return 272;
	break;
case 19:

return 273;
	break;
case 20:

return 274;
	break;
case 21:

return 275;
	break;
case 22:

return 276;
	break;
case 23:

;
	break;
case 24:

;
	break;
case 25:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case (26 + 0 + 1):
	return 0;

	case 26:
		{
		
		int yy_amount_of_matched_text = (int) (yy_cp - yytext) - 1;

		
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == 0 )
			{
			








			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = 1;
			}

		






		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ 
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			








			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext + 0;

			if ( yy_next_state )
				{
				
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case 1:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					








					yy_c_buf_p = yytext + 0;

					yy_act = (26 + ((yy_start - 1) / 2) + 1);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );
					}
				break;
				}

			case 0:
				yy_c_buf_p =
					yytext + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_match;

			case 2:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_find_action;
			}
		break;
		}

	default:
		yy_fatal_error( "fatal flex scanner internal error--no action found" );
	} 
		} 
	} 










static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ 
		if ( yy_c_buf_p - yytext - 0 == 1 )
			{
			


			return 1;
			}

		else
			{
			


			return 2;
			}
		}

	

	
	number_to_move = (int) (yy_c_buf_p - yytext) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == 2 )
		


		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ 





			
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				yy_fatal_error( "fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
			}

		if ( num_to_read > 8192 )
			num_to_read = 8192;

		
		if ( yy_current_buffer->yy_is_interactive ) { int c = '*', n; for ( n = 0; n < num_to_read && (c = getc( yyin )) != (-1) && c != '\n'; ++n ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c; if ( c == '\n' ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c; if ( c == (-1) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" ); yy_n_chars = n; } else if ( ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" );;
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == 0 )
			{
			ret_val = 1;
			yyrestart( yyin );
			}

		else
			{
			ret_val = 2;
			yy_current_buffer->yy_buffer_status =
				2;
			}
		}

	else
		ret_val = 0;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = 0;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = 0;

	yytext = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}




static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext + 0; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[((unsigned int) (unsigned char) *yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 172 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}











static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 172 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 171);

	return yy_is_jam ? 0 : yy_current_state;
	}






static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
	{
	register char *yy_cp = yy_c_buf_p;

	
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ 
		
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			yy_fatal_error( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}





static int input()
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == 0 )
		{
		



		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			
			*yy_c_buf_p = '\0';

		else
			{ 
			yytext = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case 1:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext + 0;
						return (-1);
						}

					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );



					return input();
					}

				case 0:
					yy_c_buf_p = yytext + 0;
					break;

				case 2:




					yy_fatal_error( "unexpected last match in input()" );
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	
	*yy_c_buf_p = '\0';	
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}





void yyrestart( input_file )
FILE *input_file;
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, 16384 );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}





void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	




	yy_did_buffer_switch_on_eof = 1;
	}





void yy_load_buffer_state()
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}





YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	


	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}





void yy_delete_buffer( b )
YY_BUFFER_STATE b;
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}




extern int isatty ();




void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;





	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
	}





void yy_flush_buffer( b )
YY_BUFFER_STATE b;

	{
	b->yy_n_chars = 0;

	



	b->yy_ch_buf[0] = 0;
	b->yy_ch_buf[1] = 0;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = 0;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}






YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != 0 ||
	     base[size-1] != 0 )
		
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = 0;

	yy_switch_to_buffer( b );

	return b;
	}






YY_BUFFER_STATE yy_scan_string( str )
 char *str;
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}






YY_BUFFER_STATE yy_scan_bytes( bytes, len )
 char *bytes;
int len;
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = 0;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		yy_fatal_error( "bad buffer in yy_scan_bytes()" );

	


	b->yy_is_our_buffer = 1;

	return b;
	}




























































static void yy_fatal_error( msg )
char msg[];
	{
	(void) fprintf( (&__iob_func()[2]), "%s\n", msg );
	exit( 2 );
	}









































static void *yy_flex_alloc( size )
yy_size_t size;
	{
	return (void *) malloc( size );
	}




static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
	{
	






	return (void *) realloc( (char *) ptr, size );
	}




static void yy_flex_free( ptr )
void *ptr;
	{
	free( ptr );
	}









           ú      ïÿÿÿÿ  ïÿÿÿÿ     4.È      expression was true       ferror( yyin )   ÿÿÿÿ  ï  ú  ÿÿÿÿ  ï     expression was false       ferror( yyin )   ÿÿÿÿ  ï  ú  ÿÿÿÿ  ï                    ’    ö  ïÿÿÿÿ  ïÿÿÿÿ     4-à      expression was true       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   ÿÿÿÿ  ï  ’  ÿÿÿÿ  ï  ö   expression was false       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   ÿÿÿÿ  ï  ’  ÿÿÿÿ  ï  ö                4,¸          3    A  ïÿÿÿÿ  ïÿÿÿÿ     4$       expression was true       ferror( yyin )   ÿÿÿÿ  ï  3  ÿÿÿÿ  ï  A   expression was false       ferror( yyin )   ÿÿÿÿ  ï  3  ÿÿÿÿ  ï  A                  &    /  ïÿÿÿÿ  ïÿÿÿÿ     4#¸      expression was true       c == (-1)   ÿÿÿÿ  ï  &  ÿÿÿÿ  ï  /   expression was false       c == (-1)   ÿÿÿÿ  ï  &  ÿÿÿÿ  ï  /                4"                ˆ  ïÿÿÿÿ  ïÿÿÿÿ     öÎÀ      expression was true       c != '\n'   ÿÿÿÿ  ï     ÿÿÿÿ  ï   ˆ   expression was false       c != '\n'   ÿÿÿÿ  ï     ÿÿÿÿ  ï   ˆ                öÍ    
        a     {  ïÿÿÿÿ  ïÿÿÿÿ     öË       expression was true       (c = getc( yyin )) != (-1)   ÿÿÿÿ  ï   a  ÿÿÿÿ  ï   {   expression was false       (c = getc( yyin )) != (-1)   ÿÿÿÿ  ï   a  ÿÿÿÿ  ï   {                öÉ0           N     ]  ïÿÿÿÿ  ïÿÿÿÿ     öÊ(      expression was true       n < num_to_read   ÿÿÿÿ  ï   N  ÿÿÿÿ  ï   ]   expression was false       n < num_to_read   ÿÿÿÿ  ï   N  ÿÿÿÿ  ï   ]                9     9   "  ÿÿÿÿ  ÿÿÿÿ     ò·(      expression was true       *yy_cp   9ÿÿÿÿ       9ÿÿÿÿ     "   expression was false       *yy_cp   9ÿÿÿÿ       9ÿÿÿÿ     "                Õ     Õ     ÿÿÿÿ  ÿÿÿÿ     +°@      expression was false       i < len   Õÿÿÿÿ       Õÿÿÿÿ                     ¹     ¹     ƒÿÿÿÿ  ƒÿÿÿÿ     + ø      expression was false       str[len]   ¹ÿÿÿÿ  ƒ     ¹ÿÿÿÿ  ƒ                   7     7   .  ÿÿÿÿ  ÿÿÿÿ     òÊ¸      expression was false       yy_cp < yy_c_buf_p   7ÿÿÿÿ       7ÿÿÿÿ     .                i     i     9ÿÿÿÿ  9ÿÿÿÿ     +l€      expression was true       file   iÿÿÿÿ  9     iÿÿÿÿ  9      expression was false       file   iÿÿÿÿ  9     iÿÿÿÿ  9                   Ñ     Ñ   !  µÿÿÿÿ  µÿÿÿÿ     /jx      expression was false       i < number_to_move   Ñÿÿÿÿ  µ     Ñÿÿÿÿ  µ   !                †     †   0  eÿÿÿÿ  eÿÿÿÿ     +€      expression was false       source > yy_current_buffer->yy_ch_buf   †ÿÿÿÿ  e     †ÿÿÿÿ  e   0                b   
  b   F  Bÿÿÿÿ  Bÿÿÿÿ     òß`      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   bÿÿÿÿ  B   
  bÿÿÿÿ  B   F                ò×         ?     ?   G   ÿÿÿÿ   ÿÿÿÿ     òÇ      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   ?ÿÿÿÿ        ?ÿÿÿÿ      G                ò¿P        ß     ß     Ãÿÿÿÿ  Ãÿÿÿÿ     öÁ€      expression was false       num_to_read <= 0   ßÿÿÿÿ  Ã     ßÿÿÿÿ  Ã                   á        ›     ›   H  ÿÿÿÿ  ÿÿÿÿ     4àĞ      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   ›ÿÿÿÿ       ›ÿÿÿÿ     H                40        …   
  …     kÿÿÿÿ  kÿÿÿÿ     *ıĞ      expression was false       1   …ÿÿÿÿ  k   
  …ÿÿÿÿ  k                   ¤     ¤   +  Šÿÿÿÿ  Šÿÿÿÿ     4÷ø      expression was true       yy_base[yy_current_state] != 213   ¤ÿÿÿÿ  Š     ¤ÿÿÿÿ  Š   +   expression was false       yy_base[yy_current_state] != 213   ¤ÿÿÿÿ  Š     ¤ÿÿÿÿ  Š   +                4å˜        Û     Û   
  £ÿÿÿÿ  £ÿÿÿÿ     +¶      expression was false       ! b   Ûÿÿÿÿ  £     Ûÿÿÿÿ  £   
                +´        Ò     Ò     šÿÿÿÿ  šÿÿÿÿ     +¬è      expression was false       ! buf   Òÿÿÿÿ  š     Òÿÿÿÿ  š                   +ªğ         œ     œ   
  hÿÿÿÿ  hÿÿÿÿ     +8      expression was false       ! b   œÿÿÿÿ  h     œÿÿÿÿ  h   
                +‹@   !     •     •     aÿÿÿÿ  aÿÿÿÿ     +€È      expression was true       size < 2   •ÿÿÿÿ  a     •ÿÿÿÿ  a      expression was false       size < 2   •ÿÿÿÿ  a     •ÿÿÿÿ  a              #     …     …     Rÿÿÿÿ  Rÿÿÿÿ     +{       expression was false       b == yy_current_buffer   …ÿÿÿÿ  R     …ÿÿÿÿ  R                   +y    $     G     G     ÿÿÿÿ  ÿÿÿÿ     +bø      expression was false       b->yy_is_our_buffer   Gÿÿÿÿ       Gÿÿÿÿ                %     D     D     ÿÿÿÿ  ÿÿÿÿ     +`à      expression was false       b == yy_current_buffer   Dÿÿÿÿ       Dÿÿÿÿ                     âœ    &     A     A   
  ÿÿÿÿ  ÿÿÿÿ     â›h      expression was false       ! b   Aÿÿÿÿ       Aÿÿÿÿ     
                âšH   '     /     /     ÿÿÿÿ  ÿÿÿÿ     +]¸      expression was false       ! b->yy_ch_buf   /ÿÿÿÿ       /ÿÿÿÿ                     +[À   (     &     &   
  üÿÿÿÿ  üÿÿÿÿ     +V(      expression was false       ! b   &ÿÿÿÿ  ü     &ÿÿÿÿ  ü   
                +T0   )     ú     ú     Òÿÿÿÿ  Òÿÿÿÿ     +C0      expression was false       yy_current_buffer   úÿÿÿÿ  Ò     úÿÿÿÿ  Ò              *     ÷     ÷   &  Ïÿÿÿÿ  Ïÿÿÿÿ     +<0      expression was false       yy_current_buffer == new_buffer   ÷ÿÿÿÿ  Ï     ÷ÿÿÿÿ  Ï   &                +;   +     è     è     Áÿÿÿÿ  Áÿÿÿÿ     +6(      expression was false       ! yy_current_buffer   èÿÿÿÿ  Á     èÿÿÿÿ  Á                   +3°   ,     ¿     ¿   (  œÿÿÿÿ  œÿÿÿÿ     +%ˆ      expression was false       ! yy_did_buffer_switch_on_eof   ¿ÿÿÿÿ  œ     ¿ÿÿÿÿ  œ   (                +#¨   -     ¸     ¸     •ÿÿÿÿ  •ÿÿÿÿ     +"       expression was false       yywrap()   ¸ÿÿÿÿ  •     ¸ÿÿÿÿ  •              .     ¥     ¥     ‚ÿÿÿÿ  ‚ÿÿÿÿ     +,¨      expression was false       *yy_c_buf_p == 0   ¥ÿÿÿÿ  ‚     ¥ÿÿÿÿ  ‚                   +ø   /             0  lÿÿÿÿ  lÿÿÿÿ     +€      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   ÿÿÿÿ  l     ÿÿÿÿ  l   0                +ˆ   0     }     }   /  \ÿÿÿÿ  \ÿÿÿÿ     +@      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   }ÿÿÿÿ  \     }ÿÿÿÿ  \   /                òëH   1     e     e     Eÿÿÿÿ  Eÿÿÿÿ     òİ       expression was false       yy_current_state >= 172   eÿÿÿÿ  E     eÿÿÿÿ  E                   òÚ˜   2     ]     ]   "  =ÿÿÿÿ  =ÿÿÿÿ     òÕ¸      expression was false       yy_accept[yy_current_state]   ]ÿÿÿÿ  =     ]ÿÿÿÿ  =   "           3     B   	  B      #ÿÿÿÿ  #ÿÿÿÿ     òÅĞ      expression was false       yy_current_state >= 172   Bÿÿÿÿ  #   	  Bÿÿÿÿ  #                    òÂÈ   4     :     :   #  ÿÿÿÿ  ÿÿÿÿ     ò½è      expression was false       yy_accept[yy_current_state]   :ÿÿÿÿ       :ÿÿÿÿ     #           5     –     –     bÿÿÿÿ  bÿÿÿÿ     +X      expression was true       base[size-2] != 0   –ÿÿÿÿ  b     –ÿÿÿÿ  b      expression was false       base[size-2] != 0   –ÿÿÿÿ  b     –ÿÿÿÿ  b                   +€8   7     —     —     cÿÿÿÿ  cÿÿÿÿ     +…(      expression was true       base[size-1] != 0   —ÿÿÿÿ  c     —ÿÿÿÿ  c      expression was false       base[size-1] != 0   —ÿÿÿÿ  c     —ÿÿÿÿ  c                   +ƒh   9        Ô     İ  ïÿÿÿÿ  ïÿÿÿÿ     4       expression was false       c == '\n'   ÿÿÿÿ  ï   Ô  ÿÿÿÿ  ï   İ                4à   :     	     	     ëÿÿÿÿ  ëÿÿÿÿ     öÄ      expression was false       num_to_read > 8192   	ÿÿÿÿ  ë     	ÿÿÿÿ  ë              ;     ş   	  ş     âÿÿÿÿ  âÿÿÿÿ     ö»`      expression was false       ! b->yy_ch_buf   şÿÿÿÿ  â   	  şÿÿÿÿ  â                   ö¸x   <     ¹     ¹   -  ÿÿÿÿ  ÿÿÿÿ     /dˆ      expression was false       yy_current_buffer->yy_fill_buffer == 0   ¹ÿÿÿÿ       ¹ÿÿÿÿ     -                5~    =     µ     µ   A  šÿÿÿÿ  šÿÿÿÿ     5}€      expression was false       yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1]   µÿÿÿÿ  š     µÿÿÿÿ  š   A           >             (  gÿÿÿÿ  gÿÿÿÿ     -éÈ      expression was false       ! yy_did_buffer_switch_on_eof   ÿÿÿÿ  g     ÿÿÿÿ  g   (                1	€   ?     -     -   0  ÿÿÿÿ  ÿÿÿÿ     4áğ      expression was false       yy_current_buffer->yy_buffer_status == 0   -ÿÿÿÿ       -ÿÿÿÿ     0                4ù8   @     ¨     ¨     ÿÿÿÿ  ÿÿÿÿ     5g       expression was false       yy_act == 0   ¨ÿÿÿÿ       ¨ÿÿÿÿ                     5    A        
     !  „ÿÿÿÿ  „ÿÿÿÿ     4       expression was false       yy_current_state >= 172   ÿÿÿÿ  „   
  ÿÿÿÿ  „   !                4”à   B     –   	  –   $  |ÿÿÿÿ  |ÿÿÿÿ     4f      expression was false       yy_accept[yy_current_state]   –ÿÿÿÿ  |   	  –ÿÿÿÿ  |   $           C     ~     ~     dÿÿÿÿ  dÿÿÿÿ     4ü¨      expression was false       ! yy_current_buffer   ~ÿÿÿÿ  d     ~ÿÿÿÿ  d                   4Ûh   D     {     {     aÿÿÿÿ  aÿÿÿÿ     4×h      expression was false       ! yyout   {ÿÿÿÿ  a     {ÿÿÿÿ  a                   4gà   E     x     x     ^ÿÿÿÿ  ^ÿÿÿÿ     4T`      expression was false       ! yyin   xÿÿÿÿ  ^     xÿÿÿÿ  ^                   (ß8   F     u     u     [ÿÿÿÿ  [ÿÿÿÿ     ,“       expression was false       ! yy_start   uÿÿÿÿ  [     uÿÿÿÿ  [                   4Ş    G     m     m     Sÿÿÿÿ  Sÿÿÿÿ     4î0      expression was false       yy_init   mÿÿÿÿ  S     mÿÿÿÿ  S              H     t     t     6ÿÿÿÿ  6ÿÿÿÿ     +Ã       statement executed        }   tÿÿÿÿ  6     tÿÿÿÿ  6              I     i     i   0  ,ÿÿÿÿ  ,ÿÿÿÿ     +À°       statement executed        return (void *) realloc( (char *) ptr, size );   iÿÿÿÿ  ,     iÿÿÿÿ  ,   0           J     W     W   !  ÿÿÿÿ  ÿÿÿÿ     +½ø       statement executed        return (void *) malloc( size );   Wÿÿÿÿ       Wÿÿÿÿ     !           K     (     (     íÿÿÿÿ  íÿÿÿÿ     +»À       statement executed        exit( 2 );   (ÿÿÿÿ  í     (ÿÿÿÿ  í              L     ã     ã     «ÿÿÿÿ  «ÿÿÿÿ     +¸X       statement executed        return b;   ãÿÿÿÿ  «     ãÿÿÿÿ  «              M     Ü     Ü   5  ¤ÿÿÿÿ  ¤ÿÿÿÿ     +µ0       statement executed        yy_fatal_error( "bad buffer in yy_scan_bytes()" );   Üÿÿÿÿ  ¤     Üÿÿÿÿ  ¤   5           N     Ö     Ö     ÿÿÿÿ  ÿÿÿÿ     +¯h       statement executed        buf[i] = bytes[i];   Öÿÿÿÿ       Öÿÿÿÿ                O     Ó     Ó   @  ›ÿÿÿÿ  ›ÿÿÿÿ     +¬       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );   Óÿÿÿÿ  ›     Óÿÿÿÿ  ›   @           P     ¼     ¼   #  †ÿÿÿÿ  †ÿÿÿÿ     +¡ˆ       statement executed        return yy_scan_bytes( str, len );   ¼ÿÿÿÿ  †     ¼ÿÿÿÿ  †   #           Q     º     º     „ÿÿÿÿ  „ÿÿÿÿ     + h       statement executed        ;   ºÿÿÿÿ  „     ºÿÿÿÿ  „              R     «     «     wÿÿÿÿ  wÿÿÿÿ     +œĞ       statement executed        return b;   «ÿÿÿÿ  w     «ÿÿÿÿ  w              S             A  iÿÿÿÿ  iÿÿÿÿ     +Œ`       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );   ÿÿÿÿ  i     ÿÿÿÿ  i   A           T     ™     ™     eÿÿÿÿ  eÿÿÿÿ     +‡       statement executed        return 0;   ™ÿÿÿÿ  e     ™ÿÿÿÿ  e              U     ‡     ‡     Tÿÿÿÿ  Tÿÿÿÿ     +{è       statement executed        }   ‡ÿÿÿÿ  T     ‡ÿÿÿÿ  T              V     †     †     Sÿÿÿÿ  Sÿÿÿÿ     +z(       statement executed        yy_load_buffer_state();   †ÿÿÿÿ  S     †ÿÿÿÿ  S              W     l     l     :ÿÿÿÿ  :ÿÿÿÿ     +nè       statement executed        }   lÿÿÿÿ  :     lÿÿÿÿ  :              X     K     K      ÿÿÿÿ   ÿÿÿÿ     +d       statement executed        }   Kÿÿÿÿ        Kÿÿÿÿ                 Y     H     H   )  ÿÿÿÿ  ÿÿÿÿ     +b        statement executed        yy_flex_free( (void *) b->yy_ch_buf );   Hÿÿÿÿ       Hÿÿÿÿ     )           Z     E     E   +  ÿÿÿÿ  ÿÿÿÿ     +`       statement executed        yy_current_buffer = (YY_BUFFER_STATE) 0;   Eÿÿÿÿ       Eÿÿÿÿ     +           [     B     B   
  ÿÿÿÿ  ÿÿÿÿ     âšØ       statement executed        return;   Bÿÿÿÿ       Bÿÿÿÿ     
           \     6     6     ÿÿÿÿ  ÿÿÿÿ     â—       statement executed        return b;   6ÿÿÿÿ       6ÿÿÿÿ                ]     0     0   C  ÿÿÿÿ  ÿÿÿÿ     +\à       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   0ÿÿÿÿ       0ÿÿÿÿ     C           ^     '     '   C  ıÿÿÿÿ  ıÿÿÿÿ     +UP       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   'ÿÿÿÿ  ı     'ÿÿÿÿ  ı   C           _               ïÿÿÿÿ  ïÿÿÿÿ     +N       statement executed        }   ÿÿÿÿ  ï     ÿÿÿÿ  ï              `               ãÿÿÿÿ  ãÿÿÿÿ     +F¸       statement executed        }   ÿÿÿÿ  ã     ÿÿÿÿ  ã              a                 Øÿÿÿÿ  Øÿÿÿÿ     +BX       statement executed        }    ÿÿÿÿ  Ø      ÿÿÿÿ  Ø              b     ø     ø   
  Ğÿÿÿÿ  Ğÿÿÿÿ     +;        statement executed        return;   øÿÿÿÿ  Ğ     øÿÿÿÿ  Ğ   
           c     í     í     Æÿÿÿÿ  Æÿÿÿÿ     +7¨       statement executed        }   íÿÿÿÿ  Æ     íÿÿÿÿ  Æ              d     é     é   7  Âÿÿÿÿ  Âÿÿÿÿ     +5P       statement executed        yy_current_buffer = yy_create_buffer( yyin, 16384 );   éÿÿÿÿ  Â     éÿÿÿÿ  Â   7           e     İ     İ     ·ÿÿÿÿ  ·ÿÿÿÿ     +0X       statement executed        return c;   İÿÿÿÿ  ·     İÿÿÿÿ  ·              f     Õ     Õ     ¯ÿÿÿÿ  ¯ÿÿÿÿ     ++ˆ       statement executed        }   Õÿÿÿÿ  ¯     Õÿÿÿÿ  ¯              g     Ê     Ê     ¦ÿÿÿÿ  ¦ÿÿÿÿ     +)˜       statement executed        break;   Êÿÿÿÿ  ¦     Êÿÿÿÿ  ¦              h     Ä     Ä     ¡ÿÿÿÿ  ¡ÿÿÿÿ     +&p       statement executed        return input();   Äÿÿÿÿ  ¡     Äÿÿÿÿ  ¡              i     À     À     ÿÿÿÿ  ÿÿÿÿ     +$°       statement executed        yyrestart( yyin );   Àÿÿÿÿ       Àÿÿÿÿ                j     ¼     ¼     ™ÿÿÿÿ  ™ÿÿÿÿ     +!È       statement executed        return (-1);   ¼ÿÿÿÿ  ™     ¼ÿÿÿÿ  ™              k     ­     ­     Šÿÿÿÿ  Šÿÿÿÿ     +       statement executed        *yy_c_buf_p = '\0';   ­ÿÿÿÿ  Š     ­ÿÿÿÿ  Š              l     —     —     vÿÿÿÿ  vÿÿÿÿ     +(       statement executed        }   —ÿÿÿÿ  v     —ÿÿÿÿ  v              m               nÿÿÿÿ  nÿÿÿÿ     +h       statement executed        }   ÿÿÿÿ  n     ÿÿÿÿ  n              n             8  mÿÿÿÿ  mÿÿÿÿ     +¨       statement executed        yy_fatal_error( "flex scanner push-back overflow" );   ÿÿÿÿ  m     ÿÿÿÿ  m   8           o     ‡     ‡     fÿÿÿÿ  fÿÿÿÿ     +¨       statement executed        *--dest = *--source;   ‡ÿÿÿÿ  f     ‡ÿÿÿÿ  f              p     k     k   *  Kÿÿÿÿ  Kÿÿÿÿ     òäØ       statement executed        return yy_is_jam ? 0 : yy_current_state;   kÿÿÿÿ  K     kÿÿÿÿ  K   *           q     g     g     Gÿÿÿÿ  Gÿÿÿÿ     òŞˆ       statement executed        }   gÿÿÿÿ  G     gÿÿÿÿ  G              r     f     f   (  Fÿÿÿÿ  Fÿÿÿÿ     òÜÈ       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   fÿÿÿÿ  F     fÿÿÿÿ  F   (           s     a     a     Aÿÿÿÿ  Aÿÿÿÿ     òÔà       statement executed        }   aÿÿÿÿ  A     aÿÿÿÿ  A              t     H     H     )ÿÿÿÿ  )ÿÿÿÿ     òË       statement executed        return yy_current_state;   Hÿÿÿÿ  )     Hÿÿÿÿ  )              u     F     F     'ÿÿÿÿ  'ÿÿÿÿ     òÉà       statement executed        }   Fÿÿÿÿ  '     Fÿÿÿÿ  '              v     D     D     %ÿÿÿÿ  %ÿÿÿÿ     òÆ¸       statement executed        }   Dÿÿÿÿ  %     Dÿÿÿÿ  %              w     C     C   )  $ÿÿÿÿ  $ÿÿÿÿ     òÄø       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   Cÿÿÿÿ  $     Cÿÿÿÿ  $   )           x     >     >     ÿÿÿÿ  ÿÿÿÿ     ò½       statement executed        }   >ÿÿÿÿ       >ÿÿÿÿ                y     *     *     ÿÿÿÿ  ÿÿÿÿ     ò±        statement executed        return ret_val;   *ÿÿÿÿ       *ÿÿÿÿ                z     "     "     ÿÿÿÿ  ÿÿÿÿ     òª0       statement executed        ret_val = 0;   "ÿÿÿÿ       "ÿÿÿÿ                {               ÿÿÿÿÿ  ÿÿÿÿÿ     4<H       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              |               øÿÿÿÿ  øÿÿÿÿ     48à       statement executed        }   ÿÿÿÿ  ø     ÿÿÿÿ  ø              }           <  ïÿÿÿÿ  ïÿÿÿÿ     40Ğ       statement executed        yy_fatal_error( "input in flex scanner failed" );   ÿÿÿÿ  ï    ÿÿÿÿ  ï  <           ~       †    ‡  ïÿÿÿÿ  ïÿÿÿÿ     4)°       statement executed        }   ÿÿÿÿ  ï  †  ÿÿÿÿ  ï  ‡                  D    u  ïÿÿÿÿ  ïÿÿÿÿ     4&       statement executed        yy_fatal_error( "input in flex scanner failed" );   ÿÿÿÿ  ï  D  ÿÿÿÿ  ï  u           €        à       ïÿÿÿÿ  ïÿÿÿÿ     4¸       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c;   ÿÿÿÿ  ï   à  ÿÿÿÿ  ï                           Î  ïÿÿÿÿ  ïÿÿÿÿ     4à       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c;   ÿÿÿÿ  ï     ÿÿÿÿ  ï   Î           ‚     
     
     ìÿÿÿÿ  ìÿÿÿÿ     öÃ0       statement executed        num_to_read = 8192;   
ÿÿÿÿ  ì     
ÿÿÿÿ  ì              ƒ               éÿÿÿÿ  éÿÿÿÿ     öÀğ       statement executed        }   ÿÿÿÿ  é     ÿÿÿÿ  é              „     ÿ     ÿ   E  ãÿÿÿÿ  ãÿÿÿÿ     ö¹˜       statement executed        yy_fatal_error( "fatal error - scanner input buffer overflow" );   ÿÿÿÿÿ  ã     ÿÿÿÿÿ  ã   E           …     ü     ü     àÿÿÿÿ  àÿÿÿÿ     ö¶ˆ       statement executed        b->yy_ch_buf = 0;   üÿÿÿÿ  à     üÿÿÿÿ  à              †     ù     ù     İÿÿÿÿ  İÿÿÿÿ     ö´h       statement executed        }   ùÿÿÿÿ  İ     ùÿÿÿÿ  İ              ‡     ó     ó     ×ÿÿÿÿ  ×ÿÿÿÿ     ö°P       statement executed        b->yy_buf_size *= 2;   óÿÿÿÿ  ×     óÿÿÿÿ  ×              ˆ     ñ     ñ   +  Õÿÿÿÿ  Õÿÿÿÿ     áè       statement executed        b->yy_buf_size += b->yy_buf_size / 8;   ñÿÿÿÿ  Õ     ñÿÿÿÿ  Õ   +           ‰     Ø     Ø     ¼ÿÿÿÿ  ¼ÿÿÿÿ     /m€       statement executed        yy_n_chars = 0;   Øÿÿÿÿ  ¼     Øÿÿÿÿ  ¼              Š     Ò     Ò     ¶ÿÿÿÿ  ¶ÿÿÿÿ     /i        statement executed        *(dest++) = *(source++);   Òÿÿÿÿ  ¶     Òÿÿÿÿ  ¶              ‹     È     È     ¬ÿÿÿÿ  ¬ÿÿÿÿ     /bÈ       statement executed        return 2;   Èÿÿÿÿ  ¬     Èÿÿÿÿ  ¬              Œ     À     À     ¤ÿÿÿÿ  ¤ÿÿÿÿ     /ağ       statement executed        return 1;   Àÿÿÿÿ  ¤     Àÿÿÿÿ  ¤                   ¶     ¶   O  ›ÿÿÿÿ  ›ÿÿÿÿ     5{¸       statement executed        yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );   ¶ÿÿÿÿ  ›     ¶ÿÿÿÿ  ›   O                £     £     ˆÿÿÿÿ  ˆÿÿÿÿ     *ş`       statement executed        }   £ÿÿÿÿ  ˆ     £ÿÿÿÿ  ˆ                   ¢     ¢     ‡ÿÿÿÿ  ‡ÿÿÿÿ     *ı@       statement executed        }   ¢ÿÿÿÿ  ‡     ¢ÿÿÿÿ  ‡                   ›     ›   	  ÿÿÿÿ  ÿÿÿÿ     *ûH       statement executed        break;   ›ÿÿÿÿ       ›ÿÿÿÿ     	           ‘     š     š     €ÿÿÿÿ  €ÿÿÿÿ     *ùˆ       statement executed        }   šÿÿÿÿ  €     šÿÿÿÿ  €              ’     ™     ™     ÿÿÿÿ  ÿÿÿÿ     *ø°       statement executed        goto yy_find_action;   ™ÿÿÿÿ       ™ÿÿÿÿ                “               uÿÿÿÿ  uÿÿÿÿ     6»       statement executed        goto yy_match;   ÿÿÿÿ  u     ÿÿÿÿ  u              ”     „     „     jÿÿÿÿ  jÿÿÿÿ     -ìP       statement executed        break;   „ÿÿÿÿ  j     „ÿÿÿÿ  j              •     ƒ     ƒ     iÿÿÿÿ  iÿÿÿÿ     -ê        statement executed        }   ƒÿÿÿÿ  i     ƒÿÿÿÿ  i              –     ‚     ‚     hÿÿÿÿ  hÿÿÿÿ     -èğ       statement executed        yyrestart( yyin );   ‚ÿÿÿÿ  h     ‚ÿÿÿÿ  h              —     |     |     bÿÿÿÿ  bÿÿÿÿ     1x       statement executed        goto do_action;   |ÿÿÿÿ  b     |ÿÿÿÿ  b              ˜     d     d     Jÿÿÿÿ  Jÿÿÿÿ     4d˜       statement executed        goto yy_find_action;   dÿÿÿÿ  J     dÿÿÿÿ  J              ™     ^     ^     Dÿÿÿÿ  Dÿÿÿÿ     4_ğ       statement executed        goto yy_match;   ^ÿÿÿÿ  D     ^ÿÿÿÿ  D              š     ;     ;     !ÿÿÿÿ  !ÿÿÿÿ     4çX       statement executed        }   ;ÿÿÿÿ  !     ;ÿÿÿÿ  !              ›     #     #     	ÿÿÿÿ  	ÿÿÿÿ     5        statement executed        return 0;   #ÿÿÿÿ  	     #ÿÿÿÿ  	              œ     !     !     ÿÿÿÿ  ÿÿÿÿ     5p       statement executed        break;   !ÿÿÿÿ       !ÿÿÿÿ                               ÿÿÿÿ  ÿÿÿÿ     5Ğ       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                               ÿÿÿÿÿ  ÿÿÿÿÿ     5k@       statement executed        break;   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              Ÿ               úÿÿÿÿ  úÿÿÿÿ     5f        statement executed        return 276;   ÿÿÿÿ  ú     ÿÿÿÿ  ú                              öÿÿÿÿ  öÿÿÿÿ     4ƒ`       statement executed        return 275;   ÿÿÿÿ  ö     ÿÿÿÿ  ö              ¡               òÿÿÿÿ  òÿÿÿÿ     5Aè       statement executed        return 274;   ÿÿÿÿ  ò     ÿÿÿÿ  ò              ¢               îÿÿÿÿ  îÿÿÿÿ     5aˆ       statement executed        return 273;   ÿÿÿÿ  î     ÿÿÿÿ  î              £             $  êÿÿÿÿ  êÿÿÿÿ     ,š       statement executed        return 272;   ÿÿÿÿ  ê     ÿÿÿÿ  ê   $           ¤               $  æÿÿÿÿ  æÿÿÿÿ     5Rx       statement executed        return 271;    ÿÿÿÿ  æ      ÿÿÿÿ  æ   $           ¥     ü     ü   $  âÿÿÿÿ  âÿÿÿÿ     4ìÀ       statement executed        return 270;   üÿÿÿÿ  â     üÿÿÿÿ  â   $           ¦     ø     ø   $  Şÿÿÿÿ  Şÿÿÿÿ     5x       statement executed        return 269;   øÿÿÿÿ  Ş     øÿÿÿÿ  Ş   $           §     ô     ô   $  Úÿÿÿÿ  Úÿÿÿÿ     5hx       statement executed        return 268;   ôÿÿÿÿ  Ú     ôÿÿÿÿ  Ú   $           ¨     ğ     ğ   $  Öÿÿÿÿ  Öÿÿÿÿ     5BĞ       statement executed        return 277;   ğÿÿÿÿ  Ö     ğÿÿÿÿ  Ö   $           ©     ì     ì   $  Òÿÿÿÿ  Òÿÿÿÿ     5)        statement executed        return 265;   ìÿÿÿÿ  Ò     ìÿÿÿÿ  Ò   $           ª     é     é     Ïÿÿÿÿ  Ïÿÿÿÿ     5$`       statement executed        break;   éÿÿÿÿ  Ï     éÿÿÿÿ  Ï              «     ä     ä   $  Êÿÿÿÿ  Êÿÿÿÿ     5˜       statement executed        return 264;   äÿÿÿÿ  Ê     äÿÿÿÿ  Ê   $           ¬     à     à   %  Æÿÿÿÿ  Æÿÿÿÿ     5Ğ       statement executed        return 263;   àÿÿÿÿ  Æ     àÿÿÿÿ  Æ   %           ­     Ü     Ü   %  Âÿÿÿÿ  Âÿÿÿÿ     5€       statement executed        return 263;   Üÿÿÿÿ  Â     Üÿÿÿÿ  Â   %           ®     Ø     Ø   %  ¾ÿÿÿÿ  ¾ÿÿÿÿ     4m°       statement executed        return 263;   Øÿÿÿÿ  ¾     Øÿÿÿÿ  ¾   %           ¯     Ô     Ô   %  ºÿÿÿÿ  ºÿÿÿÿ     4İ       statement executed        return 262;   Ôÿÿÿÿ  º     Ôÿÿÿÿ  º   %           °     Ğ     Ğ   %  ¶ÿÿÿÿ  ¶ÿÿÿÿ     4õÈ       statement executed        return 266;   Ğÿÿÿÿ  ¶     Ğÿÿÿÿ  ¶   %           ±     Ì     Ì   %  ²ÿÿÿÿ  ²ÿÿÿÿ     5¨       statement executed        return 267;   Ìÿÿÿÿ  ²     Ìÿÿÿÿ  ²   %           ²     È     È   &  ®ÿÿÿÿ  ®ÿÿÿÿ     4ÁÈ       statement executed        return 260;   Èÿÿÿÿ  ®     Èÿÿÿÿ  ®   &           ³     Ä     Ä   %  ªÿÿÿÿ  ªÿÿÿÿ     4fø       statement executed        return 259;   Äÿÿÿÿ  ª     Äÿÿÿÿ  ª   %           ´     À     À   &  ¦ÿÿÿÿ  ¦ÿÿÿÿ     5CØ       statement executed        return 258;   Àÿÿÿÿ  ¦     Àÿÿÿÿ  ¦   &           µ     ¼     ¼     ¢ÿÿÿÿ  ¢ÿÿÿÿ     5@8       statement executed        goto yy_find_action;   ¼ÿÿÿÿ  ¢     ¼ÿÿÿÿ  ¢              ¶     v     v     \ÿÿÿÿ  \ÿÿÿÿ     4W0       statement executed        yy_start = 1;   vÿÿÿÿ  \     vÿÿÿÿ  \              ·     y     y     _ÿÿÿÿ  _ÿÿÿÿ     4Sx       statement executed        yyin = (&__iob_func()[0]);   yÿÿÿÿ  _     yÿÿÿÿ  _              ¸     |     |     bÿÿÿÿ  bÿÿÿÿ     4Ö       statement executed        yyout = (&__iob_func()[1]);   |ÿÿÿÿ  b     |ÿÿÿÿ  b              ¹          €   %  eÿÿÿÿ  fÿÿÿÿ     4û       statement executed        yy_current_buffer =
				yy_create_buffer( yyin, 16384 );   ÿÿÿÿ  e     €ÿÿÿÿ  f   %           º     ƒ     ƒ     iÿÿÿÿ  iÿÿÿÿ     4öà       statement executed        }   ƒÿÿÿÿ  i     ƒÿÿÿÿ  i              »     š     š     €ÿÿÿÿ  €ÿÿÿÿ     4H       statement executed        }   šÿÿÿÿ  €     šÿÿÿÿ  €              ¼     Ÿ     Ÿ   *  …ÿÿÿÿ  …ÿÿÿÿ     4™       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   Ÿÿÿÿÿ  …     Ÿÿÿÿÿ  …   *           ½                 †ÿÿÿÿ  †ÿÿÿÿ     4¡        statement executed        }    ÿÿÿÿ  †      ÿÿÿÿ  †              ¾     £     £     ‰ÿÿÿÿ  ‰ÿÿÿÿ     4D8       statement executed        }   £ÿÿÿÿ  ‰     £ÿÿÿÿ  ‰              ¿     ­     ­     “ÿÿÿÿ  “ÿÿÿÿ     5Nè       statement executed        }   ­ÿÿÿÿ  “     ­ÿÿÿÿ  “           yylex int yylex ()   f     £     Lÿÿÿÿ  ˆÿÿÿÿyy_get_next_buffer static int yy_get_next_buffer()   ¯     +     ”ÿÿÿÿ  ÿÿÿÿyy_get_previous_state static yy_state_type yy_get_previous_state()   1     I     ÿÿÿÿ  *ÿÿÿÿyy_try_NUL_trans static yy_state_type yy_try_NUL_trans( yy_current_state )   X     l     8ÿÿÿÿ  Lÿÿÿÿyyunput static void yyunput( c, yy_bp )   w     —     Vÿÿÿÿ  vÿÿÿÿinput static int input()         Ş     }ÿÿÿÿ  ¸ÿÿÿÿyyrestart void yyrestart( input_file )   ç     í     Àÿÿÿÿ  Æÿÿÿÿyy_switch_to_buffer void yy_switch_to_buffer( new_buffer )   ö          Îÿÿÿÿ  ãÿÿÿÿyy_load_buffer_state void yy_load_buffer_state()             êÿÿÿÿ  ïÿÿÿÿyy_create_buffer YY_BUFFER_STATE yy_create_buffer( file, size )   "     7     øÿÿÿÿ  ÿÿÿÿyy_delete_buffer void yy_delete_buffer( b )   @     K     ÿÿÿÿ   ÿÿÿÿyy_init_buffer void yy_init_buffer( b, file )   ]     l     /ÿÿÿÿ  :ÿÿÿÿyy_flush_buffer void yy_flush_buffer( b )   v     ‡     Cÿÿÿÿ  Tÿÿÿÿyy_scan_buffer YY_BUFFER_STATE yy_scan_buffer( base, size )   ’     ¬     ^ÿÿÿÿ  xÿÿÿÿyy_scan_string YY_BUFFER_STATE yy_scan_string( str )   ·     ½     ÿÿÿÿ  ‡ÿÿÿÿyy_scan_bytes YY_BUFFER_STATE yy_scan_bytes( bytes, len )   É     ä     ‘ÿÿÿÿ  ¬ÿÿÿÿyy_fatal_error static void yy_fatal_error( msg )   &     )     ëÿÿÿÿ  îÿÿÿÿyy_flex_alloc static void *yy_flex_alloc( size )   V     X     ÿÿÿÿ  ÿÿÿÿyy_flex_realloc static void *yy_flex_realloc( ptr, size )   a     j     $ÿÿÿÿ  -ÿÿÿÿyy_flex_free static void yy_flex_free( ptr )   r     t     4ÿÿÿÿ  6ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 25
#define YY_END_OF_BUFFER 26
static yyconst short int yy_accept[172] =
    {   0,
        0,    0,   26,   24,   23,   22,   24,   10,   10,   13,
       19,   10,   10,   24,   24,   14,   24,   15,   23,    0,
       12,   10,    0,   10,   11,    0,    0,   18,   16,   17,
        0,   12,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   20,    0,    0,    0,    0,    0,    0,
        0,    0,    4,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   21,    0,    0,    0,    6,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    9,    0,    0,
        0,    0,    0,    0,    0,    8,    7,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    3,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    2,    1,
        0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    1,    1,    1,    6,    1,    7,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    9,    1,    1,
       10,    1,    1,    1,   13,   14,   15,   16,   17,   18,
       19,   20,   21,    1,    1,   22,   23,   24,   25,   26,
        1,   27,   28,   29,   30,   31,    1,   32,   33,    1,
       11,    1,   12,    1,    1,    1,   13,   14,   15,   16,

       17,   18,   19,   20,   21,    1,    1,   22,   23,   24,
       25,   26,    1,   27,   28,   29,   30,   31,    1,   32,
       33,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[34] =
    {   0,
        1,    1,    1,    1,    1,    1,    2,    2,    1,    1,
        1,    1,    2,    2,    2,    2,    2,    2,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1
    } ;

static yyconst short int yy_base[173] =
    {   0,
        0,    0,  212,  213,   32,  213,  206,   31,  178,  213,
      213,    0,  188,  191,  175,  179,  173,  177,   39,  198,
       43,  170,   45,    0,  213,  172,  176,  213,  213,  213,
       53,   47,   49,  184,  179,  169,  182,  178,  177,  176,
       32,   52,  167,  162,  161,  161,  173,  155,  164,  172,
      156,   63,  153,  162,   49,  156,  175,  174,  165,  150,
      147,   60,  151,  213,  147,  147,  150,  166,  165,  140,
      139,  150,   68,  137,  136,  160,  133,  157,  156,  139,
      155,  135,  213,  153,  134,  126,  213,  123,  137,  148,
      129,  125,  132,  131,  134,  123,  120,  125,  139,  138,

      112,  115,  120,  119,  114,  113,  118,  118,  114,  111,
      106,  105,  125,  111,  106,  102,  109,  108,  110,  117,
       97,  101,  102,  101,   93,  111,   96,  110,  108,  107,
       95,  105,  105,   80,  102,  101,  101,  213,   76,   86,
       97,   96,   71,   82,   70,  213,  213,   76,   68,   67,
       71,   65,   71,   74,   69,   64,  213,   63,   63,   62,
       73,   72,   78,   77,   74,   73,   72,   37,  213,  213,
      213,   33
    } ;

static yyconst short int yy_def[173] =
    {   0,
      171,    1,  171,  171,  171,  171,  171,  171,    8,  171,
      171,  172,  172,  171,  171,  171,  171,  171,  171,  171,
      171,    8,  171,  172,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,

      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
        0,  171
    } ;

static yyconst short int yy_nxt[247] =
    {   0,
        4,    5,    6,    5,    7,    4,    8,    9,   10,   11,
        4,    4,   12,   13,   12,   12,   12,   12,    4,    4,
        4,   14,    4,    4,    4,    4,   15,   16,   17,    4,
        4,   18,    4,   19,   24,   19,   21,   22,   22,   23,
       19,  170,   19,   24,   24,   24,   24,   24,   24,   32,
       32,   33,   33,   32,   32,   33,   33,   42,   52,   52,
       50,   65,   25,   36,   51,   37,   73,   73,   38,   52,
       52,   62,   39,   66,   73,   73,  169,  168,  167,   40,
       41,  166,  165,  164,  163,  162,  161,  160,  159,  158,
      157,  156,  155,  154,  153,  152,  151,  150,  149,  148,

      147,  146,  145,  144,  143,  142,  141,  140,  139,  138,
      137,  136,  135,  134,  133,  132,  131,  130,  129,  128,
      127,  126,  125,  124,  123,  122,  121,  120,  119,  118,
      117,  116,  115,  114,  113,  112,  111,  110,  109,  108,
      107,  106,  105,  104,  103,  102,  101,  100,   99,   98,
       97,   96,   95,   94,   93,   92,   91,   90,   89,   88,
       87,   87,   86,   85,   84,   83,   82,   81,   80,   79,
       78,   77,   76,   75,   74,   72,   71,   70,   69,   68,
       67,   64,   63,   61,   60,   59,   58,   57,   56,   55,
       54,   53,   49,   48,   47,   46,   45,   44,   43,   35,

       34,  171,   31,   30,   28,   29,   28,   27,   26,  171,
       20,  171,    3,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171
    } ;

static yyconst short int yy_chk[247] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    5,  172,    5,    8,    8,    8,    8,
       19,  168,   19,    8,    8,    8,    8,    8,    8,   21,
       21,   23,   23,   32,   32,   33,   33,   33,   42,   42,
       41,   55,    8,   31,   41,   31,   62,   62,   31,   52,
       52,   52,   31,   55,   73,   73,  167,  166,  165,   31,
       31,  164,  163,  162,  161,  160,  159,  158,  156,  155,
      154,  153,  152,  151,  150,  149,  148,  145,  144,  143,

      142,  141,  140,  139,  137,  136,  135,  134,  133,  132,
      131,  130,  129,  128,  127,  126,  125,  124,  123,  122,
      121,  120,  119,  118,  117,  116,  115,  114,  113,  112,
      111,  110,  109,  108,  107,  106,  105,  104,  103,  102,
      101,  100,   99,   98,   97,   96,   95,   94,   93,   92,
       91,   90,   89,   88,   86,   85,   84,   82,   81,   80,
       79,   78,   77,   76,   75,   74,   72,   71,   70,   69,
       68,   67,   66,   65,   63,   61,   60,   59,   58,   57,
       56,   54,   53,   51,   50,   49,   48,   47,   46,   45,
       44,   43,   40,   39,   38,   37,   36,   35,   34,   27,

       26,   22,   20,   18,   17,   16,   15,   14,   13,    9,
        7,    3,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0

#include <stdio.h>
#include <string.h>
#include "log_asc_parser.h"
char x[5] = "Hi";

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 172 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 213 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
yylval = _strdup(yytext); return BEGINLOGTOKEN;
	YY_BREAK
case 2:
YY_RULE_SETUP
yylval = _strdup(yytext);return ENDLOGTOKEN;
	YY_BREAK
case 3:
YY_RULE_SETUP
yylval = _strdup(yytext); return DATETOKEN;
	YY_BREAK
case 4:
YY_RULE_SETUP
yylval = _strdup(yytext);return TIME;
	YY_BREAK
case 5:
YY_RULE_SETUP
yylval = _strdup(yytext);return DATE;
	YY_BREAK
case 6:
YY_RULE_SETUP
yylval = _strdup(yytext);return BASE;
	YY_BREAK
case 7:
YY_RULE_SETUP
yylval = _strdup(yytext);return TIMEMODE;
	YY_BREAK
case 8:
YY_RULE_SETUP
yylval = _strdup(yytext);return TIMEMODE;
	YY_BREAK
case 9:
YY_RULE_SETUP
yylval = _strdup(yytext);return TIMEMODE;
	YY_BREAK
case 10:
YY_RULE_SETUP
yylval =_strdup(yytext);return NUMBER;
	YY_BREAK
case 11:
YY_RULE_SETUP
;
	YY_BREAK
case 12:
YY_RULE_SETUP
yylval =_strdup(yytext);return DOUBLEVAL;
	YY_BREAK
case 13:
YY_RULE_SETUP
yylval =_strdup(yytext);return COLON;
	YY_BREAK
case 14:
YY_RULE_SETUP
yylval =_strdup(yytext);return STDMSG;
	YY_BREAK
case 15:
YY_RULE_SETUP
yylval =_strdup(yytext);return EXTMSG;
	YY_BREAK
case 16:
YY_RULE_SETUP
yylval =_strdup(yytext);return STDRMSG;
	YY_BREAK
case 17:
YY_RULE_SETUP
yylval =_strdup(yytext);return EXTRMSG;
	YY_BREAK
case 18:
YY_RULE_SETUP
yylval =_strdup(yytext);return MSGDIR;
	YY_BREAK
case 19:
YY_RULE_SETUP
return EQUAL;
	YY_BREAK
case 20:
YY_RULE_SETUP
return LENGTHTOKEN;
	YY_BREAK
case 21:
YY_RULE_SETUP
return BITCOUNTTOKEN;
	YY_BREAK
case 22:
YY_RULE_SETUP
return LINEEND;
	YY_BREAK
case 23:
YY_RULE_SETUP
/* ignore whitespace */;
	YY_BREAK
case 24:
YY_RULE_SETUP
/* ignore Anything else */;
	YY_BREAK
case 25:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a singled characater, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 172 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 172 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 171);

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yytext_ptr = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext_ptr + YY_MORE_ADJ;
						return EOF;
						}

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
					break;

				case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
					YY_FATAL_ERROR(
					"unexpected last match in yyinput()" );
#else
					YY_FATAL_ERROR(
					"unexpected last match in input()" );
#endif
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *str )
#else
YY_BUFFER_STATE yy_scan_string( str )
yyconst char *str;
#endif
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif






































extern int nGetDayFromDate(char* pchDate, char *chMonth, char* chWeekDay);

int nSize = 0;
int nLen = 0;
int nTimeMode = -1;
int nNumLines = 0;
char data[256];
int nNumModeProcd = 0;
int nTimeModeProcd = 0;
int nRetval = 1;
extern FILE *yyin, *yyout;

void yyerror(const char *str)
{
	
}

int yywrap()
{
	
	
	
	return nRetval;	
				
				
}
int nGetDate(char* pchDateString,  int* nDate, char* pchMonth, char* pchDay, int* nYear)
{
	char chTempDate[18] = {'\0'};
	char chTemp;
	int nMonth;
	strcpy(chTempDate, pchDateString);
	nGetDayFromDate(chTempDate, pchMonth, pchDay);
	sscanf(pchDateString, "%d%c%d%c%d", nDate, &chTemp, &nMonth, &chTemp, nYear);
	
	return 0;
}
int nGetTime( char* pchTimeString, int* nHour, int* nMin, int* nSec, char* pchAmPm)
{
	char chTemp;
	sscanf(pchTimeString, "%d%c%d%c%d", nHour, &chTemp, nMin, &chTemp, nSec);
	strcpy(pchAmPm, "am");
	if(*nHour > 12)
	{
		*nHour = *nHour - 12;
		strcpy(pchAmPm, "pm");
	}
	return 0;
}
int nSecondToTime(unsigned int nSeconds, int *nHours, int *nMin, int *nSec)
{
	*nHours = nSeconds / 3600; 
	nSeconds = nSeconds -(*nHours * 3600);
	*nMin = nSeconds / 60; 
	*nSec = nSeconds - (*nMin) * 60;
}
int nGetAscTimeStamp(char* pchLogTime, char* pchAscTime)
{
	char chSeparators[] = ".";
	char pchTemp;
	char chMilliSeconds[5] = {'\0'};
	int nHours, nMin, nSec;
	int nMicroSeconds;
	unsigned int unTotalSec;
	float fAscTime;
	if(pchAscTime == ((void *)0) || pchLogTime == ((void *)0))
	{
		return -1;
	}
	printf("%s\n", pchLogTime);
	sscanf(pchLogTime, "%d%c%d%c%d%c%d", &nHours, &pchTemp, &nMin, &pchTemp, &nSec, &pchTemp, &nMicroSeconds);
	unTotalSec = nHours*3660 + nMin * 60 + nSec;
	printf("%d\n", nMicroSeconds);
	sprintf(pchAscTime, "%u.%06d", unTotalSec, nMicroSeconds*100);
	return 0;
}
int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile)
{
	nRetval = 1;
	if( (((void *)0) != fpInputFile) && (((void *)0) != fpOutputFile) )
	{ 
		yyin = fpInputFile;
		yyout = fpOutputFile;
		yyparse();
	}
	return nRetval;
}


typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;



















static  char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    24,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23
};





































static  short yyr1[] = {     0,
    25,    25,    26,    26,    26,    26,    26,    26,    26,    26,
    26,    26,    26,    26,    27,    27,    28,    29,    30,    31,
    32,    33,    34,    35,    36,    37,    38
};

static  short yyr2[] = {     0,
     1,     2,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     0,     2,     3,     3,     3,     1,
     1,     7,     7,     6,     6,     1,     2
};

static  short yydefact[] = {     0,
     3,    26,     0,    20,    21,     0,     0,     0,     0,     1,
    10,    11,    12,    13,    14,     4,     5,     6,     7,     8,
     9,    27,     0,     0,     0,     0,     2,    19,     0,    17,
    18,     0,     0,     0,     0,    15,    15,    24,    22,    23,
    16,     0,     0
};

static  short yydefgoto[] = {     9,
    10,    39,    11,    12,    13,    14,    15,    16,    17,    18,
    19,    20,    21
};

static  short yypact[] = {     9,
   -22,-32768,    -8,-32768,-32768,   -11,    -9,    -7,     0,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,     3,    13,    17,    18,-32768,-32768,    21,-32768,
-32768,    10,    22,    23,    24,-32768,-32768,-32768,    25,    25,
-32768,    35,-32768
};

static  short yypgoto[] = {-32768,
    27,   -19,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768
};





static  short yytable[] = {    42,
     1,    22,    23,     2,     3,    24,     4,     5,    25,     1,
    26,     6,     2,     3,    28,     4,     5,    40,     7,     8,
     6,    29,    33,    34,    35,    30,    31,     7,     8,    32,
    36,    37,    38,    41,    43,    27
};

static  short yycheck[] = {     0,
     1,    24,    11,     4,     5,    17,     7,     8,    18,     1,
    18,    12,     4,     5,    12,     7,     8,    37,    19,    20,
    12,     9,    13,    14,    15,     9,     9,    19,    20,     9,
     9,     9,     9,     9,     0,     9
};


















































































































int	yychar;			
int	yylval;			
				






int yynerrs;			































static void
__yy_memcpy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}































int
yyparse()
     
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register int *yyvsp;
  int yyerrstatus;	
  int yychar1 = 0;		

  short	yyssa[200];	
  int yyvsa[200];	

  short *yyss = yyssa;		
  int *yyvs = yyvsa;	










  int yystacksize = 200;










  int yyval;		
				
				

  int yylen;





  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = -2;		

  




  yyssp = yyss - 1;
  yyvsp = yyvs;







yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      
      
      int *yyvs1 = yyvs;
      short *yyss1 = yyss;




      
      int size = yyssp - yyss + 1;
























      
      if (yystacksize >= 10000)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > 10000)
	yystacksize = 10000;
      yyss = (short *) _alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (int *) _alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));





      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;








      if (yyssp >= yyss + yystacksize - 1)
	return(1);
    }





  goto yybackup;
 yybackup:





  

  yyn = yypact[yystate];
  if (yyn == -32768)
    goto yydefault;

  

  


  if (yychar == -2)
    {



      yychar = yylex();
    }

  

  if (yychar <= 0)		
    {
      yychar1 = 0;
      yychar = 0;		




    }
  else
    {
      yychar1 = ((unsigned)(yychar) <= 278 ? yytranslate[yychar] : 39);












    }

  yyn += yychar1;
  if (yyn < 0 || yyn > 36 || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  






  if (yyn < 0)
    {
      if (yyn == -32768)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == 43)
    return(0);

  





  
  if (yychar != 0)
    yychar = -2;

  *++yyvsp = yylval;




  
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;


yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;


yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; 
















  switch (yyn) {

case 3:
{(yyerrstatus = 0);(yychar = -2); ;
    break;}
case 16:
{
		strcpy((data+nLen) , (char*)yyvsp[0]);
		nLen += strlen((char*)yyvsp[0]);
		data[nLen] = ' ';
		nLen++;
		data[nLen] = '\0';
	;
    break;}
case 17:
{
		yyval = yyvsp[0];
	;
    break;}
case 18:
{
		yyval = yyvsp[0];
	;
    break;}
case 19:
{
		
		
		int nDate, nYear;
		int nHour, nMin, nSec;
		char pchAmPm[3] = {'\0'};
		char pchMonth[4] = {'\0'};
		char pchDay[4] = {'\0'};
		nGetDate((char*)yyvsp[-1], &nDate, pchMonth, pchDay, &nYear);
		nGetTime((char*)yyvsp[0], &nHour, &nMin, &nSec, pchAmPm);
		
		fprintf(yyout, "date %s %s %d %d:%d:%d %s %d\n", pchDay, pchMonth, nDate, nHour, nMin, nSec, pchAmPm, nYear);
	;
    break;}
case 20:
{
		if(nNumModeProcd == 0)
		{
			if(strcmp((char*)yyvsp[0], "***HEX***") == 0)
			{
				fprintf(yyout, "base hex  ");
			}
			else
			{
				fprintf(yyout, "base dec  ");
			}
			
			
			
		}
	;
    break;}
case 21:
{
		if(nTimeModeProcd == 0)
		{
			if(strcmp((char*)yyvsp[0] ,"***RELATIVE MODE***") == 0)
			{
				fprintf(yyout, "timestamps relative\n");
			}
			else if(strcmp((char*)yyvsp[0] ,"***ABSOLUTE MODE***") == 0)
			{
				fprintf(yyout, "timestamps absolute\n");
			}
			else
			{
				nRetval = -2;
			}
			fprintf(yyout, "no internal events logged\n");
			fprintf(yyout, "// version 7.1.0\n");
			
			
			
		}
	;
    break;}
case 22:
{
		
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-6], chAscTime);
		
		fprintf(yyout, "%s %s %s %s d %s %s\n", chAscTime, yyvsp[-4], yyvsp[-3], yyvsp[-5], yyvsp[-1], data);
		nLen = 0;
		
		






	;
    break;}
case 23:
{
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-6], chAscTime);
		
		fprintf(yyout, "%s %s %sx %s d %s %s\n", chAscTime, yyvsp[-4], yyvsp[-3], yyvsp[-5], yyvsp[-1], data);
		nLen = 0;
	;
    break;}
case 24:
{
		
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-5], chAscTime);
		
		fprintf(yyout, "%s %s %s %s r\n", chAscTime, yyvsp[-3], yyvsp[-2], yyvsp[-4], yyvsp[0]);
	;
    break;}
case 25:
{
		
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-5], chAscTime);
		
		fprintf(yyout, "%s %s %s %s r\n", chAscTime, yyvsp[-3], yyvsp[-2], yyvsp[-4], yyvsp[0]);
	;
    break;}
case 26:
{
		fprintf(yyout, "End TriggerBlock\n\n");
	;
    break;}
}
   


  yyvsp -= yylen;
  yyssp -= yylen;














  *++yyvsp = yyval;


















  




  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - 25] + *yyssp;
  if (yystate >= 0 && yystate <= 36 && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - 25];

  goto yynewstate;

yyerrlab:   

  if (! yyerrstatus)
    
    {
      ++yynerrs;










































	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   

  if (yyerrstatus == 3)
    {
      

      
      if (yychar == 0)
	return(1);





      yychar = -2;
    }

  


  yyerrstatus = 3;		

  goto yyerrhandle;

yyerrdefault:  







yyerrpop:   

  if (yyssp == yyss) return(1);
  yyvsp--;
  yystate = *--yyssp;














yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == -32768)
    goto yyerrdefault;

  yyn += 1;
  if (yyn < 0 || yyn > 36 || yycheck[yyn] != 1)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == -32768)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == 43)
    return(0);





  *++yyvsp = yylval;




  yystate = yyn;
  goto yynewstate;
}

         ¿     ¿   5  £ÿÿÿÿ  £ÿÿÿÿ     4Ûh      expression was true       yycheck[yyn] != yychar1   ¿ÿÿÿÿ  £     ¿ÿÿÿÿ  £   5   expression was false       yycheck[yyn] != yychar1   ¿ÿÿÿÿ  £     ¿ÿÿÿÿ  £   5                4Ù¨        ¿     ¿     £ÿÿÿÿ  £ÿÿÿÿ     4×h      expression was true       yyn > 36   ¿ÿÿÿÿ  £     ¿ÿÿÿÿ  £      expression was false       yyn > 36   ¿ÿÿÿÿ  £     ¿ÿÿÿÿ  £                   ¿     ¿     £ÿÿÿÿ  £ÿÿÿÿ     4Ö      expression was true       yyn < 0   ¿ÿÿÿÿ  £     ¿ÿÿÿÿ  £      expression was false       yyn < 0   ¿ÿÿÿÿ  £     ¿ÿÿÿÿ  £                   ¾     ¾     Ÿÿÿÿÿ  Ÿÿÿÿÿ     57      expression was true       yystate >= 0   ¾ÿÿÿÿ  Ÿ     ¾ÿÿÿÿ  Ÿ      expression was false       yystate >= 0   ¾ÿÿÿÿ  Ÿ     ¾ÿÿÿÿ  Ÿ                   55        ®     ®   +  “ÿÿÿÿ  “ÿÿÿÿ     4Ğ@      expression was true       (unsigned)(yychar) <= 278   ®ÿÿÿÿ  “     ®ÿÿÿÿ  “   +   expression was false       (unsigned)(yychar) <= 278   ®ÿÿÿÿ  “     ®ÿÿÿÿ  “   +                4Ï(   
      y   &   y   C   uÿÿÿÿ   uÿÿÿÿ     4hÈ      expression was true       (((void *)0) != fpOutputFile)    yÿÿÿÿ   u   &   yÿÿÿÿ   u   C   expression was false       (((void *)0) != fpOutputFile)    yÿÿÿÿ   u   &   yÿÿÿÿ   u   C                4fø         y      y   "   uÿÿÿÿ   uÿÿÿÿ     4gà      expression was true       (((void *)0) != fpInputFile)    yÿÿÿÿ   u      yÿÿÿÿ   u   "   expression was false       (((void *)0) != fpInputFile)    yÿÿÿÿ   u      yÿÿÿÿ   u   "                4bà         k   "   k   ;   gÿÿÿÿ   gÿÿÿÿ     4T`      expression was true       pchLogTime == ((void *)0)    kÿÿÿÿ   g   "   kÿÿÿÿ   g   ;   expression was false       pchLogTime == ((void *)0)    kÿÿÿÿ   g   "   kÿÿÿÿ   g   ;                4R         k      k      gÿÿÿÿ   gÿÿÿÿ     4Sx      expression was true       pchAscTime == ((void *)0)    kÿÿÿÿ   g      kÿÿÿÿ   g      expression was false       pchAscTime == ((void *)0)    kÿÿÿÿ   g      kÿÿÿÿ   g                   4O`        Í   
  Í     ¼ÿÿÿÿ  ¼ÿÿÿÿ     4„8      expression was false       i-- > 0   Íÿÿÿÿ  ¼   
  Íÿÿÿÿ  ¼                   ¾     ¾   $  Ÿÿÿÿÿ  Ÿÿÿÿÿ     57ğ      expression was true       yystate <= 36   ¾ÿÿÿÿ  Ÿ     ¾ÿÿÿÿ  Ÿ   $   expression was false       yystate <= 36   ¾ÿÿÿÿ  Ÿ     ¾ÿÿÿÿ  Ÿ   $                560        D     D     "ÿÿÿÿ  "ÿÿÿÿ     5p¸      expression was false       yyn == 43   Dÿÿÿÿ  "     Dÿÿÿÿ  "                   5n        A     A     ÿÿÿÿ  ÿÿÿÿ     5k@      expression was false       yyn == 0   Aÿÿÿÿ       Aÿÿÿÿ                     5i        <     <     ÿÿÿÿ  ÿÿÿÿ     5fx      expression was false       yyn == -32768   <ÿÿÿÿ       <ÿÿÿÿ                     5dÈ        ¾   (  ¾   B  Ÿÿÿÿÿ  Ÿÿÿÿÿ     5;À      expression was true       yycheck[yystate] == *yyssp   ¾ÿÿÿÿ  Ÿ   (  ¾ÿÿÿÿ  Ÿ   B   expression was false       yycheck[yystate] == *yyssp   ¾ÿÿÿÿ  Ÿ   (  ¾ÿÿÿÿ  Ÿ   B                5:         2     2     ÿÿÿÿ  ÿÿÿÿ     5X0      expression was false       yyn == -32768   2ÿÿÿÿ       2ÿÿÿÿ                     5VÈ                  üÿÿÿÿ  üÿÿÿÿ     5RÈ      expression was false       yyssp == yyss   ÿÿÿÿ  ü     ÿÿÿÿ  ü                   5Q¨                    áÿÿÿÿ  áÿÿÿÿ     5KÈ      expression was false       yychar == 0    ÿÿÿÿ  á      ÿÿÿÿ  á                   5I(        û     û     Üÿÿÿÿ  Üÿÿÿÿ     5Mğ      expression was false       yyerrstatus == 3   ûÿÿÿÿ  Ü     ûÿÿÿÿ  Ü                   5Gø        Ç     Ç     ¨ÿÿÿÿ  ¨ÿÿÿÿ     5F      expression was false       ! yyerrstatus   Çÿÿÿÿ  ¨     Çÿÿÿÿ  ¨                   5CØ        F     F     (ÿÿÿÿ  (ÿÿÿÿ     5 ˆ      expression was false       nTimeModeProcd == 0   Fÿÿÿÿ  (     Fÿÿÿÿ  (                   5          4     4     ÿÿÿÿ  ÿÿÿÿ     50      expression was false       nNumModeProcd == 0   4ÿÿÿÿ       4ÿÿÿÿ                     5ğ   !     ø     ø     Ûÿÿÿÿ  Ûÿÿÿÿ     4ÿH      expression was false       yylen > 0   øÿÿÿÿ  Û     øÿÿÿÿ  Û              "     ò     ò     Õÿÿÿÿ  Õÿÿÿÿ     4ù¨      expression was false       yyn == 0   òÿÿÿÿ  Õ     òÿÿÿÿ  Õ                   4÷ø   #     é     é     Ìÿÿÿÿ  Ìÿÿÿÿ     4óP      expression was false       yyerrstatus   éÿÿÿÿ  Ì     éÿÿÿÿ  Ì              $     à     à     Ãÿÿÿÿ  Ãÿÿÿÿ     4ïà      expression was false       yychar != 0   àÿÿÿÿ  Ã     àÿÿÿÿ  Ã                   4í€   %     Õ     Õ     ¹ÿÿÿÿ  ¹ÿÿÿÿ     4ìÀ      expression was false       yyn == 43   Õÿÿÿÿ  ¹     Õÿÿÿÿ  ¹                   4ê    &     Ò     Ò     ¶ÿÿÿÿ  ¶ÿÿÿÿ     4çH      expression was false       yyn == 0   Òÿÿÿÿ  ¶     Òÿÿÿÿ  ¶                   4å˜   '     Í     Í     ±ÿÿÿÿ  ±ÿÿÿÿ     4â€      expression was false       yyn == -32768   Íÿÿÿÿ  ±     Íÿÿÿÿ  ±                   4àĞ   (     6     6     ÿÿÿÿ  ÿÿÿÿ     5Z°      expression was true       yyn < 0   6ÿÿÿÿ       6ÿÿÿÿ        expression was false       yyn < 0   6ÿÿÿÿ       6ÿÿÿÿ                *     —     —     ~ÿÿÿÿ  ~ÿÿÿÿ     4ÈÀ      expression was false       yychar == -2   —ÿÿÿÿ  ~     —ÿÿÿÿ  ~                   4Å˜   +               vÿÿÿÿ  vÿÿÿÿ     4Äp      expression was false       yyn == -32768   ÿÿÿÿ  v     ÿÿÿÿ  v                   4ÂÀ   ,     |     |   *  dÿÿÿÿ  dÿÿÿÿ     4½¨      expression was false       yyssp >= yyss + yystacksize - 1   |ÿÿÿÿ  d     |ÿÿÿÿ  d   *                4»è   -     e     e     Oÿÿÿÿ  Oÿÿÿÿ     4¬       expression was false       yystacksize > 10000   eÿÿÿÿ  O     eÿÿÿÿ  O              .     _     _     Iÿÿÿÿ  Iÿÿÿÿ     4¨p      expression was false       yystacksize >= 10000   _ÿÿÿÿ  I     _ÿÿÿÿ  I                   4¦h   /     :     :   &  $ÿÿÿÿ  $ÿÿÿÿ     4ÀX      expression was false       yyssp >= yyss + yystacksize - 1   :ÿÿÿÿ  $     :ÿÿÿÿ  $   &                4H   0     6     6     ÿÿÿÿ  ÿÿÿÿ     5[ˆ      expression was true       yyn > 36   6ÿÿÿÿ       6ÿÿÿÿ        expression was false       yyn > 36   6ÿÿÿÿ       6ÿÿÿÿ                2     6     6   /  ÿÿÿÿ  ÿÿÿÿ     5_H      expression was true       yycheck[yyn] != 1   6ÿÿÿÿ       6ÿÿÿÿ     /   expression was false       yycheck[yyn] != 1   6ÿÿÿÿ       6ÿÿÿÿ     /                5]ˆ   4      T      T      Pÿÿÿÿ   Pÿÿÿÿ     ,h      expression was false       *nHour > 12    Tÿÿÿÿ   P      Tÿÿÿÿ   P              5     R     R     /ÿÿÿÿ  /ÿÿÿÿ     5s`       statement executed        goto yynewstate;   Rÿÿÿÿ  /     Rÿÿÿÿ  /              6     E     E     #ÿÿÿÿ  #ÿÿÿÿ     5nğ       statement executed        return(0);   Eÿÿÿÿ  #     Eÿÿÿÿ  #              7     B     B      ÿÿÿÿ   ÿÿÿÿ     5jh       statement executed        goto yyerrpop;   Bÿÿÿÿ        Bÿÿÿÿ                 8     ?     ?     ÿÿÿÿ  ÿÿÿÿ     5hx       statement executed        goto yyreduce;   ?ÿÿÿÿ       ?ÿÿÿÿ                9     =     =     ÿÿÿÿ  ÿÿÿÿ     5e        statement executed        goto yyerrpop;   =ÿÿÿÿ       =ÿÿÿÿ                :     7     7     ÿÿÿÿ  ÿÿÿÿ     5a(       statement executed        goto yyerrdefault;   7ÿÿÿÿ       7ÿÿÿÿ                ;     3     3     ÿÿÿÿ  ÿÿÿÿ     5WX       statement executed        goto yyerrdefault;   3ÿÿÿÿ       3ÿÿÿÿ                <                üÿÿÿÿ  üÿÿÿÿ     5R8       statement executed        return(1);   ÿÿÿÿ  ü     ÿÿÿÿ  ü               =               ğÿÿÿÿ  ğÿÿÿÿ     5OÀ       statement executed        goto yyerrhandle;   ÿÿÿÿ  ğ     ÿÿÿÿ  ğ              >     	     	     éÿÿÿÿ  éÿÿÿÿ     5M       statement executed        }   	ÿÿÿÿ  é     	ÿÿÿÿ  é              ?               âÿÿÿÿ  âÿÿÿÿ     5J        statement executed        return(1);   ÿÿÿÿ  â     ÿÿÿÿ  â              @     ø     ø     Ùÿÿÿÿ  Ùÿÿÿÿ     5Fğ       statement executed        goto yyerrlab1;   øÿÿÿÿ  Ù     øÿÿÿÿ  Ù              A     ö     ö     ×ÿÿÿÿ  ×ÿÿÿÿ     5E0       statement executed        }   öÿÿÿÿ  ×     öÿÿÿÿ  ×              B     Ã     Ã     ¤ÿÿÿÿ  ¤ÿÿÿÿ     5BĞ       statement executed        goto yynewstate;   Ãÿÿÿÿ  ¤     Ãÿÿÿÿ  ¤              C     Á     Á   #  ¢ÿÿÿÿ  ¢ÿÿÿÿ     5A       statement executed        yystate = yydefgoto[yyn - 25];   Áÿÿÿÿ  ¢     Áÿÿÿÿ  ¢   #           D     ¿     ¿       ÿÿÿÿ   ÿÿÿÿ     5>è       statement executed        yystate = yytable[yystate];   ¿ÿÿÿÿ        ¿ÿÿÿÿ                  E               oÿÿÿÿ  oÿÿÿÿ     5,`       statement executed        break;   ÿÿÿÿ  o     ÿÿÿÿ  o              F     ˆ     ˆ     jÿÿÿÿ  jÿÿÿÿ     5+H       statement executed        break;   ˆÿÿÿÿ  j     ˆÿÿÿÿ  j              G               aÿÿÿÿ  aÿÿÿÿ     5)X       statement executed        break;   ÿÿÿÿ  a     ÿÿÿÿ  a              H     v     v     Xÿÿÿÿ  Xÿÿÿÿ     5'h       statement executed        break;   vÿÿÿÿ  X     vÿÿÿÿ  X              I     m     m     Oÿÿÿÿ  Oÿÿÿÿ     5$`       statement executed        break;   mÿÿÿÿ  O     mÿÿÿÿ  O              J     [     [     =ÿÿÿÿ  =ÿÿÿÿ     5!p       statement executed        break;   [ÿÿÿÿ  =     [ÿÿÿÿ  =              K     Y     Y     ;ÿÿÿÿ  ;ÿÿÿÿ     5°       statement executed        }   Yÿÿÿÿ  ;     Yÿÿÿÿ  ;              L     S     S     5ÿÿÿÿ  5ÿÿÿÿ     5ˆ       statement executed        }   Sÿÿÿÿ  5     Sÿÿÿÿ  5              M     O     O     1ÿÿÿÿ  1ÿÿÿÿ     5˜       statement executed        }   Oÿÿÿÿ  1     Oÿÿÿÿ  1              N     K     K     -ÿÿÿÿ  -ÿÿÿÿ     5h       statement executed        }   Kÿÿÿÿ  -     Kÿÿÿÿ  -              O     C     C     %ÿÿÿÿ  %ÿÿÿÿ     5       statement executed        break;   Cÿÿÿÿ  %     Cÿÿÿÿ  %              P     =     =     ÿÿÿÿ  ÿÿÿÿ     5p       statement executed        }   =ÿÿÿÿ       =ÿÿÿÿ                Q     9     9     ÿÿÿÿ  ÿÿÿÿ     5X       statement executed        }   9ÿÿÿÿ       9ÿÿÿÿ                R     1     1     ÿÿÿÿ  ÿÿÿÿ     5Ğ       statement executed        break;   1ÿÿÿÿ       1ÿÿÿÿ                S     "     "     ÿÿÿÿ  ÿÿÿÿ     5à       statement executed        break;   "ÿÿÿÿ       "ÿÿÿÿ                T               ÿÿÿÿÿ  ÿÿÿÿÿ     5°       statement executed        break;   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              U               úÿÿÿÿ  úÿÿÿÿ     5€       statement executed        break;   ÿÿÿÿ  ú     ÿÿÿÿ  ú              V      9      9      5ÿÿÿÿ   5ÿÿÿÿ     (ß8       statement executed        }    9ÿÿÿÿ   5      9ÿÿÿÿ   5              W      @      @      <ÿÿÿÿ   <ÿÿÿÿ     ,“        statement executed        return nRetval;    @ÿÿÿÿ   <      @ÿÿÿÿ   <              X      M      M      Iÿÿÿÿ   Iÿÿÿÿ     ,—       statement executed        return 0;    Mÿÿÿÿ   I      Mÿÿÿÿ   I              Y      X      X      Tÿÿÿÿ   Tÿÿÿÿ     ,œ       statement executed        }    Xÿÿÿÿ   T      Xÿÿÿÿ   T              Z      Y      Y      Uÿÿÿÿ   Uÿÿÿÿ     ,@       statement executed        return 0;    Yÿÿÿÿ   U      Yÿÿÿÿ   U              [      a      a      ]ÿÿÿÿ   ]ÿÿÿÿ     4EØ       statement executed        }    aÿÿÿÿ   ]      aÿÿÿÿ   ]              \      m      m      iÿÿÿÿ   iÿÿÿÿ     4VX       statement executed        return -1;    mÿÿÿÿ   i      mÿÿÿÿ   i              ]      t      t      pÿÿÿÿ   pÿÿÿÿ     4\        statement executed        return 0;    tÿÿÿÿ   p      tÿÿÿÿ   p              ^      ~      ~      zÿÿÿÿ   zÿÿÿÿ     4m°       statement executed        }    ~ÿÿÿÿ   z      ~ÿÿÿÿ   z              _                  {ÿÿÿÿ   {ÿÿÿÿ     4op       statement executed        return nRetval;    ÿÿÿÿ   {      ÿÿÿÿ   {              `     Î     Î     ½ÿÿÿÿ  ½ÿÿÿÿ     4ƒ`       statement executed        *t++ = *f++;   Îÿÿÿÿ  ½     Îÿÿÿÿ  ½              a     Ï     Ï     ¾ÿÿÿÿ  ¾ÿÿÿÿ     4…       statement executed        }   Ïÿÿÿÿ  ¾     Ïÿÿÿÿ  ¾              b     b     b     Lÿÿÿÿ  Lÿÿÿÿ     4§˜       statement executed        return 2;   bÿÿÿÿ  L     bÿÿÿÿ  L              c     f     f     Pÿÿÿÿ  Pÿÿÿÿ     4«È       statement executed        yystacksize = 10000;   fÿÿÿÿ  P     fÿÿÿÿ  P              d     }     }     eÿÿÿÿ  eÿÿÿÿ     4¼Ğ       statement executed        return(1);   }ÿÿÿÿ  e     }ÿÿÿÿ  e              e     ~     ~     fÿÿÿÿ  fÿÿÿÿ     4¾       statement executed        }   ~ÿÿÿÿ  f     ~ÿÿÿÿ  f              f     …     …     lÿÿÿÿ  lÿÿÿÿ     4Àø       statement executed        goto yybackup;   …ÿÿÿÿ  l     …ÿÿÿÿ  l              g               wÿÿÿÿ  wÿÿÿÿ     4Ã˜       statement executed        goto yydefault;   ÿÿÿÿ  w     ÿÿÿÿ  w              h               „ÿÿÿÿ  „ÿÿÿÿ     4È0       statement executed        }   ÿÿÿÿ  „     ÿÿÿÿ  „              i     «     «     ÿÿÿÿ  ÿÿÿÿ     4ÍÀ       statement executed        }   «ÿÿÿÿ       «ÿÿÿÿ                j     ¼     ¼      ÿÿÿÿ   ÿÿÿÿ     4Óè       statement executed        }   ¼ÿÿÿÿ        ¼ÿÿÿÿ                 k     À     À     ¤ÿÿÿÿ  ¤ÿÿÿÿ     4İH       statement executed        goto yydefault;   Àÿÿÿÿ  ¤     Àÿÿÿÿ  ¤              l     Î     Î     ²ÿÿÿÿ  ²ÿÿÿÿ     4á¨       statement executed        goto yyerrlab;   Îÿÿÿÿ  ²     Îÿÿÿÿ  ²              m     Ğ     Ğ     ´ÿÿÿÿ  ´ÿÿÿÿ     4ä€       statement executed        goto yyreduce;   Ğÿÿÿÿ  ´     Ğÿÿÿÿ  ´              n     Ó     Ó     ·ÿÿÿÿ  ·ÿÿÿÿ     4æp       statement executed        goto yyerrlab;   Óÿÿÿÿ  ·     Óÿÿÿÿ  ·              o     Ö     Ö     ºÿÿÿÿ  ºÿÿÿÿ     4êø       statement executed        return(0);   Öÿÿÿÿ  º     Öÿÿÿÿ  º              p     á     á     Äÿÿÿÿ  Äÿÿÿÿ     4ï       statement executed        yychar = -2;   áÿÿÿÿ  Ä     áÿÿÿÿ  Ä              q     é     é   "  Ìÿÿÿÿ  Ìÿÿÿÿ     4òx       statement executed        yyerrstatus--;   éÿÿÿÿ  Ì     éÿÿÿÿ  Ì   "           r     ì     ì     Ïÿÿÿÿ  Ïÿÿÿÿ     4õ€       statement executed        goto yynewstate;   ìÿÿÿÿ  Ï     ìÿÿÿÿ  Ï              s     ó     ó     Öÿÿÿÿ  Öÿÿÿÿ     4øĞ       statement executed        goto yyerrlab;   óÿÿÿÿ  Ö     óÿÿÿÿ  Ö              t     ù     ù     Üÿÿÿÿ  Üÿÿÿÿ     4ı€       statement executed        yyval = yyvsp[1-yylen];   ùÿÿÿÿ  Ü     ùÿÿÿÿ  Ü              u               ñÿÿÿÿ  ñÿÿÿÿ     5 (       statement executed        break;   ÿÿÿÿ  ñ     ÿÿÿÿ  ñ           yyerror void yyerror(const char *str)    7      9      3ÿÿÿÿ   5ÿÿÿÿyywrap int yywrap()    <      C      8ÿÿÿÿ   ?ÿÿÿÿnGetDate int nGetDate(char* pchDateString,  int* nDate, char* pchMonth, char* pchDay, int* nYear)    E      N      Aÿÿÿÿ   JÿÿÿÿnGetTime int nGetTime( char* pchTimeString, int* nHour, int* nMin, int* nSec, char* pchAmPm)    P      Z      Lÿÿÿÿ   VÿÿÿÿnSecondToTime int nSecondToTime(unsigned int nSeconds, int *nHours, int *nMin, int *nSec)    \      a      Xÿÿÿÿ   ]ÿÿÿÿnGetAscTimeStamp int nGetAscTimeStamp(char* pchLogTime, char* pchAscTime)    c      u      _ÿÿÿÿ   qÿÿÿÿnConvertFile int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile)    w      €      sÿÿÿÿ   |ÿÿÿÿ__yy_memcpy static void
__yy_memcpy (from, to, count)   È     Ï     ·ÿÿÿÿ  ¾ÿÿÿÿyyparse int
yyparse()   õ     S     áÿÿÿÿ  0ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
/*  A Bison parser, made from d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.y with Bison version GNU Bison version 1.24
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	BEGINLOGTOKEN	258
#define	ENDLOGTOKEN	259
#define	DATETOKEN	260
#define	FULLTIME	261
#define	BASE	262
#define	TIMEMODE	263
#define	NUMBER	264
#define	DOUBLEVAL	265
#define	DATE	266
#define	TIME	267
#define	STDMSG	268
#define	EXTMSG	269
#define	STDRMSG	270
#define	EXTRMSG	271
#define	MSGDIR	272
#define	EQUAL	273
#define	LENGTHTOKEN	274
#define	BITCOUNTTOKEN	275
#define	LINEEND	276
#define	COLON	277
#define	TIMESTAMPTOKEN	278



#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>

#define TIME_MODE_ABSOLUTE			 0
#define TIME_MODE_RELATIVE			 1
#define TIME_MODE_SYSTEM			 2
#define	TIME_MODE_UNDEFINED			-1
#define DEF_LOG_END_TEXT			"***END DATE AND TIME ***\n"
#define	DEF_LOG_STOP_TEXT			"***[STOP LOGGING SESSION]***"
extern int nGetDayFromDate(char* pchDate, char *chMonth, char* chWeekDay);

int nSize = 0;
int nLen = 0;
int nTimeMode = TIME_MODE_UNDEFINED;
int nNumLines = 0;
char data[256];
int nNumModeProcd = 0;
int nTimeModeProcd = 0;
int nRetval = 1;
extern FILE *yyin, *yyout;

void yyerror(const char *str)
{
	//fprintf(stderr,"error: %s\n",str);
}

int yywrap()
{
	// PTV[1.6.4]
	// Removed from here and added at the end of every block
	//fprintf(yyout, "End TriggerBlock\n");
	return nRetval;	//1 Sepcifies conversion is over.
				//0 specifies the parser start the conversion from different
				//Input
}
int nGetDate(char* pchDateString,  int* nDate, char* pchMonth, char* pchDay, int* nYear)
{
	char chTempDate[18] = {'\0'};
	char chTemp;
	int nMonth;
	strcpy(chTempDate, pchDateString);
	nGetDayFromDate(chTempDate, pchMonth, pchDay);
	sscanf(pchDateString, "%d%c%d%c%d", nDate, &chTemp, &nMonth, &chTemp, nYear);
	/*printf("%d, %d, %d\n", nDay, nMonth, *nYear);*/
	return 0;
}
int nGetTime( char* pchTimeString, int* nHour, int* nMin, int* nSec, char* pchAmPm)
{
	char chTemp;
	sscanf(pchTimeString, "%d%c%d%c%d", nHour, &chTemp, nMin, &chTemp, nSec);
	strcpy(pchAmPm, "am");
	if(*nHour > 12)
	{
		*nHour = *nHour - 12;
		strcpy(pchAmPm, "pm");
	}
	return 0;
}
int nSecondToTime(unsigned int nSeconds, int *nHours, int *nMin, int *nSec)
{
	*nHours = nSeconds / 3600; 
	nSeconds = nSeconds -(*nHours * 3600);
	*nMin = nSeconds / 60; 
	*nSec = nSeconds - (*nMin) * 60;
}
int nGetAscTimeStamp(char* pchLogTime, char* pchAscTime)
{
	char chSeparators[] = ".";
	char pchTemp;
	char chMilliSeconds[5] = {'\0'};
	int nHours, nMin, nSec;
	int nMicroSeconds;
	unsigned int unTotalSec;
	float fAscTime;
	if(pchAscTime == NULL || pchLogTime == NULL)
	{
		return -1;
	}
	printf("%s\n", pchLogTime);
	sscanf(pchLogTime, "%d%c%d%c%d%c%d", &nHours, &pchTemp, &nMin, &pchTemp, &nSec, &pchTemp, &nMicroSeconds);
	unTotalSec = nHours*3660 + nMin * 60 + nSec;
	printf("%d\n", nMicroSeconds);
	sprintf(pchAscTime, "%u.%06d", unTotalSec, nMicroSeconds*100);
	return 0;
}
int nConvertFile(FILE* fpInputFile, FILE* fpOutputFile)
{
	nRetval = 1;
	if( (NULL != fpInputFile) && (NULL != fpOutputFile) )
	{ 
		yyin = fpInputFile;
		yyout = fpOutputFile;
		yyparse();
	}
	return nRetval;
}

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#ifndef YYSTYPE
#define YYSTYPE int
#endif
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		43
#define	YYFLAG		-32768
#define	YYNTBASE	25

#define YYTRANSLATE(x) ((unsigned)(x) <= 278 ? yytranslate[x] : 39)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    24,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     5,     7,     9,    11,    13,    15,    17,    19,
    21,    23,    25,    27,    29,    30,    33,    37,    41,    45,
    47,    49,    57,    65,    72,    79,    81
};

static const short yyrhs[] = {    26,
     0,    25,    26,     0,     1,     0,    33,     0,    34,     0,
    35,     0,    36,     0,    37,     0,    38,     0,    28,     0,
    29,     0,    30,     0,    31,     0,    32,     0,     0,    27,
     9,     0,    19,    18,     9,     0,    20,    18,     9,     0,
     5,    11,    12,     0,     7,     0,     8,     0,    12,    17,
     9,     9,    13,     9,    27,     0,    12,    17,     9,     9,
    14,     9,    27,     0,    12,    17,     9,     9,    15,     9,
     0,    12,    17,     9,     9,    15,     9,     0,     4,     0,
     1,    24,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   107,   108,   111,   113,   115,   117,   119,   121,   123,   125,
   127,   129,   131,   133,   137,   138,   146,   151,   156,   171,
   189,   213,   232,   241,   250,   261,   267
};

static const char * const yytname[] = {   "$","error","$undefined.","BEGINLOGTOKEN",
"ENDLOGTOKEN","DATETOKEN","FULLTIME","BASE","TIMEMODE","NUMBER","DOUBLEVAL",
"DATE","TIME","STDMSG","EXTMSG","STDRMSG","EXTRMSG","MSGDIR","EQUAL","LENGTHTOKEN",
"BITCOUNTTOKEN","LINEEND","COLON","TIMESTAMPTOKEN","';'","commands","command",
"Can_Data_Bytes","Msg_Len","Bit_Count","Creation_Time","Number_Mode","TimeStamp_Mode",
"Standard_Msg","Extended_Msg","Standard_R_Msg","Extended_R_Msg","End_Statement",
"stmnt",""
};
#endif

static const short yyr1[] = {     0,
    25,    25,    26,    26,    26,    26,    26,    26,    26,    26,
    26,    26,    26,    26,    27,    27,    28,    29,    30,    31,
    32,    33,    34,    35,    36,    37,    38
};

static const short yyr2[] = {     0,
     1,     2,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     0,     2,     3,     3,     3,     1,
     1,     7,     7,     6,     6,     1,     2
};

static const short yydefact[] = {     0,
     3,    26,     0,    20,    21,     0,     0,     0,     0,     1,
    10,    11,    12,    13,    14,     4,     5,     6,     7,     8,
     9,    27,     0,     0,     0,     0,     2,    19,     0,    17,
    18,     0,     0,     0,     0,    15,    15,    24,    22,    23,
    16,     0,     0
};

static const short yydefgoto[] = {     9,
    10,    39,    11,    12,    13,    14,    15,    16,    17,    18,
    19,    20,    21
};

static const short yypact[] = {     9,
   -22,-32768,    -8,-32768,-32768,   -11,    -9,    -7,     0,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,     3,    13,    17,    18,-32768,-32768,    21,-32768,
-32768,    10,    22,    23,    24,-32768,-32768,-32768,    25,    25,
-32768,    35,-32768
};

static const short yypgoto[] = {-32768,
    27,   -19,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768
};


#define	YYLAST		36


static const short yytable[] = {    42,
     1,    22,    23,     2,     3,    24,     4,     5,    25,     1,
    26,     6,     2,     3,    28,     4,     5,    40,     7,     8,
     6,    29,    33,    34,    35,    30,    31,     7,     8,    32,
    36,    37,    38,    41,    43,    27
};

static const short yycheck[] = {     0,
     1,    24,    11,     4,     5,    17,     7,     8,    18,     1,
    18,    12,     4,     5,    12,     7,     8,    37,    19,    20,
    12,     9,    13,    14,    15,     9,     9,    19,    20,     9,
     9,     9,     9,     9,     0,     9
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */


/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif



/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#else
#define YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#endif

int
yyparse(YYPARSE_PARAM)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 3:
{yyerrok;yyclearin; ;
    break;}
case 16:
{
		strcpy((data+nLen) , (char*)yyvsp[0]);
		nLen += strlen((char*)yyvsp[0]);
		data[nLen] = ' ';
		nLen++;
		data[nLen] = '\0';
	;
    break;}
case 17:
{
		yyval = yyvsp[0];
	;
    break;}
case 18:
{
		yyval = yyvsp[0];
	;
    break;}
case 19:
{
		//Fri Dec 9 11:58:31 am 2011
		//9:12:2011 11:58:31:000
		int nDate, nYear;
		int nHour, nMin, nSec;
		char pchAmPm[3] = {'\0'};
		char pchMonth[4] = {'\0'};
		char pchDay[4] = {'\0'};
		nGetDate((char*)yyvsp[-1], &nDate, pchMonth, pchDay, &nYear);
		nGetTime((char*)yyvsp[0], &nHour, &nMin, &nSec, pchAmPm);
		//date Fri Dec 9 11:58:31 am 2011
		fprintf(yyout, "date %s %s %d %d:%d:%d %s %d\n", pchDay, pchMonth, nDate, nHour, nMin, nSec, pchAmPm, nYear);
	;
    break;}
case 20:
{
		if(nNumModeProcd == 0)
		{
			if(strcmp((char*)yyvsp[0], "***HEX***") == 0)
			{
				fprintf(yyout, "base hex  ");
			}
			else
			{
				fprintf(yyout, "base dec  ");
			}
			// PTV[1.6.4]
			// Commented to generate mode for every block
			//nNumModeProcd = 1;
		}
	;
    break;}
case 21:
{
		if(nTimeModeProcd == 0)
		{
			if(strcmp((char*)yyvsp[0] ,"***RELATIVE MODE***") == 0)
			{
				fprintf(yyout, "timestamps relative\n");
			}
			else if(strcmp((char*)yyvsp[0] ,"***ABSOLUTE MODE***") == 0)
			{
				fprintf(yyout, "timestamps absolute\n");
			}
			else
			{
				nRetval = -2;
			}
			fprintf(yyout, "no internal events logged\n");
			fprintf(yyout, "// version 7.1.0\n");
			// PTV[1.6.4]
			// Commented to generate mode for every block
			//nTimeModeProcd = 1;
		}
	;
    break;}
case 22:
{
		/*0:0:0:0012 Tx 1 9 s 8 00 00 00 00 00 00 00 00 */
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-6], chAscTime);
		/*0.001250 1  9               Tx   d 8 00 00 00 00 00 00 00 00*/
		fprintf(yyout, "%s %s %s %s d %s %s\n", chAscTime, yyvsp[-4], yyvsp[-3], yyvsp[-5], yyvsp[-1], data);
		nLen = 0;
		
		/*free($1);
		free($2);
		free($3);
		free($4);
		free($5);
		free($6);
		free($7);*/
	;
    break;}
case 23:
{
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-6], chAscTime);
		/*0.001250 1  9               Tx   d 8 00 00 00 00 00 00 00 00*/
		fprintf(yyout, "%s %s %sx %s d %s %s\n", chAscTime, yyvsp[-4], yyvsp[-3], yyvsp[-5], yyvsp[-1], data);
		nLen = 0;
	;
    break;}
case 24:
{
		/*<Time> <Channel> <ID> <Dir> r*/
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-5], chAscTime);
		/*0.001250 1  9               Tx   d 8 00 00 00 00 00 00 00 00*/
		fprintf(yyout, "%s %s %s %s r\n", chAscTime, yyvsp[-3], yyvsp[-2], yyvsp[-4], yyvsp[0]);
	;
    break;}
case 25:
{
		/*<Time> <Channel> <ID> <Dir> r*/
		char chAscTime[256] = {'\0'};
		nGetAscTimeStamp((char*)yyvsp[-5], chAscTime);
		/*0.001250 1  9               Tx   d 8 00 00 00 00 00 00 00 00*/
		fprintf(yyout, "%s %s %s %s r\n", chAscTime, yyvsp[-3], yyvsp[-2], yyvsp[-4], yyvsp[0]);
	;
    break;}
case 26:
{
		fprintf(yyout, "End TriggerBlock\n\n");
	;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */


  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}


























using namespace std;






CComment::CComment()
{
    m_elementName = "";
    m_msgID = 0;
    m_msgType = 0;
    m_comment = "";
}






CComment::~CComment()
{
}
          2      2      1ÿÿÿÿ   1ÿÿÿÿ    "        statement executed        }    2ÿÿÿÿ   1      2ÿÿÿÿ   1                    )      )      (ÿÿÿÿ   (ÿÿÿÿ    #X       statement executed        }    )ÿÿÿÿ   (      )ÿÿÿÿ   (           CComment::CComment CComment::CComment()    $      )      #ÿÿÿÿ   (ÿÿÿÿCComment::~CComment CComment::~CComment()    1      2      0ÿÿÿÿ   1ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Comment.cpp
 * \brief     Implementation of comment class
 * \authors   Mahesh B S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the comment class.
 */

/* Project includes */
#include "Comment.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CComment
 */
CComment::CComment()
{
    m_elementName = "";
    m_msgID = 0;
    m_msgType = 0;
    m_comment = "";
}

/**
 * \brief Destructor
 *
 * Destructor of CComment
 */
CComment::~CComment()
{
}



























using namespace std;

bool CConverter::valid_msg = true;
unsigned char CConverter::ucMsg_DLC = 8;
extern "C" int nBus ;
extern "C" int nProtocal ;
extern "C" int FindProtoCol(char*);
extern FILE* yyin;





CConverter::CConverter()
{
    m_uiResultCode = CON_RC_NOERROR;
}






CConverter::~CConverter()
{
    m_listMessages.clear();
}










unsigned int CConverter::Convert(string& sCanoeFile, string& sCanMonFile)
{
    
	fstream fileInput, fileOutput;
    char acLine[2052]; 

	
	char file[254];
	strcpy_s(file, 254, sCanoeFile.c_str());
	FindProtoCol(file);
	

    fileInput.open(sCanoeFile.c_str(), fstream::in);

    if(!fileInput.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);
    }

    
    if(fileInput.getline(acLine, 2052) == 0)
    {
        
        fileInput.close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
    }

    
    GenerateMessageList(fileInput);
    
    
	if(m_listMessages.size() > 0)
	{
		ValidateMessageList();
	}
    
    fileOutput.open(sCanMonFile.c_str(), fstream::out);

    if(!fileOutput.is_open())
    {
        
        
        fileInput.close();
        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);
    }

    EncryptData(m_notProcessed);
    bool bRes = WriteToOutputFile(fileOutput);
    fileInput.close();
    fileOutput.close();
	nProtocal = -1;
	nBus = 0;
    if(!bRes)
    {
        string sLogFile = sCanMonFile.substr(0, sCanMonFile.length()-4);
        sLogFile += ".log";
        m_omLogFilePath = sLogFile;
        fstream fileLog;
        fileLog.open(sLogFile.c_str(), fstream::out);

        if(!fileLog.is_open())
        {
            
            return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);
        }
        else
        {
            CreateLogFile(fileLog);
            fileLog.close();
            return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
        }
    }
	
	
    return m_uiResultCode;
}







void CConverter::GetResultString(string& str)
{
    switch(m_uiResultCode)
    {
        case 0:
            str = "Conversion completed.";
            break;

        case 1:
            str = "Conversion completed with warnings. See log file.";
            break;

        case 2:
            str = "Conversion aborted. Error opening input file.";
            break;

        case 3:
            str = "Conversion aborted. Error creating output file.";
            break;

        case 4:
            str = "Conversion aborted. Error with input file format.";
            break;

        case 5:
            str = "Conversion aborted. Error creating log file.";
            break;

        default:
            str = "Unknown";
            break;
    }
}








unsigned int CConverter::SetResultCode(unsigned int uiCode)
{
    return (m_uiResultCode = uiCode);
}






void CConverter::ValidateMessageList()
{
    list<CMessage>::iterator rMsg;
    unsigned int uiResult;

    for(rMsg=m_listMessages.begin(); rMsg!=m_listMessages.end(); ++rMsg)
    {
        unsigned char ucDataFormat = 0;

        
        
        if(rMsg->m_uiMsgID < 0x80000000UL)
        {
            rMsg->m_cFrameFormat = CMessage::MSG_FF_STANDARD;
        }
        else
        {
            rMsg->m_cFrameFormat = CMessage::MSG_FF_EXTENDED;
            rMsg->m_uiMsgID &= 0x7FFFFFFF;
        }

        rMsg->m_ucNumOfSignals = 0; 
        
        
        
        
        
        int iCntMotorolaSignals = 0;
        int iCntIntelSignals = 0;
        list<CSignal>::iterator rSig;

        for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
        {
            switch (rSig->m_ucDataFormat)
            {
                case CSignal::SIG_DF_INTEL:
                    iCntIntelSignals++;
                    break;

                case CSignal::SIG_DF_MOTOROLA:
                    iCntMotorolaSignals++;
                    break;
            }
        }

        
        if(iCntIntelSignals >= iCntMotorolaSignals)
        {
            ucDataFormat = CSignal::SIG_DF_INTEL;
            rMsg->m_cDataFormat = ucDataFormat; 
        }
        else
        {
            ucDataFormat = CSignal::SIG_DF_MOTOROLA;
            rMsg->m_cDataFormat = ucDataFormat;
        }

        

        for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
        {
            uiResult = rSig->Validate(ucDataFormat);

            
            if((uiResult == CSignal::SIG_EC_NO_ERR) || (uiResult == CSignal::SIG_EC_OVERFLOW))
            {
                






                rMsg->m_ucNumOfSignals++; 
            }
            else
            {
                int flag = 0;
                list<CMessage>::iterator usMsg;

                for(usMsg=m_unsupList.begin(); usMsg!=m_unsupList.end(); ++usMsg)
                {
                    
                    if((usMsg->m_uiMsgID == rMsg->m_uiMsgID) && (usMsg->m_cFrameFormat == rMsg->m_cFrameFormat))
                    {
                        usMsg->m_listSignals.push_back(*rSig);
                        flag = 1;
                    }
                }

                if(flag == 0)
                {
                    m_unsupList.push_back(*rMsg);
                    CMessage& msg = m_unsupList.back();
                    msg.m_listSignals.clear();
                    msg.m_listSignals.push_back(*rSig);
                }
            }
        }
    }

    
    list<CSignal>::iterator rSig;

    for(rSig=m_listSignal.begin(); rSig!=m_listSignal.end(); ++rSig)
    {
        uiResult = rSig->Validate(rSig->m_ucDataFormat);

        
        if((uiResult == CSignal::SIG_EC_NO_ERR) || (uiResult == CSignal::SIG_EC_OVERFLOW))
        {
            






        }
        else
        {
            int flag = 0;
            list<CMessage>::iterator usMsg;

            for(usMsg=m_unsupList.begin(); usMsg!=m_unsupList.end(); ++usMsg)
            {
                if((usMsg->m_uiMsgID == 1073741824) && (usMsg->m_cFrameFormat == 'X'))
                {
                    usMsg->m_listSignals.push_back(*rSig);
                    flag = 1;
                }
            }

            if(flag == 0)
            {
                CMessage def_msg;
                def_msg.m_acName = "VECTOR__INDEPENDENT_SIG_MSG";
                def_msg.m_uiMsgID = 1073741824 ;
                def_msg.m_cFrameFormat = 'X';
                m_unsupList.push_back(def_msg);
                def_msg.m_listSignals.push_back(*rSig);
            }
        }
    }

    list<CParameter>::iterator rParam;

    for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
    {
        if(rParam->m_ObjectId == "BU_")
        {
            m_listParameterArray[1].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "BO_")
        {
            m_listParameterArray[2].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "SG_")
        {
            m_listParameterArray[3].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "")
        {
            m_listParameterArray[0].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "BU_SG_REL_")
        {
            m_listParameterArray[4].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "BU_BO_REL_")
        {
            m_listParameterArray[5].push_back(*rParam);
        }
    }
}








void CConverter::GenerateMessageList(fstream& fileInput)
{
    char acLine[2052]; 
    string local_copy;
    char* pcTok;
    int flag=0;
	int _flag_BS_= 0; 

    
    while(fileInput.getline(acLine, 2052))
    {
        char* pcToken=0, *pcLine=0;

        for (;;)
        {
            pcLine = acLine;
            pcLine += strlen(pcLine); 
            pcLine --;

            if (*pcLine == '\r')
            {
                fileInput.getline(pcLine, 2052);
            }
            else
            {
                break;
            }
        }

        
        
        
        local_copy = acLine;
        pcLine = acLine;

        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        pcToken = strtok_s(pcLine, " :", &pcTok);

        if(pcToken)
        {
            
			if(strstr(pcToken, "BS_") != 0)  
            {
                if (_flag_BS_ == 1 )
					_flag_BS_ = 2; 
            }
			if(strstr(pcToken, "NS_") != 0)
            {
                if (_flag_BS_ == 0 )
					_flag_BS_ = 1; 
            }

            
            else if(strcmp(pcToken, "\n") == 0)
            {
                continue;
            }
            
            else if(strcmp(pcToken, "BO_") == 0)
            {
                CMessage msg;
                msg.Format(pcLine + strlen(pcToken)+1);

                
                if((msg.m_acName != "VECTOR__INDEPENDENT_SIG_MSG") && !(msg.m_uiMsgID == 3221225472))
                {
                    CConverter::valid_msg = true;
                    m_listMessages.push_back(msg);
                }
                else
                {
                    CConverter::valid_msg = false;
                }
            }
            
            else if(strcmp(pcToken, "SG_") == 0)
            {
                CSignal sig;
                sig.Format(pcLine + strlen(pcToken) + 1);

                
                
                if(CConverter::valid_msg == true)
                {
                    
                    int flag = 0;
                    CMessage& msg = m_listMessages.back();

                    if (msg.m_listSignals.empty())
                    {
                        msg.m_listSignals.push_front(sig);
                        flag = 1;
                        continue;
                    }

                    int count = 0;
                    list<CSignal>::iterator sig1 = msg.m_listSignals.end();

                    while(sig1!=msg.m_listSignals.begin())
                    {
                        --sig1;
                        count++;

                        if(((sig1->m_ucWhichByte * 8) + sig1->m_ucStartBit) > ((sig.m_ucWhichByte * 8) + sig.m_ucStartBit))
                        {
                            ++sig1;
                            msg.m_listSignals.insert(sig1, sig);
                            flag = 1;
                            break;
                        }
                    }

                    if (flag == 0)
                    {
                        msg.m_listSignals.push_front(sig);
                    }

                    
                    msg.m_ucNumOfSignals++; 
                }
                else
                {
                    sig.m_ucWhichByte = 1;
                    sig.m_ucStartBit = 0;
                    m_listSignal.push_back(sig);
                }
            }
            
            else if(strcmp(pcToken, "VAL_") == 0)
            {
                
                
                
                
                pcLine = pcLine + strlen(pcToken) + 1; 
                pcToken = strtok_s(pcLine, " ", &pcTok); 
                unsigned int id = (unsigned int) strtoul(pcToken, 0, 10);

                if(id != 3221225472)
                {
                    list<CMessage>::iterator rMsg;

                    for(rMsg=m_listMessages.begin(); rMsg!=m_listMessages.end(); ++rMsg)
                    {
                        
                        if(rMsg->m_uiMsgID == id)
                        {
                            pcLine = pcLine + strlen(pcToken) + 1; 
                            pcToken = strtok_s(pcLine, " ", &pcTok); 
                            list<CSignal>::iterator rSig;

                            
                            for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
                            {
                                if(rSig->m_acName == pcToken)
                                {
                                    rSig->AddValueDescriptors(pcLine + strlen(pcToken) + 1, fileInput);
                                    break; 
                                }
                            }

                            break; 
                        }
                    }
                }
                else
                {
                    pcLine = pcLine + strlen(pcToken) + 1; 
                    pcToken = strtok_s(pcLine, " ", &pcTok); 
                    list<CSignal>::iterator rSig;

                    
                    for(rSig=m_listSignal.begin(); rSig!=m_listSignal.end(); ++rSig)
                    {
                        if(rSig->m_acName == pcToken)
                        {
                            rSig->AddValueDescriptors(pcLine + strlen(pcToken) + 1, fileInput);
                            break; 
                        }
                    }
                }
            }
            
            else if(strcmp(pcToken, "SIG_VALTYPE_") == 0)
            {
                
                
                
                
                
                pcToken = strtok_s(0, " :;", &pcTok); 
                unsigned int id = (unsigned int)strtoul(pcToken, 0, 10);

                if(id != 3221225472)
                {
                    list<CMessage>::iterator rMsg;

                    for(rMsg=m_listMessages.begin(); rMsg!=m_listMessages.end(); ++rMsg)
                    {
                        
                        if(rMsg->m_uiMsgID == id)
                        {
                            pcToken = strtok_s(0, " :;", &pcTok); 
                            list<CSignal>::iterator rSig;

                            
                            for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
                            {
                                if(rSig->m_acName == pcToken)
                                {
                                    if(pcToken = strtok_s(0, " :;", &pcTok)) 
                                    {
                                        
                                        switch(*pcToken)
                                        {
                                            case '1':
                                                rSig->m_ucType = CSignal::SIG_TYPE_FLOAT;
                                                break;

                                            case '2':
                                                rSig->m_ucType = CSignal::SIG_TYPE_DOUBLE;
                                                break;

                                            default:
                                                break;
                                        }
                                    }

                                    break; 
                                }
                            }

                            break; 
                        }
                    }
                }
                else
                {
                    pcToken = strtok_s(0, " :;", &pcTok); 
                    
                    list<CSignal>::iterator rSig;

                    for(rSig=m_listSignal.begin(); rSig!=m_listSignal.end(); ++rSig)
                    {
                        if(rSig->m_acName == pcToken)
                        {
                            if(pcToken = strtok_s(0, " :;", &pcTok)) 
                            {
                                
                                switch(*pcToken)
                                {
                                    case '1':
                                        rSig->m_ucType = CSignal::SIG_TYPE_FLOAT;
                                        break;

                                    case '2':
                                        rSig->m_ucType = CSignal::SIG_TYPE_DOUBLE;
                                        break;

                                    default:
                                        break;
                                }
                            }

                            break; 
                        }
                    }
                }
            }
            
            else if(strcmp(pcToken, "VAL_TABLE_") == 0)
            {
                CValueTable tab;
                pcToken = strtok_s(pcLine, " ", &pcTok);
                tab.Format(pcLine + strlen(pcToken) + 1, fileInput);
                m_vTab.push_back(tab);
            }
            
            else if(strcmp(pcToken, "CM_") == 0)
            {
                string comment = pcTok; 
                pcLine = pcLine + strlen(pcToken) + 1;
                pcToken = strtok_s(pcLine, " ", &pcTok);
                CComment cm;

                
                if(strcmp(pcToken, "BU_") == 0)
                {
                    pcToken = strtok_s(0, " ", &pcTok);
                    cm.m_elementName= pcToken;
                    pcToken = strtok_s(0, "", &pcTok);
                    comment = pcToken;

                    while(strstr(pcToken, "\";") == 0)
                    {
                        fileInput.getline(acLine, 2052);
                        pcToken = acLine;
                        comment = comment + pcToken;
                    }

                    cm.m_comment= comment;
                    m_cmNode.push_back(cm);
                }
                
                else if(strcmp(pcToken,"BO_") == 0)
                {
                    pcToken = strtok_s(0, " ", &pcTok);
                    cm.m_msgID = strtoul(pcToken, 0, 10);

                    
                    
                    if(cm.m_msgID < 0x80000000UL)
                    {
                        cm.m_msgType= 'S';
                    }
                    else
                    {
                        cm.m_msgType= 'X';
                        cm.m_msgID  &= 0x7FFFFFFF;
                    }

                    pcToken = strtok_s(0, "", &pcTok);
                    comment = pcToken;

                    while(strstr(pcToken, "\";") == 0)
                    {
                        fileInput.getline(acLine, 2052);
                        pcToken = acLine;
                        comment = comment + pcToken;
                    }

                    cm.m_comment= comment;
                    m_cmMsg.push_back(cm);
                }
                
                else if(strcmp(pcToken, "SG_") == 0)
                {
                    pcToken = strtok_s(0, " ", &pcTok);
                    cm.m_msgID = strtoul(pcToken, 0, 10);

                    if(cm.m_msgID < 0x80000000UL)
                    {
                        cm.m_msgType = 'S';
                    }
                    else
                    {
                        cm.m_msgType = 'X';
                        cm.m_msgID &= 0x7FFFFFFF;
                    }

                    pcToken = strtok_s(0, " ", &pcTok);
                    cm.m_elementName = pcToken;
                    pcToken = strtok_s(0, "", &pcTok);
                    comment = pcToken;

                    while(strstr(pcToken, "\";") == 0)
                    {
                        fileInput.getline(acLine, 2052);
                        pcToken = acLine;
                        comment = comment + pcToken;
                    }

                    cm.m_comment= comment;
                    m_cmSig.push_back(cm);
                }
                
                else
                {
                    
					int nRetVal = comment.find(";");
                    if( nRetVal < 0)
                    {
                        while(strstr(pcToken, "\";") == 0)
                        {
                            fileInput.getline(acLine, 2052);
                            pcToken = acLine;
                            comment = comment + pcToken;
                        }
                    }

                    cm.m_comment= comment;
                    m_cmNet.push_back(cm);
                }
            }
            
            else if(strcmp(pcToken, "BU_") == 0)
            {
                create_Node_List(pcLine + strlen(pcToken)+1);
            }
            else if ( ( (strcmp(pcToken, "BA_DEF_")==0) || (strcmp(pcToken, "BA_DEF_REL_")==0)) && _flag_BS_ > 1)
            {
                CParameter pObj;
                pObj.Format(pcLine + strlen(pcToken) + 1); 
                m_listParameters.push_back(pObj);
            }
            
            else if(strcmp(pcToken, "BA_DEF_DEF_")==0 && _flag_BS_ > 1 )
            {
                char acTemp[250],*pcTemp;
                pcTemp = acTemp;
                pcToken = strtok_s(0, "\"", &pcTok);
                pcToken = strtok_s(0, "\"", &pcTok);
                flag=0;

                while(*pcToken && *pcToken != '"')
                {
                    *pcTemp++ = *pcToken++;
                }

                *pcTemp = '\0';
                list<CParameter>::iterator rParam;

                for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
                {
                    
                    if(rParam->m_ParamName == acTemp)
                    {
                        pcTemp=acTemp;
                        pcToken = strtok_s(0, ";", &pcTok); 
                        rParam->ReadDefaultVal(pcToken);
                        flag=1;
                        break;
                    }
                }

                if(flag==0)
                {
                    string errString = "BA_DEF_DEF_ \"";
                    errString += acTemp;
                    errString += "\" ";
                    errString += pcToken;
                    errString += " : Match not Found in Param List\n";
                    defList.push_back(errString);
                }
            }
            
            else if(strcmp(pcToken,"BA_DEF_DEF_REL_")==0 && _flag_BS_ > 1)
            {
                char acTemp[250],*pcTemp;
                pcTemp = acTemp;
                flag = 0;
                pcToken = strtok_s(0, "\"", &pcTok);

                while(*pcToken && (*pcToken != '"'))
                {
                    *pcTemp++ = *pcToken++; 
                }

                *pcTemp = '\0';
                list<CParameter>::iterator rParam;

                for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
                {
                    
                    if(rParam->m_ParamName == acTemp)
                    {
                        pcTemp = acTemp;
                        pcToken = strtok_s(0, ";", &pcTok); 
                        rParam->ReadDefaultVal(pcToken);
                        flag=1;
                        break;
                    }
                }

                if(flag==0)
                {
                    string errString = "BA_DEF_DEF_REL \"";
                    errString += acTemp;
                    errString += "\" ";
                    errString += pcToken;
                    errString += " : Match not Found in Param List\n";
                    defList.push_back(errString);
                }
            }
            
            else if(strcmp(pcToken, "BA_")==0)
            {
                char acTemp[250],*pcTemp;
                pcTemp = acTemp;

                while(*pcLine && (*pcLine == ' '))
                {
                    *pcLine++;
                }

                
                pcLine = pcLine + strlen(pcToken) + 1;
                pcToken = strtok_s(pcLine, "\"", &pcTok);

                while(*pcToken && (*pcToken != '"'))
                {
                    *pcTemp++ = *pcToken++;
                }

                *pcTemp = '\0';
                list<CParameter>::iterator rParam;

                for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
                {
                    
                    if(rParam->m_ParamName == acTemp)
                    {
                        rParam->FormatParamValue(pcLine + strlen(acTemp) + 3); 
                        pcTemp=acTemp;
                        break;
                    }
                }
            }
            
            else
            {
                string str = local_copy;
                m_notProcessed.push_back(str);
                continue;
            }
        }
    }
}








bool CConverter::WriteToOutputFile(fstream& fileOutput)
{
    bool bResult = true;
    
    
    fileOutput << "//******************************BUSMASTER Messages and signals Database ******************************//" << endl;
    fileOutput << endl;
    fileOutput << "[""DATABASE_VERSION""]" " " "1.3" << endl;
    fileOutput << endl;
	if(nProtocal == 1)
	{
		fileOutput << "[""PROTOCOL""]" " " "J1939";
	}
	else
	{
		
		fileOutput << "[""PROTOCOL""]" " " "CAN";
	}
	fileOutput << endl;
	fileOutput << endl;

	
	fileOutput<< "[BUSMASTER_VERSION] [1.6.5]"<<endl;

    
    fileOutput << "[""NUMBER_OF_MESSAGES""]" " " << dec << m_listMessages.size() << endl;
    fileOutput << endl;
    
    CMessage msg;
    bResult &= msg.writeMessageToFile(fileOutput, m_listMessages, false, nProtocal);

    
    if(!m_listSignal.empty())
    {
        fileOutput << "[""START_SIG_LIST""]" << endl;
        CSignal sig;
        bResult &= sig.WriteSignaltofile(fileOutput, m_listSignal, 0, 0, false);
        fileOutput << "[""END_SIG_LIST""]" << endl;
        fileOutput << endl;
    }

    
    fileOutput << "[""START_VALUE_TABLE""]" << endl;
    CValueTable temp_vtab;
    temp_vtab.writeValueTabToFile (fileOutput,m_vTab);
    fileOutput << "[""END_VALUE_TABLE""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""NODE""]" " ";
    bool comma = false;
    list<string>::iterator node;

    for(node=m_listNode.begin(); node!=m_listNode.end(); ++node)
    {
        if(comma)
        {
            fileOutput << ",";
        }

        fileOutput << node->c_str();
        comma = true;
    }

    fileOutput << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_DESC""]" << endl;
    
    fileOutput << "[""START_DESC_NET""]" << endl;
    list<CComment>::iterator cmt;

    for(cmt=m_cmNet.begin(); cmt!=m_cmNet.end(); ++cmt)
    {
		fileOutput << cmt->m_elementName.c_str();
		fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << "[""END_DESC_NET""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_DESC_NODE""]" << endl;

    for(cmt=m_cmNode.begin(); cmt!=m_cmNode.end(); ++cmt)
    {
        fileOutput << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << "[""END_DESC_NODE""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_DESC_MSG""]" << endl;

    for(cmt=m_cmMsg.begin(); cmt!=m_cmMsg.end(); ++cmt)
    {
        fileOutput << cmt->m_msgID;
        fileOutput << " " << cmt->m_msgType;
        fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << "[""END_DESC_MSG""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_DESC_SIG""]" << endl;

    for(cmt=m_cmSig.begin(); cmt!=m_cmSig.end(); ++cmt)
    {
        fileOutput << cmt->m_msgID;
        fileOutput << " " << cmt->m_msgType;
        fileOutput << " " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << "[""END_DESC_SIG""]" << endl;
    fileOutput << "[""END_DESC""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_PARAM""]" << endl;
    fileOutput << "[""START_PARAM_NET""]" << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[0]);
    fileOutput << "[""END_PARAM_NET""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_NODE""]" << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[1]);
    fileOutput << "[""END_PARAM_NODE""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_MSG""]" << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[2]);
    fileOutput << "[""END_PARAM_MSG""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_SIG""]" << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[3]);
    fileOutput << "[""END_PARAM_SIG""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_NODE_RX_SIG""]" << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[4]);
    fileOutput << "[""END_PARAM_NODE_RX_SIG""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_NODE_TX_MSG""]" << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[5]);
    fileOutput << "[""END_PARAM_NODE_TX_MSG""]" << endl;
    fileOutput << "[""END_PARAM""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_PARAM_VAL""]" << endl;
    fileOutput << "[""START_PARAM_NET_VAL""]" << endl;
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameterArray[0].begin(); rParam!=m_listParameterArray[0].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[0].begin(); vParam!=rParam->m_listParamValues[0].end(); ++vParam)
        {
            vParam->WriteNetValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << "[""END_PARAM_NET_VAL""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_NODE_VAL""]" << endl;

    for(rParam=m_listParameterArray[1].begin(); rParam!=m_listParameterArray[1].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[1].begin(); vParam!=rParam->m_listParamValues[1].end(); ++vParam)
        {
            vParam->WriteNodeValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << "[""END_PARAM_NODE_VAL""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_MSG_VAL""]" << endl;

    for(rParam=m_listParameterArray[2].begin(); rParam!=m_listParameterArray[2].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[2].begin(); vParam!=rParam->m_listParamValues[2].end(); ++vParam)
        {
            vParam->WriteMesgValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << "[""END_PARAM_MSG_VAL""]" << endl;
    fileOutput << endl;
    fileOutput << "[""START_PARAM_SIG_VAL""]" << endl;

    for(rParam=m_listParameterArray[3].begin(); rParam!=m_listParameterArray[3].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[3].begin(); vParam!=rParam->m_listParamValues[3].end(); ++vParam)
        {
            vParam->WriteSigValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << "[""END_PARAM_SIG_VAL""]" << endl;
    fileOutput << endl;
    fileOutput << "[""END_PARAM_VAL""]" << endl;
    fileOutput << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_NOT_SUPPORTED""]" << endl;
    msg.writeMessageToFile(fileOutput, m_unsupList, true, nProtocal);
    fileOutput << "[""END_NOT_SUPPORTED""]" << endl;
    fileOutput << endl;
    
    fileOutput << "[""START_NOT_PROCESSED""]" << endl;
    list<string>::iterator np;

    for(np=m_notProcessed.begin(); np!=m_notProcessed.end(); ++np)
    {
        fileOutput << np->c_str() << endl;
    }

    fileOutput << endl;
    fileOutput << "[""END_NOT_PROCESSED""]" << endl;
    return bResult;
}







void CConverter::CreateLogFile(fstream& fileLog)
{
    char first_msg = 1;
    
    fileLog << "Conversion Error Log" << endl;
    fileLog << endl;
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        first_msg = 1;
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            
            if(sig->m_uiError != CSignal::SIG_EC_NO_ERR)
            {
                string str;

                
                if(first_msg == 1)
                {
                    fileLog << endl;
                    fileLog << "MSG_ID: " << dec << msg->m_uiMsgID;
                    fileLog << " \tMSG_TYPE: " << msg->m_cFrameFormat;
                    fileLog << " \tMSG_NAME: " << msg->m_acName.c_str() << endl;
                    first_msg = 0;
                }

                fileLog << "\tSIG_NAME: " << sig->m_acName.c_str();
                sig->GetErrorString(str);
                fileLog << ", STATUS: " << str;
                sig->GetErrorAction(str);
                fileLog << ", ACTION: " << str << endl;
            }
        }
    }

    
    first_msg = 1;
    list<CSignal>::iterator sig;

    for(sig=m_listSignal.begin(); sig!=m_listSignal.end(); ++sig)
    {
        
        if(sig->m_uiError != CSignal::SIG_EC_OVERFLOW)
        {
            string str;

            
            if(first_msg == 1)
            {
                fileLog << endl;
                fileLog << "MSG_ID: 1073741824";
                fileLog << " \tMSG_TYPE: X";
                fileLog << " \tMSG_NAME: VECTOR__INDEPENDENT_SIG_MSG" << endl;
                first_msg = 0;
            }

            fileLog << "\tSIG_NAME: " << sig->m_acName.c_str();
            sig->GetErrorString(str);
            fileLog << ", STATUS: " << str.c_str();
            sig->GetErrorAction(str);
            fileLog << ", ACTION: " << str.c_str() << endl;
        }
    }

    list<string>::iterator str;

    for(str=defList.begin(); str!=defList.end(); ++str)
    {
        fileLog << str->c_str();
    }

    list<CParameter>::iterator rParam;

    for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
    {
        if(rParam->m_defError)
        {
            fileLog << "OBJECT ID : " << rParam->m_ObjectId.c_str();
            fileLog << "\tPARAM_NAME :\"" << rParam->m_ParamName.c_str() << "\"" << endl;
            fileLog << "\tDescription:Default Value tag(BA_DEF_DEF_) doesn;t exist ";
            fileLog << "\t Action Taken : Reset to default value" << endl;
        }

        if(rParam->m_RangeError)
        {
            fileLog << "OBJECT ID : " << rParam->m_ObjectId.c_str();
            fileLog << "\tPARAM_NAME :\"" << rParam->m_ParamName.c_str() << "\"" << endl;
            fileLog << "\tDescription: Invalid Data Ranges";
            fileLog << "\t Action Taken : Reset to default value" << endl;
        }
    }
}







void CConverter::create_Node_List(char* pcLine)
{
    char* pcToken, *pcTok;
    
    pcToken = strtok_s(pcLine, " ,", &pcTok);

    while(pcToken)
    {
        string str = pcToken;
        m_listNode.push_back(str);
        pcToken = strtok_s(0, " ,", &pcTok);
    }
}







void CConverter::EncryptData(list<string> &m_notProcessed)
{
    list<string>::iterator str;

    for(str=m_notProcessed.begin(); str!=m_notProcessed.end(); ++str)
    {
        
        string::iterator ch;

        for(ch=str->begin() ; ch<str->end(); ++ch)
        {
            if ((*ch >= 'a' && *ch <= 'm') || (*ch >= 'A' && *ch <= 'M'))
            {
                *ch = *ch + 13;
            }
            else if ((*ch >= 'n' && *ch <= 'z') || (*ch >= 'N' && *ch <= 'Z'))
            {
                *ch = *ch - 13;
            }
        }
    }
}

            #     2  ÿÿÿÿ  ÿÿÿÿ     å¨      expression was true       *pcToken != '"'   ÿÿÿÿ     #  ÿÿÿÿ     2   expression was false       *pcToken != '"'   ÿÿÿÿ     #  ÿÿÿÿ     2                åø                  ÿÿÿÿ  ÿÿÿÿ     åĞ      expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                        :     G  ÿÿÿÿ  ÿÿÿÿ     å0      expression was true       _flag_BS_ > 1   ÿÿÿÿ     :  ÿÿÿÿ     G   expression was false       _flag_BS_ > 1   ÿÿÿÿ     :  ÿÿÿÿ     G                        6  ÿÿÿÿ  ÿÿÿÿ     åH      expression was true       strcmp(pcToken, "BA_DEF_DEF_")==0   ÿÿÿÿ       ÿÿÿÿ     6   expression was false       strcmp(pcToken, "BA_DEF_DEF_")==0   ÿÿÿÿ       ÿÿÿÿ     6                å@        	   d  	   q  ÿÿÿÿ  ÿÿÿÿ     åÈ      expression was true       _flag_BS_ > 1   	ÿÿÿÿ     d  	ÿÿÿÿ     q   expression was false       _flag_BS_ > 1   	ÿÿÿÿ     d  	ÿÿÿÿ     q           
     	   <  	   _  ÿÿÿÿ  ÿÿÿÿ     å
ø      expression was true       (strcmp(pcToken, "BA_DEF_REL_")==0)   	ÿÿÿÿ     <  	ÿÿÿÿ     _   expression was false       (strcmp(pcToken, "BA_DEF_REL_")==0)   	ÿÿÿÿ     <  	ÿÿÿÿ     _                å	(        	     	   8  ÿÿÿÿ  ÿÿÿÿ     å
      expression was true       (strcmp(pcToken, "BA_DEF_")==0)   	ÿÿÿÿ       	ÿÿÿÿ     8   expression was false       (strcmp(pcToken, "BA_DEF_")==0)   	ÿÿÿÿ       	ÿÿÿÿ     8                å(        8     8   9  6ÿÿÿÿ  6ÿÿÿÿ    Kµh      expression was true       strcmp(pcToken,"BA_DEF_DEF_REL_")==0   8ÿÿÿÿ  6     8ÿÿÿÿ  6   9   expression was false       strcmp(pcToken,"BA_DEF_DEF_REL_")==0   8ÿÿÿÿ  6     8ÿÿÿÿ  6   9               K´`        Ä   G  Ä   e  Âÿÿÿÿ  Âÿÿÿÿ     3j      expression was true       !(msg.m_uiMsgID == 3221225472)   Äÿÿÿÿ  Â   G  Äÿÿÿÿ  Â   e   expression was false       !(msg.m_uiMsgID == 3221225472)   Äÿÿÿÿ  Â   G  Äÿÿÿÿ  Â   e                3h@        Ä     Ä   C  Âÿÿÿÿ  Âÿÿÿÿ     3i(      expression was true       (msg.m_acName != "VECTOR__INDEPENDENT_SIG_MSG")   Äÿÿÿÿ  Â     Äÿÿÿÿ  Â   C   expression was false       (msg.m_acName != "VECTOR__INDEPENDENT_SIG_MSG")   Äÿÿÿÿ  Â     Äÿÿÿÿ  Â   C                3eX        £     £   (  ¡ÿÿÿÿ  ¡ÿÿÿÿ    JP      expression was true       *pcLine == ' '   £ÿÿÿÿ  ¡     £ÿÿÿÿ  ¡   (   expression was false       *pcLine == ' '   £ÿÿÿÿ  ¡     £ÿÿÿÿ  ¡   (               J         £     £     ¡ÿÿÿÿ  ¡ÿÿÿÿ    Jx      expression was true       *pcLine   £ÿÿÿÿ  ¡     £ÿÿÿÿ  ¡      expression was false       *pcLine   £ÿÿÿÿ  ¡     £ÿÿÿÿ  ¡                   G   8  G   V  Eÿÿÿÿ  Eÿÿÿÿ    +ÎØ      expression was true       (usMsg->m_cFrameFormat == 'X')   Gÿÿÿÿ  E   8  Gÿÿÿÿ  E   V   expression was false       (usMsg->m_cFrameFormat == 'X')   Gÿÿÿÿ  E   8  Gÿÿÿÿ  E   V                3ïà        G     G   4  Eÿÿÿÿ  Eÿÿÿÿ     øh      expression was true       (usMsg->m_uiMsgID == 1073741824)   Gÿÿÿÿ  E     Gÿÿÿÿ  E   4   expression was false       (usMsg->m_uiMsgID == 1073741824)   Gÿÿÿÿ  E     Gÿÿÿÿ  E   4                3ò°        6   4  6   Z  4ÿÿÿÿ  4ÿÿÿÿ     4
      expression was true       (uiResult == CSignal::SIG_EC_OVERFLOW)   6ÿÿÿÿ  4   4  6ÿÿÿÿ  4   Z   expression was false       (uiResult == CSignal::SIG_EC_OVERFLOW)   6ÿÿÿÿ  4   4  6ÿÿÿÿ  4   Z                4(        6     6   0  4ÿÿÿÿ  4ÿÿÿÿ     4È      expression was true       (uiResult == CSignal::SIG_EC_NO_ERR)   6ÿÿÿÿ  4     6ÿÿÿÿ  4   0   expression was false       (uiResult == CSignal::SIG_EC_NO_ERR)   6ÿÿÿÿ  4     6ÿÿÿÿ  4   0                4)            A     p  ÿÿÿÿ  ÿÿÿÿ    5>H      expression was true       (usMsg->m_cFrameFormat == rMsg->m_cFrameFormat)   ÿÿÿÿ     A  ÿÿÿÿ     p   expression was false       (usMsg->m_cFrameFormat == rMsg->m_cFrameFormat)   ÿÿÿÿ     A  ÿÿÿÿ     p               +ˆ   "             =  ÿÿÿÿ  ÿÿÿÿ    +-      expression was true       (usMsg->m_uiMsgID == rMsg->m_uiMsgID)   ÿÿÿÿ       ÿÿÿÿ     =   expression was false       (usMsg->m_uiMsgID == rMsg->m_uiMsgID)   ÿÿÿÿ       ÿÿÿÿ     =               5kè   $     	   8  	   ^  ÿÿÿÿ  ÿÿÿÿ     41°      expression was true       (uiResult == CSignal::SIG_EC_OVERFLOW)   	ÿÿÿÿ     8  	ÿÿÿÿ     ^   expression was false       (uiResult == CSignal::SIG_EC_OVERFLOW)   	ÿÿÿÿ     8  	ÿÿÿÿ     ^               +    &     	     	   4  ÿÿÿÿ  ÿÿÿÿ     41       expression was true       (uiResult == CSignal::SIG_EC_NO_ERR)   	ÿÿÿÿ       	ÿÿÿÿ     4   expression was false       (uiResult == CSignal::SIG_EC_NO_ERR)   	ÿÿÿÿ       	ÿÿÿÿ     4               +=€   (     ü     ü   ,  úÿÿÿÿ  úÿÿÿÿ    }(      expression was false       ch<str->end()   üÿÿÿÿ  ú     üÿÿÿÿ  ú   ,           )     ÷   %  ÷   >  õÿÿÿÿ  õÿÿÿÿ    ~Ø      expression was false       str!=m_notProcessed.end()   ÷ÿÿÿÿ  õ   %  ÷ÿÿÿÿ  õ   >               Wø   *     Å   *  Å   H  Ãÿÿÿÿ  Ãÿÿÿÿ    MšÈ      expression was false       rParam!=m_listParameters.end()   Åÿÿÿÿ  Ã   *  Åÿÿÿÿ  Ã   H               Mh   +     ¾     ¾   0  ¼ÿÿÿÿ  ¼ÿÿÿÿ    MŒø      expression was false       str!=defList.end()   ¾ÿÿÿÿ  ¼     ¾ÿÿÿÿ  ¼   0               MŠˆ   ,     £   #  £   :  ¡ÿÿÿÿ  ¡ÿÿÿÿ    Mˆ0      expression was false       sig!=m_listSignal.end()   £ÿÿÿÿ  ¡   #  £ÿÿÿÿ  ¡   :               My    -     …   -  …   J  ƒÿÿÿÿ  ƒÿÿÿÿ    Mt      expression was false       sig!=msg->m_listSignals.end()   …ÿÿÿÿ  ƒ   -  …ÿÿÿÿ  ƒ   J               Mdh   .     €   %  €   >  ~ÿÿÿÿ  ~ÿÿÿÿ    MvP      expression was false       msg!=m_listMessages.end()   €ÿÿÿÿ  ~   %  €ÿÿÿÿ  ~   >               M`Ğ   /     h   $  h   <  fÿÿÿÿ  fÿÿÿÿ    MYh      expression was false       np!=m_notProcessed.end()   hÿÿÿÿ  f   $  hÿÿÿÿ  f   <               MVØ   0     T   :  T   d  Rÿÿÿÿ  Rÿÿÿÿ    MMx      expression was false       vParam!=rParam->m_listParamValues[3].end()   Tÿÿÿÿ  R   :  Tÿÿÿÿ  R   d               MK    1     P   1  P   V  Nÿÿÿÿ  Nÿÿÿÿ    MO8      expression was false       rParam!=m_listParameterArray[3].end()   Pÿÿÿÿ  N   1  Pÿÿÿÿ  N   V               MH˜   2     F   :  F   d  Dÿÿÿÿ  Dÿÿÿÿ    MCø      expression was false       vParam!=rParam->m_listParamValues[2].end()   Fÿÿÿÿ  D   :  Fÿÿÿÿ  D   d               MA    3     B   1  B   V  @ÿÿÿÿ  @ÿÿÿÿ    ME¸      expression was false       rParam!=m_listParameterArray[2].end()   Bÿÿÿÿ  @   1  Bÿÿÿÿ  @   V               %?   4     8   :  8   d  6ÿÿÿÿ  6ÿÿÿÿ    %:x      expression was false       vParam!=rParam->m_listParamValues[1].end()   8ÿÿÿÿ  6   :  8ÿÿÿÿ  6   d               %8    5     4   1  4   V  2ÿÿÿÿ  2ÿÿÿÿ    %<8      expression was false       rParam!=m_listParameterArray[1].end()   4ÿÿÿÿ  2   1  4ÿÿÿÿ  2   V               %5˜   6     *   :  *   d  (ÿÿÿÿ  (ÿÿÿÿ    %0ø      expression was false       vParam!=rParam->m_listParamValues[0].end()   *ÿÿÿÿ  (   :  *ÿÿÿÿ  (   d               %.    7     &   1  &   V  $ÿÿÿÿ  $ÿÿÿÿ    %2¸      expression was false       rParam!=m_listParameterArray[0].end()   &ÿÿÿÿ  $   1  &ÿÿÿÿ  $   V               %,   8     û     û   0  ùÿÿÿÿ  ùÿÿÿÿ    %P      expression was false       cmt!=m_cmSig.end()   ûÿÿÿÿ  ù     ûÿÿÿÿ  ù   0               %Ğ   9     ï     ï   0  íÿÿÿÿ  íÿÿÿÿ    %è      expression was false       cmt!=m_cmMsg.end()   ïÿÿÿÿ  í     ïÿÿÿÿ  í   0               %x   :     ä     ä   2  âÿÿÿÿ  âÿÿÿÿ    %      expression was false       cmt!=m_cmNode.end()   äÿÿÿÿ  â     äÿÿÿÿ  â   2               % ¨   ;     Ù     Ù   0  ×ÿÿÿÿ  ×ÿÿÿÿ    $ı¸      expression was false       cmt!=m_cmNet.end()   Ùÿÿÿÿ  ×     Ùÿÿÿÿ  ×   0               $ùĞ   <     Æ   "  Æ   8  Äÿÿÿÿ  Äÿÿÿÿ    $õP      expression was false       node!=m_listNode.end()   Æÿÿÿÿ  Ä   "  Æÿÿÿÿ  Ä   8                äÜ°   =     u   6  u   T  sÿÿÿÿ  sÿÿÿÿ     ä®è      expression was false       rParam!=m_listParameters.end()   uÿÿÿÿ  s   6  uÿÿÿÿ  s   T                ä¨   >     G   6  G   T  Eÿÿÿÿ  Eÿÿÿÿ    KÏè      expression was false       rParam!=m_listParameters.end()   Gÿÿÿÿ  E   6  Gÿÿÿÿ  E   T               KÆ˜   ?         6      T  ÿÿÿÿ  ÿÿÿÿ    K¨¸      expression was false       rParam!=m_listParameters.end()    ÿÿÿÿ     6   ÿÿÿÿ     T               KŸh   @     v   4  v   L  tÿÿÿÿ  tÿÿÿÿ     ô8      expression was false       rSig!=m_listSignal.end()   vÿÿÿÿ  t   4  vÿÿÿÿ  t   L                ôX   A     R   C  R   b  Pÿÿÿÿ  Pÿÿÿÿ     ô©p      expression was false       rSig!=rMsg->m_listSignals.end()   Rÿÿÿÿ  P   C  Rÿÿÿÿ  P   b                ôœH   B     I   6  I   P  Gÿÿÿÿ  Gÿÿÿÿ     ô¬ğ      expression was false       rMsg!=m_listMessages.end()   Iÿÿÿÿ  G   6  Iÿÿÿÿ  G   P                ô—    C     0   4  0   L  .ÿÿÿÿ  .ÿÿÿÿ    Uùp      expression was false       rSig!=m_listSignal.end()   0ÿÿÿÿ  .   4  0ÿÿÿÿ  .   L               Uô    D        C     b  ÿÿÿÿ  ÿÿÿÿ    +éø      expression was false       rSig!=rMsg->m_listSignals.end()   ÿÿÿÿ     C  ÿÿÿÿ     b               +äp   E        6     P  ÿÿÿÿ  ÿÿÿÿ    Uì@      expression was false       rMsg!=m_listMessages.end()   ÿÿÿÿ     6  ÿÿÿÿ     P               +ÛÀ   F     \   *  \   H  Zÿÿÿÿ  Zÿÿÿÿ    X¨€      expression was false       rParam!=m_listParameters.end()   \ÿÿÿÿ  Z   *  \ÿÿÿÿ  Z   H                4   G     E   ,  E   D  Cÿÿÿÿ  Cÿÿÿÿ    +Yh      expression was false       usMsg!=m_unsupList.end()   Eÿÿÿÿ  C   ,  Eÿÿÿÿ  C   D                4Ğ   H     1   $  1   <  /ÿÿÿÿ  /ÿÿÿÿ    _Î      expression was false       rSig!=m_listSignal.end()   1ÿÿÿÿ  /   $  1ÿÿÿÿ  /   <                4h   I        0     H  ÿÿÿÿ  ÿÿÿÿ    +¶H      expression was false       usMsg!=m_unsupList.end()   ÿÿÿÿ     0  ÿÿÿÿ     H               +
X   J        /     N  ÿÿÿÿ  ÿÿÿÿ     3â      expression was false       rSig!=rMsg->m_listSignals.end()   ÿÿÿÿ     /  ÿÿÿÿ     N                47ø   K      è   /   è   N   æÿÿÿÿ   æÿÿÿÿ    +—0      expression was false       rSig!=rMsg->m_listSignals.end()    èÿÿÿÿ   æ   /   èÿÿÿÿ   æ   N                øˆ   L      Î   &   Î   @   Ìÿÿÿÿ   Ìÿÿÿÿ     4 p      expression was false       rMsg!=m_listMessages.end()    Îÿÿÿÿ   Ì   &   Îÿÿÿÿ   Ì   @                ôIP   M     å     å     ãÿÿÿÿ  ãÿÿÿÿ    Sø      expression was false       pcToken   åÿÿÿÿ  ã     åÿÿÿÿ  ã              N     8   =  8   J  6ÿÿÿÿ  6ÿÿÿÿ    K¶P      expression was true       _flag_BS_ > 1   8ÿÿÿÿ  6   =  8ÿÿÿÿ  6   J   expression was false       _flag_BS_ > 1   8ÿÿÿÿ  6   =  8ÿÿÿÿ  6   J           P     ?     ?     =ÿÿÿÿ  =ÿÿÿÿ    K¾`      expression was true       *pcToken   ?ÿÿÿÿ  =     ?ÿÿÿÿ  =      expression was false       *pcToken   ?ÿÿÿÿ  =     ?ÿÿÿÿ  =              R     ?   #  ?   4  =ÿÿÿÿ  =ÿÿÿÿ    K¿8      expression was true       (*pcToken != '"')   ?ÿÿÿÿ  =   #  ?ÿÿÿÿ  =   4   expression was false       (*pcToken != '"')   ?ÿÿÿÿ  =   #  ?ÿÿÿÿ  =   4               K½x   T     d     d     bÿÿÿÿ  bÿÿÿÿ     ä”¸      expression was true       *pcLine   dÿÿÿÿ  b     dÿÿÿÿ  b      expression was false       *pcLine   dÿÿÿÿ  b     dÿÿÿÿ  b              V     ø     ø   :  öÿÿÿÿ  öÿÿÿÿ     äû°      expression was false       strstr(pcToken, "\";") == 0   øÿÿÿÿ  ö     øÿÿÿÿ  ö   :                äõˆ   W     ç     ç   6  åÿÿÿÿ  åÿÿÿÿ     äïˆ      expression was false       strstr(pcToken, "\";") == 0   çÿÿÿÿ  å     çÿÿÿÿ  å   6                äé`   X     È     È   6  Æÿÿÿÿ  Æÿÿÿÿ    B€      expression was false       strstr(pcToken, "\";") == 0   Èÿÿÿÿ  Æ     Èÿÿÿÿ  Æ   6               <X   Y     ©     ©   6  §ÿÿÿÿ  §ÿÿÿÿ    *˜      expression was false       strstr(pcToken, "\";") == 0   ©ÿÿÿÿ  §     ©ÿÿÿÿ  §   6               $p   Z     æ     æ   :  äÿÿÿÿ  äÿÿÿÿ    H§à      expression was false       sig1!=msg.m_listSignals.begin()   æÿÿÿÿ  ä     æÿÿÿÿ  ä   :               Hx   [     d   "  d   2  bÿÿÿÿ  bÿÿÿÿ     ä•      expression was true       (*pcLine == ' ')   dÿÿÿÿ  b   "  dÿÿÿÿ  b   2   expression was false       (*pcLine == ' ')   dÿÿÿÿ  b   "  dÿÿÿÿ  b   2                ä“Ğ   ]     ‰     ‰   *  ‡ÿÿÿÿ  ‡ÿÿÿÿ     äÀø      expression was false       fileInput.getline(acLine, 2052)   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡   *           ^     m     m     kÿÿÿÿ  kÿÿÿÿ     äŸĞ      expression was true       *pcToken   mÿÿÿÿ  k     mÿÿÿÿ  k      expression was false       *pcToken   mÿÿÿÿ  k     mÿÿÿÿ  k              `     m   #  m   4  kÿÿÿÿ  kÿÿÿÿ     ä ¨      expression was true       (*pcToken != '"')   mÿÿÿÿ  k   #  mÿÿÿÿ  k   4   expression was false       (*pcToken != '"')   mÿÿÿÿ  k   #  mÿÿÿÿ  k   4                äè   b     ş     ş     üÿÿÿÿ  üÿÿÿÿ    [¸      expression was true       *ch >= 'a'   şÿÿÿÿ  ü     şÿÿÿÿ  ü      expression was false       *ch >= 'a'   şÿÿÿÿ  ü     şÿÿÿÿ  ü                  Z   d     ş      ş   *  üÿÿÿÿ  üÿÿÿÿ    \       expression was true       *ch <= 'm'   şÿÿÿÿ  ü      şÿÿÿÿ  ü   *   expression was false       *ch <= 'm'   şÿÿÿÿ  ü      şÿÿÿÿ  ü   *               Zà   f     ş   0  ş   :  üÿÿÿÿ  üÿÿÿÿ    a      expression was true       *ch >= 'A'   şÿÿÿÿ  ü   0  şÿÿÿÿ  ü   :   expression was false       *ch >= 'A'   şÿÿÿÿ  ü   0  şÿÿÿÿ  ü   :               _X   h     ş   >  ş   H  üÿÿÿÿ  üÿÿÿÿ    ağ      expression was true       *ch <= 'M'   şÿÿÿÿ  ü   >  şÿÿÿÿ  ü   H   expression was false       *ch <= 'M'   şÿÿÿÿ  ü   >  şÿÿÿÿ  ü   H               `0   j             !   ÿÿÿÿ   ÿÿÿÿ    l       expression was true       *ch >= 'n'   ÿÿÿÿ        ÿÿÿÿ      !   expression was false       *ch >= 'n'   ÿÿÿÿ        ÿÿÿÿ      !               jP   l        %     /   ÿÿÿÿ   ÿÿÿÿ    lè      expression was true       *ch <= 'z'   ÿÿÿÿ      %  ÿÿÿÿ      /   expression was false       *ch <= 'z'   ÿÿÿÿ      %  ÿÿÿÿ      /               k(   n     Ï     Ï      Íÿÿÿÿ  Íÿÿÿÿ    M™      expression was false       rParam->m_RangeError   Ïÿÿÿÿ  Í     Ïÿÿÿÿ  Í               o     Ç     Ç     Åÿÿÿÿ  Åÿÿÿÿ    M”X      expression was false       rParam->m_defError   Çÿÿÿÿ  Å     Çÿÿÿÿ  Å              p     «     «     ©ÿÿÿÿ  ©ÿÿÿÿ    M0      expression was false       first_msg == 1   «ÿÿÿÿ  ©     «ÿÿÿÿ  ©                  M|È   q     ¦     ¦   6  ¤ÿÿÿÿ  ¤ÿÿÿÿ    M†p      expression was false       sig->m_uiError != CSignal::SIG_EC_OVERFLOW   ¦ÿÿÿÿ  ¤     ¦ÿÿÿÿ  ¤   6               M{   r             "  ‹ÿÿÿÿ  ‹ÿÿÿÿ    MmĞ      expression was false       first_msg == 1   ÿÿÿÿ  ‹     ÿÿÿÿ  ‹   "               Mg   s     ˆ     ˆ   8  †ÿÿÿÿ  †ÿÿÿÿ    MrĞ      expression was false       sig->m_uiError != CSignal::SIG_EC_NO_ERR   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †   8               MeØ   t     È     È     Æÿÿÿÿ  Æÿÿÿÿ    $ñ˜      expression was false       comma   Èÿÿÿÿ  Æ     Èÿÿÿÿ  Æ              u     ²     ²     °ÿÿÿÿ  °ÿÿÿÿ     äÕ°      expression was false       !m_listSignal.empty()   ²ÿÿÿÿ  °     ²ÿÿÿÿ  °                   äĞx   v     x     x   5  vÿÿÿÿ  vÿÿÿÿ     ä­(      expression was false       rParam->m_ParamName == acTemp   xÿÿÿÿ  v     xÿÿÿÿ  v   5                ä©x   w     T     T     Rÿÿÿÿ  Rÿÿÿÿ    KÙ      expression was false       flag==0   Tÿÿÿÿ  R     Tÿÿÿÿ  R                  KÑ   x     J     J   5  Hÿÿÿÿ  Hÿÿÿÿ    KÎ(      expression was false       rParam->m_ParamName == acTemp   Jÿÿÿÿ  H     Jÿÿÿÿ  H   5               KÈ   y     -     -     +ÿÿÿÿ  +ÿÿÿÿ    K²`      expression was false       flag==0   -ÿÿÿÿ  +     -ÿÿÿÿ  +                  K©à   z     #     #   5  !ÿÿÿÿ  !ÿÿÿÿ    K¦ø      expression was false       rParam->m_ParamName == acTemp   #ÿÿÿÿ  !     #ÿÿÿÿ  !   5               K Ø   {     ö     ö   $  ôÿÿÿÿ  ôÿÿÿÿ     äıp      expression was false       nRetVal < 0   öÿÿÿÿ  ô     öÿÿÿÿ  ô   $           |     z      z   D  xÿÿÿÿ  xÿÿÿÿ     ôÈ      expression was false       pcToken = strtok_s(0, " :;", &pcTok)   zÿÿÿÿ  x      zÿÿÿÿ  x   D           }     x     x   5  vÿÿÿÿ  vÿÿÿÿ     ôx      expression was false       rSig->m_acName == pcToken   xÿÿÿÿ  v     xÿÿÿÿ  v   5                ô°   ~     V   (  V   L  Tÿÿÿÿ  Tÿÿÿÿ     ô¦       expression was false       pcToken = strtok_s(0, " :;", &pcTok)   Vÿÿÿÿ  T   (  Vÿÿÿÿ  T   L                T   $  T   =  Rÿÿÿÿ  Rÿÿÿÿ     ô§°      expression was false       rSig->m_acName == pcToken   Tÿÿÿÿ  R   $  Tÿÿÿÿ  R   =                ô¸   €     L     L   1  Jÿÿÿÿ  Jÿÿÿÿ     ô«0      expression was false       rMsg->m_uiMsgID == id   Lÿÿÿÿ  J     Lÿÿÿÿ  J   1                ô˜p        2     2   5  0ÿÿÿÿ  0ÿÿÿÿ    U÷°      expression was false       rSig->m_acName == pcToken   2ÿÿÿÿ  0     2ÿÿÿÿ  0   5               UõX   ‚        $     =  ÿÿÿÿ  ÿÿÿÿ    +è8      expression was false       rSig->m_acName == pcToken   ÿÿÿÿ     $  ÿÿÿÿ     =               +åà   ƒ             1  ÿÿÿÿ  ÿÿÿÿ    UêØ      expression was false       rMsg->m_uiMsgID == id   ÿÿÿÿ       ÿÿÿÿ     1               +İ0   „     ô     ô   "  òÿÿÿÿ  òÿÿÿÿ    H«p      expression was false       flag == 0   ôÿÿÿÿ  ò     ôÿÿÿÿ  ò   "               H©   …     ë     ë   {  éÿÿÿÿ  éÿÿÿÿ    H¦       expression was false       ((sig1->m_ucWhichByte * 8) + sig1->m_ucStartBit) > ((sig.m_ucWhichByte * 8) + sig.m_ucStartBit)   ëÿÿÿÿ  é     ëÿÿÿÿ  é   {               H¢(   †     Ü     Ü   2  Úÿÿÿÿ  Úÿÿÿÿ    J0      expression was false       msg.m_listSignals.empty()   Üÿÿÿÿ  Ú     Üÿÿÿÿ  Ú   2           ‡     ´     ´   #  ²ÿÿÿÿ  ²ÿÿÿÿ    Vp      expression was false       _flag_BS_ == 0   ´ÿÿÿÿ  ²     ´ÿÿÿÿ  ²   #               V    ˆ     ¯     ¯   #  ­ÿÿÿÿ  ­ÿÿÿÿ    V˜      expression was false       _flag_BS_ == 1   ¯ÿÿÿÿ  ­     ¯ÿÿÿÿ  ­   #               VÈ   ‰     ­     ­   "  «ÿÿÿÿ  «ÿÿÿÿ    V	X      expression was false       strstr(pcToken, "BS_") != 0   ­ÿÿÿÿ  «     ­ÿÿÿÿ  «   "               V   Š     ª     ª     ¨ÿÿÿÿ  ¨ÿÿÿÿ     ä¿H      expression was false       pcToken   ªÿÿÿÿ  ¨     ªÿÿÿÿ  ¨              ‹     r     r   3  pÿÿÿÿ  pÿÿÿÿ    X¢8      expression was false       rParam->m_ObjectId == "BU_BO_REL_"   rÿÿÿÿ  p     rÿÿÿÿ  p   3                4h   Œ     N     N     Lÿÿÿÿ  Lÿÿÿÿ    "‰0      expression was false       flag == 0   Nÿÿÿÿ  L     Nÿÿÿÿ  L                   êJ(           5     ?   ÿÿÿÿ   ÿÿÿÿ    qP      expression was true       *ch >= 'N'   ÿÿÿÿ      5  ÿÿÿÿ      ?   expression was false       *ch >= 'N'   ÿÿÿÿ      5  ÿÿÿÿ      ?               o         #     #     !ÿÿÿÿ  !ÿÿÿÿ     ô{8      expression was false       flag == 0   #ÿÿÿÿ  !     #ÿÿÿÿ  !                   4"           C     M   ÿÿÿÿ   ÿÿÿÿ    r8      expression was true       *ch <= 'Z'   ÿÿÿÿ      C  ÿÿÿÿ      M   expression was false       *ch <= 'Z'   ÿÿÿÿ      C  ÿÿÿÿ      M               px   ’      w      w      uÿÿÿÿ   uÿÿÿÿ    %@      expression was false       !bRes    wÿÿÿÿ   u      wÿÿÿÿ   u                  +ÌÀ   “      i      i      gÿÿÿÿ   gÿÿÿÿ    "”€      expression was false       !fileOutput.is_open()    iÿÿÿÿ   g      iÿÿÿÿ   g                  "œp   ”      b      b      `ÿÿÿÿ   `ÿÿÿÿ     áø      expression was false       m_listMessages.size() > 0    bÿÿÿÿ   `      bÿÿÿÿ   `              •      W      W   ,   Uÿÿÿÿ   Uÿÿÿÿ     ê%°      expression was false       fileInput.getline(acLine, 2052) == 0    Wÿÿÿÿ   U      Wÿÿÿÿ   U   ,                ê#¨   –      Q      Q      Oÿÿÿÿ   Oÿÿÿÿ     á˜      expression was false       !fileInput.is_open()    Qÿÿÿÿ   O      Qÿÿÿÿ   O                  5Uà   —               ÿÿÿÿ  ÿÿÿÿ    À       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ˜               ÿÿÿÿ  ÿÿÿÿ    ~        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ™               ÿÿÿÿ  ÿÿÿÿ    y¨       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                š               ÿÿÿÿÿ  ÿÿÿÿÿ    ix       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              ›     ë     ë     éÿÿÿÿ  éÿÿÿÿ    TĞ       statement executed        }   ëÿÿÿÿ  é     ëÿÿÿÿ  é              œ     ê     ê     èÿÿÿÿ  èÿÿÿÿ    S        statement executed        }   êÿÿÿÿ  è     êÿÿÿÿ  è                   ×     ×     Õÿÿÿÿ  Õÿÿÿÿ    M›°       statement executed        }   ×ÿÿÿÿ  Õ     ×ÿÿÿÿ  Õ                   Ö     Ö     Ôÿÿÿÿ  Ôÿÿÿÿ    M™ğ       statement executed        }   Öÿÿÿÿ  Ô     Öÿÿÿÿ  Ô              Ÿ     Õ   	  Õ   
  Óÿÿÿÿ  Óÿÿÿÿ    M˜@       statement executed        }   Õÿÿÿÿ  Ó   	  Õÿÿÿÿ  Ó   
                 Í   	  Í   
  Ëÿÿÿÿ  Ëÿÿÿÿ    M“€       statement executed        }   Íÿÿÿÿ  Ë   	  Íÿÿÿÿ  Ë   
           ¡     Á     Á     ¿ÿÿÿÿ  ¿ÿÿÿÿ    MŒ        statement executed        }   Áÿÿÿÿ  ¿     Áÿÿÿÿ  ¿              ¢     º     º     ¸ÿÿÿÿ  ¸ÿÿÿÿ    M‡X       statement executed        }   ºÿÿÿÿ  ¸     ºÿÿÿÿ  ¸              £     ¹   	  ¹   
  ·ÿÿÿÿ  ·ÿÿÿÿ    M…˜       statement executed        }   ¹ÿÿÿÿ  ·   	  ¹ÿÿÿÿ  ·   
           ¤     ²     ²     °ÿÿÿÿ  °ÿÿÿÿ    M€X       statement executed        }   ²ÿÿÿÿ  °     ²ÿÿÿÿ  °              ¥               ›ÿÿÿÿ  ›ÿÿÿÿ    Mux       statement executed        }   ÿÿÿÿ  ›     ÿÿÿÿ  ›              ¦     œ   	  œ   
  šÿÿÿÿ  šÿÿÿÿ    Ms¸       statement executed        }   œÿÿÿÿ  š   	  œÿÿÿÿ  š   
           §     ›     ›     ™ÿÿÿÿ  ™ÿÿÿÿ    Mqø       statement executed        }   ›ÿÿÿÿ  ™     ›ÿÿÿÿ  ™              ¨     ”     ”     ’ÿÿÿÿ  ’ÿÿÿÿ    Mlø       statement executed        }   ”ÿÿÿÿ  ’     ”ÿÿÿÿ  ’              ©     o     o     mÿÿÿÿ  mÿÿÿÿ    M[H       statement executed        return bResult;   oÿÿÿÿ  m     oÿÿÿÿ  m              ª     k     k     iÿÿÿÿ  iÿÿÿÿ    MX       statement executed        }   kÿÿÿÿ  i     kÿÿÿÿ  i              «     X     X     Vÿÿÿÿ  Vÿÿÿÿ    MN`       statement executed        }   Xÿÿÿÿ  V     Xÿÿÿÿ  V              ¬     W   	  W   
  Uÿÿÿÿ  Uÿÿÿÿ    ML        statement executed        }   Wÿÿÿÿ  U   	  Wÿÿÿÿ  U   
           ­     J     J     Hÿÿÿÿ  Hÿÿÿÿ    MDà       statement executed        }   Jÿÿÿÿ  H     Jÿÿÿÿ  H              ®     I   	  I   
  Gÿÿÿÿ  Gÿÿÿÿ    MC        statement executed        }   Iÿÿÿÿ  G   	  Iÿÿÿÿ  G   
           ¯     <     <     :ÿÿÿÿ  :ÿÿÿÿ    %;`       statement executed        }   <ÿÿÿÿ  :     <ÿÿÿÿ  :              °     ;   	  ;   
  9ÿÿÿÿ  9ÿÿÿÿ    %9        statement executed        }   ;ÿÿÿÿ  9   	  ;ÿÿÿÿ  9   
           ±     .     .     ,ÿÿÿÿ  ,ÿÿÿÿ    %1à       statement executed        }   .ÿÿÿÿ  ,     .ÿÿÿÿ  ,              ²     -   	  -   
  +ÿÿÿÿ  +ÿÿÿÿ    %0        statement executed        }   -ÿÿÿÿ  +   	  -ÿÿÿÿ  +   
           ³               ÿÿÿÿÿ  ÿÿÿÿÿ    %x       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ              ´     ô     ô     òÿÿÿÿ  òÿÿÿÿ    %       statement executed        }   ôÿÿÿÿ  ò     ôÿÿÿÿ  ò              µ     è     è     æÿÿÿÿ  æÿÿÿÿ    %¸       statement executed        }   èÿÿÿÿ  æ     èÿÿÿÿ  æ              ¶     İ     İ     Ûÿÿÿÿ  Ûÿÿÿÿ    $üà       statement executed        }   İÿÿÿÿ  Û     İÿÿÿÿ  Û              ·     Ï     Ï     Íÿÿÿÿ  Íÿÿÿÿ    $ôx       statement executed        }   Ïÿÿÿÿ  Í     Ïÿÿÿÿ  Í              ¸     Ë   	  Ë   
  Éÿÿÿÿ  Éÿÿÿÿ    $ğÀ       statement executed        }   Ëÿÿÿÿ  É   	  Ëÿÿÿÿ  É   
           ¹     ¹     ¹     ·ÿÿÿÿ  ·ÿÿÿÿ     äÔØ       statement executed        }   ¹ÿÿÿÿ  ·     ¹ÿÿÿÿ  ·              º     £     £     ¡ÿÿÿÿ  ¡ÿÿÿÿ     äÉx       statement executed        }   £ÿÿÿÿ  ¡     £ÿÿÿÿ  ¡              »               œÿÿÿÿ  œÿÿÿÿ     äÈX       statement executed        }   ÿÿÿÿ  œ     ÿÿÿÿ  œ              ¼     ‰     ‰     ‡ÿÿÿÿ  ‡ÿÿÿÿ     äÁĞ       statement executed        }   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡              ½     ˆ     ˆ     †ÿÿÿÿ  †ÿÿÿÿ     äÀ        statement executed        }   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †              ¾     …     …     ƒÿÿÿÿ  ƒÿÿÿÿ     ä²¨       statement executed        continue;   …ÿÿÿÿ  ƒ     …ÿÿÿÿ  ƒ              ¿               }ÿÿÿÿ  }ÿÿÿÿ     ä¯Ğ       statement executed        }   ÿÿÿÿ  }     ÿÿÿÿ  }              À     ~     ~     |ÿÿÿÿ  |ÿÿÿÿ     ä®       statement executed        }   ~ÿÿÿÿ  |     ~ÿÿÿÿ  |              Á     |     |     zÿÿÿÿ  zÿÿÿÿ     ä¬P       statement executed        break;   |ÿÿÿÿ  z     |ÿÿÿÿ  z              Â     p     p     nÿÿÿÿ  nÿÿÿÿ     ä£¨       statement executed        }   pÿÿÿÿ  n     pÿÿÿÿ  n              Ã     g     g     eÿÿÿÿ  eÿÿÿÿ     ä—        statement executed        }   gÿÿÿÿ  e     gÿÿÿÿ  e              Ä     ]     ]     [ÿÿÿÿ  [ÿÿÿÿ    KÚx       statement executed        }   ]ÿÿÿÿ  [     ]ÿÿÿÿ  [              Å     \     \     Zÿÿÿÿ  Zÿÿÿÿ    KØ¸       statement executed        }   \ÿÿÿÿ  Z     \ÿÿÿÿ  Z              Æ      .      .      ,ÿÿÿÿ   ,ÿÿÿÿ     ôQ       statement executed        }    .ÿÿÿÿ   ,      .ÿÿÿÿ   ,              Ç      8      8      6ÿÿÿÿ   6ÿÿÿÿ    +Mp       statement executed        }    8ÿÿÿÿ   6      8ÿÿÿÿ   6              È      S   	   S   <   Qÿÿÿÿ   Qÿÿÿÿ    +Ê(       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);    Sÿÿÿÿ   Q   	   Sÿÿÿÿ   Q   <           É      [   	   [   :   Yÿÿÿÿ   Yÿÿÿÿ     ø8       statement executed        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);    [ÿÿÿÿ   Y   	   [ÿÿÿÿ   Y   :           Ê      e      e      cÿÿÿÿ   cÿÿÿÿ     í€Ğ       statement executed        }    eÿÿÿÿ   c      eÿÿÿÿ   c              Ë      n   	   n   =   lÿÿÿÿ   lÿÿÿÿ     ê(X       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);    nÿÿÿÿ   l   	   nÿÿÿÿ   l   =           Ì      ‚      ‚   A   €ÿÿÿÿ   €ÿÿÿÿ     áÈ       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);    ‚ÿÿÿÿ   €      ‚ÿÿÿÿ   €   A           Í      ˆ      ˆ   ?   †ÿÿÿÿ   †ÿÿÿÿ     í†¨       statement executed        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);    ˆÿÿÿÿ   †      ˆÿÿÿÿ   †   ?           Î                  ‹ÿÿÿÿ   ‹ÿÿÿÿ     ø2X       statement executed        return m_uiResultCode;    ÿÿÿÿ   ‹      ÿÿÿÿ   ‹              Ï      œ      œ      šÿÿÿÿ   šÿÿÿÿ     øJÈ       statement executed        break;    œÿÿÿÿ   š      œÿÿÿÿ   š              Ğ                    ÿÿÿÿ   ÿÿÿÿ     íƒh       statement executed        break;     ÿÿÿÿ          ÿÿÿÿ                 Ñ      ¤      ¤      ¢ÿÿÿÿ   ¢ÿÿÿÿ    +ÉP       statement executed        break;    ¤ÿÿÿÿ   ¢      ¤ÿÿÿÿ   ¢              Ò      ¨      ¨      ¦ÿÿÿÿ   ¦ÿÿÿÿ    +        statement executed        break;    ¨ÿÿÿÿ   ¦      ¨ÿÿÿÿ   ¦              Ó      ¬      ¬      ªÿÿÿÿ   ªÿÿÿÿ     á
x       statement executed        break;    ¬ÿÿÿÿ   ª      ¬ÿÿÿÿ   ª              Ô      °      °      ®ÿÿÿÿ   ®ÿÿÿÿ     ôF°       statement executed        break;    °ÿÿÿÿ   ®      °ÿÿÿÿ   ®              Õ      ´      ´      ²ÿÿÿÿ   ²ÿÿÿÿ     ø       statement executed        break;    ´ÿÿÿÿ   ²      ´ÿÿÿÿ   ²              Ö      ¶      ¶      ´ÿÿÿÿ   ´ÿÿÿÿ    +·Ğ       statement executed        }    ¶ÿÿÿÿ   ´      ¶ÿÿÿÿ   ´              ×      Á      Á   &   ¿ÿÿÿÿ   ¿ÿÿÿÿ     ôL(       statement executed        return (m_uiResultCode = uiCode);    Áÿÿÿÿ   ¿      Áÿÿÿÿ   ¿   &           Ø      ×   	   ×   
   Õÿÿÿÿ   Õÿÿÿÿ     4ˆ       statement executed        }    ×ÿÿÿÿ   Õ   	   ×ÿÿÿÿ   Õ   
           Ù      Ü   	   Ü   
   Úÿÿÿÿ   Úÿÿÿÿ     ÷è¸       statement executed        }    Üÿÿÿÿ   Ú   	   Üÿÿÿÿ   Ú   
           Ú      î      î      ìÿÿÿÿ   ìÿÿÿÿ     ø9P       statement executed        break;    îÿÿÿÿ   ì      îÿÿÿÿ   ì              Û      ò      ò      ğÿÿÿÿ   ğÿÿÿÿ     6(       statement executed        break;    òÿÿÿÿ   ğ      òÿÿÿÿ   ğ              Ü      ô   	   ô   
   òÿÿÿÿ   òÿÿÿÿ     4'€       statement executed        }    ôÿÿÿÿ   ò   	   ôÿÿÿÿ   ò   
           İ      û   	   û   
   ùÿÿÿÿ   ùÿÿÿÿ    5`À       statement executed        }    ûÿÿÿÿ   ù   	   ûÿÿÿÿ   ù   
           Ş         	      
   şÿÿÿÿ   şÿÿÿÿ     ôc@       statement executed        }    ÿÿÿÿ   ş   	   ÿÿÿÿ   ş   
           ß               ÿÿÿÿ  ÿÿÿÿ     ô@Ø       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                à                 ÿÿÿÿ  ÿÿÿÿ    +ÔÈ       statement executed        }    ÿÿÿÿ        ÿÿÿÿ                á     !     !     ÿÿÿÿ  ÿÿÿÿ     êI@       statement executed        }   !ÿÿÿÿ       !ÿÿÿÿ                â     )     )     'ÿÿÿÿ  'ÿÿÿÿ     ôK        statement executed        }   )ÿÿÿÿ  '     )ÿÿÿÿ  '              ã     *     *     (ÿÿÿÿ  (ÿÿÿÿ     +
0       statement executed        }   *ÿÿÿÿ  (     *ÿÿÿÿ  (              ä     ,     ,     *ÿÿÿÿ  *ÿÿÿÿ     3ãp       statement executed        }   ,ÿÿÿÿ  *     ,ÿÿÿÿ  *              å     ?   	  ?   
  =ÿÿÿÿ  =ÿÿÿÿ     4       statement executed        }   ?ÿÿÿÿ  =   	  ?ÿÿÿÿ  =   
           æ     K     K     Iÿÿÿÿ  Iÿÿÿÿ     ôhP       statement executed        }   Kÿÿÿÿ  I     Kÿÿÿÿ  I              ç     L     L     Jÿÿÿÿ  Jÿÿÿÿ     4<¨       statement executed        }   Lÿÿÿÿ  J     Lÿÿÿÿ  J              è     V     V     Tÿÿÿÿ  Tÿÿÿÿ    "™h       statement executed        }   Vÿÿÿÿ  T     Vÿÿÿÿ  T              é     W   	  W   
  Uÿÿÿÿ  Uÿÿÿÿ    +°       statement executed        }   Wÿÿÿÿ  U   	  Wÿÿÿÿ  U   
           ê     a   	  a   
  _ÿÿÿÿ  _ÿÿÿÿ     4„0       statement executed        }   aÿÿÿÿ  _   	  aÿÿÿÿ  _   
           ë     e   	  e   
  cÿÿÿÿ  cÿÿÿÿ     4†¸       statement executed        }   eÿÿÿÿ  c   	  eÿÿÿÿ  c   
           ì     i   	  i   
  gÿÿÿÿ  gÿÿÿÿ     4‰@       statement executed        }   iÿÿÿÿ  g   	  iÿÿÿÿ  g   
           í     m   	  m   
  kÿÿÿÿ  kÿÿÿÿ     4‹È       statement executed        }   mÿÿÿÿ  k   	  mÿÿÿÿ  k   
           î     q   	  q   
  oÿÿÿÿ  oÿÿÿÿ     4P       statement executed        }   qÿÿÿÿ  o   	  qÿÿÿÿ  o   
           ï     u   	  u   
  sÿÿÿÿ  sÿÿÿÿ    X¡`       statement executed        }   uÿÿÿÿ  s   	  uÿÿÿÿ  s   
           ğ     w     w     uÿÿÿÿ  uÿÿÿÿ    X©h       statement executed        }   wÿÿÿÿ  u     wÿÿÿÿ  u              ñ     –     –     ”ÿÿÿÿ  ”ÿÿÿÿ    Jh       statement executed        }   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”              ò     ™     ™     —ÿÿÿÿ  —ÿÿÿÿ    J@       statement executed        break;   ™ÿÿÿÿ  —     ™ÿÿÿÿ  —              ó     ¦   	  ¦   
  ¤ÿÿÿÿ  ¤ÿÿÿÿ    V H       statement executed        }   ¦ÿÿÿÿ  ¤   	  ¦ÿÿÿÿ  ¤   
           ô     °     °     ®ÿÿÿÿ  ®ÿÿÿÿ    VÀ       statement executed        _flag_BS_ = 2;   °ÿÿÿÿ  ®     °ÿÿÿÿ  ®              õ     ±     ±     ¯ÿÿÿÿ  ¯ÿÿÿÿ    V€       statement executed        }   ±ÿÿÿÿ  ¯     ±ÿÿÿÿ  ¯              ö     µ     µ     ³ÿÿÿÿ  ³ÿÿÿÿ    V˜       statement executed        _flag_BS_ = 1;   µÿÿÿÿ  ³     µÿÿÿÿ  ³              ÷     ¶     ¶     ´ÿÿÿÿ  ´ÿÿÿÿ    VX       statement executed        }   ¶ÿÿÿÿ  ´     ¶ÿÿÿÿ  ´              ø     »     »     ¹ÿÿÿÿ  ¹ÿÿÿÿ     3aH       statement executed        continue;   »ÿÿÿÿ  ¹     »ÿÿÿÿ  ¹              ù     È     È     Æÿÿÿÿ  Æÿÿÿÿ     3n0       statement executed        }   Èÿÿÿÿ  Æ     Èÿÿÿÿ  Æ              ú     Ì     Ì     Êÿÿÿÿ  Êÿÿÿÿ    Jà       statement executed        }   Ìÿÿÿÿ  Ê     Ìÿÿÿÿ  Ê              û     à     à   "  Şÿÿÿÿ  Şÿÿÿÿ    JX       statement executed        continue;   àÿÿÿÿ  Ş     àÿÿÿÿ  Ş   "           ü     ğ     ğ   #  îÿÿÿÿ  îÿÿÿÿ    H¥H       statement executed        break;   ğÿÿÿÿ  î     ğÿÿÿÿ  î   #           ı     ò     ò     ğÿÿÿÿ  ğÿÿÿÿ    H§       statement executed        }   òÿÿÿÿ  ğ     òÿÿÿÿ  ğ              ş     ÷     ÷     õÿÿÿÿ  õÿÿÿÿ    Hª˜       statement executed        }   ÷ÿÿÿÿ  õ     ÷ÿÿÿÿ  õ              ÿ     û     û     ùÿÿÿÿ  ùÿÿÿÿ    H¬è       statement executed        }   ûÿÿÿÿ  ù     ûÿÿÿÿ  ù                             ÿÿÿÿÿ  ÿÿÿÿÿ    M0è       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ                  !   %  !   +  ÿÿÿÿ  ÿÿÿÿ    +ç`       statement executed        break;   !ÿÿÿÿ     %  !ÿÿÿÿ     +               #     #     !ÿÿÿÿ  !ÿÿÿÿ    +é        statement executed        }   #ÿÿÿÿ  !     #ÿÿÿÿ  !                  %     %   #  #ÿÿÿÿ  #ÿÿÿÿ    +êà       statement executed        break;   %ÿÿÿÿ  #     %ÿÿÿÿ  #   #               '     '     %ÿÿÿÿ  %ÿÿÿÿ    Uëh       statement executed        }   'ÿÿÿÿ  %     'ÿÿÿÿ  %                  (     (     &ÿÿÿÿ  &ÿÿÿÿ    Uí       statement executed        }   (ÿÿÿÿ  &     (ÿÿÿÿ  &                  5     5   #  3ÿÿÿÿ  3ÿÿÿÿ    UöØ       statement executed        break;   5ÿÿÿÿ  3     5ÿÿÿÿ  3   #               7     7     5ÿÿÿÿ  5ÿÿÿÿ    Uø˜       statement executed        }   7ÿÿÿÿ  5     7ÿÿÿÿ  5                  8     8     6ÿÿÿÿ  6ÿÿÿÿ    UúX       statement executed        }   8ÿÿÿÿ  6     8ÿÿÿÿ  6             	     ]   1  ]   7  [ÿÿÿÿ  [ÿÿÿÿ     ô¡        statement executed        break;   ]ÿÿÿÿ  [   1  ]ÿÿÿÿ  [   7          
     a   1  a   7  _ÿÿÿÿ  _ÿÿÿÿ     ô£x       statement executed        break;   aÿÿÿÿ  _   1  aÿÿÿÿ  _   7               d   1  d   7  bÿÿÿÿ  bÿÿÿÿ     ô¤P       statement executed        break;   dÿÿÿÿ  b   1  dÿÿÿÿ  b   7               f   %  f   &  dÿÿÿÿ  dÿÿÿÿ     ô¥(       statement executed        }   fÿÿÿÿ  d   %  fÿÿÿÿ  d   &               h   %  h   +  fÿÿÿÿ  fÿÿÿÿ     ô¦Ø       statement executed        break;   hÿÿÿÿ  f   %  hÿÿÿÿ  f   +               j     j     hÿÿÿÿ  hÿÿÿÿ     ô¨˜       statement executed        }   jÿÿÿÿ  h     jÿÿÿÿ  h                  l     l   #  jÿÿÿÿ  jÿÿÿÿ     ôªX       statement executed        break;   lÿÿÿÿ  j     lÿÿÿÿ  j   #               n     n     lÿÿÿÿ  lÿÿÿÿ     ô¬       statement executed        }   nÿÿÿÿ  l     nÿÿÿÿ  l                  o     o     mÿÿÿÿ  mÿÿÿÿ     ô­Ø       statement executed        }   oÿÿÿÿ  m     oÿÿÿÿ  m                     )     /  ÿÿÿÿ  ÿÿÿÿ     ôÈ       statement executed        break;   ÿÿÿÿ     )  ÿÿÿÿ     /               …   )  …   /  ƒÿÿÿÿ  ƒÿÿÿÿ     ô@       statement executed        break;   …ÿÿÿÿ  ƒ   )  …ÿÿÿÿ  ƒ   /               ˆ   )  ˆ   /  †ÿÿÿÿ  †ÿÿÿÿ     ô       statement executed        break;   ˆÿÿÿÿ  †   )  ˆÿÿÿÿ  †   /               Š     Š     ˆÿÿÿÿ  ˆÿÿÿÿ     ôğ       statement executed        }   Šÿÿÿÿ  ˆ     Šÿÿÿÿ  ˆ                  Œ     Œ   #  Šÿÿÿÿ  Šÿÿÿÿ     ô        statement executed        break;   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š   #                         Œÿÿÿÿ  Œÿÿÿÿ     ô`       statement executed        }   ÿÿÿÿ  Œ     ÿÿÿÿ  Œ                            ÿÿÿÿ  ÿÿÿÿ     ô        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                    ˜     ˜     –ÿÿÿÿ  –ÿÿÿÿ     ô$        statement executed        }   ˜ÿÿÿÿ  –     ˜ÿÿÿÿ  –                  ®     ®     ¬ÿÿÿÿ  ¬ÿÿÿÿ    )À       statement executed        }   ®ÿÿÿÿ  ¬     ®ÿÿÿÿ  ¬                  ²     ²     °ÿÿÿÿ  °ÿÿÿÿ    -˜       statement executed        }   ²ÿÿÿÿ  °     ²ÿÿÿÿ  °                  ¾     ¾     ¼ÿÿÿÿ  ¼ÿÿÿÿ    48       statement executed        }   ¾ÿÿÿÿ  ¼     ¾ÿÿÿÿ  ¼                  Ã     Ã     Áÿÿÿÿ  Áÿÿÿÿ    7È       statement executed        }   Ãÿÿÿÿ  Á     Ãÿÿÿÿ  Á                  Í     Í     Ëÿÿÿÿ  Ëÿÿÿÿ    A¨       statement executed        }   Íÿÿÿÿ  Ë     Íÿÿÿÿ  Ë                  Ñ     Ñ     Ïÿÿÿÿ  Ïÿÿÿÿ    Ex       statement executed        }   Ñÿÿÿÿ  Ï     Ñÿÿÿÿ  Ï                   Û     Û     Ùÿÿÿÿ  Ùÿÿÿÿ    L       statement executed        }   Ûÿÿÿÿ  Ù     Ûÿÿÿÿ  Ù             !     à     à     Şÿÿÿÿ  Şÿÿÿÿ     äáĞ       statement executed        }   àÿÿÿÿ  Ş     àÿÿÿÿ  Ş             "     ì     ì     êÿÿÿÿ  êÿÿÿÿ     äî°       statement executed        }   ìÿÿÿÿ  ê     ìÿÿÿÿ  ê             #     ğ     ğ     îÿÿÿÿ  îÿÿÿÿ     äò€       statement executed        }   ğÿÿÿÿ  î     ğÿÿÿÿ  î             $     ı     ı     ûÿÿÿÿ  ûÿÿÿÿ     äúØ       statement executed        }   ıÿÿÿÿ  û     ıÿÿÿÿ  û             %     ş     ş     üÿÿÿÿ  üÿÿÿÿ     äü˜       statement executed        }   şÿÿÿÿ  ü     şÿÿÿÿ  ü             &                ÿÿÿÿ   ÿÿÿÿ     å @       statement executed        }   ÿÿÿÿ        ÿÿÿÿ                '               ÿÿÿÿ  ÿÿÿÿ     å8       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               (               ÿÿÿÿ  ÿÿÿÿ     å(       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               )               ÿÿÿÿ  ÿÿÿÿ    K›       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               *     )     )     'ÿÿÿÿ  'ÿÿÿÿ    K¦        statement executed        break;   )ÿÿÿÿ  '     )ÿÿÿÿ  '             +     +     +     )ÿÿÿÿ  )ÿÿÿÿ    K§à       statement executed        }   +ÿÿÿÿ  )     +ÿÿÿÿ  )             ,     5     5     3ÿÿÿÿ  3ÿÿÿÿ    K±ˆ       statement executed        }   5ÿÿÿÿ  3     5ÿÿÿÿ  3             -     6     6     4ÿÿÿÿ  4ÿÿÿÿ    K³H       statement executed        }   6ÿÿÿÿ  4     6ÿÿÿÿ  4             .     B     B     @ÿÿÿÿ  @ÿÿÿÿ    KÂ8       statement executed        }   Bÿÿÿÿ  @     Bÿÿÿÿ  @             /     P     P     Nÿÿÿÿ  Nÿÿÿÿ    KÍP       statement executed        break;   Pÿÿÿÿ  N     Pÿÿÿÿ  N             0     R     R     Pÿÿÿÿ  Pÿÿÿÿ    KÏ       statement executed        }   Rÿÿÿÿ  P     Rÿÿÿÿ  P           CConverter::CConverter CConverter::CConverter()    ,      .      *ÿÿÿÿ   ,ÿÿÿÿCConverter::~CConverter CConverter::~CConverter()    6      8      4ÿÿÿÿ   6ÿÿÿÿCConverter::Convert unsigned int CConverter::Convert(string& sCanoeFile, string& sCanMonFile)    D            Bÿÿÿÿ   ŒÿÿÿÿCConverter::GetResultString void CConverter::GetResultString(string& str)    —      ¶      •ÿÿÿÿ   ´ÿÿÿÿCConverter::SetResultCode unsigned int CConverter::SetResultCode(unsigned int uiCode)    À      Â      ¾ÿÿÿÿ   ÀÿÿÿÿCConverter::ValidateMessageList void CConverter::ValidateMessageList()    Ê     w      Èÿÿÿÿ  uÿÿÿÿCConverter::GenerateMessageList void CConverter::GenerateMessageList(fstream& fileInput)        ‰     ÿÿÿÿ  ‡ÿÿÿÿCConverter::WriteToOutputFile bool CConverter::WriteToOutputFile(fstream& fileOutput)   “     p     ‘ÿÿÿÿ  nÿÿÿÿCConverter::CreateLogFile void CConverter::CreateLogFile(fstream& fileLog)   y     ×     wÿÿÿÿ  ÕÿÿÿÿCConverter::create_Node_List void CConverter::create_Node_List(char* pcLine)   à     ë     Şÿÿÿÿ  éÿÿÿÿCConverter::EncryptData void CConverter::EncryptData(list<string> &m_notProcessed)   ô          òÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Converter.cpp
 * \brief     Implementation of converter class
 * \authors   Amitesh Bharti, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the converter class.
 */

/* Project includes */
#include "Converter.h"
#include "Signal.h"
#include "Tag.h"
#include "Definitions.h"
using namespace std;

bool CConverter::valid_msg = true;
unsigned char CConverter::ucMsg_DLC = 8;
extern "C" int nBus ;
extern "C" int nProtocal ;
extern "C" int FindProtoCol(char*);
extern FILE* yyin;
/**
 * \brief Constructor
 *
 * Constructor of CConverter
 */
CConverter::CConverter()
{
    m_uiResultCode = CON_RC_NOERROR;
}

/**
 * \brief Destructor
 *
 * Destructor of CConverter
 */
CConverter::~CConverter()
{
    m_listMessages.clear();
}

/**
 * \brief     Conversion function
 * \param[in] sCanoeFile name of input file
 * \param[in] sCanMonFile name of output file
 * \return    Status code
 *
 * This is the basic function which is to be called
 * to convert any given CANoe file to a CANMon file.
 */
unsigned int CConverter::Convert(string& sCanoeFile, string& sCanMonFile)
{
    
	fstream fileInput, fileOutput;
    char acLine[defCON_MAX_LINE_LEN]; // I don't expect one line to be more than this

	//Protocol type
	char file[254];
	strcpy_s(file, 254, sCanoeFile.c_str());
	FindProtoCol(file);
	

    fileInput.open(sCanoeFile.c_str(), fstream::in);

    if(!fileInput.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);
    }

    // first line of input file starts with keyword "VERSION", else file format error
    if(fileInput.getline(acLine, defCON_MAX_LINE_LEN) == NULL)
    {
        // eof file reached without reading anything
        fileInput.close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
    }

    // Generate the list of messages
    GenerateMessageList(fileInput);
    // All information gathered, validate and update if necessary
    // Make appropriate changes in the contents of the list
	if(m_listMessages.size() > 0)
	{
		ValidateMessageList();
	}
    // the format is OK then open the output file
    fileOutput.open(sCanMonFile.c_str(), fstream::out);

    if(!fileOutput.is_open())
    {
        // if output file cannot be opened the close the input file
        // and return the error code
        fileInput.close();
        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);
    }

    EncryptData(m_notProcessed);
    bool bRes = WriteToOutputFile(fileOutput);
    fileInput.close();
    fileOutput.close();
	nProtocal = NONE;
	nBus = BUS_CAN;
    if(!bRes)
    {
        string sLogFile = sCanMonFile.substr(0, sCanMonFile.length()-4);
        sLogFile += ".log";
        m_omLogFilePath = sLogFile;
        fstream fileLog;
        fileLog.open(sLogFile.c_str(), fstream::out);

        if(!fileLog.is_open())
        {
            // if log file cannot be opened return the error code
            return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);
        }
        else
        {
            CreateLogFile(fileLog);
            fileLog.close();
            return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
        }
    }
	//CConverter::valid_msg = false;
	
    return m_uiResultCode;
}

/**
 * \brief      Get result string
 * \param[out] str Result String
 *
 * Returns the error string
 */
void CConverter::GetResultString(string& str)
{
    switch(m_uiResultCode)
    {
        case 0:
            str = "Conversion completed.";
            break;

        case 1:
            str = "Conversion completed with warnings. See log file.";
            break;

        case 2:
            str = "Conversion aborted. Error opening input file.";
            break;

        case 3:
            str = "Conversion aborted. Error creating output file.";
            break;

        case 4:
            str = "Conversion aborted. Error with input file format.";
            break;

        case 5:
            str = "Conversion aborted. Error creating log file.";
            break;

        default:
            str = "Unknown";
            break;
    }
}

/**
 * \brief     Set result code
 * \param[in] uiCode Result code
 * \return    Result code
 *
 * Sets and returns the result code
 */
unsigned int CConverter::SetResultCode(unsigned int uiCode)
{
    return (m_uiResultCode = uiCode);
}

/**
 * \brief Validates the message list
 *
 * Validates the message list and set the error in each signal if present.
 */
void CConverter::ValidateMessageList()
{
    list<CMessage>::iterator rMsg;
    unsigned int uiResult;

    for(rMsg=m_listMessages.begin(); rMsg!=m_listMessages.end(); ++rMsg)
    {
        unsigned char ucDataFormat = 0;

        // set the id and frame format
        // canoe puts MSbit = 1 for extended ID
        if(rMsg->m_uiMsgID < 0x80000000UL)
        {
            rMsg->m_cFrameFormat = CMessage::MSG_FF_STANDARD;
        }
        else
        {
            rMsg->m_cFrameFormat = CMessage::MSG_FF_EXTENDED;
            rMsg->m_uiMsgID &= 0x7FFFFFFF;
        }

        rMsg->m_ucNumOfSignals = 0; // reset number of signals to 0
        // this should be updated to number of
        // valid signals as we parse the Signal list
        //pems - Start
        //Scan the message list and make the message format same as the
        //one that has maximum number of signals.
        int iCntMotorolaSignals = 0;
        int iCntIntelSignals = 0;
        list<CSignal>::iterator rSig;

        for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
        {
            switch (rSig->m_ucDataFormat)
            {
                case CSignal::SIG_DF_INTEL:
                    iCntIntelSignals++;
                    break;

                case CSignal::SIG_DF_MOTOROLA:
                    iCntMotorolaSignals++;
                    break;
            }
        }

        // Update the message data format
        if(iCntIntelSignals >= iCntMotorolaSignals)
        {
            ucDataFormat = CSignal::SIG_DF_INTEL;
            rMsg->m_cDataFormat = ucDataFormat; // set message data format to this i.e format of first valid signal
        }
        else
        {
            ucDataFormat = CSignal::SIG_DF_MOTOROLA;
            rMsg->m_cDataFormat = ucDataFormat;
        }

        //pems - end

        for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
        {
            uiResult = rSig->Validate(ucDataFormat);

            // if the signal is valid
            if((uiResult == CSignal::SIG_EC_NO_ERR) || (uiResult == CSignal::SIG_EC_OVERFLOW))
            {
                /*Pems Start
                if(ucDataFormat == 0)
                {
                ucDataFormat = rSig.m_ucDataFormat; // now this is updated to the first valid signal's format
                rMsg.m_cDataFormat = ucDataFormat; // set message data format to this i.e format of first valid signal
                }
                Pems End*/
                rMsg->m_ucNumOfSignals++; // increment the signal count for this message
            }
            else
            {
                int flag = 0;
                list<CMessage>::iterator usMsg;

                for(usMsg=m_unsupList.begin(); usMsg!=m_unsupList.end(); ++usMsg)
                {
                    // find matching message from list
                    if((usMsg->m_uiMsgID == rMsg->m_uiMsgID) && (usMsg->m_cFrameFormat == rMsg->m_cFrameFormat))
                    {
                        usMsg->m_listSignals.push_back(*rSig);
                        flag = 1;
                    }
                }

                if(flag == 0)
                {
                    m_unsupList.push_back(*rMsg);
                    CMessage& msg = m_unsupList.back();
                    msg.m_listSignals.clear();
                    msg.m_listSignals.push_back(*rSig);
                }
            }
        }
    }

    //vaildate signals not associated with any messages.
    list<CSignal>::iterator rSig;

    for(rSig=m_listSignal.begin(); rSig!=m_listSignal.end(); ++rSig)
    {
        uiResult = rSig->Validate(rSig->m_ucDataFormat);

        // if the signal is valid
        if((uiResult == CSignal::SIG_EC_NO_ERR) || (uiResult == CSignal::SIG_EC_OVERFLOW))
        {
            /*Pems Start
            if(ucDataFormat == 0)
            {
            ucDataFormat = rSig.m_ucDataFormat; // now this is updated to the first valid signal's format
            rMsg.m_cDataFormat = ucDataFormat; // set message data format to this i.e format of first valid signal
            }
            Pems End*/
        }
        else
        {
            int flag = 0;
            list<CMessage>::iterator usMsg;

            for(usMsg=m_unsupList.begin(); usMsg!=m_unsupList.end(); ++usMsg)
            {
                if((usMsg->m_uiMsgID == 1073741824) && (usMsg->m_cFrameFormat == 'X'))
                {
                    usMsg->m_listSignals.push_back(*rSig);
                    flag = 1;
                }
            }

            if(flag == 0)
            {
                CMessage def_msg;
                def_msg.m_acName = "VECTOR__INDEPENDENT_SIG_MSG";
                def_msg.m_uiMsgID = 1073741824 ;
                def_msg.m_cFrameFormat = 'X';
                m_unsupList.push_back(def_msg);
                def_msg.m_listSignals.push_back(*rSig);
            }
        }
    }

    list<CParameter>::iterator rParam;

    for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
    {
        if(rParam->m_ObjectId == "BU_")
        {
            m_listParameterArray[1].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "BO_")
        {
            m_listParameterArray[2].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "SG_")
        {
            m_listParameterArray[3].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "")
        {
            m_listParameterArray[0].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "BU_SG_REL_")
        {
            m_listParameterArray[4].push_back(*rParam);
        }
        else if(rParam->m_ObjectId == "BU_BO_REL_")
        {
            m_listParameterArray[5].push_back(*rParam);
        }
    }
}

/**
 * \brief     Generates the message list
 * \param[in] fileInput Input file
 *
 * This function will parse the input file and line by line
 * and generates  a list of message,signal,value table,comments,etc
 */
void CConverter::GenerateMessageList(fstream& fileInput)
{
    char acLine[defCON_MAX_LINE_LEN]; // I don't expect one line to be more than this
    string local_copy;
    char* pcTok;
    int flag=0;
	int _flag_BS_= 0; //possible values 0,1,2// this flag is used to check if parsing is done in between NS_: and BS_:  #git issue 174

    // parsing the input file
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN))
    {
        char* pcToken=0, *pcLine=0;

        for (;;)
        {
            pcLine = acLine;
            pcLine += strlen(pcLine); // go to last position
            pcLine --;

            if (*pcLine == '\r')
            {
                fileInput.getline(pcLine, defCON_MAX_LINE_LEN);
            }
            else
            {
                break;
            }
        }

        // avoid leading <spaces> before tokenising, so passing the
        // starting point will be correct in each case, when calling
        // msg.Format, sig.Format etc.
        local_copy = acLine;
        pcLine = acLine;

        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        pcToken = strtok_s(pcLine, " :", &pcTok);

        if(pcToken)
        {
            //compare token to known types to interpret the line further
			if(strstr(pcToken, "BS_") != NULL)  // git issue #174
            {
                if (_flag_BS_ == 1 )
					_flag_BS_ = 2; // this means just NS_ and BS_ are done.
            }
			if(strstr(pcToken, "NS_") != NULL)
            {
                if (_flag_BS_ == 0 )
					_flag_BS_ = 1; // this means just NS_ is hit and BS_ is still due.
            }

            // new line - skip
            else if(strcmp(pcToken, "\n") == 0)
            {
                continue;
            }
            // message
            else if(strcmp(pcToken, "BO_") == 0)
            {
                CMessage msg;
                msg.Format(pcLine + strlen(pcToken)+1);

                // add the new message to the list
                if((msg.m_acName != "VECTOR__INDEPENDENT_SIG_MSG") && !(msg.m_uiMsgID == 3221225472))
                {
                    CConverter::valid_msg = true;
                    m_listMessages.push_back(msg);
                }
                else
                {
                    CConverter::valid_msg = false;
                }
            }
            // signal
            else if(strcmp(pcToken, "SG_") == 0)
            {
                CSignal sig;
                sig.Format(pcLine + strlen(pcToken) + 1);

                //if signal associated with a msg add it to that perticular list
                //elses add it to msg independent list
                if(CConverter::valid_msg == true)
                {
                    //insert signals in sorted order
                    int flag = 0;
                    CMessage& msg = m_listMessages.back();

                    if (msg.m_listSignals.empty())
                    {
                        msg.m_listSignals.push_front(sig);
                        flag = 1;
                        continue;
                    }

                    int count = 0;
                    list<CSignal>::iterator sig1 = msg.m_listSignals.end();

                    while(sig1!=msg.m_listSignals.begin())
                    {
                        --sig1;
                        count++;

                        if(((sig1->m_ucWhichByte * 8) + sig1->m_ucStartBit) > ((sig.m_ucWhichByte * 8) + sig.m_ucStartBit))
                        {
                            ++sig1;
                            msg.m_listSignals.insert(sig1, sig);
                            flag = 1;
                            break;
                        }
                    }

                    if (flag == 0)
                    {
                        msg.m_listSignals.push_front(sig);
                    }

                    // this signal should belong to the last message
                    msg.m_ucNumOfSignals++; // increment the signal count
                }
                else
                {
                    sig.m_ucWhichByte = 1;
                    sig.m_ucStartBit = 0;
                    m_listSignal.push_back(sig);
                }
            }
            // value descriptor
            else if(strcmp(pcToken, "VAL_") == 0)
            {
                // <msgid><sp><signalName><sp><value1><sp><"desc1"><sp><value2><sp><"desc2"> ...;
                // get MsgId, find the message from the messagelist.
                // find the signal from the message, then add the value descritors
                // to the respective signals
                pcLine = pcLine + strlen(pcToken) + 1; // to get next token
                pcToken = strtok_s(pcLine, " ", &pcTok); // msgid
                unsigned int id = (unsigned int) strtoul(pcToken, NULL, 10);

                if(id != 3221225472)
                {
                    list<CMessage>::iterator rMsg;

                    for(rMsg=m_listMessages.begin(); rMsg!=m_listMessages.end(); ++rMsg)
                    {
                        // find matching message from list
                        if(rMsg->m_uiMsgID == id)
                        {
                            pcLine = pcLine + strlen(pcToken) + 1; // to get next token
                            pcToken = strtok_s(pcLine, " ", &pcTok); // Signal name
                            list<CSignal>::iterator rSig;

                            // find matching signal
                            for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
                            {
                                if(rSig->m_acName == pcToken)
                                {
                                    rSig->AddValueDescriptors(pcLine + strlen(pcToken) + 1, fileInput);
                                    break; // if we got the signal we wanted
                                }
                            }

                            break; // we got the message we wanted
                        }
                    }
                }
                else
                {
                    pcLine = pcLine + strlen(pcToken) + 1; // to get next token
                    pcToken = strtok_s(pcLine, " ", &pcTok); // Signal name
                    list<CSignal>::iterator rSig;

                    // find matching signal
                    for(rSig=m_listSignal.begin(); rSig!=m_listSignal.end(); ++rSig)
                    {
                        if(rSig->m_acName == pcToken)
                        {
                            rSig->AddValueDescriptors(pcLine + strlen(pcToken) + 1, fileInput);
                            break; // if we got the signal we wanted
                        }
                    }
                }
            }
            // signal value qualifier
            else if(strcmp(pcToken, "SIG_VALTYPE_") == 0)
            {
                // <msgID> <signal name> : 1 -- float
                // <msgID> <signal name> : 2 -- double
                // get MsgId, find the message from the messagelist.
                // find the signal from the message, then update the
                // signal type appropriately of the respective signal
                pcToken = strtok_s(NULL, " :;", &pcTok); // msgid
                unsigned int id = (unsigned int)strtoul(pcToken, NULL, 10);

                if(id != 3221225472)
                {
                    list<CMessage>::iterator rMsg;

                    for(rMsg=m_listMessages.begin(); rMsg!=m_listMessages.end(); ++rMsg)
                    {
                        // find matching message from list
                        if(rMsg->m_uiMsgID == id)
                        {
                            pcToken = strtok_s(NULL, " :;", &pcTok); // Signal name
                            list<CSignal>::iterator rSig;

                            // find matching signal
                            for(rSig=rMsg->m_listSignals.begin(); rSig!=rMsg->m_listSignals.end(); ++rSig)
                            {
                                if(rSig->m_acName == pcToken)
                                {
                                    if(pcToken = strtok_s(NULL, " :;", &pcTok)) // qualifier (1 or 2)
                                    {
                                        // update signal type based on qualifier
                                        switch(*pcToken)
                                        {
                                            case '1':
                                                rSig->m_ucType = CSignal::SIG_TYPE_FLOAT;
                                                break;

                                            case '2':
                                                rSig->m_ucType = CSignal::SIG_TYPE_DOUBLE;
                                                break;

                                            default:
                                                break;
                                        }
                                    }

                                    break; // we got the signal we wanted
                                }
                            }

                            break; // we got the message we wanted
                        }
                    }
                }
                else
                {
                    pcToken = strtok_s(NULL, " :;", &pcTok); // Signal name
                    // find matching signal
                    list<CSignal>::iterator rSig;

                    for(rSig=m_listSignal.begin(); rSig!=m_listSignal.end(); ++rSig)
                    {
                        if(rSig->m_acName == pcToken)
                        {
                            if(pcToken = strtok_s(NULL, " :;", &pcTok)) // qualifier (1 or 2)
                            {
                                // update signal type based on qualifier
                                switch(*pcToken)
                                {
                                    case '1':
                                        rSig->m_ucType = CSignal::SIG_TYPE_FLOAT;
                                        break;

                                    case '2':
                                        rSig->m_ucType = CSignal::SIG_TYPE_DOUBLE;
                                        break;

                                    default:
                                        break;
                                }
                            }

                            break; // we got the signal we wanted
                        }
                    }
                }
            }
            //value table
            else if(strcmp(pcToken, "VAL_TABLE_") == 0)
            {
                CValueTable tab;
                pcToken = strtok_s(pcLine, " ", &pcTok);
                tab.Format(pcLine + strlen(pcToken) + 1, fileInput);
                m_vTab.push_back(tab);
            }
            //comments
            else if(strcmp(pcToken, "CM_") == 0)
            {
                string comment = pcTok; // for network node - venkat
                pcLine = pcLine + strlen(pcToken) + 1;
                pcToken = strtok_s(pcLine, " ", &pcTok);
                CComment cm;

                //comments related to node
                if(strcmp(pcToken, "BU_") == 0)
                {
                    pcToken = strtok_s(NULL, " ", &pcTok);
                    cm.m_elementName= pcToken;
                    pcToken = strtok_s(NULL, "", &pcTok);
                    comment = pcToken;

                    while(strstr(pcToken, "\";") == NULL)
                    {
                        fileInput.getline(acLine, defCON_MAX_LINE_LEN);
                        pcToken = acLine;
                        comment = comment + pcToken;
                    }

                    cm.m_comment= comment;
                    m_cmNode.push_back(cm);
                }
                //comments related to messages
                else if(strcmp(pcToken,"BO_") == 0)
                {
                    pcToken = strtok_s(NULL, " ", &pcTok);
                    cm.m_msgID = strtoul(pcToken, NULL, 10);

                    // set the id and frame format
                    // canoe puts MSbit = 1 for extended ID
                    if(cm.m_msgID < 0x80000000UL)
                    {
                        cm.m_msgType= 'S';
                    }
                    else
                    {
                        cm.m_msgType= 'X';
                        cm.m_msgID  &= 0x7FFFFFFF;
                    }

                    pcToken = strtok_s(NULL, "", &pcTok);
                    comment = pcToken;

                    while(strstr(pcToken, "\";") == NULL)
                    {
                        fileInput.getline(acLine, defCON_MAX_LINE_LEN);
                        pcToken = acLine;
                        comment = comment + pcToken;
                    }

                    cm.m_comment= comment;
                    m_cmMsg.push_back(cm);
                }
                //comments related to signals
                else if(strcmp(pcToken, "SG_") == 0)
                {
                    pcToken = strtok_s(NULL, " ", &pcTok);
                    cm.m_msgID = strtoul(pcToken, NULL, 10);

                    if(cm.m_msgID < 0x80000000UL)
                    {
                        cm.m_msgType = 'S';
                    }
                    else
                    {
                        cm.m_msgType = 'X';
                        cm.m_msgID &= 0x7FFFFFFF;
                    }

                    pcToken = strtok_s(NULL, " ", &pcTok);
                    cm.m_elementName = pcToken;
                    pcToken = strtok_s(NULL, "", &pcTok);
                    comment = pcToken;

                    while(strstr(pcToken, "\";") == NULL)
                    {
                        fileInput.getline(acLine, defCON_MAX_LINE_LEN);
                        pcToken = acLine;
                        comment = comment + pcToken;
                    }

                    cm.m_comment= comment;
                    m_cmSig.push_back(cm);
                }
                //comments related to network
                else
                {
                    //comment = pcToken;
					int nRetVal = comment.find(";");
                    if( nRetVal < 0)
                    {
                        while(strstr(pcToken, "\";") == NULL)
                        {
                            fileInput.getline(acLine, defCON_MAX_LINE_LEN);
                            pcToken = acLine;
                            comment = comment + pcToken;
                        }
                    }

                    cm.m_comment= comment;
                    m_cmNet.push_back(cm);
                }
            }
            // node
            else if(strcmp(pcToken, "BU_") == 0)
            {
                create_Node_List(pcLine + strlen(pcToken)+1);
            }
            else if ( ( (strcmp(pcToken, "BA_DEF_")==0) || (strcmp(pcToken, "BA_DEF_REL_")==0)) && _flag_BS_ > 1)
            {
                CParameter pObj;
                pObj.Format(pcLine + strlen(pcToken) + 1); // to get next token
                m_listParameters.push_back(pObj);
            }
            //Param Initial Values
            else if(strcmp(pcToken, "BA_DEF_DEF_")==0 && _flag_BS_ > 1 )
            {
                char acTemp[defCON_TEMP_LEN],*pcTemp;
                pcTemp = acTemp;
                pcToken = strtok_s(NULL, "\"", &pcTok);
                pcToken = strtok_s(NULL, "\"", &pcTok);
                flag=0;

                while(*pcToken && *pcToken != '"')
                {
                    *pcTemp++ = *pcToken++;
                }

                *pcTemp = '\0';
                list<CParameter>::iterator rParam;

                for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
                {
                    // find matching Parameter from list
                    if(rParam->m_ParamName == acTemp)
                    {
                        pcTemp=acTemp;
                        pcToken = strtok_s(NULL, ";", &pcTok); // default val
                        rParam->ReadDefaultVal(pcToken);
                        flag=1;
                        break;
                    }
                }

                if(flag==0)
                {
                    string errString = "BA_DEF_DEF_ \"";
                    errString += acTemp;
                    errString += "\" ";
                    errString += pcToken;
                    errString += " : Match not Found in Param List\n";
                    defList.push_back(errString);
                }
            }
            //RX,Tx Parameter Definition
            else if(strcmp(pcToken,"BA_DEF_DEF_REL_")==0 && _flag_BS_ > 1)
            {
                char acTemp[defCON_TEMP_LEN],*pcTemp;
                pcTemp = acTemp;
                flag = 0;
                pcToken = strtok_s(NULL, "\"", &pcTok);

                while(*pcToken && (*pcToken != '"'))
                {
                    *pcTemp++ = *pcToken++; // copy SIG_NAME only, i.e. till first 'space'
                }

                *pcTemp = '\0';
                list<CParameter>::iterator rParam;

                for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
                {
                    // find matching Parameter from list
                    if(rParam->m_ParamName == acTemp)
                    {
                        pcTemp = acTemp;
                        pcToken = strtok_s(NULL, ";", &pcTok); // default val
                        rParam->ReadDefaultVal(pcToken);
                        flag=1;
                        break;
                    }
                }

                if(flag==0)
                {
                    string errString = "BA_DEF_DEF_REL \"";
                    errString += acTemp;
                    errString += "\" ";
                    errString += pcToken;
                    errString += " : Match not Found in Param List\n";
                    defList.push_back(errString);
                }
            }
            // Parameter Other values //
            else if(strcmp(pcToken, "BA_")==0)
            {
                char acTemp[defCON_TEMP_LEN],*pcTemp;
                pcTemp = acTemp;

                while(*pcLine && (*pcLine == ' '))
                {
                    *pcLine++;
                }

                //get Param name
                pcLine = pcLine + strlen(pcToken) + 1;
                pcToken = strtok_s(pcLine, "\"", &pcTok);

                while(*pcToken && (*pcToken != '"'))
                {
                    *pcTemp++ = *pcToken++;
                }

                *pcTemp = '\0';
                list<CParameter>::iterator rParam;

                for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
                {
                    // find matching Parameter from list
                    if(rParam->m_ParamName == acTemp)
                    {
                        rParam->FormatParamValue(pcLine + strlen(acTemp) + 3); // to get next token
                        pcTemp=acTemp;
                        break;
                    }
                }
            }
            //maintain a list of lines not processed
            else
            {
                string str = local_copy;
                m_notProcessed.push_back(str);
                continue;
            }
        }
    }
}

/**
 * \brief     Writes all the data to the output file in CANoe format
 * \param[in] fileOutput Output file
 * \return    Status code
 *
 * Writes all the data to the output file in CANoe format.
 */
bool CConverter::WriteToOutputFile(fstream& fileOutput)
{
    bool bResult = true;
    // write to the output file
    // write header
    fileOutput << T_HEADER << endl;
    fileOutput << endl;
    fileOutput << T_DB_VER " " T_VER_NO << endl;
    fileOutput << endl;
	if(nProtocal == PROTOCAL_J1939)
	{
		fileOutput << T_PROTOCOL " " T_PRPTOCOL_J1939;
	}
	else
	{
		//default CAN
		fileOutput << T_PROTOCOL " " T_PROTOCOL_CAN;
	}
	fileOutput << endl;
	fileOutput << endl;

	//For easy replacement of version Info #define is not added
	fileOutput<< "[BUSMASTER_VERSION] [1.6.5]"<<endl;

    // number of messages
    fileOutput << T_NUM_OF_MSG " " << dec << m_listMessages.size() << endl;
    fileOutput << endl;
    //Write Messagess to the Output file
    CMessage msg;
    bResult &= msg.writeMessageToFile(fileOutput, m_listMessages, false, nProtocal);

    // write all messages, signals not associated with any Messages
    if(!m_listSignal.empty())
    {
        fileOutput << T_ST_SIG_LIST << endl;
        CSignal sig;
        bResult &= sig.WriteSignaltofile(fileOutput, m_listSignal, 0, 0, false);
        fileOutput << T_END_SIG_LIST << endl;
        fileOutput << endl;
    }

    //write value table
    fileOutput << T_ST_VAL_TAB << endl;
    CValueTable temp_vtab;
    temp_vtab.writeValueTabToFile (fileOutput,m_vTab);
    fileOutput << T_END_VAL_TAB << endl;
    fileOutput << endl;
    //write list of nodes
    fileOutput << T_NODE " ";
    bool comma = false;
    list<string>::iterator node;

    for(node=m_listNode.begin(); node!=m_listNode.end(); ++node)
    {
        if(comma)
        {
            fileOutput << ",";
        }

        fileOutput << node->c_str();
        comma = true;
    }

    fileOutput << endl;
    fileOutput << endl;
    //Write Comments
    fileOutput << T_ST_COMMENT << endl;
    //network comments
    fileOutput << T_ST_CM_NET << endl;
    list<CComment>::iterator cmt;

    for(cmt=m_cmNet.begin(); cmt!=m_cmNet.end(); ++cmt)
    {
		fileOutput << cmt->m_elementName.c_str();
		fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << T_END_CM_NET << endl;
    fileOutput << endl;
    //node comments
    fileOutput << T_ST_CM_NODE << endl;

    for(cmt=m_cmNode.begin(); cmt!=m_cmNode.end(); ++cmt)
    {
        fileOutput << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << T_END_CM_NODE << endl;
    fileOutput << endl;
    //message comments
    fileOutput << T_ST_CM_MSG << endl;

    for(cmt=m_cmMsg.begin(); cmt!=m_cmMsg.end(); ++cmt)
    {
        fileOutput << cmt->m_msgID;
        fileOutput << " " << cmt->m_msgType;
        fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << T_END_CM_MSG << endl;
    fileOutput << endl;
    //signal comments
    fileOutput << T_ST_CM_SIG << endl;

    for(cmt=m_cmSig.begin(); cmt!=m_cmSig.end(); ++cmt)
    {
        fileOutput << cmt->m_msgID;
        fileOutput << " " << cmt->m_msgType;
        fileOutput << " " << cmt->m_elementName.c_str();
        fileOutput << " " << cmt->m_comment.c_str() << endl;
    }

    fileOutput << T_END_CM_SIG << endl;
    fileOutput << T_END_COMMENT << endl;
    fileOutput << endl;
    //Write Parameters to the output file.
    fileOutput << START_PARAM_TAG << endl;
    fileOutput << START_NETPARAM_TAG << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[0]);
    fileOutput << END_NETPARAM_TAG << endl;
    fileOutput << endl;
    fileOutput << START_NODEPARAM_TAG << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[1]);
    fileOutput << END_NODEPARAM_TAG << endl;
    fileOutput << endl;
    fileOutput << START_MSGPARAM_TAG << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[2]);
    fileOutput << END_MSGPARAM_TAG << endl;
    fileOutput << endl;
    fileOutput << START_SIGPARAM_TAG << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[3]);
    fileOutput << END_SIGPARAM_TAG << endl;
    fileOutput << endl;
    fileOutput << START_RXPARAM_TAG << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[4]);
    fileOutput << END_RXPARAM_TAG << endl;
    fileOutput << endl;
    fileOutput << START_TXPARAM_TAG << endl;
    bResult=bResult & WriteParametersToFile(fileOutput, m_listParameterArray[5]);
    fileOutput << END_TXPARAM_TAG << endl;
    fileOutput << END_PARAM_TAG << endl;
    fileOutput << endl;
    //Parameter Values
    fileOutput << START_PARAMVAL_TAG << endl;
    fileOutput << START_NETVAL_TAG << endl;
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameterArray[0].begin(); rParam!=m_listParameterArray[0].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[0].begin(); vParam!=rParam->m_listParamValues[0].end(); ++vParam)
        {
            vParam->WriteNetValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << END_NETVAL_TAG << endl;
    fileOutput << endl;
    fileOutput << START_NODEVAL_TAG << endl;

    for(rParam=m_listParameterArray[1].begin(); rParam!=m_listParameterArray[1].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[1].begin(); vParam!=rParam->m_listParamValues[1].end(); ++vParam)
        {
            vParam->WriteNodeValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << END_NODEVAL_TAG << endl;
    fileOutput << endl;
    fileOutput << START_MSGVAL_TAG << endl;

    for(rParam=m_listParameterArray[2].begin(); rParam!=m_listParameterArray[2].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[2].begin(); vParam!=rParam->m_listParamValues[2].end(); ++vParam)
        {
            vParam->WriteMesgValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << END_MSGVAL_TAG << endl;
    fileOutput << endl;
    fileOutput << START_SIGVAL_TAG << endl;

    for(rParam=m_listParameterArray[3].begin(); rParam!=m_listParameterArray[3].end(); ++rParam)
    {
        list<CParameterValues>::iterator vParam;

        for(vParam=rParam->m_listParamValues[3].begin(); vParam!=rParam->m_listParamValues[3].end(); ++vParam)
        {
            vParam->WriteSigValuesToFile(fileOutput, rParam->m_ParamType, rParam->m_ParamName);
        }
    }

    fileOutput << END_SIGVAL_TAG << endl;
    fileOutput << endl;
    fileOutput << END_PARAMVAL_TAG << endl;
    fileOutput << endl;
    fileOutput << endl;
    //list of not supported
    fileOutput << T_ST_NOT_SUP << endl;
    msg.writeMessageToFile(fileOutput, m_unsupList, true, nProtocal);
    fileOutput << T_END_NOT_SUP << endl;
    fileOutput << endl;
    //lines that were not processed
    fileOutput << T_ST_NOT_PRO << endl;
    list<string>::iterator np;

    for(np=m_notProcessed.begin(); np!=m_notProcessed.end(); ++np)
    {
        fileOutput << np->c_str() << endl;
    }

    fileOutput << endl;
    fileOutput << T_END_NOT_PRO << endl;
    return bResult;
}

/**
 * \brief     Logs the eror info in log file
 * \param[in] fileLog Log file
 *
 * Logs the eror info in log file.
 */
void CConverter::CreateLogFile(fstream& fileLog)
{
    char first_msg = 1;
    // write to the output file
    fileLog << "Conversion Error Log" << endl;
    fileLog << endl;
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        first_msg = 1;
        list<CSignal>::iterator sig;

        for(sig=msg->m_listSignals.begin(); sig!=msg->m_listSignals.end(); ++sig)
        {
            // write signal only if it is not valid
            if(sig->m_uiError != CSignal::SIG_EC_NO_ERR)
            {
                string str;

                // for the first wrong signal, log the message details also
                if(first_msg == 1)
                {
                    fileLog << endl;
                    fileLog << "MSG_ID: " << dec << msg->m_uiMsgID;
                    fileLog << " \tMSG_TYPE: " << msg->m_cFrameFormat;
                    fileLog << " \tMSG_NAME: " << msg->m_acName.c_str() << endl;
                    first_msg = 0;
                }

                fileLog << "\tSIG_NAME: " << sig->m_acName.c_str();
                sig->GetErrorString(str);
                fileLog << ", STATUS: " << str;
                sig->GetErrorAction(str);
                fileLog << ", ACTION: " << str << endl;
            }
        }
    }

    //log errors in the signal list.
    first_msg = 1;
    list<CSignal>::iterator sig;

    for(sig=m_listSignal.begin(); sig!=m_listSignal.end(); ++sig)
    {
        // write signal only if it is not valid
        if(sig->m_uiError != CSignal::SIG_EC_OVERFLOW)
        {
            string str;

            // for the first wrong signal, log the message details also
            if(first_msg == 1)
            {
                fileLog << endl;
                fileLog << "MSG_ID: 1073741824";
                fileLog << " \tMSG_TYPE: X";
                fileLog << " \tMSG_NAME: VECTOR__INDEPENDENT_SIG_MSG" << endl;
                first_msg = 0;
            }

            fileLog << "\tSIG_NAME: " << sig->m_acName.c_str();
            sig->GetErrorString(str);
            fileLog << ", STATUS: " << str.c_str();
            sig->GetErrorAction(str);
            fileLog << ", ACTION: " << str.c_str() << endl;
        }
    }

    list<string>::iterator str;

    for(str=defList.begin(); str!=defList.end(); ++str)
    {
        fileLog << str->c_str();
    }

    list<CParameter>::iterator rParam;

    for(rParam=m_listParameters.begin(); rParam!=m_listParameters.end(); ++rParam)
    {
        if(rParam->m_defError)
        {
            fileLog << "OBJECT ID : " << rParam->m_ObjectId.c_str();
            fileLog << "\tPARAM_NAME :\"" << rParam->m_ParamName.c_str() << "\"" << endl;
            fileLog << "\tDescription:Default Value tag(BA_DEF_DEF_) doesn;t exist ";
            fileLog << "\t Action Taken : Reset to default value" << endl;
        }

        if(rParam->m_RangeError)
        {
            fileLog << "OBJECT ID : " << rParam->m_ObjectId.c_str();
            fileLog << "\tPARAM_NAME :\"" << rParam->m_ParamName.c_str() << "\"" << endl;
            fileLog << "\tDescription: Invalid Data Ranges";
            fileLog << "\t Action Taken : Reset to default value" << endl;
        }
    }
}

/**
 * \brief     creates a list of nodes inthe network
 * \param[in] pcLine String having all the node names
 *
 * Creates a list of nodes in the network.
 */
void CConverter::create_Node_List(char* pcLine)
{
    char* pcToken, *pcTok;
    // get the MSG ID
    pcToken = strtok_s(pcLine, " ,", &pcTok);

    while(pcToken)
    {
        string str = pcToken;
        m_listNode.push_back(str);
        pcToken = strtok_s(NULL, " ,", &pcTok);
    }
}

/**
 * \brief     encrypts all the strings present in the list
 * \param[in] m_notProcessed List of strings
 *
 * Encrypts all the strings present in the list
 */
void CConverter::EncryptData(list<string> &m_notProcessed)
{
    list<string>::iterator str;

    for(str=m_notProcessed.begin(); str!=m_notProcessed.end(); ++str)
    {
        //read the string at the position
        string::iterator ch;

        for(ch=str->begin() ; ch<str->end(); ++ch)
        {
            if ((*ch >= 'a' && *ch <= 'm') || (*ch >= 'A' && *ch <= 'M'))
            {
                *ch = *ch + 13;
            }
            else if ((*ch >= 'n' && *ch <= 'z') || (*ch >= 'N' && *ch <= 'Z'))
            {
                *ch = *ch - 13;
            }
        }
    }
}



























using namespace std;






CDBC2DBFConverter::CDBC2DBFConverter(void)
{
}






CDBC2DBFConverter::~CDBC2DBFConverter(void)
{
}








HRESULT CDBC2DBFConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the CANoe Database(.dbc) file to BUSMASTER Database(.dbf) file";
    return ((HRESULT)0L);
}








HRESULT CDBC2DBFConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "DBC TO DBF Conversion";
    return ((HRESULT)0L);
}









HRESULT CDBC2DBFConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case ((HRESULT)0L):
            m_omstrConversionStatus = "Conversion success";
            break;

        case ((HRESULT)1L):
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return ((HRESULT)0L);
}










HRESULT CDBC2DBFConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "dbc";
    pchInputFilters = "CANoe Database File(s) (*.dbc)|*.dbc||";
    return ((HRESULT)0L);
}









HRESULT CDBC2DBFConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return ((HRESULT)0L);
}










HRESULT CDBC2DBFConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "dbf";
    pchOutputFilters = "BUSMASTER Database File(s) (*.dbf)|*.dbf||";
    return ((HRESULT)0L);
}









HRESULT CDBC2DBFConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = ((HRESULT)0L);
    CConverter ouConverter;
    INT nRetVal = ouConverter.Convert(chInputFile, chOutputFile);
    
    ouConverter.GetResultString(m_omstrConversionStatus);

    if(nRetVal != 0)
    {
        m_omstrConversionStatus += ouConverter.m_omLogFilePath.data();
        m_hResult = nRetVal;
    }

    return hResult;
}







BOOL CDBC2DBFConverter::bHaveOwnWindow()
{
    return 0;
}
























#pragma once






class CDBC2DBFConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CDBC2DBFConverter(void);
    ~CDBC2DBFConverter(void);
    virtual HRESULT GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters);
    virtual HRESULT GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters);
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return ((HRESULT)1L);
    };
};
          §      §      ¥ÿÿÿÿ   ¥ÿÿÿÿ     á@      expression was false       nRetVal != 0    §ÿÿÿÿ   ¥      §ÿÿÿÿ   ¥                   íƒh         ¸      ¸      ¶ÿÿÿÿ   ¶ÿÿÿÿ    +Âx       statement executed        return 0;    ¸ÿÿÿÿ   ¶      ¸ÿÿÿÿ   ¶                    ­      ­      «ÿÿÿÿ   «ÿÿÿÿ    "”€       statement executed        return hResult;    ­ÿÿÿÿ   «      ­ÿÿÿÿ   «                    «      «      ©ÿÿÿÿ   ©ÿÿÿÿ     ê(X       statement executed        }    «ÿÿÿÿ   ©      «ÿÿÿÿ   ©                    ”      ”      ’ÿÿÿÿ   ’ÿÿÿÿ    "œp       statement executed        return ((HRESULT)0L);    ”ÿÿÿÿ   ’      ”ÿÿÿÿ   ’                    „      „      ‚ÿÿÿÿ   ‚ÿÿÿÿ     áø       statement executed        return ((HRESULT)0L);    „ÿÿÿÿ   ‚      „ÿÿÿÿ   ‚                    u      u      sÿÿÿÿ   sÿÿÿÿ     í€Ğ       statement executed        return ((HRESULT)0L);    uÿÿÿÿ   s      uÿÿÿÿ   s                    e      e      cÿÿÿÿ   cÿÿÿÿ     ê%°       statement executed        return ((HRESULT)0L);    eÿÿÿÿ   c      eÿÿÿÿ   c                    b      b      `ÿÿÿÿ   `ÿÿÿÿ     ø8       statement executed        break;    bÿÿÿÿ   `      bÿÿÿÿ   `              	      ^      ^      \ÿÿÿÿ   \ÿÿÿÿ     ê#¨       statement executed        break;    ^ÿÿÿÿ   \      ^ÿÿÿÿ   \              
      Z      Z      Xÿÿÿÿ   Xÿÿÿÿ     á˜       statement executed        break;    Zÿÿÿÿ   X      Zÿÿÿÿ   X                    I      I      Gÿÿÿÿ   Gÿÿÿÿ    +Ê(       statement executed        return ((HRESULT)0L);    Iÿÿÿÿ   G      Iÿÿÿÿ   G                    <      <      :ÿÿÿÿ   :ÿÿÿÿ    5Uà       statement executed        return ((HRESULT)0L);    <ÿÿÿÿ   :      <ÿÿÿÿ   :                    0      0      .ÿÿÿÿ   .ÿÿÿÿ    +Mp       statement executed        }    0ÿÿÿÿ   .      0ÿÿÿÿ   .                    '      '      %ÿÿÿÿ   %ÿÿÿÿ     ôQ       statement executed        }    'ÿÿÿÿ   %      'ÿÿÿÿ   %                    2   	   2      1ÿÿÿÿ   1ÿÿÿÿ    +       statement executed        return ((HRESULT)1L);    2ÿÿÿÿ   1   	   2ÿÿÿÿ   1           CDBC2DBFConverter::CDBC2DBFConverter CDBC2DBFConverter::CDBC2DBFConverter(void)    &      '      $ÿÿÿÿ   %ÿÿÿÿCDBC2DBFConverter::~CDBC2DBFConverter CDBC2DBFConverter::~CDBC2DBFConverter(void)    /      0      -ÿÿÿÿ   .ÿÿÿÿCDBC2DBFConverter::GetHelpText HRESULT CDBC2DBFConverter::GetHelpText(string& pchHelpText)    :      =      8ÿÿÿÿ   ;ÿÿÿÿCDBC2DBFConverter::GetConverterName HRESULT CDBC2DBFConverter::GetConverterName(string& strConverterName)    G      J      Eÿÿÿÿ   HÿÿÿÿCDBC2DBFConverter::GetErrorStatus HRESULT CDBC2DBFConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)    U      f      Sÿÿÿÿ   dÿÿÿÿCDBC2DBFConverter::GetInputFileFilters HRESULT CDBC2DBFConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)    r      v      pÿÿÿÿ   tÿÿÿÿCDBC2DBFConverter::GetLastConversionStatus HRESULT CDBC2DBFConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)          …      ÿÿÿÿ   ƒÿÿÿÿCDBC2DBFConverter::GetOutputFileFilters HRESULT CDBC2DBFConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)    ‘      •      ÿÿÿÿ   “ÿÿÿÿCDBC2DBFConverter::ConvertFile HRESULT CDBC2DBFConverter::ConvertFile(string& chInputFile, string& chOutputFile)           ®      ÿÿÿÿ   ¬ÿÿÿÿCDBC2DBFConverter::bHaveOwnWindow BOOL CDBC2DBFConverter::bHaveOwnWindow()    ·      ¹      µÿÿÿÿ   ·ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿCDBC2DBFConverter::GetPropertyPage HRESULT GetPropertyPage(CPropertyPage*& pPage)    1      3      0ÿÿÿÿ   2ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      DBC2DBFConverter.cpp
 * \brief     Definition of converter class
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Definition of the converter class.
 */

/* Project includes */
#include "Converter.h"
#include "DBC2DBFConverter.h"
#include "Definitions.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CDBC2DBFConverter
 */
CDBC2DBFConverter::CDBC2DBFConverter(void)
{
}

/**
 * \brief Destructor
 *
 * Destructor of CDBC2DBFConverter
 */
CDBC2DBFConverter::~CDBC2DBFConverter(void)
{
}

/**
 * \brief      Get help text
 * \param[out] pchHelpText Help Text
 * \return     Result code
 *
 * Returns pchHelpText containing the help text.
 */
HRESULT CDBC2DBFConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the CANoe Database(.dbc) file to BUSMASTER Database(.dbf) file";
    return S_OK;
}

/**
 * \brief      Get converter name
 * \param[out] strConverterName Converter Name
 * \return     Result code
 *
 * Returns strConverterName containing the converter name.
 */
HRESULT CDBC2DBFConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "DBC TO DBF Conversion";
    return S_OK;
}

/**
 * \brief      Get error status string
 * \param[in]  hResult Error code
 * \param[out] omstrStatus Corresponding error string
 * \return     Result code
 *
 * Returns omstrStatus containing the error string depending on hResult.
 */
HRESULT CDBC2DBFConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case S_OK:
            m_omstrConversionStatus = "Conversion success";
            break;

        case S_FALSE:
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return S_OK;
}

/**
 * \brief      Get input file filter type and name
 * \param[out] pchInputDefFilters file filter types
 * \param[out] pchInputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CDBC2DBFConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    pchInputDefFilters = "dbc";
    pchInputFilters = "CANoe Database File(s) (*.dbc)|*.dbc||";
    return S_OK;
}

/**
 * \brief      Get last conversion status
 * \param[out] hResult Last conversion status.
 * \param[out] omstrStatus String describing the last conversion status.
 * \return     Result code
 *
 * Returns a string containing the last conversion status.
 */
HRESULT CDBC2DBFConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    hResult = m_hResult;
    omstrStatus = m_omstrConversionStatus;
    return S_OK;
}

/**
 * \brief      Get output file filter type and name
 * \param[out] pchOutputDefFilters file filter types
 * \param[out] pchOutputFilters file filter name
 * \return     Result code
 *
 * Returns strings containing the file extensions and a
 * corresponding filter description.
 */
HRESULT CDBC2DBFConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    pchOutputDefFilters = "dbf";
    pchOutputFilters = "BUSMASTER Database File(s) (*.dbf)|*.dbf||";
    return S_OK;
}

/**
 * \brief     Conversion function
 * \param[in] chInputFile Input file name to convert from
 * \param[in] chOutputFile Output file name to convert to
 * \return    Result code
 *
 * This is the actual conversion function with input and output file name.
 */
HRESULT CDBC2DBFConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    HRESULT hResult = S_OK;
    CConverter ouConverter;
    INT nRetVal = ouConverter.Convert(chInputFile, chOutputFile);
    // display final result
    ouConverter.GetResultString(m_omstrConversionStatus);

    if(nRetVal != 0)
    {
        m_omstrConversionStatus += ouConverter.m_omLogFilePath.data();
        m_hResult = nRetVal;
    }

    return hResult;
}

/**
 * \brief     Returns if it has an own window
 * \return    True, if it has an own window.
 *
 * This returns true, if the converter has an own window, false otherwise.
 */
BOOL CDBC2DBFConverter::bHaveOwnWindow()
{
    return FALSE;
}
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      DBC2DBFConverter.h
 * \brief     Definition of converter class
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Definition of converter class.
 */

#pragma once

/* C++ includes */
#include <string>

/* Project includes */
#include "../FormatConverterApp/BaseConverter.h"

class CDBC2DBFConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CDBC2DBFConverter(void);
    ~CDBC2DBFConverter(void);
    virtual HRESULT GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters);
    virtual HRESULT GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters);
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return S_FALSE;
    };
};






























using namespace std;











static AFX_EXTENSION_MODULE DBC2DBFConverterDLL = { 0, 0 };





extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
    (lpReserved);

    if (dwReason == 1)
    {
        ;

        
        if (!AfxInitExtensionModule(DBC2DBFConverterDLL, hInstance))
        {
            return 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        new CDynLinkLibrary(DBC2DBFConverterDLL);
    }
    else if (dwReason == 0)
    {
        ;
        
        AfxTermExtensionModule(DBC2DBFConverterDLL);
    }

    return 1;   
}





extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CDBC2DBFConverter();
    return ((HRESULT)0L);
}
























#pragma once





class CDBC2DBFConverter : public CBaseConverter
{
    string m_omstrConversionStatus;
    HRESULT m_hResult;
public:
    CDBC2DBFConverter(void);
    ~CDBC2DBFConverter(void);
    virtual HRESULT GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters);
    virtual HRESULT GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters);
    virtual HRESULT ConvertFile(string& chInputFile, string& chOutputFile);
    virtual HRESULT GetConverterName(string& strConverterName);
    virtual HRESULT GetErrorStatus(HRESULT hResult, string& omstrStatus);
    virtual HRESULT GetLastConversionStatus(HRESULT& hResult, string& omstrStatus);
    virtual HRESULT GetHelpText(string& pchHelpText);
    virtual BOOL bHaveOwnWindow();
    virtual HRESULT GetPropertyPage(CPropertyPage*& pPage)
    {
        return ((HRESULT)1L);
    };
};
          S      S      Nÿÿÿÿ   Nÿÿÿÿ     á˜      expression was false       dwReason == 0    Sÿÿÿÿ   N      Sÿÿÿÿ   N                   ÷ö         C      C      >ÿÿÿÿ   >ÿÿÿÿ    +Ê(       statement executed        return 0;    Cÿÿÿÿ   >      Cÿÿÿÿ   >                    R      R      Mÿÿÿÿ   Mÿÿÿÿ     ôSP       statement executed        }    Rÿÿÿÿ   M      Rÿÿÿÿ   M                    X      X      Sÿÿÿÿ   Sÿÿÿÿ    5Uà       statement executed        }    Xÿÿÿÿ   S      Xÿÿÿÿ   S                    Z      Z      Uÿÿÿÿ   Uÿÿÿÿ    "¸       statement executed        return 1;    Zÿÿÿÿ   U      Zÿÿÿÿ   U                    d      d      _ÿÿÿÿ   _ÿÿÿÿ    +Mp       statement executed        return ((HRESULT)0L);    dÿÿÿÿ   _      dÿÿÿÿ   _                    A      A   D   <ÿÿÿÿ   <ÿÿÿÿ     ôQ      expression was false       !AfxInitExtensionModule(DBC2DBFConverterDLL, hInstance)    Aÿÿÿÿ   <      Aÿÿÿÿ   <   D                ê#¨         2   	   2      0ÿÿÿÿ   0ÿÿÿÿ     øJÈ       statement executed        return ((HRESULT)1L);    2ÿÿÿÿ   0   	   2ÿÿÿÿ   0           DllMain extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)    8      [      3ÿÿÿÿ   VÿÿÿÿGetBaseConverter extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)    b      e      ]ÿÿÿÿ   `ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿCDBC2DBFConverter::GetPropertyPage HRESULT GetPropertyPage(CPropertyPage*& pPage)    1      3      /ÿÿÿÿ   1ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      DBC2DBFConverterDLL.cpp
 * \brief     Definition of initialization routines for the DLL
 * \authors   Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Defines the initialization routines for the DLL.
 */

#define VC_EXTRALEAN        /* Exclude rarely-used stuff from Windows headers */

/* MFC includes */
#include <afxwin.h>         /* MFC core and standard components */
#include <afxdllx.h>        /* MFC dynamic link library extension */

/* Project includes */
#include "DBC2DBFConverter.h"
#include "tag.h"
#include "definitions.h"

using namespace std;

#ifdef _MANAGED
#error Please read instructions in DBC2DBFConverter.cpp to compile with /clr
// If you want to add /clr to your project you must do the following:
//  1. Remove the above include for afxdllx.h
//  2. Add a .cpp file to your project that does not have /clr thrown and has
//     Precompiled headers disabled, with the following text:
//          #include <afxwin.h>
//          #include <afxdllx.h>
#endif

static AFX_EXTENSION_MODULE DBC2DBFConverterDLL = { NULL, NULL };

#ifdef _MANAGED
#pragma managed(push, off)
#endif

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("DBC2DBFConverter.DLL Initializing!\n");

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(DBC2DBFConverterDLL, hInstance))
        {
            return 0;
        }

        // Insert this DLL into the resource chain
        // NOTE: If this Extension DLL is being implicitly linked to by
        //  an MFC Regular DLL (such as an ActiveX Control)
        //  instead of an MFC application, then you will want to
        //  remove this line from DllMain and put it in a separate
        //  function exported from this Extension DLL.  The Regular DLL
        //  that uses this Extension DLL should then explicitly call that
        //  function to initialize this Extension DLL.  Otherwise,
        //  the CDynLinkLibrary object will not be attached to the
        //  Regular DLL's resource chain, and serious problems will
        //  result.
        new CDynLinkLibrary(DBC2DBFConverterDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("DBC2DBFConverter.DLL Terminating!\n");
        // Terminate the library before destructors are called
        AfxTermExtensionModule(DBC2DBFConverterDLL);
    }

    return 1;   // ok
}

#ifdef _MANAGED
#pragma managed(pop)
#endif

extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CDBC2DBFConverter();
    return S_OK;
}




























































































typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;





































typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		
	char *yy_buf_pos;		

	


	yy_size_t yy_buf_size;

	


	int yy_n_chars;

	



	int yy_is_our_buffer;

	




	int yy_is_interactive;

	



	int yy_at_bol;

	


	int yy_fill_buffer;

	int yy_buffer_status;


	










	};

static YY_BUFFER_STATE yy_current_buffer = 0;









static char yy_hold_char;

static int yy_n_chars;		


int yyleng;


static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		
static int yy_start = 0;	




static int yy_did_buffer_switch_on_eof;

void yyrestart ();

void yy_switch_to_buffer ();
void yy_load_buffer_state ();
YY_BUFFER_STATE yy_create_buffer ();
void yy_delete_buffer ();
void yy_init_buffer ();
void yy_flush_buffer ();


YY_BUFFER_STATE yy_scan_buffer ();
YY_BUFFER_STATE yy_scan_string ();
YY_BUFFER_STATE yy_scan_bytes ();

static void *yy_flex_alloc ();
static void *yy_flex_realloc ();
static void yy_flex_free ();



















typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;


static yy_state_type yy_get_previous_state ();
static yy_state_type yy_try_NUL_trans ();
static int yy_get_next_buffer ();
static void yy_fatal_error ();













static  short int yy_accept[55] =
    {   0,
        0,    0,    6,    3,    4,    3,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    1,    0,    0,    0,    0,    0,
        0,    0,    2,    0
    } ;

static  int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    5,    1,
        6,    1,    1,    1,    1,    1,    7,    1,    1,    1,
        1,    1,    1,    1,    9,   10,   11,   12,   13,   14,
        1,    1,    1,   15,    1,   16,    1,   17,   18,   19,
        1,   20,   21,   22,   23,    1,    1,    1,   24,    1,
        1,    1,    1,    1,    8,    1,    9,   10,   11,   12,

       13,   14,    1,    1,    1,   15,    1,   16,    1,   17,
       18,   19,    1,   20,   21,   22,   23,    1,    1,    1,
       24,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static  int yy_meta[25] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1
    } ;

static  short int yy_base[56] =
    {   0,
        0,    1,   65,   66,   66,   55,   55,    3,    5,   49,
        2,   47,   37,   39,   50,   36,   38,   43,   32,   31,
       39,   27,   32,   35,   29,   36,   38,   32,   26,   11,
       39,   26,   14,   19,   16,   16,   28,   19,   28,   23,
       18,   30,   29,   20,   66,   22,   17,   26,   23,   23,
       21,   23,   66,   66,    0
    } ;

static  short int yy_def[56] =
    {   0,
       55,   55,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,    0,   54
    } ;

static  short int yy_nxt[91] =
    {   0,
        4,   54,    5,    5,    9,    9,    9,    9,   11,    6,
        6,   13,    9,    9,   10,   35,   35,   35,   35,   37,
       14,   46,   46,   46,   46,   47,   53,   52,   51,   50,
       49,   48,   45,   44,   43,   42,   41,   40,   39,   38,
       36,   34,   33,   32,   31,   30,   29,   28,   27,   26,
       25,   24,   23,   22,   21,   20,   19,   18,   17,   16,
       15,   12,    8,    7,   54,    3,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54
    } ;

static  short int yy_chk[91] =
    {   0,
       55,    0,    1,    2,    8,    8,    9,    9,    9,    1,
        2,   11,   30,   30,    8,   33,   33,   35,   35,   35,
       11,   44,   44,   46,   46,   46,   52,   51,   50,   49,
       48,   47,   43,   42,   41,   40,   39,   38,   37,   36,
       34,   32,   31,   29,   28,   27,   26,   25,   24,   23,
       22,   21,   20,   19,   18,   17,   16,   15,   14,   13,
       12,   10,    7,    6,    3,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;







char *yytext;




int nBus = 0;
int nProtocal = -1;
int FindProtoCol(char* file)
{
yyin = fopen(file, "r");
yylex();
return 0;
}









extern int yywrap ();


static void yyunput ();









static int input ();


































































































int yylex ()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;





		if ( ! yy_start )
			yy_start = 1;	

		if ( ! yyin )
			yyin = (&__iob_func()[0]);

		if ( ! yyout )
			yyout = (&__iob_func()[1]);

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, 16384 );

		yy_load_buffer_state();
		}

	while ( 1 )		
		{
		yy_cp = yy_c_buf_p;

		
		*yy_cp = yy_hold_char;

		


		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[((unsigned int) (unsigned char) *yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 55 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 66 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ 
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		yytext = yy_bp; yyleng = (int) (yy_cp - yy_bp); yy_hold_char = *yy_cp; *yy_cp = '\0'; yy_c_buf_p = yy_cp;;


do_action:	


		switch ( yy_act )
	{ 
			case 0: 
			
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:

nBus = 0;
	break;
case 2:

nProtocal = 1;
	break;
case 3:

;;
	break;
case 4:

;;
	break;
case 5:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case (6 + 0 + 1):
	return 0;

	case 6:
		{
		
		int yy_amount_of_matched_text = (int) (yy_cp - yytext) - 1;

		
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == 0 )
			{
			








			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = 1;
			}

		






		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ 
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			








			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext + 0;

			if ( yy_next_state )
				{
				
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case 1:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					








					yy_c_buf_p = yytext + 0;

					yy_act = (6 + ((yy_start - 1) / 2) + 1);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );
					}
				break;
				}

			case 0:
				yy_c_buf_p =
					yytext + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_match;

			case 2:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_find_action;
			}
		break;
		}

	default:
		yy_fatal_error( "fatal flex scanner internal error--no action found" );
	} 
		} 
	} 










static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ 
		if ( yy_c_buf_p - yytext - 0 == 1 )
			{
			


			return 1;
			}

		else
			{
			


			return 2;
			}
		}

	

	
	number_to_move = (int) (yy_c_buf_p - yytext) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == 2 )
		


		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ 





			
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				yy_fatal_error( "fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
			}

		if ( num_to_read > 8192 )
			num_to_read = 8192;

		
		if ( yy_current_buffer->yy_is_interactive ) { int c = '*', n; for ( n = 0; n < num_to_read && (c = getc( yyin )) != (-1) && c != '\n'; ++n ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c; if ( c == '\n' ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c; if ( c == (-1) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" ); yy_n_chars = n; } else if ( ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" );;
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == 0 )
			{
			ret_val = 1;
			yyrestart( yyin );
			}

		else
			{
			ret_val = 2;
			yy_current_buffer->yy_buffer_status =
				2;
			}
		}

	else
		ret_val = 0;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = 0;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = 0;

	yytext = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}




static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext + 0; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[((unsigned int) (unsigned char) *yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 55 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}











static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 55 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 54);

	return yy_is_jam ? 0 : yy_current_state;
	}






static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
	{
	register char *yy_cp = yy_c_buf_p;

	
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ 
		
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			yy_fatal_error( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}





static int input()
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == 0 )
		{
		



		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			
			*yy_c_buf_p = '\0';

		else
			{ 
			yytext = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case 1:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext + 0;
						return (-1);
						}

					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );



					return input();
					}

				case 0:
					yy_c_buf_p = yytext + 0;
					break;

				case 2:




					yy_fatal_error( "unexpected last match in input()" );
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	
	*yy_c_buf_p = '\0';	
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}





void yyrestart( input_file )
FILE *input_file;
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, 16384 );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}





void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	




	yy_did_buffer_switch_on_eof = 1;
	}





void yy_load_buffer_state()
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}





YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	


	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}





void yy_delete_buffer( b )
YY_BUFFER_STATE b;
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}




extern int isatty ();




void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;





	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
	}





void yy_flush_buffer( b )
YY_BUFFER_STATE b;

	{
	b->yy_n_chars = 0;

	



	b->yy_ch_buf[0] = 0;
	b->yy_ch_buf[1] = 0;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = 0;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}






YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != 0 ||
	     base[size-1] != 0 )
		
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = 0;

	yy_switch_to_buffer( b );

	return b;
	}






YY_BUFFER_STATE yy_scan_string( str )
 char *str;
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}






YY_BUFFER_STATE yy_scan_bytes( bytes, len )
 char *bytes;
int len;
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = 0;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		yy_fatal_error( "bad buffer in yy_scan_bytes()" );

	


	b->yy_is_our_buffer = 1;

	return b;
	}




























































static void yy_fatal_error( msg )
char msg[];
	{
	(void) fprintf( (&__iob_func()[2]), "%s\n", msg );
	exit( 2 );
	}









































static void *yy_flex_alloc( size )
yy_size_t size;
	{
	return (void *) malloc( size );
	}




static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
	{
	






	return (void *) realloc( (char *) ptr, size );
	}




static void yy_flex_free( ptr )
void *ptr;
	{
	free( ptr );
	}








int yywrap()
{
fclose(yyin);
return 1;
}
         x  ú  x    [ÿÿÿÿ  [ÿÿÿÿ     0˜      expression was true       ferror( yyin )   xÿÿÿÿ  [  ú  xÿÿÿÿ  [     expression was false       ferror( yyin )   xÿÿÿÿ  [  ú  xÿÿÿÿ  [                  x  ’  x  ö  [ÿÿÿÿ  [ÿÿÿÿ     0—       expression was true       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   xÿÿÿÿ  [  ’  xÿÿÿÿ  [  ö   expression was false       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   xÿÿÿÿ  [  ’  xÿÿÿÿ  [  ö                0•ø        x  3  x  A  [ÿÿÿÿ  [ÿÿÿÿ     0È      expression was true       ferror( yyin )   xÿÿÿÿ  [  3  xÿÿÿÿ  [  A   expression was false       ferror( yyin )   xÿÿÿÿ  [  3  xÿÿÿÿ  [  A                x  &  x  /  [ÿÿÿÿ  [ÿÿÿÿ     0Œà      expression was true       c == (-1)   xÿÿÿÿ  [  &  xÿÿÿÿ  [  /   expression was false       c == (-1)   xÿÿÿÿ  [  &  xÿÿÿÿ  [  /                0‹¸        x     x   ˆ  [ÿÿÿÿ  [ÿÿÿÿ     0„8      expression was true       c != '\n'   xÿÿÿÿ  [     xÿÿÿÿ  [   ˆ   expression was false       c != '\n'   xÿÿÿÿ  [     xÿÿÿÿ  [   ˆ                0‚x   
     x   a  x   {  [ÿÿÿÿ  [ÿÿÿÿ     0€x      expression was true       (c = getc( yyin )) != (-1)   xÿÿÿÿ  [   a  xÿÿÿÿ  [   {   expression was false       (c = getc( yyin )) != (-1)   xÿÿÿÿ  [   a  xÿÿÿÿ  [   {                0~¨        x   N  x   ]  [ÿÿÿÿ  [ÿÿÿÿ     0       expression was true       n < num_to_read   xÿÿÿÿ  [   N  xÿÿÿÿ  [   ]   expression was false       n < num_to_read   xÿÿÿÿ  [   N  xÿÿÿÿ  [   ]                ¤     ¤   "  †ÿÿÿÿ  †ÿÿÿÿ     0µĞ      expression was true       *yy_cp   ¤ÿÿÿÿ  †     ¤ÿÿÿÿ  †   "   expression was false       *yy_cp   ¤ÿÿÿÿ  †     ¤ÿÿÿÿ  †   "                @     @     	ÿÿÿÿ  	ÿÿÿÿ     3/      expression was false       i < len   @ÿÿÿÿ  	     @ÿÿÿÿ  	                   $     $     ïÿÿÿÿ  ïÿÿÿÿ     3À      expression was false       str[len]   $ÿÿÿÿ  ï     $ÿÿÿÿ  ï                   ¢     ¢   .  „ÿÿÿÿ  „ÿÿÿÿ     0É`      expression was false       yy_cp < yy_c_buf_p   ¢ÿÿÿÿ  „     ¢ÿÿÿÿ  „   .                Ô     Ô     ¥ÿÿÿÿ  ¥ÿÿÿÿ     2ëH      expression was true       file   Ôÿÿÿÿ  ¥     Ôÿÿÿÿ  ¥      expression was false       file   Ôÿÿÿÿ  ¥     Ôÿÿÿÿ  ¥                   <     <   !  !ÿÿÿÿ  !ÿÿÿÿ     0P`      expression was false       i < number_to_move   <ÿÿÿÿ  !     <ÿÿÿÿ  !   !                ñ     ñ   0  Ñÿÿÿÿ  Ñÿÿÿÿ     0ó       expression was false       source > yy_current_buffer->yy_ch_buf   ñÿÿÿÿ  Ñ     ñÿÿÿÿ  Ñ   0                Í   
  Í   F  ®ÿÿÿÿ  ®ÿÿÿÿ     0Ş€      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   Íÿÿÿÿ  ®   
  Íÿÿÿÿ  ®   F                0Ö@        ª     ª   G  Œÿÿÿÿ  Œÿÿÿÿ     0Æ8      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   ªÿÿÿÿ  Œ     ªÿÿÿÿ  Œ   G                0½ø        J     J     /ÿÿÿÿ  /ÿÿÿÿ     0vø      expression was false       num_to_read <= 0   Jÿÿÿÿ  /     Jÿÿÿÿ  /                   0Xh        V     V   H  =ÿÿÿÿ  =ÿÿÿÿ     /Õ8      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   Vÿÿÿÿ  =     Vÿÿÿÿ  =   H                /Ìø        @   
  @     'ÿÿÿÿ  'ÿÿÿÿ     09°      expression was false       1   @ÿÿÿÿ  '   
  @ÿÿÿÿ  '                   _     _   *  Fÿÿÿÿ  Fÿÿÿÿ     /Ù¸      expression was true       yy_base[yy_current_state] != 66   _ÿÿÿÿ  F     _ÿÿÿÿ  F   *   expression was false       yy_base[yy_current_state] != 66   _ÿÿÿÿ  F     _ÿÿÿÿ  F   *                /Øà        F     F   
  ÿÿÿÿ  ÿÿÿÿ     34Ø      expression was false       ! b   Fÿÿÿÿ       Fÿÿÿÿ     
                32à        =     =     ÿÿÿÿ  ÿÿÿÿ     3+°      expression was false       ! buf   =ÿÿÿÿ       =ÿÿÿÿ                     3)¸                 
  Ôÿÿÿÿ  Ôÿÿÿÿ     3       expression was false       ! b   ÿÿÿÿ  Ô     ÿÿÿÿ  Ô   
                3
   !                 Íÿÿÿÿ  Íÿÿÿÿ     2ÿ      expression was true       size < 2    ÿÿÿÿ  Í      ÿÿÿÿ  Í      expression was false       size < 2    ÿÿÿÿ  Í      ÿÿÿÿ  Í              #     ğ     ğ     ¾ÿÿÿÿ  ¾ÿÿÿÿ     2ùÈ      expression was false       b == yy_current_buffer   ğÿÿÿÿ  ¾     ğÿÿÿÿ  ¾                   2÷È   $     ²     ²     ˆÿÿÿÿ  ˆÿÿÿÿ     2áÀ      expression was false       b->yy_is_our_buffer   ²ÿÿÿÿ  ˆ     ²ÿÿÿÿ  ˆ              %     ¯     ¯     …ÿÿÿÿ  …ÿÿÿÿ     2ßp      expression was false       b == yy_current_buffer   ¯ÿÿÿÿ  …     ¯ÿÿÿÿ  …                   2Ûh   &     ¬     ¬   
  ‚ÿÿÿÿ  ‚ÿÿÿÿ     2Ú0      expression was false       ! b   ¬ÿÿÿÿ  ‚     ¬ÿÿÿÿ  ‚   
                2Ù   '     š     š     qÿÿÿÿ  qÿÿÿÿ     2Ó0      expression was false       ! b->yy_ch_buf   šÿÿÿÿ  q     šÿÿÿÿ  q                   2Ñ8   (     ‘     ‘   
  hÿÿÿÿ  hÿÿÿÿ     2Ëè      expression was false       ! b   ‘ÿÿÿÿ  h     ‘ÿÿÿÿ  h   
                2Éğ   )     e     e     >ÿÿÿÿ  >ÿÿÿÿ     2¸ø      expression was false       yy_current_buffer   eÿÿÿÿ  >     eÿÿÿÿ  >              *     b     b   &  ;ÿÿÿÿ  ;ÿÿÿÿ     2±ø      expression was false       yy_current_buffer == new_buffer   bÿÿÿÿ  ;     bÿÿÿÿ  ;   &                2°Ø   +     S     S     -ÿÿÿÿ  -ÿÿÿÿ     2«ğ      expression was false       ! yy_current_buffer   Sÿÿÿÿ  -     Sÿÿÿÿ  -                   2©x   ,     *     *   (  ÿÿÿÿ  ÿÿÿÿ     2›P      expression was false       ! yy_did_buffer_switch_on_eof   *ÿÿÿÿ       *ÿÿÿÿ     (                2™p   -     #     #     ÿÿÿÿ  ÿÿÿÿ     2˜h      expression was false       yywrap()   #ÿÿÿÿ       #ÿÿÿÿ                .               îÿÿÿÿ  îÿÿÿÿ     2¢p      expression was false       *yy_c_buf_p == 0   ÿÿÿÿ  î     ÿÿÿÿ  î                   2È   /     ø     ø   0  Øÿÿÿÿ  Øÿÿÿÿ     2ƒP      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   øÿÿÿÿ  Ø     øÿÿÿÿ  Ø   0                2X   0     è     è   /  Èÿÿÿÿ  Èÿÿÿÿ     2…      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   èÿÿÿÿ  È     èÿÿÿÿ  È   /                0êh   1     Ğ     Ğ     ±ÿÿÿÿ  ±ÿÿÿÿ     0ÜÀ      expression was false       yy_current_state >= 55   Ğÿÿÿÿ  ±     Ğÿÿÿÿ  ±                   0Ù¸   2     È     È   "  ©ÿÿÿÿ  ©ÿÿÿÿ     0ÔØ      expression was false       yy_accept[yy_current_state]   Èÿÿÿÿ  ©     Èÿÿÿÿ  ©   "           3     ­   	  ­     ÿÿÿÿ  ÿÿÿÿ     0Äx      expression was false       yy_current_state >= 55   ­ÿÿÿÿ     	  ­ÿÿÿÿ                     0Áp   4     ¥     ¥   #  ‡ÿÿÿÿ  ‡ÿÿÿÿ     0¼      expression was false       yy_accept[yy_current_state]   ¥ÿÿÿÿ  ‡     ¥ÿÿÿÿ  ‡   #           5               Îÿÿÿÿ  Îÿÿÿÿ     3        expression was true       base[size-2] != 0   ÿÿÿÿ  Î     ÿÿÿÿ  Î      expression was false       base[size-2] != 0   ÿÿÿÿ  Î     ÿÿÿÿ  Î                   2ÿ    7               Ïÿÿÿÿ  Ïÿÿÿÿ     3ğ      expression was true       base[size-1] != 0   ÿÿÿÿ  Ï     ÿÿÿÿ  Ï      expression was false       base[size-1] != 0   ÿÿÿÿ  Ï     ÿÿÿÿ  Ï                   30   9     x   Ô  x   İ  [ÿÿÿÿ  [ÿÿÿÿ     0‰¸      expression was false       c == '\n'   xÿÿÿÿ  [   Ô  xÿÿÿÿ  [   İ                0ˆ   :     t     t     Wÿÿÿÿ  Wÿÿÿÿ     0y€      expression was false       num_to_read > 8192   tÿÿÿÿ  W     tÿÿÿÿ  W              ;     i   	  i     Nÿÿÿÿ  Nÿÿÿÿ     0p¸      expression was false       ! b->yy_ch_buf   iÿÿÿÿ  N   	  iÿÿÿÿ  N                   0mÈ   <     $     $   -  	ÿÿÿÿ  	ÿÿÿÿ     0Jp      expression was false       yy_current_buffer->yy_fill_buffer == 0   $ÿÿÿÿ  	     $ÿÿÿÿ  	   -                0D   =               A  ÿÿÿÿ  ÿÿÿÿ     0Ch      expression was false       yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1]    ÿÿÿÿ        ÿÿÿÿ     A           >     ì     ì   (  Óÿÿÿÿ  Óÿÿÿÿ     0"ˆ      expression was false       ! yy_did_buffer_switch_on_eof   ìÿÿÿÿ  Ó     ìÿÿÿÿ  Ó   (                0    ?     ˜     ˜   0  ÿÿÿÿ  ÿÿÿÿ     0X      expression was false       yy_current_buffer->yy_buffer_status == 0   ˜ÿÿÿÿ       ˜ÿÿÿÿ     0                /ûø   @     c     c     Jÿÿÿÿ  Jÿÿÿÿ     /â       expression was false       yy_act == 0   cÿÿÿÿ  J     cÿÿÿÿ  J                   /Ü(   A     Y   
  Y      @ÿÿÿÿ  @ÿÿÿÿ     /Óx      expression was false       yy_current_state >= 55   Yÿÿÿÿ  @   
  Yÿÿÿÿ  @                    /Ğp   B     Q   	  Q   $  8ÿÿÿÿ  8ÿÿÿÿ     /Ë      expression was false       yy_accept[yy_current_state]   Qÿÿÿÿ  8   	  Qÿÿÿÿ  8   $           C     9     9      ÿÿÿÿ   ÿÿÿÿ     /½      expression was false       ! yy_current_buffer   9ÿÿÿÿ        9ÿÿÿÿ                      /¹è   D     6     6     ÿÿÿÿ  ÿÿÿÿ     /¸°      expression was false       ! yyout   6ÿÿÿÿ       6ÿÿÿÿ                     /µ    E     3     3     ÿÿÿÿ  ÿÿÿÿ     /³Ø      expression was false       ! yyin   3ÿÿÿÿ       3ÿÿÿÿ                     /°(   F     0     0     ÿÿÿÿ  ÿÿÿÿ     /¯       expression was false       ! yy_start   0ÿÿÿÿ       0ÿÿÿÿ                     /¬x   G     (     (     ÿÿÿÿ  ÿÿÿÿ     /¿       expression was false       yy_init   (ÿÿÿÿ       (ÿÿÿÿ                H     ì     ì   
  ®ÿÿÿÿ  ®ÿÿÿÿ     3C       statement executed        return 1;   ìÿÿÿÿ  ®     ìÿÿÿÿ  ®   
           I     ß     ß     ¢ÿÿÿÿ  ¢ÿÿÿÿ     3AØ       statement executed        }   ßÿÿÿÿ  ¢     ßÿÿÿÿ  ¢              J     Ô     Ô   0  ˜ÿÿÿÿ  ˜ÿÿÿÿ     3?x       statement executed        return (void *) realloc( (char *) ptr, size );   Ôÿÿÿÿ  ˜     Ôÿÿÿÿ  ˜   0           K     Â     Â   !  ‡ÿÿÿÿ  ‡ÿÿÿÿ     3<È       statement executed        return (void *) malloc( size );   Âÿÿÿÿ  ‡     Âÿÿÿÿ  ‡   !           L     “     “     Yÿÿÿÿ  Yÿÿÿÿ     3:       statement executed        exit( 2 );   “ÿÿÿÿ  Y     “ÿÿÿÿ  Y              M     N     N     ÿÿÿÿ  ÿÿÿÿ     37(       statement executed        return b;   Nÿÿÿÿ       Nÿÿÿÿ                N     G     G   5  ÿÿÿÿ  ÿÿÿÿ     34        statement executed        yy_fatal_error( "bad buffer in yy_scan_bytes()" );   Gÿÿÿÿ       Gÿÿÿÿ     5           O     A     A     
ÿÿÿÿ  
ÿÿÿÿ     3.0       statement executed        buf[i] = bytes[i];   Aÿÿÿÿ  
     Aÿÿÿÿ  
              P     >     >   @  ÿÿÿÿ  ÿÿÿÿ     3*Ø       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );   >ÿÿÿÿ       >ÿÿÿÿ     @           Q     '     '   #  òÿÿÿÿ  òÿÿÿÿ     3 P       statement executed        return yy_scan_bytes( str, len );   'ÿÿÿÿ  ò     'ÿÿÿÿ  ò   #           R     %     %     ğÿÿÿÿ  ğÿÿÿÿ     30       statement executed        ;   %ÿÿÿÿ  ğ     %ÿÿÿÿ  ğ              S               ãÿÿÿÿ  ãÿÿÿÿ     3˜       statement executed        return b;   ÿÿÿÿ  ã     ÿÿÿÿ  ã              T             A  Õÿÿÿÿ  Õÿÿÿÿ     3(       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );   ÿÿÿÿ  Õ     ÿÿÿÿ  Õ   A           U               Ñÿÿÿÿ  Ñÿÿÿÿ     3Ğ       statement executed        return 0;   ÿÿÿÿ  Ñ     ÿÿÿÿ  Ñ              V     ò     ò     Àÿÿÿÿ  Àÿÿÿÿ     2ú°       statement executed        }   òÿÿÿÿ  À     òÿÿÿÿ  À              W     ñ     ñ     ¿ÿÿÿÿ  ¿ÿÿÿÿ     2øğ       statement executed        yy_load_buffer_state();   ñÿÿÿÿ  ¿     ñÿÿÿÿ  ¿              X     ×     ×     ¦ÿÿÿÿ  ¦ÿÿÿÿ     2í°       statement executed        }   ×ÿÿÿÿ  ¦     ×ÿÿÿÿ  ¦              Y     ¶     ¶     Œÿÿÿÿ  Œÿÿÿÿ     2âà       statement executed        }   ¶ÿÿÿÿ  Œ     ¶ÿÿÿÿ  Œ              Z     ³     ³   )  ‰ÿÿÿÿ  ‰ÿÿÿÿ     2àè       statement executed        yy_flex_free( (void *) b->yy_ch_buf );   ³ÿÿÿÿ  ‰     ³ÿÿÿÿ  ‰   )           [     °     °   +  †ÿÿÿÿ  †ÿÿÿÿ     2Ş˜       statement executed        yy_current_buffer = (YY_BUFFER_STATE) 0;   °ÿÿÿÿ  †     °ÿÿÿÿ  †   +           \     ­     ­   
  ƒÿÿÿÿ  ƒÿÿÿÿ     2Ù        statement executed        return;   ­ÿÿÿÿ  ƒ     ­ÿÿÿÿ  ƒ   
           ]     ¡     ¡     xÿÿÿÿ  xÿÿÿÿ     2ÕÈ       statement executed        return b;   ¡ÿÿÿÿ  x     ¡ÿÿÿÿ  x              ^     ›     ›   C  rÿÿÿÿ  rÿÿÿÿ     2ÒX       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   ›ÿÿÿÿ  r     ›ÿÿÿÿ  r   C           _     ’     ’   C  iÿÿÿÿ  iÿÿÿÿ     2Ë       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   ’ÿÿÿÿ  i     ’ÿÿÿÿ  i   C           `     ƒ     ƒ     [ÿÿÿÿ  [ÿÿÿÿ     2ÃØ       statement executed        }   ƒÿÿÿÿ  [     ƒÿÿÿÿ  [              a     v     v     Oÿÿÿÿ  Oÿÿÿÿ     2¼€       statement executed        }   vÿÿÿÿ  O     vÿÿÿÿ  O              b     k     k     Dÿÿÿÿ  Dÿÿÿÿ     2¸        statement executed        }   kÿÿÿÿ  D     kÿÿÿÿ  D              c     c     c   
  <ÿÿÿÿ  <ÿÿÿÿ     2±h       statement executed        return;   cÿÿÿÿ  <     cÿÿÿÿ  <   
           d     X     X     2ÿÿÿÿ  2ÿÿÿÿ     2­p       statement executed        }   Xÿÿÿÿ  2     Xÿÿÿÿ  2              e     T     T   7  .ÿÿÿÿ  .ÿÿÿÿ     2«       statement executed        yy_current_buffer = yy_create_buffer( yyin, 16384 );   Tÿÿÿÿ  .     Tÿÿÿÿ  .   7           f     H     H     #ÿÿÿÿ  #ÿÿÿÿ     2¦        statement executed        return c;   Hÿÿÿÿ  #     Hÿÿÿÿ  #              g     @     @     ÿÿÿÿ  ÿÿÿÿ     2¡P       statement executed        }   @ÿÿÿÿ       @ÿÿÿÿ                h     5     5     ÿÿÿÿ  ÿÿÿÿ     2Ÿ`       statement executed        break;   5ÿÿÿÿ       5ÿÿÿÿ                i     /     /     ÿÿÿÿ  ÿÿÿÿ     2œ8       statement executed        return input();   /ÿÿÿÿ       /ÿÿÿÿ                j     +     +     	ÿÿÿÿ  	ÿÿÿÿ     2šx       statement executed        yyrestart( yyin );   +ÿÿÿÿ  	     +ÿÿÿÿ  	              k     '     '     ÿÿÿÿ  ÿÿÿÿ     2—       statement executed        return (-1);   'ÿÿÿÿ       'ÿÿÿÿ                l               öÿÿÿÿ  öÿÿÿÿ     2‘Ø       statement executed        *yy_c_buf_p = '\0';   ÿÿÿÿ  ö     ÿÿÿÿ  ö              m               âÿÿÿÿ  âÿÿÿÿ     2‹ø       statement executed        }   ÿÿÿÿ  â     ÿÿÿÿ  â              n     ú     ú     Úÿÿÿÿ  Úÿÿÿÿ     2„8       statement executed        }   úÿÿÿÿ  Ú     úÿÿÿÿ  Ú              o     ù     ù   8  Ùÿÿÿÿ  Ùÿÿÿÿ     2‚x       statement executed        yy_fatal_error( "flex scanner push-back overflow" );   ùÿÿÿÿ  Ù     ùÿÿÿÿ  Ù   8           p     ò     ò     Òÿÿÿÿ  Òÿÿÿÿ     0òÈ       statement executed        *--dest = *--source;   òÿÿÿÿ  Ò     òÿÿÿÿ  Ò              q     Ö     Ö   *  ·ÿÿÿÿ  ·ÿÿÿÿ     0ãø       statement executed        return yy_is_jam ? 0 : yy_current_state;   Öÿÿÿÿ  ·     Öÿÿÿÿ  ·   *           r     Ò     Ò     ³ÿÿÿÿ  ³ÿÿÿÿ     0İ¨       statement executed        }   Òÿÿÿÿ  ³     Òÿÿÿÿ  ³              s     Ñ     Ñ   (  ²ÿÿÿÿ  ²ÿÿÿÿ     0Ûè       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   Ñÿÿÿÿ  ²     Ñÿÿÿÿ  ²   (           t     Ì     Ì     ­ÿÿÿÿ  ­ÿÿÿÿ     0Ô        statement executed        }   Ìÿÿÿÿ  ­     Ìÿÿÿÿ  ­              u     ³     ³     •ÿÿÿÿ  •ÿÿÿÿ     0Ê8       statement executed        return yy_current_state;   ³ÿÿÿÿ  •     ³ÿÿÿÿ  •              v     ±     ±     “ÿÿÿÿ  “ÿÿÿÿ     0Èˆ       statement executed        }   ±ÿÿÿÿ  “     ±ÿÿÿÿ  “              w     ¯     ¯     ‘ÿÿÿÿ  ‘ÿÿÿÿ     0Å`       statement executed        }   ¯ÿÿÿÿ  ‘     ¯ÿÿÿÿ  ‘              x     ®     ®   )  ÿÿÿÿ  ÿÿÿÿ     0Ã        statement executed        yy_c = yy_meta[(unsigned int) yy_c];   ®ÿÿÿÿ       ®ÿÿÿÿ     )           y     ©     ©     ‹ÿÿÿÿ  ‹ÿÿÿÿ     0»¸       statement executed        }   ©ÿÿÿÿ  ‹     ©ÿÿÿÿ  ‹              z     •     •     wÿÿÿÿ  wÿÿÿÿ     0¯P       statement executed        return ret_val;   •ÿÿÿÿ  w     •ÿÿÿÿ  w              {               oÿÿÿÿ  oÿÿÿÿ     0¨`       statement executed        ret_val = 0;   ÿÿÿÿ  o     ÿÿÿÿ  o              |     ‰     ‰     kÿÿÿÿ  kÿÿÿÿ     0¥ˆ       statement executed        }   ‰ÿÿÿÿ  k     ‰ÿÿÿÿ  k              }     ‚     ‚     dÿÿÿÿ  dÿÿÿÿ     0¢        statement executed        }   ‚ÿÿÿÿ  d     ‚ÿÿÿÿ  d              ~     x    x  <  [ÿÿÿÿ  [ÿÿÿÿ     0š       statement executed        yy_fatal_error( "input in flex scanner failed" );   xÿÿÿÿ  [    xÿÿÿÿ  [  <                x  †  x  ‡  [ÿÿÿÿ  [ÿÿÿÿ     0’ğ       statement executed        }   xÿÿÿÿ  [  †  xÿÿÿÿ  [  ‡           €     x  D  x  u  [ÿÿÿÿ  [ÿÿÿÿ     0Ğ       statement executed        yy_fatal_error( "input in flex scanner failed" );   xÿÿÿÿ  [  D  xÿÿÿÿ  [  u                x   à  x     [ÿÿÿÿ  [ÿÿÿÿ     0ˆà       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c;   xÿÿÿÿ  [   à  xÿÿÿÿ  [              ‚     x     x   Î  [ÿÿÿÿ  [ÿÿÿÿ     0†       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c;   xÿÿÿÿ  [     xÿÿÿÿ  [   Î           ƒ     u     u     Xÿÿÿÿ  Xÿÿÿÿ     0x¨       statement executed        num_to_read = 8192;   uÿÿÿÿ  X     uÿÿÿÿ  X              „     r     r     Uÿÿÿÿ  Uÿÿÿÿ     0vh       statement executed        }   rÿÿÿÿ  U     rÿÿÿÿ  U              …     j     j   E  Oÿÿÿÿ  Oÿÿÿÿ     0nè       statement executed        yy_fatal_error( "fatal error - scanner input buffer overflow" );   jÿÿÿÿ  O     jÿÿÿÿ  O   E           †     g     g     Lÿÿÿÿ  Lÿÿÿÿ     0kØ       statement executed        b->yy_ch_buf = 0;   gÿÿÿÿ  L     gÿÿÿÿ  L              ‡     d     d     Iÿÿÿÿ  Iÿÿÿÿ     0i¸       statement executed        }   dÿÿÿÿ  I     dÿÿÿÿ  I              ˆ     ^     ^     Cÿÿÿÿ  Cÿÿÿÿ     0ep       statement executed        b->yy_buf_size *= 2;   ^ÿÿÿÿ  C     ^ÿÿÿÿ  C              ‰     \     \   +  Aÿÿÿÿ  Aÿÿÿÿ     0c8       statement executed        b->yy_buf_size += b->yy_buf_size / 8;   \ÿÿÿÿ  A     \ÿÿÿÿ  A   +           Š     C     C     (ÿÿÿÿ  (ÿÿÿÿ     0Sh       statement executed        yy_n_chars = 0;   Cÿÿÿÿ  (     Cÿÿÿÿ  (              ‹     =     =     "ÿÿÿÿ  "ÿÿÿÿ     0Oˆ       statement executed        *(dest++) = *(source++);   =ÿÿÿÿ  "     =ÿÿÿÿ  "              Œ     3     3     ÿÿÿÿ  ÿÿÿÿ     0H°       statement executed        return 2;   3ÿÿÿÿ       3ÿÿÿÿ                     +     +     ÿÿÿÿ  ÿÿÿÿ     0GØ       statement executed        return 1;   +ÿÿÿÿ       +ÿÿÿÿ                     !     !   O  ÿÿÿÿ  ÿÿÿÿ     0A        statement executed        yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );   !ÿÿÿÿ       !ÿÿÿÿ     O                          ôÿÿÿÿ  ôÿÿÿÿ     0:@       statement executed        }   ÿÿÿÿ  ô     ÿÿÿÿ  ô                             óÿÿÿÿ  óÿÿÿÿ     09        statement executed        }   ÿÿÿÿ  ó     ÿÿÿÿ  ó              ‘             	  íÿÿÿÿ  íÿÿÿÿ     07(       statement executed        break;   ÿÿÿÿ  í     ÿÿÿÿ  í   	           ’               ìÿÿÿÿ  ìÿÿÿÿ     05h       statement executed        }   ÿÿÿÿ  ì     ÿÿÿÿ  ì              “               ëÿÿÿÿ  ëÿÿÿÿ     04       statement executed        goto yy_find_action;   ÿÿÿÿ  ë     ÿÿÿÿ  ë              ”     ú     ú     áÿÿÿÿ  áÿÿÿÿ     0-€       statement executed        goto yy_match;   úÿÿÿÿ  á     úÿÿÿÿ  á              •     ï     ï     Öÿÿÿÿ  Öÿÿÿÿ     0%        statement executed        break;   ïÿÿÿÿ  Ö     ïÿÿÿÿ  Ö              –     î     î     Õÿÿÿÿ  Õÿÿÿÿ     0#p       statement executed        }   îÿÿÿÿ  Õ     îÿÿÿÿ  Õ              —     í     í     Ôÿÿÿÿ  Ôÿÿÿÿ     0!°       statement executed        yyrestart( yyin );   íÿÿÿÿ  Ô     íÿÿÿÿ  Ô              ˜     ç     ç     Îÿÿÿÿ  Îÿÿÿÿ     0`       statement executed        goto do_action;   çÿÿÿÿ  Î     çÿÿÿÿ  Î              ™     Ï     Ï     ¶ÿÿÿÿ  ¶ÿÿÿÿ     0Ø       statement executed        goto yy_find_action;   Ïÿÿÿÿ  ¶     Ïÿÿÿÿ  ¶              š     É     É     °ÿÿÿÿ  °ÿÿÿÿ     0        statement executed        goto yy_match;   Éÿÿÿÿ  °     Éÿÿÿÿ  °              ›     ¦     ¦     ÿÿÿÿ  ÿÿÿÿ     0€       statement executed        }   ¦ÿÿÿÿ       ¦ÿÿÿÿ                œ               uÿÿÿÿ  uÿÿÿÿ     /ö        statement executed        return 0;   ÿÿÿÿ  u     ÿÿÿÿ  u                   Œ     Œ     sÿÿÿÿ  sÿÿÿÿ     /õ(       statement executed        break;   Œÿÿÿÿ  s     Œÿÿÿÿ  s                   ˆ     ˆ     oÿÿÿÿ  oÿÿÿÿ     /ôP       statement executed        break;   ˆÿÿÿÿ  o     ˆÿÿÿÿ  o              Ÿ     „     „     kÿÿÿÿ  kÿÿÿÿ     /óx       statement executed        break;   „ÿÿÿÿ  k     „ÿÿÿÿ  k                    €     €     gÿÿÿÿ  gÿÿÿÿ     /ò        statement executed        break;   €ÿÿÿÿ  g     €ÿÿÿÿ  g              ¡     |     |     cÿÿÿÿ  cÿÿÿÿ     /ğ¨       statement executed        break;   |ÿÿÿÿ  c     |ÿÿÿÿ  c              ¢     w     w     ^ÿÿÿÿ  ^ÿÿÿÿ     /î¸       statement executed        goto yy_find_action;   wÿÿÿÿ  ^     wÿÿÿÿ  ^              £     h     h     Oÿÿÿÿ  Oÿÿÿÿ     /áH       statement executed        }   hÿÿÿÿ  O     hÿÿÿÿ  O              ¤     ^     ^     Eÿÿÿÿ  Eÿÿÿÿ     /×È       statement executed        }   ^ÿÿÿÿ  E     ^ÿÿÿÿ  E              ¥     [     [     Bÿÿÿÿ  Bÿÿÿÿ     /Ô`       statement executed        }   [ÿÿÿÿ  B     [ÿÿÿÿ  B              ¦     Z     Z   *  Aÿÿÿÿ  Aÿÿÿÿ     /Ò        statement executed        yy_c = yy_meta[(unsigned int) yy_c];   Zÿÿÿÿ  A     Zÿÿÿÿ  A   *           §     U     U     <ÿÿÿÿ  <ÿÿÿÿ     /Ê¸       statement executed        }   Uÿÿÿÿ  <     Uÿÿÿÿ  <              ¨     ’     ’   
  Œÿÿÿÿ  Œÿÿÿÿ     /¦       statement executed        return 0;   ’ÿÿÿÿ  Œ     ’ÿÿÿÿ  Œ   
           ©     1     1     ÿÿÿÿ  ÿÿÿÿ     /®(       statement executed        yy_start = 1;   1ÿÿÿÿ       1ÿÿÿÿ                ª     4     4     ÿÿÿÿ  ÿÿÿÿ     /³        statement executed        yyin = (&__iob_func()[0]);   4ÿÿÿÿ       4ÿÿÿÿ                «     7     7     ÿÿÿÿ  ÿÿÿÿ     /·Ø       statement executed        yyout = (&__iob_func()[1]);   7ÿÿÿÿ       7ÿÿÿÿ                ¬     :     ;   %  !ÿÿÿÿ  "ÿÿÿÿ     /¼8       statement executed        yy_current_buffer =
				yy_create_buffer( yyin, 16384 );   :ÿÿÿÿ  !     ;ÿÿÿÿ  "   %           ­     >     >     %ÿÿÿÿ  %ÿÿÿÿ     /¾H       statement executed        }   >ÿÿÿÿ  %     >ÿÿÿÿ  %           FindProtoCol int FindProtoCol(char* file)        “     ‰ÿÿÿÿ  ÿÿÿÿyylex int yylex ()   !          ÿÿÿÿ  ôÿÿÿÿyy_get_next_buffer static int yy_get_next_buffer()        –      ÿÿÿÿ  xÿÿÿÿyy_get_previous_state static yy_state_type yy_get_previous_state()   œ     ´     ~ÿÿÿÿ  –ÿÿÿÿyy_try_NUL_trans static yy_state_type yy_try_NUL_trans( yy_current_state )   Ã     ×     ¤ÿÿÿÿ  ¸ÿÿÿÿyyunput static void yyunput( c, yy_bp )   â          Âÿÿÿÿ  âÿÿÿÿinput static int input()        I     éÿÿÿÿ  $ÿÿÿÿyyrestart void yyrestart( input_file )   R     X     ,ÿÿÿÿ  2ÿÿÿÿyy_switch_to_buffer void yy_switch_to_buffer( new_buffer )   a     v     :ÿÿÿÿ  Oÿÿÿÿyy_load_buffer_state void yy_load_buffer_state()   ~     ƒ     Vÿÿÿÿ  [ÿÿÿÿyy_create_buffer YY_BUFFER_STATE yy_create_buffer( file, size )        ¢     dÿÿÿÿ  yÿÿÿÿyy_delete_buffer void yy_delete_buffer( b )   «     ¶     ÿÿÿÿ  Œÿÿÿÿyy_init_buffer void yy_init_buffer( b, file )   È     ×     ›ÿÿÿÿ  ¦ÿÿÿÿyy_flush_buffer void yy_flush_buffer( b )   á     ò     ¯ÿÿÿÿ  Àÿÿÿÿyy_scan_buffer YY_BUFFER_STATE yy_scan_buffer( base, size )   ı          Êÿÿÿÿ  äÿÿÿÿyy_scan_string YY_BUFFER_STATE yy_scan_string( str )   "     (     íÿÿÿÿ  óÿÿÿÿyy_scan_bytes YY_BUFFER_STATE yy_scan_bytes( bytes, len )   4     O     ıÿÿÿÿ  ÿÿÿÿyy_fatal_error static void yy_fatal_error( msg )   ‘     ”     Wÿÿÿÿ  Zÿÿÿÿyy_flex_alloc static void *yy_flex_alloc( size )   Á     Ã     †ÿÿÿÿ  ˆÿÿÿÿyy_flex_realloc static void *yy_flex_realloc( ptr, size )   Ì     Õ     ÿÿÿÿ  ™ÿÿÿÿyy_flex_free static void yy_flex_free( ptr )   İ     ß      ÿÿÿÿ  ¢ÿÿÿÿyywrap int yywrap()   ê     í     ¬ÿÿÿÿ  ¯ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 5
#define YY_END_OF_BUFFER 6
static yyconst short int yy_accept[55] =
    {   0,
        0,    0,    6,    3,    4,    3,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    1,    0,    0,    0,    0,    0,
        0,    0,    2,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    5,    1,
        6,    1,    1,    1,    1,    1,    7,    1,    1,    1,
        1,    1,    1,    1,    9,   10,   11,   12,   13,   14,
        1,    1,    1,   15,    1,   16,    1,   17,   18,   19,
        1,   20,   21,   22,   23,    1,    1,    1,   24,    1,
        1,    1,    1,    1,    8,    1,    9,   10,   11,   12,

       13,   14,    1,    1,    1,   15,    1,   16,    1,   17,
       18,   19,    1,   20,   21,   22,   23,    1,    1,    1,
       24,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[25] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1
    } ;

static yyconst short int yy_base[56] =
    {   0,
        0,    1,   65,   66,   66,   55,   55,    3,    5,   49,
        2,   47,   37,   39,   50,   36,   38,   43,   32,   31,
       39,   27,   32,   35,   29,   36,   38,   32,   26,   11,
       39,   26,   14,   19,   16,   16,   28,   19,   28,   23,
       18,   30,   29,   20,   66,   22,   17,   26,   23,   23,
       21,   23,   66,   66,    0
    } ;

static yyconst short int yy_def[56] =
    {   0,
       55,   55,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,    0,   54
    } ;

static yyconst short int yy_nxt[91] =
    {   0,
        4,   54,    5,    5,    9,    9,    9,    9,   11,    6,
        6,   13,    9,    9,   10,   35,   35,   35,   35,   37,
       14,   46,   46,   46,   46,   47,   53,   52,   51,   50,
       49,   48,   45,   44,   43,   42,   41,   40,   39,   38,
       36,   34,   33,   32,   31,   30,   29,   28,   27,   26,
       25,   24,   23,   22,   21,   20,   19,   18,   17,   16,
       15,   12,    8,    7,   54,    3,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54
    } ;

static yyconst short int yy_chk[91] =
    {   0,
       55,    0,    1,    2,    8,    8,    9,    9,    9,    1,
        2,   11,   30,   30,    8,   33,   33,   35,   35,   35,
       11,   44,   44,   46,   46,   46,   52,   51,   50,   49,
       48,   47,   43,   42,   41,   40,   39,   38,   37,   36,
       34,   32,   31,   29,   28,   27,   26,   25,   24,   23,
       22,   21,   20,   19,   18,   17,   16,   15,   14,   13,
       12,   10,    7,    6,    3,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0

#include <stdio.h>
#include "Definitions.h"

int nBus = BUS_CAN;
int nProtocal = NONE;
int FindProtoCol(char* file)
{
yyin = fopen(file, "r");
yylex();
return 0;
}

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 55 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 66 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
nBus = BUS_CAN;
	YY_BREAK
case 2:
YY_RULE_SETUP
nProtocal = PROTOCAL_J1939;
	YY_BREAK
case 3:
YY_RULE_SETUP
;/* ignore Anything else */;
	YY_BREAK
case 4:
YY_RULE_SETUP
;/* ignore Anything else */;
	YY_BREAK
case 5:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a singled characater, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 55 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 55 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 54);

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yytext_ptr = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext_ptr + YY_MORE_ADJ;
						return EOF;
						}

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
					break;

				case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
					YY_FATAL_ERROR(
					"unexpected last match in yyinput()" );
#else
					YY_FATAL_ERROR(
					"unexpected last match in input()" );
#endif
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *str )
#else
YY_BUFFER_STATE yy_scan_string( str )
yyconst char *str;
#endif
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif

int yywrap()
{
fclose(yyin);
return 1;
}


























using namespace std;






CMessage::CMessage()
{
    m_acName = "";
    m_txNode = "";
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    m_cFrameFormat = MSG_FF_STANDARD;
    m_ucLength = 8;
    m_ucNumOfSignals = 1;
    m_uiMsgID = 0;
    m_listSignals.clear();
}






CMessage::~CMessage()
{
    m_listSignals.clear();
}








CMessage& CMessage::operator=(CMessage& message)
{
    m_acName = message.m_acName;
    m_txNode = message.m_txNode;
    m_cDataFormat = message.m_cDataFormat;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_ucNumOfSignals = message.m_ucNumOfSignals;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals = message.m_listSignals;
    return (*this);
}









int CMessage::Format(char* pcLine)
{
    char* pcToken, *pcTok;
    
    pcToken = strtok_s(pcLine, " :", &pcTok);
    m_uiMsgID = strtoul(pcToken, 0, 0);
	
	
	
    
    pcToken = strtok_s(0, " :", &pcTok);
    m_acName = pcToken;
    
    pcToken = strtok_s(0, " :", &pcTok);
    m_ucLength = (unsigned char)strtoul(pcToken, 0, 10);
    CConverter::ucMsg_DLC = m_ucLength;
    
    pcToken = strtok_s(0, " :", &pcTok);

    if(strcmp(pcToken, "Vector__XXX"))
    {
        m_txNode = pcToken;
    }
    else
    {
        m_txNode = "";
    }

    
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    
    m_ucNumOfSignals = 0;
    return 1;
}











bool CMessage::writeMessageToFile(fstream& fileOutput, list<CMessage> &m_listMessages, bool writeErr, int protocol)
{
    bool bResult = true;
    
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        fileOutput << "[""START_MSG""]" << " " << msg->m_acName.c_str();
		
		
		unsigned int unMsgId = msg->m_uiMsgID;
		if(protocol == 1)
		{
			unsigned int unPGNId = msg->m_uiMsgID;
			unPGNId = msg->m_uiMsgID & 0x00FFFF00;

			
			unPGNId = unPGNId >> 8;

			
			unsigned int unPDU = unPGNId & 0xFF00;
			unPDU = unPDU >> 8;
			
			if ( unPDU <=239 )
			{				
				unMsgId = unPGNId & 0xFF00;
			}
			else
			{
				
				unMsgId = unPGNId;
			}
		}
		
        fileOutput << "," << dec << unMsgId;
        fileOutput << "," << dec << msg->m_ucLength;
        fileOutput << "," << dec << msg->m_ucNumOfSignals;
        fileOutput << "," << msg->m_cDataFormat;
        fileOutput << "," << msg->m_cFrameFormat;
        fileOutput << "," << msg->m_txNode.c_str() << endl;
        CSignal sig;
        
        bResult &= sig.WriteSignaltofile(fileOutput,
                                         msg->m_listSignals,
                                         msg->m_ucLength,
                                         msg->m_cDataFormat,
                                         writeErr);
        fileOutput << "[""END_MSG""]" << endl;
        fileOutput << endl;
    }

    return bResult;
}
          Š   %   Š   >   ˆÿÿÿÿ   ˆÿÿÿÿ    "¸      expression was false       msg!=m_listMessages.end()    Šÿÿÿÿ   ˆ   %   Šÿÿÿÿ   ˆ   >                í‰@                     ÿÿÿÿ   ÿÿÿÿ     ê%°      expression was false       protocol == 1    ÿÿÿÿ         ÿÿÿÿ                     +[¨         ¸      ¸      ¶ÿÿÿÿ   ¶ÿÿÿÿ    "‘Ø       statement executed        return bResult;    ¸ÿÿÿÿ   ¶      ¸ÿÿÿÿ   ¶                    ¶      ¶      ´ÿÿÿÿ   ´ÿÿÿÿ     á˜       statement executed        }    ¶ÿÿÿÿ   ´      ¶ÿÿÿÿ   ´                    ¤      ¤      ¢ÿÿÿÿ   ¢ÿÿÿÿ    5Uà       statement executed        }    ¤ÿÿÿÿ   ¢      ¤ÿÿÿÿ   ¢                    Ÿ      Ÿ      ÿÿÿÿ   ÿÿÿÿ     ÷ö       statement executed        }    Ÿÿÿÿÿ         Ÿÿÿÿÿ                       w      w      uÿÿÿÿ   uÿÿÿÿ     ôSP       statement executed        return 1;    wÿÿÿÿ   u      wÿÿÿÿ   u                    q      q      oÿÿÿÿ   oÿÿÿÿ     ôQ       statement executed        }    qÿÿÿÿ   o      qÿÿÿÿ   o                    m      m      kÿÿÿÿ   kÿÿÿÿ    +Ê(       statement executed        }    mÿÿÿÿ   k      mÿÿÿÿ   k              	      L      L      Jÿÿÿÿ   Jÿÿÿÿ     ê#¨       statement executed        return (*this);    Lÿÿÿÿ   J      Lÿÿÿÿ   J              
      9      9      7ÿÿÿÿ   7ÿÿÿÿ     ø2X       statement executed        }    9ÿÿÿÿ   7      9ÿÿÿÿ   7                    /      /      -ÿÿÿÿ   -ÿÿÿÿ     øJÈ       statement executed        }    /ÿÿÿÿ   -      /ÿÿÿÿ   -           CMessage::CMessage CMessage::CMessage()    &      /      $ÿÿÿÿ   -ÿÿÿÿCMessage::~CMessage CMessage::~CMessage()    7      9      5ÿÿÿÿ   7ÿÿÿÿCMessage::operator= CMessage& CMessage::operator=(CMessage& message)    C      M      Aÿÿÿÿ   KÿÿÿÿCMessage::Format int CMessage::Format(char* pcLine)    X      x      Vÿÿÿÿ   vÿÿÿÿCMessage::writeMessageToFile bool CMessage::writeMessageToFile(fstream& fileOutput, list<CMessage> &m_listMessages, bool writeErr, int protocol)    …      ¹      ƒÿÿÿÿ   ·ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Message.cpp
 * \brief     Implementation of message class
 * \authors   Mahesh B S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the message class.
 */

/* Project includes */
#include "Converter.h"
#include "Message.h"
#include "Tag.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CMessage
 */
CMessage::CMessage()
{
    m_acName = "";
    m_txNode = "";
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    m_cFrameFormat = MSG_FF_STANDARD;
    m_ucLength = 8;
    m_ucNumOfSignals = 1;
    m_uiMsgID = 0;
    m_listSignals.clear();
}

/**
 * \brief Destructor
 *
 * Destructor of CMessage
 */
CMessage::~CMessage()
{
    m_listSignals.clear();
}

/**
 * \brief     overloaded operator =
 * \param[in] message Message to copy content from
 * \return    Reference to local object with new content
 *
 * Copy the elements of the given message to this
 */
CMessage& CMessage::operator=(CMessage& message)
{
    m_acName = message.m_acName;
    m_txNode = message.m_txNode;
    m_cDataFormat = message.m_cDataFormat;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_ucNumOfSignals = message.m_ucNumOfSignals;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals = message.m_listSignals;
    return (*this);
}

/**
 * \brief     Extracts the message data
 * \param[in] pcLine Message data
 * \return    Status code
 *
 * Extracts the message data from the given Line and populates
 * the message structure.
 */
int CMessage::Format(char* pcLine)
{
    char* pcToken, *pcTok;
    // get the MSG ID
    pcToken = strtok_s(pcLine, " :", &pcTok);
    m_uiMsgID = strtoul(pcToken, NULL, 0);
	
	//m_uiMsgID = m_uiMsgID & 0x00FFFF00;
	//m_uiMsgID = m_uiMsgID >> 8;
    // get the message name
    pcToken = strtok_s(NULL, " :", &pcTok);
    m_acName = pcToken;
    // set the message length
    pcToken = strtok_s(NULL, " :", &pcTok);
    m_ucLength = (unsigned char)strtoul(pcToken, NULL, 10);
    CConverter::ucMsg_DLC = m_ucLength;
    //get the Tx'ing Node Name
    pcToken = strtok_s(NULL, " :", &pcTok);

    if(strcmp(pcToken, "Vector__XXX"))
    {
        m_txNode = pcToken;
    }
    else
    {
        m_txNode = "";
    }

    // set the Data format
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    // set the number of signals
    m_ucNumOfSignals = 0;
    return 1;
}

/**
 * \brief      writes the Messages in the given list to the output file
 * \param[in]  fileOutput Pointer to the Output file
 * \param[in]  m_listMessages List of Message
 * \param[in]  writeErr If true write error signals also else write only correct signals
 *             associated with the message
 * \return     Status code
 *
 * Writes the Messages in the given list to the output file.
 */
bool CMessage::writeMessageToFile(fstream& fileOutput, list<CMessage> &m_listMessages, bool writeErr, int protocol)
{
    bool bResult = true;
    //Write all the message
    list<CMessage>::iterator msg;

    for(msg=m_listMessages.begin(); msg!=m_listMessages.end(); ++msg)
    {
        fileOutput << T_START_MSG << " " << msg->m_acName.c_str();
		//Currently Onlu PGN ID is used insttead of Extended ID.
		//In Database version 1.4 Extended id will be used instead of PGNID.
		unsigned int unMsgId = msg->m_uiMsgID;
		if(protocol == PROTOCAL_J1939)
		{
			unsigned int unPGNId = msg->m_uiMsgID;
			unPGNId = msg->m_uiMsgID & 0x00FFFF00;

			//Get PGN ID
			unPGNId = unPGNId >> 8;

			//Get PDU ID
			unsigned int unPDU = unPGNId & 0xFF00;
			unPDU = unPDU >> 8;
			//If it is PDU1 - Data message
			if ( unPDU <=239 )
			{				
				unMsgId = unPGNId & 0xFF00;
			}
			else
			{
				//Broadcast Msg
				unMsgId = unPGNId;
			}
		}
		
        fileOutput << "," << dec << unMsgId;
        fileOutput << "," << dec << msg->m_ucLength;
        fileOutput << "," << dec << msg->m_ucNumOfSignals;
        fileOutput << "," << msg->m_cDataFormat;
        fileOutput << "," << msg->m_cFrameFormat;
        fileOutput << "," << msg->m_txNode.c_str() << endl;
        CSignal sig;
        //write all related signals to the messages
        bResult &= sig.WriteSignaltofile(fileOutput,
                                         msg->m_listSignals,
                                         msg->m_ucLength,
                                         msg->m_cDataFormat,
                                         writeErr);
        fileOutput << T_END_MSG << endl;
        fileOutput << endl;
    }

    return bResult;
}




























using namespace std;






CParameter::CParameter()
{
    m_MaxVal.iValue = -1;
    m_MaxVal.uiValue = 0;
    m_MaxVal.fValue = -1;
    m_MaxVal.dValue = -1;
    m_MaxVal.cValue = "";
    m_MaxVal.i64Value = -1;
    m_MaxVal.ui64Value = 0;
    m_MinVal.iValue = -1;
    m_MinVal.uiValue = 0;
    m_MinVal.fValue = -1;
    m_MinVal.dValue = -1;
    m_MinVal.cValue = "";
    m_MinVal.i64Value = -1;
    m_MinVal.ui64Value = 0;
    m_InitVal.iValue = -1;
    m_InitVal.uiValue = 0;
    m_InitVal.fValue = -1;
    m_InitVal.dValue = -1;
    m_InitVal.cValue = "";
    m_InitVal.i64Value = -1;
    m_InitVal.ui64Value = 0;
    m_ValRange = "";
    m_ParamType = "";
    m_ParamName = "";
    m_RangeError = false;
    m_defError = false;
}






CParameter::~CParameter()
{
    
}








CParameter& CParameter::operator=( CParameter& param)
{
    
    m_listParamValues[0].clear();
    
    m_ObjectId = param.m_ObjectId;
    m_ParamName = param.m_ParamName;
    m_ValRange = param.m_ValRange;
    m_ParamType = param.m_ParamType;
    m_InitVal = param.m_InitVal;
    m_MaxVal = param.m_MaxVal;
    m_MinVal = param.m_MinVal;
    m_RangeError = param.m_RangeError;
    m_defError = param.m_defError;

    for(int i=0; i<6; i++)
    {
        m_listParamValues[i] = param.m_listParamValues[i];
    }

    return (*this);
}










bool WriteParametersToFile(fstream& fileOutput, list<CParameter> &m_listParameter)
{
    bool pResult=true;
    
    
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameter.begin(); rParam!=m_listParameter.end(); ++rParam)
    {
        
        if(rParam->m_RangeError)
        {
            pResult=false;
        }

        
        fileOutput << "\"" << rParam->m_ParamName.c_str() << "\"";
        fileOutput << "," << rParam->m_ParamType.c_str();

        
        if(rParam->m_ParamType == "INT")
        {
            
            if(rParam->m_InitVal.iValue == -1)
            {
                rParam->m_defError = rParam->m_defError | true;
                pResult = pResult & false;
                rParam->m_InitVal.iValue = rParam->m_MinVal.iValue;
                fileOutput << "," << dec << rParam->m_InitVal.iValue;
                fileOutput << "," << dec << rParam->m_MinVal.iValue;
                fileOutput << "," << dec << rParam->m_MaxVal.iValue;
            }
            
            else
            {
                fileOutput << "," << dec << rParam->m_InitVal.iValue;
                fileOutput << "," << dec << rParam->m_MinVal.iValue;
                fileOutput << "," << dec << rParam->m_MaxVal.iValue;
            }
        }
        
        else if(rParam->m_ParamType == "HEX")
        {
            
            if(rParam->m_InitVal.uiValue == -1)
            {
                rParam->m_defError = rParam->m_defError | true;
                pResult = pResult & false;
                rParam->m_InitVal.uiValue = rParam->m_MinVal.uiValue;
                fileOutput << "," << dec << rParam->m_InitVal.uiValue;
                fileOutput << "," << dec << rParam->m_MinVal.uiValue;
                fileOutput << "," << dec << rParam->m_MaxVal.uiValue;
            }
            
            else
            {
                fileOutput << "," << dec << rParam->m_InitVal.uiValue;
                fileOutput << "," << dec << rParam->m_MinVal.uiValue;
                fileOutput << "," << dec << rParam->m_MaxVal.uiValue;
            }
        }
        
        else if(rParam->m_ParamType == "FLOAT")
        {
            
            if(rParam->m_InitVal.fValue == -1)
            {
                rParam->m_defError = rParam->m_defError | true;
                pResult = pResult & false;
                rParam->m_InitVal.fValue = rParam->m_MinVal.fValue;
                fileOutput << "," << rParam->m_InitVal.fValue;
                fileOutput << "," << rParam->m_MinVal.fValue;
                fileOutput << "," << rParam->m_MaxVal.fValue;
            }
            
            else
            {
                fileOutput << "," << rParam->m_InitVal.fValue;
                fileOutput << "," << rParam->m_MinVal.fValue;
                fileOutput << "," << rParam->m_MaxVal.fValue;
            }
        }
        
        else if(rParam->m_ParamType == "ENUM")
        {
            
            if(rParam->m_InitVal.cValue.length() == 0)
            {
                fileOutput << ",\"\"";
                fileOutput << "," << rParam->m_ValRange.c_str();
            }
            
            else
            {
                fileOutput << ",\"" << rParam->m_InitVal.cValue << "\"";
                fileOutput << "," << rParam->m_ValRange.c_str();
            }
        }
        
        else
        {
            fileOutput << "," << rParam->m_InitVal.cValue;
        }

        
        fileOutput << endl;
    }

    return pResult;
}









int CParameter::FormatParamValue(char* pcLine)
{
    char* pcToken, *pcTok;
    CParameterValues pVal;

    
    while(*pcLine && *pcLine==' ')
    {
        *pcLine++;
    }

    pcToken = strtok_s(pcLine, " ", &pcTok);

    
    if(strcmp(pcToken, "BU_")==0)
    {
        pVal.GetNodeParams(m_ParamType, (pcLine+strlen(pcToken)+1));
        
        m_listParamValues[1].push_back(pVal);
    }
    
    else if(strcmp(pcToken, "BO_")==0)
    {
        pVal.GetMesgParams(m_ParamType, (pcLine+strlen(pcToken)+1));
        
        m_listParamValues[2].push_back(pVal);
    }
    
    else if(strcmp(pcToken, "SG_")==0)
    {
        pVal.GetSignalParams(m_ParamType, (pcLine+strlen(pcToken)+1));
        
        m_listParamValues[3].push_back(pVal);
    }
    
    else
    {
        pVal.GetNetParams(m_ParamType,pcToken);
        
        m_listParamValues[0].push_back(pVal);
    }

    return 1;
}








int CParameter::Format(char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[250];
    char* pcTemp = acTemp;
    int success = 1;
    
    pcToken = strtok_s(pcLine, "\"", &pcTok);

    while(*pcToken == ' ')
    {
        *pcToken++;
    }

    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_ObjectId = acTemp; 
    pcTemp = acTemp; 
    
    pcToken = strtok_s(0, "\"", &pcTok);

    while(*pcToken && *pcToken != '"')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_ParamName = acTemp; 
    pcTemp = acTemp; 
    
    pcToken = strtok_s(0, " ", &pcTok);

    while(*pcToken == ' ')
    {
        *pcToken++;
    }

    while(*pcToken && *pcToken != ' ' && *pcToken != ';')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_ParamType = acTemp; 
    pcTemp = acTemp; 

    if(m_ParamType != "STRING")
    {
        pcToken = strtok_s(0, ";", &pcTok);

        if(m_ParamType == "ENUM")
        {
            while(*pcToken && *pcToken == ' ')
            {
                *pcToken++;
            }

            m_ValRange = pcToken;
        }
        
        else if(m_ParamType == "FLOAT")
        {
            double temp;
            pcToken = strtok_s(pcToken, " ", &pcTok);
            temp = atof(pcToken);

            if(temp < 1.175494351e-38F) 
            {
                m_MinVal.fValue = 1.175494351e-38F;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MinVal.fValue = float(temp);
            }

            pcToken = strtok_s(0, " ", &pcTok);
            temp=atof(pcToken);

            if((temp>3.402823466e+38F) || (temp<m_MinVal.fValue)) 
            {
                m_MaxVal.fValue = 3.402823466e+38F;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MaxVal.fValue = float(temp);
            }

            pcTemp = acTemp; 
        }
        
        else if(m_ParamType == "INT")
        {
            long long temp;
            pcToken = strtok_s(pcToken, " ", &pcTok);
            temp = _atoi64(pcToken);

            if(temp < (-2147483647 - 1) ) 
            {
                m_MinVal.iValue = (-2147483647 - 1);
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MinVal.iValue = int(temp);
            }

            pcToken = strtok_s(0, " ", &pcTok);
            temp = _atoi64(pcToken);

            if((temp>2147483647) || (temp<m_MinVal.iValue)) 
            {
                m_MaxVal.iValue = 2147483647;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MaxVal.iValue = int(temp);
            }

            pcTemp = acTemp; 
        }
        
        else if(m_ParamType == "HEX")
        {
            pcToken = strtok_s(pcToken, " ", &pcTok);
            m_MinVal.uiValue = strtoul(pcToken, 0, 10);

            if(m_MinVal.uiValue < 0) 
            {
                m_MinVal.uiValue = 0;
                m_RangeError = m_RangeError | true;
            }

            pcToken = strtok_s(0, ";", &pcTok);
            m_MaxVal.uiValue = strtoul(pcToken, 0, 10);

            
            if((m_MaxVal.uiValue == 0) || (m_MaxVal.uiValue < m_MinVal.uiValue))
            {
                m_MaxVal.uiValue = 0xffffffff;
                m_RangeError = m_RangeError | true;
            }

            pcTemp = acTemp;
        }
    }

    return success;
}








int CParameter::ReadDefaultVal(char* pcToken)
{
    char acTemp[250];
    char* pcTemp = acTemp;
    int success=1;
    

    
    if(m_ParamType == "ENUM")
    {
        
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        pcToken++;

        
        while(*pcToken && *pcToken != '"')
        {
            *pcTemp++ = *pcToken++;
        }

        *pcTemp = '\0';
        m_InitVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    
    else if(m_ParamType == "INT")
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_InitVal.iValue = strtoul(pcToken, 0, 10);
        }

        
        if((m_InitVal.iValue<m_MinVal.iValue) || (m_InitVal.iValue>m_MaxVal.iValue))
        {
            m_InitVal.iValue = m_MinVal.iValue;
            m_RangeError = m_RangeError | true;
        }
    }
    
    else if(m_ParamType == "HEX")
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_InitVal.uiValue = strtoul(pcToken, 0, 10);
        }

        
        if((m_InitVal.uiValue<m_MinVal.uiValue) || (m_InitVal.uiValue>m_MaxVal.uiValue))
        {
            m_InitVal.uiValue = m_MinVal.uiValue;
            m_RangeError = m_RangeError | true;
        }
    }
    
    else if(m_ParamType == "FLOAT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.fValue=float(atof(pcToken));
        }

        
        if(m_InitVal.fValue<m_MinVal.fValue || m_InitVal.fValue>m_MaxVal.fValue)
        {
            m_InitVal.fValue=m_MinVal.fValue;
            m_RangeError=m_RangeError | true;
        }
    }
    
    else if(m_ParamType == "STRING")
    {
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        m_InitVal.cValue = pcToken;
    }

    return success;
}
         ”     ”   !  ‘ÿÿÿÿ  ‘ÿÿÿÿ    5V¸      expression was true       (temp>2147483647)   ”ÿÿÿÿ  ‘     ”ÿÿÿÿ  ‘   !   expression was false       (temp>2147483647)   ”ÿÿÿÿ  ‘     ”ÿÿÿÿ  ‘   !               5U        t   +  t   A  qÿÿÿÿ  qÿÿÿÿ    +[      expression was true       (temp<m_MinVal.fValue)   tÿÿÿÿ  q   +  tÿÿÿÿ  q   A   expression was false       (temp<m_MinVal.fValue)   tÿÿÿÿ  q   +  tÿÿÿÿ  q   A               +         t     t   '  qÿÿÿÿ  qÿÿÿÿ    +ø      expression was true       (temp>3.402823466e+38F)   tÿÿÿÿ  q     tÿÿÿÿ  q   '   expression was false       (temp>3.402823466e+38F)   tÿÿÿÿ  q     tÿÿÿÿ  q   '                ÷è¸        Y     Y   .  Vÿÿÿÿ  Vÿÿÿÿ     ôRÀ      expression was true       *pcToken == ' '   Yÿÿÿÿ  V     Yÿÿÿÿ  V   .   expression was false       *pcToken == ' '   Yÿÿÿÿ  V     Yÿÿÿÿ  V   .                ôF°        Y     Y     Vÿÿÿÿ  Vÿÿÿÿ     ôGˆ      expression was true       *pcToken   Yÿÿÿÿ  V     Yÿÿÿÿ  V      expression was false       *pcToken   Yÿÿÿÿ  V     Yÿÿÿÿ  V              
     J   *  J   9  Gÿÿÿÿ  Gÿÿÿÿ    +?p      expression was true       *pcToken != ';'   Jÿÿÿÿ  G   *  Jÿÿÿÿ  G   9   expression was false       *pcToken != ';'   Jÿÿÿÿ  G   *  Jÿÿÿÿ  G   9                ø        J     J   &  Gÿÿÿÿ  Gÿÿÿÿ    +…°      expression was true       *pcToken != ' '   Jÿÿÿÿ  G     Jÿÿÿÿ  G   &   expression was false       *pcToken != ' '   Jÿÿÿÿ  G     Jÿÿÿÿ  G   &               +·Ğ        J     J     Gÿÿÿÿ  Gÿÿÿÿ    +…       expression was true       *pcToken   Jÿÿÿÿ  G     Jÿÿÿÿ  G      expression was false       *pcToken   Jÿÿÿÿ  G     Jÿÿÿÿ  G                   ”   %  ”   ;  ‘ÿÿÿÿ  ‘ÿÿÿÿ    5W       expression was true       (temp<m_MinVal.iValue)   ”ÿÿÿÿ  ‘   %  ”ÿÿÿÿ  ‘   ;   expression was false       (temp<m_MinVal.iValue)   ”ÿÿÿÿ  ‘   %  ”ÿÿÿÿ  ‘   ;               5Uà        :     :   &  7ÿÿÿÿ  7ÿÿÿÿ     ø       expression was true       *pcToken != '"'   :ÿÿÿÿ  7     :ÿÿÿÿ  7   &   expression was false       *pcToken != '"'   :ÿÿÿÿ  7     :ÿÿÿÿ  7   &                øJÈ        :     :     7ÿÿÿÿ  7ÿÿÿÿ     ø-ˆ      expression was true       *pcToken   :ÿÿÿÿ  7     :ÿÿÿÿ  7      expression was false       *pcToken   :ÿÿÿÿ  7     :ÿÿÿÿ  7                   /     /   &  ,ÿÿÿÿ  ,ÿÿÿÿ     ôO¸      expression was true       *pcToken != ' '   /ÿÿÿÿ  ,     /ÿÿÿÿ  ,   &   expression was false       *pcToken != ' '   /ÿÿÿÿ  ,     /ÿÿÿÿ  ,   &                ôL(        /     /     ,ÿÿÿÿ  ,ÿÿÿÿ     ôNH      expression was true       *pcToken   /ÿÿÿÿ  ,     /ÿÿÿÿ  ,      expression was false       *pcToken   /ÿÿÿÿ  ,     /ÿÿÿÿ  ,                    ó      ó   "   ğÿÿÿÿ   ğÿÿÿÿ     ê78      expression was true       *pcLine==' '    óÿÿÿÿ   ğ      óÿÿÿÿ   ğ   "   expression was false       *pcLine==' '    óÿÿÿÿ   ğ      óÿÿÿÿ   ğ   "                ê1¸         ó      ó      ğÿÿÿÿ   ğÿÿÿÿ     ê6      expression was true       *pcLine    óÿÿÿÿ   ğ      óÿÿÿÿ   ğ      expression was false       *pcLine    óÿÿÿÿ   ğ      óÿÿÿÿ   ğ                    }   )   }   F   zÿÿÿÿ   zÿÿÿÿ     êKè      expression was false       rParam!=m_listParameter.end()    }ÿÿÿÿ   z   )   }ÿÿÿÿ   z   F               +gˆ         e      e      bÿÿÿÿ   bÿÿÿÿ     ôaˆ      expression was false       i<6    eÿÿÿÿ   b      eÿÿÿÿ   b                    °     °   '  ­ÿÿÿÿ  ­ÿÿÿÿ     ê&ˆ      expression was true       (m_MaxVal.uiValue == 0)   °ÿÿÿÿ  ­     °ÿÿÿÿ  ­   '   expression was false       (m_MaxVal.uiValue == 0)   °ÿÿÿÿ  ­     °ÿÿÿÿ  ­   '                ê$€   "     °   +  °   P  ­ÿÿÿÿ  ­ÿÿÿÿ     ê'p      expression was true       (m_MaxVal.uiValue < m_MinVal.uiValue)   °ÿÿÿÿ  ­   +  °ÿÿÿÿ  ­   P   expression was false       (m_MaxVal.uiValue < m_MinVal.uiValue)   °ÿÿÿÿ  ­   +  °ÿÿÿÿ  ­   P                ê%°   $     Ï     Ï     Ìÿÿÿÿ  Ìÿÿÿÿ     í¨      expression was true       *pcToken   Ïÿÿÿÿ  Ì     Ïÿÿÿÿ  Ì      expression was false       *pcToken   Ïÿÿÿÿ  Ì     Ïÿÿÿÿ  Ì              &     Ï     Ï   *  Ìÿÿÿÿ  Ìÿÿÿÿ     í‚€      expression was true       *pcToken == ' '   Ïÿÿÿÿ  Ì     Ïÿÿÿÿ  Ì   *   expression was false       *pcToken == ' '   Ïÿÿÿÿ  Ì     Ïÿÿÿÿ  Ì   *                í€Ğ   (     ×     ×     Ôÿÿÿÿ  Ôÿÿÿÿ     í‡€      expression was true       *pcToken   ×ÿÿÿÿ  Ô     ×ÿÿÿÿ  Ô      expression was false       *pcToken   ×ÿÿÿÿ  Ô     ×ÿÿÿÿ  Ô              *     E     E     Bÿÿÿÿ  Bÿÿÿÿ    +·0      expression was false       *pcToken == ' '   Eÿÿÿÿ  B     Eÿÿÿÿ  B                   ø2X   +     ×     ×   *  Ôÿÿÿÿ  Ôÿÿÿÿ     íˆX      expression was true       *pcToken != '"'   ×ÿÿÿÿ  Ô     ×ÿÿÿÿ  Ô   *   expression was false       *pcToken != '"'   ×ÿÿÿÿ  Ô     ×ÿÿÿÿ  Ô   *                í†¨   -     é     é   .  æÿÿÿÿ  æÿÿÿÿ     áp      expression was true       (m_InitVal.iValue<m_MinVal.iValue)   éÿÿÿÿ  æ     éÿÿÿÿ  æ   .   expression was false       (m_InitVal.iValue<m_MinVal.iValue)   éÿÿÿÿ  æ     éÿÿÿÿ  æ   .                á
x   /     *     *     'ÿÿÿÿ  'ÿÿÿÿ     ÷Ò      expression was false       *pcToken == ' '   *ÿÿÿÿ  '     *ÿÿÿÿ  '                   ôIP   0     é   2  é   T  æÿÿÿÿ  æÿÿÿÿ     áX      expression was true       (m_InitVal.iValue>m_MaxVal.iValue)   éÿÿÿÿ  æ   2  éÿÿÿÿ  æ   T   expression was false       (m_InitVal.iValue>m_MaxVal.iValue)   éÿÿÿÿ  æ   2  éÿÿÿÿ  æ   T                á˜   2     ø     ø   0  õÿÿÿÿ  õÿÿÿÿ    "’°      expression was true       (m_InitVal.uiValue<m_MinVal.uiValue)   øÿÿÿÿ  õ     øÿÿÿÿ  õ   0   expression was false       (m_InitVal.uiValue<m_MinVal.uiValue)   øÿÿÿÿ  õ     øÿÿÿÿ  õ   0               "¸   4     ø   4  ø   X  õÿÿÿÿ  õÿÿÿÿ    "“˜      expression was true       (m_InitVal.uiValue>m_MaxVal.uiValue)   øÿÿÿÿ  õ   4  øÿÿÿÿ  õ   X   expression was false       (m_InitVal.uiValue>m_MaxVal.uiValue)   øÿÿÿÿ  õ   4  øÿÿÿÿ  õ   X               "‘Ø   6             $  ÿÿÿÿ  ÿÿÿÿ    +Ò       expression was false       m_ParamType == "STRING"   ÿÿÿÿ       ÿÿÿÿ     $               +ÉP   7             ,  ÿÿÿÿ  ÿÿÿÿ    +ÀÈ      expression was true       m_InitVal.fValue<m_MinVal.fValue   ÿÿÿÿ       ÿÿÿÿ     ,   expression was false       m_InitVal.fValue<m_MinVal.fValue   ÿÿÿÿ       ÿÿÿÿ     ,           9             "  şÿÿÿÿ  şÿÿÿÿ    +¿˜      expression was false       strcmp(pcToken," ")!=0   ÿÿÿÿ  ş     ÿÿÿÿ  ş   "               "œp   :        0     P  ÿÿÿÿ  ÿÿÿÿ    +Á       expression was true       m_InitVal.fValue>m_MaxVal.fValue   ÿÿÿÿ     0  ÿÿÿÿ     P   expression was false       m_InitVal.fValue>m_MaxVal.fValue   ÿÿÿÿ     0  ÿÿÿÿ     P           <     ò     ò   %  ïÿÿÿÿ  ïÿÿÿÿ    "       expression was false       strcmp(pcToken, " ") != 0   òÿÿÿÿ  ï     òÿÿÿÿ  ï   %               "Œ8   =               ÿÿÿÿ  ÿÿÿÿ    +Ë       expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                ?     ã     ã   %  àÿÿÿÿ  àÿÿÿÿ     á	`      expression was false       strcmp(pcToken, " ") != 0   ãÿÿÿÿ  à     ãÿÿÿÿ  à   %                áø   @             *  ÿÿÿÿ  ÿÿÿÿ    +ËØ      expression was true       *pcToken == ' '   ÿÿÿÿ       ÿÿÿÿ     *   expression was false       *pcToken == ' '   ÿÿÿÿ       ÿÿÿÿ     *               +Ê(   B     ¦     ¦   $  £ÿÿÿÿ  £ÿÿÿÿ     ê       expression was false       m_MinVal.uiValue < 0   ¦ÿÿÿÿ  £     ¦ÿÿÿÿ  £   $           C     ¡     ¡   %  ÿÿÿÿ  ÿÿÿÿ    +È      expression was false       m_ParamType == "HEX"   ¡ÿÿÿÿ       ¡ÿÿÿÿ     %               %@   D     S     S     Pÿÿÿÿ  Pÿÿÿÿ    +@      expression was false       m_ParamType != "STRING"   Sÿÿÿÿ  P     Sÿÿÿÿ  P                   ê0¸   E      €      €       }ÿÿÿÿ   }ÿÿÿÿ    +SØ      expression was false       rParam->m_RangeError    €ÿÿÿÿ   }      €ÿÿÿÿ   }               F               ÿÿÿÿ  ÿÿÿÿ    +×€       statement executed        return success;   ÿÿÿÿ       ÿÿÿÿ                G               ÿÿÿÿ  ÿÿÿÿ    +ÑH       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                H        	     
  ÿÿÿÿ  ÿÿÿÿ    +Î        statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           I               	ÿÿÿÿ  	ÿÿÿÿ    +ÈH       statement executed        }   ÿÿÿÿ  	     ÿÿÿÿ  	              J        	     
  ÿÿÿÿ  ÿÿÿÿ    +Æˆ       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           K        	     
  ÿÿÿÿ  ÿÿÿÿ    +¿       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           L     ı     ı     úÿÿÿÿ  úÿÿÿÿ    "šP       statement executed        }   ıÿÿÿÿ  ú     ıÿÿÿÿ  ú              M     ü   	  ü   
  ùÿÿÿÿ  ùÿÿÿÿ    "˜       statement executed        }   üÿÿÿÿ  ù   	  üÿÿÿÿ  ù   
           N     õ   	  õ   
  òÿÿÿÿ  òÿÿÿÿ    "È       statement executed        }   õÿÿÿÿ  ò   	  õÿÿÿÿ  ò   
           O     î     î     ëÿÿÿÿ  ëÿÿÿÿ    "Š       statement executed        }   îÿÿÿÿ  ë     îÿÿÿÿ  ë              P     í   	  í   
  êÿÿÿÿ  êÿÿÿÿ    "ˆX       statement executed        }   íÿÿÿÿ  ê   	  íÿÿÿÿ  ê   
           Q     æ   	  æ   
  ãÿÿÿÿ  ãÿÿÿÿ     áˆ       statement executed        }   æÿÿÿÿ  ã   	  æÿÿÿÿ  ã   
           R     ß     ß     Üÿÿÿÿ  Üÿÿÿÿ     áÀ       statement executed        }   ßÿÿÿÿ  Ü     ßÿÿÿÿ  Ü              S     Ú   	  Ú   
  ×ÿÿÿÿ  ×ÿÿÿÿ     í‹@       statement executed        }   Úÿÿÿÿ  ×   	  Úÿÿÿÿ  ×   
           T     Ò   	  Ò   
  Ïÿÿÿÿ  Ïÿÿÿÿ     í„¨       statement executed        }   Òÿÿÿÿ  Ï   	  Òÿÿÿÿ  Ï   
           U     º     º     ·ÿÿÿÿ  ·ÿÿÿÿ    +(       statement executed        return success;   ºÿÿÿÿ  ·     ºÿÿÿÿ  ·              V     ·   	  ·   
  ´ÿÿÿÿ  ´ÿÿÿÿ    +ğ       statement executed        }   ·ÿÿÿÿ  ´   	  ·ÿÿÿÿ  ´   
           W     ´     ´     ±ÿÿÿÿ  ±ÿÿÿÿ    +Ø       statement executed        }   ´ÿÿÿÿ  ±     ´ÿÿÿÿ  ±              X     ª     ª     §ÿÿÿÿ  §ÿÿÿÿ    %G       statement executed        }   ªÿÿÿÿ  §     ªÿÿÿÿ  §              Y     Ÿ   	  Ÿ   
  œÿÿÿÿ  œÿÿÿÿ     ùÕ¨       statement executed        }   Ÿÿÿÿÿ  œ   	  Ÿÿÿÿÿ  œ   
           Z     œ     œ     ™ÿÿÿÿ  ™ÿÿÿÿ     ùÒ       statement executed        }   œÿÿÿÿ  ™     œÿÿÿÿ  ™              [     ˜     ˜     •ÿÿÿÿ  •ÿÿÿÿ     ùĞP       statement executed        }   ˜ÿÿÿÿ  •     ˜ÿÿÿÿ  •              \               Œÿÿÿÿ  Œÿÿÿÿ     ø5ˆ       statement executed        }   ÿÿÿÿ  Œ     ÿÿÿÿ  Œ              ]     ‹     ‹     ˆÿÿÿÿ  ˆÿÿÿÿ     ø3h       statement executed        }   ‹ÿÿÿÿ  ˆ     ‹ÿÿÿÿ  ˆ              ^        	     
  |ÿÿÿÿ  |ÿÿÿÿ     ô_H       statement executed        }   ÿÿÿÿ  |   	  ÿÿÿÿ  |   
           _     |     |     yÿÿÿÿ  yÿÿÿÿ     ÷ØX       statement executed        }   |ÿÿÿÿ  y     |ÿÿÿÿ  y              `     x     x     uÿÿÿÿ  uÿÿÿÿ    +³0       statement executed        }   xÿÿÿÿ  u     xÿÿÿÿ  u              a     o     o     lÿÿÿÿ  lÿÿÿÿ    5k       statement executed        }   oÿÿÿÿ  l     oÿÿÿÿ  l              b     k     k     hÿÿÿÿ  hÿÿÿÿ    5[¨       statement executed        }   kÿÿÿÿ  h     kÿÿÿÿ  h              c     _   	  _   
  \ÿÿÿÿ  \ÿÿÿÿ     ôn(       statement executed        }   _ÿÿÿÿ  \   	  _ÿÿÿÿ  \   
           d     \     \     Yÿÿÿÿ  Yÿÿÿÿ     ôT`       statement executed        }   \ÿÿÿÿ  Y     \ÿÿÿÿ  Y              e     M     M     Jÿÿÿÿ  Jÿÿÿÿ    +8        statement executed        }   Mÿÿÿÿ  J     Mÿÿÿÿ  J              f     H     H     Eÿÿÿÿ  Eÿÿÿÿ     ø`       statement executed        }   Hÿÿÿÿ  E     Hÿÿÿÿ  E              g     =     =     :ÿÿÿÿ  :ÿÿÿÿ     4P       statement executed        }   =ÿÿÿÿ  :     =ÿÿÿÿ  :              h     2     2     /ÿÿÿÿ  /ÿÿÿÿ    +^È       statement executed        }   2ÿÿÿÿ  /     2ÿÿÿÿ  /              i     -     -     *ÿÿÿÿ  *ÿÿÿÿ     ÷Òğ       statement executed        }   -ÿÿÿÿ  *     -ÿÿÿÿ  *              j               ÿÿÿÿ  ÿÿÿÿ     ô†@       statement executed        return 1;   ÿÿÿÿ       ÿÿÿÿ                k               ÿÿÿÿ  ÿÿÿÿ     øÀ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                l               ÿÿÿÿ  ÿÿÿÿ     ên        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                m               ÿÿÿÿ  ÿÿÿÿ     êZè       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                n                  ıÿÿÿÿ   ıÿÿÿÿ     3ç˜       statement executed        }    ÿÿÿÿ   ı      ÿÿÿÿ   ı              o      ö      ö      óÿÿÿÿ   óÿÿÿÿ     êEØ       statement executed        }    öÿÿÿÿ   ó      öÿÿÿÿ   ó              p      â      â      ßÿÿÿÿ   ßÿÿÿÿ     ê@X       statement executed        return pResult;    âÿÿÿÿ   ß      âÿÿÿÿ   ß              q      à      à      İÿÿÿÿ   İÿÿÿÿ     ê*       statement executed        }    àÿÿÿÿ   İ      àÿÿÿÿ   İ              r      Ü   	   Ü   
   Ùÿÿÿÿ   Ùÿÿÿÿ     4*Ø       statement executed        }    Üÿÿÿÿ   Ù   	   Üÿÿÿÿ   Ù   
           s      Ö      Ö      Óÿÿÿÿ   Óÿÿÿÿ     4h       statement executed        }    Öÿÿÿÿ   Ó      Öÿÿÿÿ   Ó              t      Ğ      Ğ      Íÿÿÿÿ   Íÿÿÿÿ     øDx       statement executed        }    Ğÿÿÿÿ   Í      Ğÿÿÿÿ   Í              u      Æ      Æ      Ãÿÿÿÿ   Ãÿÿÿÿ     ÷Éğ       statement executed        }    Æÿÿÿÿ   Ã      Æÿÿÿÿ   Ã              v      ¿      ¿      ¼ÿÿÿÿ   ¼ÿÿÿÿ     ÷İ8       statement executed        }    ¿ÿÿÿÿ   ¼      ¿ÿÿÿÿ   ¼              w      ±      ±      ®ÿÿÿÿ   ®ÿÿÿÿ    5=x       statement executed        }    ±ÿÿÿÿ   ®      ±ÿÿÿÿ   ®              x      ª      ª      §ÿÿÿÿ   §ÿÿÿÿ     êCØ       statement executed        }    ªÿÿÿÿ   §      ªÿÿÿÿ   §              y      œ      œ      ™ÿÿÿÿ   ™ÿÿÿÿ    +p`       statement executed        }    œÿÿÿÿ   ™      œÿÿÿÿ   ™              z      •      •      ’ÿÿÿÿ   ’ÿÿÿÿ     ÷ûè       statement executed        }    •ÿÿÿÿ   ’      •ÿÿÿÿ   ’              {      ƒ   	   ƒ   
   €ÿÿÿÿ   €ÿÿÿÿ     ô‡¸       statement executed        }    ƒÿÿÿÿ   €   	   ƒÿÿÿÿ   €   
           |      j      j      gÿÿÿÿ   gÿÿÿÿ     ø       statement executed        return (*this);    jÿÿÿÿ   g      jÿÿÿÿ   g              }      h      h      eÿÿÿÿ   eÿÿÿÿ     êK       statement executed        }    hÿÿÿÿ   e      hÿÿÿÿ   e              ~      M      M      Jÿÿÿÿ   Jÿÿÿÿ     ÷Ó¸       statement executed        }    Mÿÿÿÿ   J      Mÿÿÿÿ   J                    C      C      @ÿÿÿÿ   @ÿÿÿÿ    +ˆ        statement executed        }    Cÿÿÿÿ   @      Cÿÿÿÿ   @           CParameter::CParameter CParameter::CParameter()    (      C      %ÿÿÿÿ   @ÿÿÿÿCParameter::~CParameter CParameter::~CParameter()    K      M      Hÿÿÿÿ   JÿÿÿÿCParameter::operator= CParameter& CParameter::operator=( CParameter& param)    W      k      Tÿÿÿÿ   hÿÿÿÿWriteParametersToFile bool WriteParametersToFile(fstream& fileOutput, list<CParameter> &m_listParameter)    w      ã      tÿÿÿÿ   àÿÿÿÿCParameter::FormatParamValue int CParameter::FormatParamValue(char* pcLine)    î           ëÿÿÿÿ  ÿÿÿÿCParameter::Format int CParameter::Format(char* pcLine)   "     »     ÿÿÿÿ  ¸ÿÿÿÿCParameter::ReadDefaultVal int CParameter::ReadDefaultVal(char* pcToken)   Å          Âÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Parameter.cpp
 * \brief     Implementation of parameter class
 * \authors   Padmaja A, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the parameter class.
 */

/* C includes */
#include <float.h>
#include <limits.h>

/* Project includes */
#include "Parameter.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CParameter
 */
CParameter::CParameter()
{
    m_MaxVal.iValue = -1;
    m_MaxVal.uiValue = 0;
    m_MaxVal.fValue = -1;
    m_MaxVal.dValue = -1;
    m_MaxVal.cValue = "";
    m_MaxVal.i64Value = -1;
    m_MaxVal.ui64Value = 0;
    m_MinVal.iValue = -1;
    m_MinVal.uiValue = 0;
    m_MinVal.fValue = -1;
    m_MinVal.dValue = -1;
    m_MinVal.cValue = "";
    m_MinVal.i64Value = -1;
    m_MinVal.ui64Value = 0;
    m_InitVal.iValue = -1;
    m_InitVal.uiValue = 0;
    m_InitVal.fValue = -1;
    m_InitVal.dValue = -1;
    m_InitVal.cValue = "";
    m_InitVal.i64Value = -1;
    m_InitVal.ui64Value = 0;
    m_ValRange = "";
    m_ParamType = "";
    m_ParamName = "";
    m_RangeError = false;
    m_defError = false;
}

/**
 * \brief Destructor
 *
 * Destructor of CParameter
 */
CParameter::~CParameter()
{
    // nothing special to do here
}

/**
 * \brief     Operator overloading for =
 * \param[in] param Data to copy from
 * \return    Reference to local object with new data
 *
 * Copies the data from param to the local object.
 */
CParameter& CParameter::operator=( CParameter& param)
{
    // if there are some elements in the signal list clear them first
    m_listParamValues[0].clear();
    // now copy the other elements of the new message to this
    m_ObjectId = param.m_ObjectId;
    m_ParamName = param.m_ParamName;
    m_ValRange = param.m_ValRange;
    m_ParamType = param.m_ParamType;
    m_InitVal = param.m_InitVal;
    m_MaxVal = param.m_MaxVal;
    m_MinVal = param.m_MinVal;
    m_RangeError = param.m_RangeError;
    m_defError = param.m_defError;

    for(int i=0; i<6; i++)
    {
        m_listParamValues[i] = param.m_listParamValues[i];
    }

    return (*this);
}

/**
 * \brief     Writes the parameter definition
 * \param[in] fileOutput filename of output file
 * \param[in] m_listParameter Parameters List
 * \return    Status code
 *
 * Writes the parameter definition and default value to the
 * specified output file.
 */
bool WriteParametersToFile(fstream& fileOutput, list<CParameter> &m_listParameter)
{
    bool pResult=true;
    // if no parameter in the list then it simply returns true.
    // otherwise writes definition and default value of all parameters to the o/p file
    list<CParameter>::iterator rParam;

    for(rParam=m_listParameter.begin(); rParam!=m_listParameter.end(); ++rParam)
    {
        //Gets the next parameter from the list.
        if(rParam->m_RangeError)
        {
            pResult=false;
        }

        //Validation of  Default value of the parameter before writing to the o/p file.
        fileOutput << "\"" << rParam->m_ParamName.c_str() << "\"";
        fileOutput << "," << rParam->m_ParamType.c_str();

        //Parameter : INT type
        if(rParam->m_ParamType == "INT")
        {
            //Default value is NULL
            if(rParam->m_InitVal.iValue == -1)
            {
                rParam->m_defError = rParam->m_defError | true;
                pResult = pResult & false;
                rParam->m_InitVal.iValue = rParam->m_MinVal.iValue;
                fileOutput << "," << dec << rParam->m_InitVal.iValue;
                fileOutput << "," << dec << rParam->m_MinVal.iValue;
                fileOutput << "," << dec << rParam->m_MaxVal.iValue;
            }
            //Default value is not NULL
            else
            {
                fileOutput << "," << dec << rParam->m_InitVal.iValue;
                fileOutput << "," << dec << rParam->m_MinVal.iValue;
                fileOutput << "," << dec << rParam->m_MaxVal.iValue;
            }
        }
        //Parameter : HEX type
        else if(rParam->m_ParamType == "HEX")
        {
            //Default value is NULL
            if(rParam->m_InitVal.uiValue == -1)
            {
                rParam->m_defError = rParam->m_defError | true;
                pResult = pResult & false;
                rParam->m_InitVal.uiValue = rParam->m_MinVal.uiValue;
                fileOutput << "," << dec << rParam->m_InitVal.uiValue;
                fileOutput << "," << dec << rParam->m_MinVal.uiValue;
                fileOutput << "," << dec << rParam->m_MaxVal.uiValue;
            }
            //Default value is not NULL
            else
            {
                fileOutput << "," << dec << rParam->m_InitVal.uiValue;
                fileOutput << "," << dec << rParam->m_MinVal.uiValue;
                fileOutput << "," << dec << rParam->m_MaxVal.uiValue;
            }
        }
        //Parameter : FLOAT type
        else if(rParam->m_ParamType == "FLOAT")
        {
            //Default value is NULL
            if(rParam->m_InitVal.fValue == -1)
            {
                rParam->m_defError = rParam->m_defError | true;
                pResult = pResult & false;
                rParam->m_InitVal.fValue = rParam->m_MinVal.fValue;
                fileOutput << "," << rParam->m_InitVal.fValue;
                fileOutput << "," << rParam->m_MinVal.fValue;
                fileOutput << "," << rParam->m_MaxVal.fValue;
            }
            //Default value is not NULL
            else
            {
                fileOutput << "," << rParam->m_InitVal.fValue;
                fileOutput << "," << rParam->m_MinVal.fValue;
                fileOutput << "," << rParam->m_MaxVal.fValue;
            }
        }
        //Parameter : ENUM type
        else if(rParam->m_ParamType == "ENUM")
        {
            //Default value is NULL
            if(rParam->m_InitVal.cValue.length() == 0)
            {
                fileOutput << ",\"\"";
                fileOutput << "," << rParam->m_ValRange.c_str();
            }
            //Default value is not NULL
            else
            {
                fileOutput << ",\"" << rParam->m_InitVal.cValue << "\"";
                fileOutput << "," << rParam->m_ValRange.c_str();
            }
        }
        //Parameter : STRING type
        else
        {
            fileOutput << "," << rParam->m_InitVal.cValue;
        }

        //After validation parameter is written to the o/p file.
        fileOutput << endl;
    }

    return pResult;
}

/**
 * \brief     Calls the appropriate function of CParamValues
 * \param[in] pcLine Input line
 * \return    Status code
 *
 * This function calls the appropriate function of CParamValues
 * to get the Other Value of Attributes form CanoeDB file.
 */
int CParameter::FormatParamValue(char* pcLine)
{
    char* pcToken, *pcTok;
    CParameterValues pVal;

    //get object id
    while(*pcLine && *pcLine==' ')
    {
        *pcLine++;
    }

    pcToken = strtok_s(pcLine, " ", &pcTok);

    // if object id is node then calls GetNodeParams funtion to read the other values lilke min/max
    if(strcmp(pcToken, "BU_")==0)
    {
        pVal.GetNodeParams(m_ParamType, (pcLine+strlen(pcToken)+1));
        //adds the other calues to the list
        m_listParamValues[1].push_back(pVal);
    }
    // if object id is Message then calls GetMsgParams funtion to read the other values lilke min/max
    else if(strcmp(pcToken, "BO_")==0)
    {
        pVal.GetMesgParams(m_ParamType, (pcLine+strlen(pcToken)+1));
        //adds the other calues to the list
        m_listParamValues[2].push_back(pVal);
    }
    // if object id is signal then calls GetSignalParams funtion to read the other values lilke min/max
    else if(strcmp(pcToken, "SG_")==0)
    {
        pVal.GetSignalParams(m_ParamType, (pcLine+strlen(pcToken)+1));
        //adds the other calues to the list
        m_listParamValues[3].push_back(pVal);
    }
    // if object id is net then calls GetNetParams funtion to read the other values lilke min/max
    else
    {
        pVal.GetNetParams(m_ParamType,pcToken);
        //adds the other calues to the list
        m_listParamValues[0].push_back(pVal);
    }

    return 1;
}

/**
 * \brief     Parses the attribute lines from CanoeDB file.
 * \param[in] pcLine Input file string
 * \return    Status code
 *
 * Parses the attribute lines from CanoeDB file.
 */
int CParameter::Format(char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[defCON_TEMP_LEN];
    char* pcTemp = acTemp;
    int success = 1;
    //get object id
    pcToken = strtok_s(pcLine, "\"", &pcTok);

    while(*pcToken == ' ')
    {
        *pcToken++;
    }

    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; // copy OBJECT_ID only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_ObjectId = acTemp; // copy the object_id to the parameter's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer
    //get Attribute name
    pcToken = strtok_s(NULL, "\"", &pcTok);

    while(*pcToken && *pcToken != '"')
    {
        *pcTemp++ = *pcToken++; // copy PARAM_NAME only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_ParamName = acTemp; // copy the name to the parameter's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer
    //get Value Type
    pcToken = strtok_s(NULL, " ", &pcTok);

    while(*pcToken == ' ')
    {
        *pcToken++;
    }

    while(*pcToken && *pcToken != ' ' && *pcToken != ';')
    {
        *pcTemp++ = *pcToken++; // copy PARAM_TYPE only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_ParamType = acTemp; // copy the type to the parameter's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer

    if(m_ParamType != "STRING")
    {
        pcToken = strtok_s(NULL, ";", &pcTok);

        if(m_ParamType == "ENUM")
        {
            while(*pcToken && *pcToken == ' ')
            {
                *pcToken++;
            }

            m_ValRange = pcToken;
        }
        //Reads the flaot min,max values and validates those values.
        else if(m_ParamType == "FLOAT")
        {
            double temp;
            pcToken = strtok_s(pcToken, " ", &pcTok);
            temp = atof(pcToken);

            if(temp < FLT_MIN) //min val valildation
            {
                m_MinVal.fValue = FLT_MIN;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MinVal.fValue = float(temp);
            }

            pcToken = strtok_s(NULL, " ", &pcTok);
            temp=atof(pcToken);

            if((temp>FLT_MAX) || (temp<m_MinVal.fValue)) //max value validation
            {
                m_MaxVal.fValue = FLT_MAX;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MaxVal.fValue = float(temp);
            }

            pcTemp = acTemp; // reset pcTemp to start of buffer
        }
        //Reads the flaot min,max values and validates those values.
        else if(m_ParamType == "INT")
        {
            long long temp;
            pcToken = strtok_s(pcToken, " ", &pcTok);
            temp = _atoi64(pcToken);

            if(temp < INT_MIN ) //min value validation
            {
                m_MinVal.iValue = INT_MIN;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MinVal.iValue = int(temp);
            }

            pcToken = strtok_s(NULL, " ", &pcTok);
            temp = _atoi64(pcToken);

            if((temp>INT_MAX) || (temp<m_MinVal.iValue)) //max value validation
            {
                m_MaxVal.iValue = INT_MAX;
                m_RangeError = m_RangeError | true;
            }
            else
            {
                m_MaxVal.iValue = int(temp);
            }

            pcTemp = acTemp; // reset pcTemp to start of buffer*/
        }
        //Reads the flaot min,max values and validates those values.
        else if(m_ParamType == "HEX")
        {
            pcToken = strtok_s(pcToken, " ", &pcTok);
            m_MinVal.uiValue = strtoul(pcToken, NULL, 10);

            if(m_MinVal.uiValue < 0) //min vlaue validation
            {
                m_MinVal.uiValue = 0;
                m_RangeError = m_RangeError | true;
            }

            pcToken = strtok_s(NULL, ";", &pcTok);
            m_MaxVal.uiValue = strtoul(pcToken, NULL, 10);

            //max value validation
            if((m_MaxVal.uiValue == 0) || (m_MaxVal.uiValue < m_MinVal.uiValue))
            {
                m_MaxVal.uiValue = 0xffffffff;
                m_RangeError = m_RangeError | true;
            }

            pcTemp = acTemp;
        }
    }

    return success;
}

/**
 * \brief     Reads the default value of attribute from the CanoeDB file
 * \param[in] pcToken Input string
 * \return    Status code
 *
 * Reads the default value of attribute from the CanoeDB file.
 */
int CParameter::ReadDefaultVal(char* pcToken)
{
    char acTemp[defCON_TEMP_LEN];
    char* pcTemp = acTemp;
    int success=1;
    //Default value validation with respect to max.min values.

    //Param Type: ENUM :No need to validate.
    if(m_ParamType == "ENUM")
    {
        //omits all balcnk spaces.
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        pcToken++;

        //reads the enum default value.
        while(*pcToken && *pcToken != '"')
        {
            *pcTemp++ = *pcToken++;
        }

        *pcTemp = '\0';
        m_InitVal.cValue = acTemp;
        pcTemp=acTemp;
    }
    //Param Type: INT
    else if(m_ParamType == "INT")
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_InitVal.iValue = strtoul(pcToken, NULL, 10);
        }

        //if default value is not with in the range then set default vlaue as min value.
        if((m_InitVal.iValue<m_MinVal.iValue) || (m_InitVal.iValue>m_MaxVal.iValue))
        {
            m_InitVal.iValue = m_MinVal.iValue;
            m_RangeError = m_RangeError | true;
        }
    }
    //PArameter Type: HEX
    else if(m_ParamType == "HEX")
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_InitVal.uiValue = strtoul(pcToken, NULL, 10);
        }

        //if default value is not with in the range then set default vlaue as min value.
        if((m_InitVal.uiValue<m_MinVal.uiValue) || (m_InitVal.uiValue>m_MaxVal.uiValue))
        {
            m_InitVal.uiValue = m_MinVal.uiValue;
            m_RangeError = m_RangeError | true;
        }
    }
    //Parameter Type : FLOAT
    else if(m_ParamType == "FLOAT")
    {
        if(strcmp(pcToken," ")!=0)
        {
            m_InitVal.fValue=float(atof(pcToken));
        }

        //if default value is not with in the range then set default vlaue as min value.
        if(m_InitVal.fValue<m_MinVal.fValue || m_InitVal.fValue>m_MaxVal.fValue)
        {
            m_InitVal.fValue=m_MinVal.fValue;
            m_RangeError=m_RangeError | true;
        }
    }
    ////Parameter Type :String : Not Required.
    else if(m_ParamType == "STRING")
    {
        while(*pcToken && *pcToken == ' ')
        {
            *pcToken++;
        }

        m_InitVal.cValue = pcToken;
    }

    return success;
}


























using namespace std;






CParameterValues::CParameterValues()
{
    m_NodeName = "";
    m_MsgId = 0;
    m_SignalName = "";
    m_cFrameFormat = MSG_FF_STANDARD;
    m_ParamVal.iValue = -1;
    m_ParamVal.uiValue = 0;
    m_ParamVal.fValue = -1;
    m_ParamVal.dValue = -1;
    m_ParamVal.cValue = "";
    m_ParamVal.i64Value = -1;
    m_ParamVal.ui64Value = 0;
}






CParameterValues::~CParameterValues()
{
}









CParameterValues& CParameterValues::operator=(CParameterValues& param)
{
    
    m_NodeName = param.m_NodeName;
    m_SignalName = param.m_SignalName;
    m_MsgId = param.m_MsgId;
    m_ParamVal = param.m_ParamVal;
    m_cFrameFormat = param.m_cFrameFormat;
    return (*this);
}










int CParameterValues::GetNodeParams(string& paramType, char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[250],*pcTemp;
    pcTemp = acTemp;
    int success=1;
    
    pcToken = strtok_s(pcLine, ";", &pcTok);

    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_NodeName = acTemp;
    pcTemp = acTemp;
    
    ReadParamValue(paramType, pcToken);
    return success;
}









int CParameterValues::GetNetParams(string& paramType, char* pcLine)
{
    char* pcToken = pcLine;
    char* pcTok;
    int success = 1;
    
    pcToken=strtok_s(pcToken, ";", &pcTok);
    ReadParamValue(paramType, pcToken);
    return success;
}










int CParameterValues::GetMesgParams(string& paramType,char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[250], *pcTemp;
    int success = 1;
    pcTemp = acTemp;
    
    pcToken = strtok_s(pcLine, ";", &pcTok);

    while(*pcToken && (*pcToken != ' '))
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_MsgId = (unsigned int)strtoul(acTemp, 0, 10);
    pcTemp = acTemp;

    
    if(m_MsgId < 0x80000000UL)
    {
        m_cFrameFormat = CParameterValues::MSG_FF_STANDARD;
    }
    else
    {
        m_cFrameFormat = CParameterValues::MSG_FF_EXTENDED;
        m_MsgId &= 0x7FFFFFFF;
    }

    
    
    ReadParamValue(paramType, pcToken);
    return success;
}











int CParameterValues::GetSignalParams(string& paramType,char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[250],*pcTemp;
    int success=1;
    pcTemp = acTemp;
    pcToken = strtok_s(pcLine, " ", &pcTok);

    
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_MsgId = strtoul(acTemp, 0, 10);
    pcTemp = acTemp;
    pcToken = strtok_s(0, ";", &pcTok);

    
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_SignalName = acTemp;
    pcTemp=acTemp;

    
    if(m_MsgId < 0x80000000UL)
    {
        m_cFrameFormat = CParameterValues::MSG_FF_STANDARD;
    }
    else
    {
        m_cFrameFormat = CParameterValues::MSG_FF_EXTENDED;
        m_MsgId &= 0x7FFFFFFF;
    }

    
    ReadParamValue(paramType, pcToken);
    return success;
}









int CParameterValues::ReadParamValue(string& paramType,char* pcToken)
{
    int success = 1;

    
    if(paramType == "STRING")
    {
        while(*pcToken != '"')
        {
            *pcToken++;
        }

        m_ParamVal.cValue = pcToken;
    }
    
    else if((paramType == "INT") || (paramType == "HEX"))
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_ParamVal.iValue = strtoul(pcToken, 0, 10);
        }
    }
    
    else if(paramType == "ENUM")
    {
        while(*pcToken == ' ')
        {
            *pcToken++;
        }

        m_ParamVal.cValue = pcToken;
    }
    
    else if(paramType == "FLOAT")
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_ParamVal.fValue = float(atof(pcToken));
        }
    }

    return success;
}









const void CParameterValues::WriteNetValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}









const void CParameterValues::WriteNodeValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << m_NodeName.c_str();
    fileOutput << ",\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}









const void CParameterValues::WriteMesgValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << dec << m_MsgId;
    fileOutput << ",";
    fileOutput << m_cFrameFormat;
    fileOutput << ",\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}









const void CParameterValues::WriteSigValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << m_MsgId;
    fileOutput << ",";
    fileOutput << m_cFrameFormat;
    fileOutput << ",";
    fileOutput << m_SignalName.c_str();
    fileOutput << ",\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}
          ú      ú   !   ùÿÿÿÿ   ùÿÿÿÿ    5_h      expression was true       (paramType == "INT")    úÿÿÿÿ   ù      úÿÿÿÿ   ù   !   expression was false       (paramType == "INT")    úÿÿÿÿ   ù      úÿÿÿÿ   ù   !               0µ@         Ê      Ê   &   Éÿÿÿÿ   Éÿÿÿÿ     3øà      expression was true       *pcToken != ' '    Êÿÿÿÿ   É      Êÿÿÿÿ   É   &   expression was false       *pcToken != ' '    Êÿÿÿÿ   É      Êÿÿÿÿ   É   &                4 p         Ê      Ê      Éÿÿÿÿ   Éÿÿÿÿ     3ú       expression was true       *pcToken    Êÿÿÿÿ   É      Êÿÿÿÿ   É      expression was false       *pcToken    Êÿÿÿÿ   É      Êÿÿÿÿ   É                    ¿      ¿   &   ¾ÿÿÿÿ   ¾ÿÿÿÿ     4      expression was true       *pcToken != ' '    ¿ÿÿÿÿ   ¾      ¿ÿÿÿÿ   ¾   &   expression was false       *pcToken != ' '    ¿ÿÿÿÿ   ¾      ¿ÿÿÿÿ   ¾   &                4h         ¿      ¿      ¾ÿÿÿÿ   ¾ÿÿÿÿ     4      expression was true       *pcToken    ¿ÿÿÿÿ   ¾      ¿ÿÿÿÿ   ¾      expression was false       *pcToken    ¿ÿÿÿÿ   ¾      ¿ÿÿÿÿ   ¾              
      ’      ’   (   ‘ÿÿÿÿ   ‘ÿÿÿÿ    5‚@      expression was true       (*pcToken != ' ')    ’ÿÿÿÿ   ‘      ’ÿÿÿÿ   ‘   (   expression was false       (*pcToken != ' ')    ’ÿÿÿÿ   ‘      ’ÿÿÿÿ   ‘   (                ê-         ’      ’      ‘ÿÿÿÿ   ‘ÿÿÿÿ    54`      expression was true       *pcToken    ’ÿÿÿÿ   ‘      ’ÿÿÿÿ   ‘      expression was false       *pcToken    ’ÿÿÿÿ   ‘      ’ÿÿÿÿ   ‘                    `      `   &   _ÿÿÿÿ   _ÿÿÿÿ     êdğ      expression was true       *pcToken != ' '    `ÿÿÿÿ   _      `ÿÿÿÿ   _   &   expression was false       *pcToken != ' '    `ÿÿÿÿ   _      `ÿÿÿÿ   _   &                êiP         `      `      _ÿÿÿÿ   _ÿÿÿÿ     êgø      expression was true       *pcToken    `ÿÿÿÿ   _      `ÿÿÿÿ   _      expression was false       *pcToken    `ÿÿÿÿ   _      `ÿÿÿÿ   _                             ÿÿÿÿ  ÿÿÿÿ     4>X      expression was false       *pcToken == ' '   ÿÿÿÿ       ÿÿÿÿ                     ô@         ò      ò      ñÿÿÿÿ   ñÿÿÿÿ     3ßP      expression was false       *pcToken != '"'    òÿÿÿÿ   ñ      òÿÿÿÿ   ñ                   3â         ú   %   ú   9   ùÿÿÿÿ   ùÿÿÿÿ    5‡`      expression was true       (paramType == "HEX")    úÿÿÿÿ   ù   %   úÿÿÿÿ   ù   9   expression was false       (paramType == "HEX")    úÿÿÿÿ   ù   %   úÿÿÿÿ   ù   9               5r°        &     &     %ÿÿÿÿ  %ÿÿÿÿ     ê:h      expression was true       (paramType == "INT")   &ÿÿÿÿ  %     &ÿÿÿÿ  %      expression was false       (paramType == "INT")   &ÿÿÿÿ  %     &ÿÿÿÿ  %                   ÷İ8        &      &   4  %ÿÿÿÿ  %ÿÿÿÿ     ø8      expression was true       (paramType == "HEX")   &ÿÿÿÿ  %      &ÿÿÿÿ  %   4   expression was false       (paramType == "HEX")   &ÿÿÿÿ  %      &ÿÿÿÿ  %   4                ÷Éğ        U     U     Tÿÿÿÿ  Tÿÿÿÿ     ôˆĞ      expression was true       (paramType == "INT")   Uÿÿÿÿ  T     Uÿÿÿÿ  T      expression was false       (paramType == "INT")   Uÿÿÿÿ  T     Uÿÿÿÿ  T                  +         U      U   4  Tÿÿÿÿ  Tÿÿÿÿ    +}p      expression was true       (paramType == "HEX")   Uÿÿÿÿ  T      Uÿÿÿÿ  T   4   expression was false       (paramType == "HEX")   Uÿÿÿÿ  T      Uÿÿÿÿ  T   4               +¯8        †     †     …ÿÿÿÿ  …ÿÿÿÿ    +ğ      expression was true       (paramType == "INT")   †ÿÿÿÿ  …     †ÿÿÿÿ  …      expression was false       (paramType == "INT")   †ÿÿÿÿ  …     †ÿÿÿÿ  …                   øˆ         †      †   4  …ÿÿÿÿ  …ÿÿÿÿ    +5H      expression was true       (paramType == "HEX")   †ÿÿÿÿ  …      †ÿÿÿÿ  …   4   expression was false       (paramType == "HEX")   †ÿÿÿÿ  …      †ÿÿÿÿ  …   4                øDx   "     ¹     ¹     ¸ÿÿÿÿ  ¸ÿÿÿÿ     4=8      expression was true       (paramType == "INT")   ¹ÿÿÿÿ  ¸     ¹ÿÿÿÿ  ¸      expression was false       (paramType == "INT")   ¹ÿÿÿÿ  ¸     ¹ÿÿÿÿ  ¸                   4h   $     ¹      ¹   4  ¸ÿÿÿÿ  ¸ÿÿÿÿ     ê2H      expression was true       (paramType == "HEX")   ¹ÿÿÿÿ  ¸      ¹ÿÿÿÿ  ¸   4   expression was false       (paramType == "HEX")   ¹ÿÿÿÿ  ¸      ¹ÿÿÿÿ  ¸   4                41°   &     Ğ     Ğ   "  Ïÿÿÿÿ  Ïÿÿÿÿ     ÷È@      expression was false       paramType == "STRING"   Ğÿÿÿÿ  Ï     Ğÿÿÿÿ  Ï   "               +ix   '     Ê     Ê   #  Éÿÿÿÿ  Éÿÿÿÿ    +µ(      expression was false       m_ParamVal.fValue != -1   Êÿÿÿÿ  É     Êÿÿÿÿ  É   #               +p`   (     »     »   #  ºÿÿÿÿ  ºÿÿÿÿ    +‰ğ      expression was false       m_ParamVal.iValue != -1   »ÿÿÿÿ  º     »ÿÿÿÿ  º   #                6(   )             "  œÿÿÿÿ  œÿÿÿÿ    +_X      expression was false       paramType == "STRING"   ÿÿÿÿ  œ     ÿÿÿÿ  œ   "                êià   *     —     —   #  –ÿÿÿÿ  –ÿÿÿÿ     êd      expression was false       m_ParamVal.fValue != -1   —ÿÿÿÿ  –     —ÿÿÿÿ  –   #               +SØ   +     ˆ     ˆ   #  ‡ÿÿÿÿ  ‡ÿÿÿÿ    +o      expression was false       m_ParamVal.iValue != -1   ˆÿÿÿÿ  ‡     ˆÿÿÿÿ  ‡   #               +gˆ   ,     l     l   "  kÿÿÿÿ  kÿÿÿÿ     ôz¨      expression was false       paramType == "STRING"   lÿÿÿÿ  k     lÿÿÿÿ  k   "                ôaˆ   -     f     f   #  eÿÿÿÿ  eÿÿÿÿ     ênØ      expression was false       m_ParamVal.fValue != -1   fÿÿÿÿ  e     fÿÿÿÿ  e   #                êK   .     W     W   #  Vÿÿÿÿ  Vÿÿÿÿ     ÷Ç       expression was false       m_ParamVal.iValue != -1   Wÿÿÿÿ  V     Wÿÿÿÿ  V   #               5`À   /     =     =   "  <ÿÿÿÿ  <ÿÿÿÿ     ÷Ş˜      expression was false       paramType == "STRING"   =ÿÿÿÿ  <     =ÿÿÿÿ  <   "                ôc@   0     0     0   #  /ÿÿÿÿ  /ÿÿÿÿ    5f      expression was false       m_ParamVal.fValue != -1   0ÿÿÿÿ  /     0ÿÿÿÿ  /   #               5M˜   1     (     (   #  'ÿÿÿÿ  'ÿÿÿÿ     êN€      expression was false       m_ParamVal.iValue != -1   (ÿÿÿÿ  '     (ÿÿÿÿ  '   #                êI@   2             %  ÿÿÿÿ  ÿÿÿÿ    +>      expression was false       strcmp(pcToken, " ") != 0   ÿÿÿÿ       ÿÿÿÿ     %               +¶H   3             !  ÿÿÿÿ  ÿÿÿÿ    +È      expression was false       paramType == "FLOAT"   ÿÿÿÿ       ÿÿÿÿ     !                4"   4      ü      ü   %   ûÿÿÿÿ   ûÿÿÿÿ     ôb      expression was false       strcmp(pcToken, " ") != 0    üÿÿÿÿ   û      üÿÿÿÿ   û   %                ô{8   5     Ö     Ö     Õÿÿÿÿ  Õÿÿÿÿ     ø/H       statement executed        }   Öÿÿÿÿ  Õ     Öÿÿÿÿ  Õ              6     Ó     Ó     Òÿÿÿÿ  Òÿÿÿÿ    5†p       statement executed        }   Óÿÿÿÿ  Ò     Óÿÿÿÿ  Ò              7     Î     Î     Íÿÿÿÿ  Íÿÿÿÿ    +h        statement executed        }   Îÿÿÿÿ  Í     Îÿÿÿÿ  Í              8     Í   	  Í   
  Ìÿÿÿÿ  Ìÿÿÿÿ    +´˜       statement executed        }   Íÿÿÿÿ  Ì   	  Íÿÿÿÿ  Ì   
           9     Æ     Æ     Åÿÿÿÿ  Åÿÿÿÿ     ø*@       statement executed        }   Æÿÿÿÿ  Å     Æÿÿÿÿ  Å              :     ¿     ¿     ¾ÿÿÿÿ  ¾ÿÿÿÿ    +#°       statement executed        }   ¿ÿÿÿÿ  ¾     ¿ÿÿÿÿ  ¾              ;     ¾   	  ¾   
  ½ÿÿÿÿ  ½ÿÿÿÿ    +‰       statement executed        }   ¾ÿÿÿÿ  ½   	  ¾ÿÿÿÿ  ½   
           <     £     £     ¢ÿÿÿÿ  ¢ÿÿÿÿ     ô‹0       statement executed        }   £ÿÿÿÿ  ¢     £ÿÿÿÿ  ¢              =                 Ÿÿÿÿÿ  Ÿÿÿÿÿ     ôQ        statement executed        }    ÿÿÿÿ  Ÿ      ÿÿÿÿ  Ÿ              >     ›     ›     šÿÿÿÿ  šÿÿÿÿ     ê-˜       statement executed        }   ›ÿÿÿÿ  š     ›ÿÿÿÿ  š              ?     š   	  š   
  ™ÿÿÿÿ  ™ÿÿÿÿ     ê^È       statement executed        }   šÿÿÿÿ  ™   	  šÿÿÿÿ  ™   
           @     “     “     ’ÿÿÿÿ  ’ÿÿÿÿ    +è       statement executed        }   “ÿÿÿÿ  ’     “ÿÿÿÿ  ’              A     Œ     Œ     ‹ÿÿÿÿ  ‹ÿÿÿÿ    +wğ       statement executed        }   Œÿÿÿÿ  ‹     Œÿÿÿÿ  ‹              B     ‹   	  ‹   
  Šÿÿÿÿ  Šÿÿÿÿ    +mx       statement executed        }   ‹ÿÿÿÿ  Š   	  ‹ÿÿÿÿ  Š   
           C     r     r     qÿÿÿÿ  qÿÿÿÿ    5^        statement executed        }   rÿÿÿÿ  q     rÿÿÿÿ  q              D     o     o     nÿÿÿÿ  nÿÿÿÿ     ôr       statement executed        }   oÿÿÿÿ  n     oÿÿÿÿ  n              E     j     j     iÿÿÿÿ  iÿÿÿÿ     ôJ8       statement executed        }   jÿÿÿÿ  i     jÿÿÿÿ  i              F     i   	  i   
  hÿÿÿÿ  hÿÿÿÿ     êeØ       statement executed        }   iÿÿÿÿ  h   	  iÿÿÿÿ  h   
           G     b     b     aÿÿÿÿ  aÿÿÿÿ     4!`       statement executed        }   bÿÿÿÿ  a     bÿÿÿÿ  a              H     [     [     Zÿÿÿÿ  Zÿÿÿÿ     ÷Ğè       statement executed        }   [ÿÿÿÿ  Z     [ÿÿÿÿ  Z              I     Z   	  Z   
  Yÿÿÿÿ  Yÿÿÿÿ     ÷Å˜       statement executed        }   Zÿÿÿÿ  Y   	  Zÿÿÿÿ  Y   
           J      0      0      /ÿÿÿÿ   /ÿÿÿÿ    +„8       statement executed        }    0ÿÿÿÿ   /      0ÿÿÿÿ   /              K      9      9      8ÿÿÿÿ   8ÿÿÿÿ     ôUÀ       statement executed        }    9ÿÿÿÿ   8      9ÿÿÿÿ   8              L      K      K      Jÿÿÿÿ   Jÿÿÿÿ     ôD        statement executed        return (*this);    Kÿÿÿÿ   J      Kÿÿÿÿ   J              M      c      c      bÿÿÿÿ   bÿÿÿÿ     êX˜       statement executed        }    cÿÿÿÿ   b      cÿÿÿÿ   b              N      j      j      iÿÿÿÿ   iÿÿÿÿ     ê>˜       statement executed        return success;    jÿÿÿÿ   i      jÿÿÿÿ   i              O      }      }      |ÿÿÿÿ   |ÿÿÿÿ     ê4       statement executed        return success;    }ÿÿÿÿ   |      }ÿÿÿÿ   |              P      •      •      ”ÿÿÿÿ   ”ÿÿÿÿ     ê(È       statement executed        }    •ÿÿÿÿ   ”      •ÿÿÿÿ   ”              Q      Ÿ      Ÿ      ÿÿÿÿ   ÿÿÿÿ     4,0       statement executed        }    Ÿÿÿÿÿ         Ÿÿÿÿÿ                 R      ¤      ¤      £ÿÿÿÿ   £ÿÿÿÿ     4&¸       statement executed        }    ¤ÿÿÿÿ   £      ¤ÿÿÿÿ   £              S      ©      ©      ¨ÿÿÿÿ   ¨ÿÿÿÿ     4(       statement executed        return success;    ©ÿÿÿÿ   ¨      ©ÿÿÿÿ   ¨              T      Â      Â      Áÿÿÿÿ   Áÿÿÿÿ     4°       statement executed        }    Âÿÿÿÿ   Á      Âÿÿÿÿ   Á              U      Í      Í      Ìÿÿÿÿ   Ìÿÿÿÿ     3õ8       statement executed        }    Íÿÿÿÿ   Ì      Íÿÿÿÿ   Ì              V      ×      ×      Öÿÿÿÿ   Öÿÿÿÿ     3í        statement executed        }    ×ÿÿÿÿ   Ö      ×ÿÿÿÿ   Ö              W      Ü      Ü      Ûÿÿÿÿ   Ûÿÿÿÿ     3é        statement executed        }    Üÿÿÿÿ   Û      Üÿÿÿÿ   Û              X      à      à      ßÿÿÿÿ   ßÿÿÿÿ     3æ0       statement executed        return success;    àÿÿÿÿ   ß      àÿÿÿÿ   ß              Y      õ   	   õ   
   ôÿÿÿÿ   ôÿÿÿÿ     3à°       statement executed        }    õÿÿÿÿ   ô   	   õÿÿÿÿ   ô   
           Z      ø      ø      ÷ÿÿÿÿ   ÷ÿÿÿÿ     4È       statement executed        }    øÿÿÿÿ   ÷      øÿÿÿÿ   ÷              [      ÿ   	   ÿ   
   şÿÿÿÿ   şÿÿÿÿ     ôl(       statement executed        }    ÿÿÿÿÿ   ş   	   ÿÿÿÿÿ   ş   
           \                  ÿÿÿÿÿ   ÿÿÿÿÿ     ôWp       statement executed        }    ÿÿÿÿ   ÿ      ÿÿÿÿ   ÿ              ]        	     
  ÿÿÿÿ  ÿÿÿÿ     ê3h       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           ^     
     
     	ÿÿÿÿ  	ÿÿÿÿ     4(h       statement executed        }   
ÿÿÿÿ  	     
ÿÿÿÿ  	              _        	     
  ÿÿÿÿ  ÿÿÿÿ    +EÈ       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           `               ÿÿÿÿ  ÿÿÿÿ    +6       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                a               ÿÿÿÿ  ÿÿÿÿ     ÷ÿè       statement executed        return success;   ÿÿÿÿ       ÿÿÿÿ                b     +   	  +   
  *ÿÿÿÿ  *ÿÿÿÿ    +<`       statement executed        }   +ÿÿÿÿ  *   	  +ÿÿÿÿ  *   
           c     ,     ,     +ÿÿÿÿ  +ÿÿÿÿ     ô‚Ğ       statement executed        }   ,ÿÿÿÿ  +     ,ÿÿÿÿ  +              d     3   	  3   
  2ÿÿÿÿ  2ÿÿÿÿ    5dH       statement executed        }   3ÿÿÿÿ  2   	  3ÿÿÿÿ  2   
           e     4     4     3ÿÿÿÿ  3ÿÿÿÿ    5gH       statement executed        }   4ÿÿÿÿ  3     4ÿÿÿÿ  3              f     ;     ;     :ÿÿÿÿ  :ÿÿÿÿ    5Šh       statement executed        }   ;ÿÿÿÿ  :     ;ÿÿÿÿ  :              g     @     @     ?ÿÿÿÿ  ?ÿÿÿÿ    5›°       statement executed        }   @ÿÿÿÿ  ?     @ÿÿÿÿ  ?              h     C     C     Bÿÿÿÿ  Bÿÿÿÿ    +(       statement executed        }   Cÿÿÿÿ  B     Cÿÿÿÿ  B           CParameterValues::CParameterValues CParameterValues::CParameterValues()    $      0      #ÿÿÿÿ   /ÿÿÿÿCParameterValues::~CParameterValues CParameterValues::~CParameterValues()    8      9      7ÿÿÿÿ   8ÿÿÿÿCParameterValues::operator= CParameterValues& CParameterValues::operator=(CParameterValues& param)    D      L      Cÿÿÿÿ   KÿÿÿÿCParameterValues::GetNodeParams int CParameterValues::GetNodeParams(string& paramType, char* pcLine)    X      k      Wÿÿÿÿ   jÿÿÿÿCParameterValues::GetNetParams int CParameterValues::GetNetParams(string& paramType, char* pcLine)    v      ~      uÿÿÿÿ   }ÿÿÿÿCParameterValues::GetMesgParams int CParameterValues::GetMesgParams(string& paramType,char* pcLine)    Š      ª      ‰ÿÿÿÿ   ©ÿÿÿÿCParameterValues::GetSignalParams int CParameterValues::GetSignalParams(string& paramType,char* pcLine)    ·      á      ¶ÿÿÿÿ   àÿÿÿÿCParameterValues::ReadParamValue int CParameterValues::ReadParamValue(string& paramType,char* pcToken)    ì           ëÿÿÿÿ  ÿÿÿÿCParameterValues::WriteNetValuesToFile const void CParameterValues::WriteNetValuesToFile(fstream& fileOutput, string& paramType, string& paramName)         C     ÿÿÿÿ  BÿÿÿÿCParameterValues::WriteNodeValuesToFile const void CParameterValues::WriteNodeValuesToFile(fstream& fileOutput, string& paramType, string& paramName)   N     r     Mÿÿÿÿ  qÿÿÿÿCParameterValues::WriteMesgValuesToFile const void CParameterValues::WriteMesgValuesToFile(fstream& fileOutput, string& paramType, string& paramName)   }     £     |ÿÿÿÿ  ¢ÿÿÿÿCParameterValues::WriteSigValuesToFile const void CParameterValues::WriteSigValuesToFile(fstream& fileOutput, string& paramType, string& paramName)   ®     Ö     ­ÿÿÿÿ  Õÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ParameterVal.cpp
 * \brief     Implementation of parameter value class
 * \authors   Padmaja A, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the parameter value class.
 */

/* Project includes */
#include "ParameterVal.h"

using namespace std;

/**
 * \brief Constructor of CParameterValues
 *
 * Default Constructor used to initialse parameterVal class object.
 */
CParameterValues::CParameterValues()
{
    m_NodeName = "";
    m_MsgId = 0;
    m_SignalName = "";
    m_cFrameFormat = MSG_FF_STANDARD;
    m_ParamVal.iValue = -1;
    m_ParamVal.uiValue = 0;
    m_ParamVal.fValue = -1;
    m_ParamVal.dValue = -1;
    m_ParamVal.cValue = "";
    m_ParamVal.i64Value = -1;
    m_ParamVal.ui64Value = 0;
}

/**
 * \brief Destructor
 *
 * Destructor of CParameterValues
 */
CParameterValues::~CParameterValues()
{
}


/**
 * \brief     copy operator
 * \param[in] param Data to assign from
 * \return    Reference to local object with new contents
 *
 * Copies the contents of param to the local object.
 */
CParameterValues& CParameterValues::operator=(CParameterValues& param)
{
    // now copy the other elements of the new message to this
    m_NodeName = param.m_NodeName;
    m_SignalName = param.m_SignalName;
    m_MsgId = param.m_MsgId;
    m_ParamVal = param.m_ParamVal;
    m_cFrameFormat = param.m_cFrameFormat;
    return (*this);
}


/**
 * \brief     Parses the Node Parameter Values
 * \param[in] paramType Parameter Type
 * \param[in] pcLine Input line
 * \return    Status code
 *
 * Parses the Node Parameter Values other than Default value from the input CanoeDB file.
 */
int CParameterValues::GetNodeParams(string& paramType, char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[defCON_TEMP_LEN],*pcTemp;
    pcTemp = acTemp;
    int success=1;
    //reads the nodes name
    pcToken = strtok_s(pcLine, ";", &pcTok);

    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_NodeName = acTemp;
    pcTemp = acTemp;
    //Gets the node param value.
    ReadParamValue(paramType, pcToken);
    return success;
}

/**
 * \brief     Parses the Network Parameter Values
 * \param[in] paramType Parameter Type
 * \param[in] pcLine Input line
 * \return    Status code
 *
 * Parses the Network Parameter Values other than Default value from the input CanoeDB file.
 */
int CParameterValues::GetNetParams(string& paramType, char* pcLine)
{
    char* pcToken = pcLine;
    char* pcTok;
    int success = 1;
    //reads the net param value.
    pcToken=strtok_s(pcToken, ";", &pcTok);
    ReadParamValue(paramType, pcToken);
    return success;
}

/**
 * \brief     Parses the Message Parameter
 * \param[in] paramType Parameter Type
 * \param[in] pcLine Input line
 * \return    Status code
 *
 * This function Parses the Message Parameter other Values rather than Default value from the input CanoeDB
 * file and finds the frame foramt for that Message ID.
 */
int CParameterValues::GetMesgParams(string& paramType,char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[defCON_TEMP_LEN], *pcTemp;
    int success = 1;
    pcTemp = acTemp;
    //get Message Id.
    pcToken = strtok_s(pcLine, ";", &pcTok);

    while(*pcToken && (*pcToken != ' '))
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_MsgId = (unsigned int)strtoul(acTemp, NULL, 10);
    pcTemp = acTemp;

    //Validates the MsgId to get frame format.
    if(m_MsgId < 0x80000000UL)
    {
        m_cFrameFormat = CParameterValues::MSG_FF_STANDARD;
    }
    else
    {
        m_cFrameFormat = CParameterValues::MSG_FF_EXTENDED;
        m_MsgId &= 0x7FFFFFFF;
    }

    //pcToken=strtok(NULL,";");
    //get the mesg param value.
    ReadParamValue(paramType, pcToken);
    return success;
}

/**
 * \brief     Parses the Signal Parameter Values
 * \param[in] paramType Parameter Type
 * \param[in] pcLine Input line
 * \return    Status code
 *
 * Parses the Signal Parameter Values other than Default value from the
 * input CanoeDB file and calculates the frame format
 * for the corresponding Message ID.
 */
int CParameterValues::GetSignalParams(string& paramType,char* pcLine)
{
    char* pcToken, *pcTok;
    char acTemp[defCON_TEMP_LEN],*pcTemp;
    int success=1;
    pcTemp = acTemp;
    pcToken = strtok_s(pcLine, " ", &pcTok);

    //get the message Id.
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_MsgId = strtoul(acTemp, NULL, 10);
    pcTemp = acTemp;
    pcToken = strtok_s(NULL, ";", &pcTok);

    //get signal name.
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp = '\0';
    m_SignalName = acTemp;
    pcTemp=acTemp;

    //validates the msgId to get the frame format.
    if(m_MsgId < 0x80000000UL)
    {
        m_cFrameFormat = CParameterValues::MSG_FF_STANDARD;
    }
    else
    {
        m_cFrameFormat = CParameterValues::MSG_FF_EXTENDED;
        m_MsgId &= 0x7FFFFFFF;
    }

    //get signal param value.
    ReadParamValue(paramType, pcToken);
    return success;
}

/**
 * \brief     Reads the other vlaue of attributes from CanoeDB file.
 * \param[in] paramType Parameter Type
 * \param[in] pcToken Input line
 * \return    Status code
 *
 * Reads the other vlaue of attributes from CanoeDB file.
 */
int CParameterValues::ReadParamValue(string& paramType,char* pcToken)
{
    int success = 1;

    //Param type :STRING
    if(paramType == "STRING")
    {
        while(*pcToken != '"')
        {
            *pcToken++;
        }

        m_ParamVal.cValue = pcToken;
    }
    //Param type :INT/HEX
    else if((paramType == "INT") || (paramType == "HEX"))
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_ParamVal.iValue = strtoul(pcToken, NULL, 10);
        }
    }
    //Param type :ENUM
    else if(paramType == "ENUM")
    {
        while(*pcToken == ' ')
        {
            *pcToken++;
        }

        m_ParamVal.cValue = pcToken;
    }
    //Param type :FLOAT
    else if(paramType == "FLOAT")
    {
        if(strcmp(pcToken, " ") != 0)
        {
            m_ParamVal.fValue = float(atof(pcToken));
        }
    }

    return success;
}

/**
 * \brief     Writes network values to file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Writes network values to file.
 */
const void CParameterValues::WriteNetValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << "\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    //writes int/hex param net values to o/p file and validates initial value.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    //writes Float param net values to o/p file and validates initial value.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    //writes enum param net values to o/p file and validates initial value.
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    //writes string param net values to o/p file and validates initial value.
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}

/**
 * \brief     Writes node value to file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Writes node value to file.
 */
const void CParameterValues::WriteNodeValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << m_NodeName.c_str();
    fileOutput << ",\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    //writes int/hex param node values to o/p file and validates initial value.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    //writes enum param node values to o/p file and validates initial value.
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    //writes float param node values to o/p file and validates initial value.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    //writes string param node values to o/p file and validates initial value.
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}

/**
 * \brief     Writes message values to file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Writes message values to file.
 */
const void CParameterValues::WriteMesgValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << dec << m_MsgId;
    fileOutput << ",";
    fileOutput << m_cFrameFormat;
    fileOutput << ",\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    //writes int/hex param mesg values to o/p file and validates initial value.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    //writes enum param mesg values to o/p file and validates initial value.
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    //writes float param mesg values to o/p file and validates initial value.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    //writes string param mesg values to o/p file and validates initial value.
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}

/**
 * \brief     Writes signal values to file
 * \param[in] fileOutput Output file
 * \param[in] paramType Parameter Type
 * \param[in] paramName Parameter Name
 *
 * Writes signal values to file.
 */
const void CParameterValues::WriteSigValuesToFile(fstream& fileOutput, string& paramType, string& paramName)
{
    fileOutput << m_MsgId;
    fileOutput << ",";
    fileOutput << m_cFrameFormat;
    fileOutput << ",";
    fileOutput << m_SignalName.c_str();
    fileOutput << ",\"";
    fileOutput << paramName.c_str();
    fileOutput << "\",";

    //writes int/hex param sig values to o/p file and validates initial value.
    if((paramType == "INT") || (paramType == "HEX"))
    {
        if(m_ParamVal.iValue != -1)
        {
            fileOutput << dec << m_ParamVal.iValue;
        }
    }
    //writes enum param sig values to o/p file and validates initial value.
    else if(paramType == "ENUM")
    {
        fileOutput << "\"";
        fileOutput << m_ParamVal.cValue;
        fileOutput << "\"";
    }
    //writes float param sig values to o/p file and validates initial value.
    else if(paramType == "FLOAT")
    {
        if(m_ParamVal.fValue != -1)
        {
            fileOutput << m_ParamVal.fValue;
        }
    }
    //writes string param sig values to o/p file and validates initial value.
    else if(paramType == "STRING")
    {
        fileOutput << m_ParamVal.cValue;
    }

    fileOutput << endl;
}





























using namespace std;






CSignal::CSignal()
{
    m_acMultiplex = "";
    m_acName = "";
    m_ucLength = 1; 
    m_ucWhichByte = 1; 
    m_ucStartBit = 0; 
    m_ucType = SIG_TYPE_BOOL; 
    m_MaxValue.iValue = 1; 
    m_MaxValue.uiValue = 1;
    m_MaxValue.fValue = 1;
    m_MaxValue.dValue = 1;
    m_MaxValue.cValue = "";
    m_MaxValue.i64Value = 1;
    m_MaxValue.ui64Value = 1;
    m_MinValue.iValue = 0;
    m_MinValue.uiValue = 0;
    m_MinValue.fValue = 0;
    m_MinValue.dValue = 0;
    m_MinValue.cValue = "";
    m_MinValue.i64Value = 0;
    m_MinValue.ui64Value = 0;
    m_ucDataFormat = SIG_DF_INTEL;
    m_fOffset = 0.0f;
    m_fScaleFactor = 1.0f;
    m_acUnit = "";
    m_uiError = SIG_EC_NO_ERR;
    m_rxNode = "";
    m_listValueDescriptor.clear();
}







CSignal::~CSignal()
{
    
    m_listValueDescriptor.clear();
}











CSignal& CSignal::operator=(CSignal& signal)
{
    m_listValueDescriptor.clear(); 
    
    m_acMultiplex = signal.m_acMultiplex;
    m_acName = signal.m_acName;
    m_ucLength = signal.m_ucLength;
    m_ucWhichByte = signal.m_ucWhichByte;
    m_ucStartBit = signal.m_ucStartBit;
    m_ucType = signal.m_ucType;
    m_MaxValue = signal.m_MaxValue;
    m_MinValue = signal.m_MinValue;
    m_ucDataFormat = signal.m_ucDataFormat;
    m_fOffset = signal.m_fOffset;
    m_fScaleFactor = signal.m_fScaleFactor;
    m_acUnit = signal.m_acUnit;
    m_rxNode = signal.m_rxNode;
    m_uiError = signal.m_uiError;
    
    m_listValueDescriptor = signal.m_listValueDescriptor;
    return (*this);
}










int CSignal::Format(char* pcLine)
{
    char* pcToken;
    char acTemp[1026],*pcTemp,*pcTok;
    pcTemp = acTemp;
    
    
    
    
    
    pcToken = strtok_s(pcLine, ":", &pcTok); 

    
    
    while(*pcToken && *pcToken == ' ')
    {
        pcToken++;
    }

    
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_acName = acTemp; 
    pcTemp = acTemp; 
    
    *pcToken++;

    
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_acMultiplex = acTemp; 
    pcTemp = acTemp; 
    
    pcToken = strtok_s(0, " :", &pcTok);

    
    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    
    int uiStartBit = atoi(acTemp);
    int uiStartBitX = uiStartBit;
    
    
    
    
    
    
    
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '@')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    m_ucLength = strtoul(acTemp, 0, 10); 
    
    m_ucDataFormat = *pcToken;

    if(SIG_DF_MOTOROLA == m_ucDataFormat)
    {
        
        
        
        


        
        
        int ntemp;

        if(uiStartBit == 0)
        {
            ntemp = 0;
        }
        else
        {
            ntemp = uiStartBit % 4;    
        }

        
        if(uiStartBit % 8 <= 3)
        {
            uiStartBit = uiStartBit + 7 - ntemp * 2;
        }
        else
        {
            uiStartBit = uiStartBit - 1 - ntemp * 2;
        }

        uiStartBit = uiStartBit + m_ucLength-1;
        
        uiStartBitX = (CConverter::ucMsg_DLC*8)-1 - uiStartBit;
    }

    m_ucWhichByte = uiStartBit / 8 + 1;
    m_ucStartBit = uiStartBitX % 8;

    
    
    
    if(m_ucLength > 32)
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT64 : SIG_TYPE_UINT64;
    }
    else
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT : SIG_TYPE_UINT;
    }

    
    pcToken = strtok_s(0, " (", &pcTok);
    pcTemp = acTemp;

    
    while(*pcToken && *pcToken != ',')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    m_fScaleFactor = (float)atof(acTemp); 
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ')')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    m_fOffset = (float)atof(acTemp); 
    
    pcToken = strtok_s(0, " [", &pcTok);
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    
    m_MinValue.dValue = atof(acTemp); 
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ']')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    
    m_MaxValue.dValue = atof(acTemp); 
    
    pcTemp = acTemp;
    pcToken++;

    
    while(*pcToken && *pcToken != '\"')
    {
        pcToken++;
    }

    pcToken++; 

    
    while(*pcToken && *pcToken != '\"')
    {
        *pcTemp++ = *pcToken++;
    }

    pcToken++; 
    *pcTemp='\0';
    m_acUnit = acTemp; 
    replace(m_acUnit.begin(), m_acUnit.end(), ',', '_'); 

    
    while(*pcToken && *pcToken == ' ')
    {
        pcToken++;
    }

    pcTemp = acTemp;

    while(*pcToken)
    {
        if ((*pcToken != '\r') && (*pcToken != ' '))
        {
            *pcTemp++ = *pcToken++;
        }
        else
        {
            pcToken++;
        }
    }

    *pcTemp='\0';

    
    if(strcmp(acTemp, "Vector__XXX") != 0)
    {
        m_rxNode = acTemp;
    }
    else
    {
        m_rxNode = "";
    }

    return 1;
}











int CSignal::AddValueDescriptors(char* pcLine, fstream& fileInput)
{
    char acValue[300];
    char acDesc[300];
    char acLine[1026] = {'\0'};
    char* pcToken, *pcTok;
    bool true_end = true;
    char* pcValue = acValue;
    char* pcDesc = acDesc;

    if(pcLine[strlen(pcLine)-1] != ';')
    {
        true_end = false;
    }

    
    while(*pcLine && (*pcLine == ' '))
    {
        *pcLine++;
    }

    while(*pcLine && (*pcLine != ';'))
    {
        if(true_end == false)
        {
            string pcTemp;
            fileInput.getline(acLine, 1026);
            pcTemp = pcLine;
            pcTemp += acLine;
            strncpy(pcLine, pcTemp.c_str(), sizeof(pcLine));

            if(pcLine[strlen(pcLine)-1] == ';')
            {
                true_end  = true;
            }
        }

        pcDesc = acDesc;

        while(*pcLine && (*pcLine == ' '))
        {
            pcLine++;
        }

        pcToken = strtok_s(pcLine, " ", &pcTok);
        strncpy_s(acValue, pcToken, sizeof(acValue));
        pcLine = pcLine + (strlen(pcToken)) + 1;

        if(*pcLine == '\"')
        {
            pcLine++;

            if(*pcLine != '\"')
            {
                *pcDesc++ = *pcLine++;

                while(*pcLine && (*pcLine != '\"'))
                {
                    if (*pcLine != '\r')
                    {
                        *pcDesc++ = *pcLine;
                    }

                    pcLine++;
                }
            }

            *pcDesc = '\0';
        }

        pcLine++;

        while(*pcLine == ' ')
        {
            pcLine++;
        }

        CValueDescriptor valDesc;

        if(this->m_ucLength <= 32)
        {
            valDesc.m_value.dValue = atof(acValue);
        }
        else
        {
            valDesc.m_value.i64Value = _atoi64(acValue);
        }

        valDesc.m_acDescriptor = acDesc;
        m_listValueDescriptor.push_back(valDesc);
        pcDesc = acDesc;
    }

    return 1;
}
















unsigned int CSignal::Validate(unsigned char ucFormat)
{
    
    





















    
    if(m_ucLength == 1) 
    {
        m_ucType = SIG_TYPE_BOOL;
    }

    m_uiError = SIG_EC_NO_ERR;

    

    
    switch(m_ucType)
    {
        case SIG_TYPE_BOOL:
        case SIG_TYPE_UINT:
        {
            unsigned long long int unMaxVal;
            unsigned long long int unMinVal;
            unConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, unMaxVal, unMinVal);
            m_MaxValue.uiValue = (unsigned int)unMaxVal;             
            m_MinValue.uiValue = (unsigned int)unMinVal;             
            unsigned int uiDefault;
			uiDefault = (unsigned int)(pow((float) 2.0, (int) m_ucLength) - 1);

            
            if(m_MaxValue.uiValue == 0 && m_MinValue.uiValue == 0)
            {
                m_MaxValue.uiValue = uiDefault;
                m_MinValue.uiValue = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if((m_MaxValue.uiValue > uiDefault) || (m_MaxValue.uiValue < 0))
            {
                m_MaxValue.uiValue = uiDefault;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if((m_MinValue.uiValue < 0) || (m_MinValue.uiValue > uiDefault))
            {
                m_MinValue.uiValue = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.uiValue == m_MinValue.uiValue)
            {
                if(m_MaxValue.uiValue == 0)
                {
                    
                    
                    m_MaxValue.uiValue = uiDefault;
                }

                m_MinValue.uiValue = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }
        }
        break;

        case SIG_TYPE_INT:
        {
            long long int nMaxVal;
            long long int nMinVal;
            nConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, nMaxVal, nMinVal);
            m_MaxValue.iValue = (int)nMaxVal;             
            m_MinValue.iValue = (int)nMinVal;             
            int iDefault;
            iDefault = (int)(unsigned int)1 << (m_ucLength - 1);
            iDefault -= 1;

            
            if(m_MaxValue.iValue == 0 && m_MinValue.iValue == 0)
            {
                m_MaxValue.iValue = iDefault;
                m_MinValue.iValue = -iDefault-1;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.iValue > iDefault || m_MaxValue.iValue < (-iDefault-1))
            {
                m_MaxValue.iValue = iDefault;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MinValue.iValue < (-iDefault-1) || m_MinValue.iValue > iDefault )
            {
                m_MinValue.iValue = (-iDefault-1);
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.iValue == m_MinValue.iValue)
            {
                m_MinValue.iValue = (-iDefault-1);
                m_uiError = SIG_EC_OVERFLOW;
            }

            break;
        }

        
        case SIG_TYPE_FLOAT:
            m_MaxValue.fValue = (float)m_MaxValue.dValue;
            m_MinValue.fValue = (float)m_MinValue.dValue;
            break;

            
        case SIG_TYPE_DOUBLE:
            
            break;

        case SIG_TYPE_INT64:
        {
            
            
            long long int nMaxVal;
            long long int nMinVal;
            nConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, nMaxVal, nMinVal);
            m_MaxValue.i64Value = nMaxVal;             
            m_MinValue.i64Value = nMinVal;             
            unsigned int unPower;
            __int64 i64Default;
            unsigned int i;
            







            unPower = m_ucLength - 1;
            i64Default = 1;

            for(i = 0; i<unPower; i++)
            {
                i64Default = (__int64)( 2*i64Default);
            }

            i64Default -= 1;

            if(m_MaxValue.i64Value == 0 && m_MinValue.i64Value == 0)
            {
                m_MaxValue.i64Value = i64Default;
                m_MinValue.i64Value = -i64Default-1;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.i64Value > i64Default || m_MaxValue.i64Value < (-i64Default-1))
            {
                m_MaxValue.i64Value = i64Default;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MinValue.i64Value < (-i64Default-1) || m_MinValue.i64Value > i64Default )
            {
                m_MinValue.i64Value = (-i64Default-1);
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.i64Value == m_MinValue.i64Value)
            {
                m_MinValue.i64Value = (-i64Default-1);
                m_uiError = SIG_EC_OVERFLOW;
            }
        }
        break;

        case SIG_TYPE_UINT64:
        {
            unsigned long long int unMaxVal;
            unsigned long long int unMinVal;
            unConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, unMaxVal, unMinVal);
            m_MaxValue.ui64Value = unMaxVal;             
            m_MinValue.ui64Value = unMinVal;             
            unsigned __int64 ui64Default;
            







            unsigned int unPower = m_ucLength - 1;
            ui64Default = 1;

            for(unsigned int i = 0; i < unPower; i++)
            {
                ui64Default = (unsigned __int64)( 2*ui64Default);
            }

            ui64Default -= 1;

            
            if(m_MaxValue.ui64Value == 0 && m_MinValue.ui64Value == 0)
            {
                m_MaxValue.ui64Value = ui64Default;
                m_MinValue.ui64Value = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.ui64Value > ui64Default || m_MaxValue.ui64Value < 0)
            {
                m_MaxValue.ui64Value = ui64Default;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MinValue.ui64Value < 0 || m_MinValue.ui64Value > ui64Default )
            {
                m_MinValue.ui64Value = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            
            if(m_MaxValue.ui64Value == m_MinValue.ui64Value)
            {
                m_MinValue.ui64Value = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            break;
        }

        default:
            break;
    }

    
    list<CValueDescriptor>::iterator rValDesc;

    for (rValDesc=m_listValueDescriptor.begin(); rValDesc!=m_listValueDescriptor.end(); ++rValDesc)
    {
        switch(m_ucType)
        {
            case SIG_TYPE_BOOL:
            case SIG_TYPE_UINT:
                rValDesc->m_value.uiValue = (unsigned int)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_INT:
                rValDesc->m_value.iValue = (int)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_FLOAT:
                rValDesc->m_value.fValue = (float)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_DOUBLE:
                break;

            case SIG_TYPE_INT64:
                
                break;

            case SIG_TYPE_UINT64:
                rValDesc->m_value.ui64Value = (unsigned long long)rValDesc->m_value.i64Value;
                break;

            default:
                break;
        }
    }

    return (m_uiError);
}







void CSignal::GetErrorString(string& str)
{
    switch(m_uiError)
    {
        case SIG_EC_NO_ERR:
            str = "No error";
            break;

        case SIG_EC_DATA_FORMAT_ERR:
            str = "Data format mismatch";
            break;

        case SIG_EC_LENGTH_ERR:
            str = "Invalid signal length";
            break;

        case SIG_EC_STARTBIT_ERR:
            str = "Invalid start bit";
            break;

        case SIG_EC_TYPE_ERR:
            str = "Invalid signal type";
            break;

        case SIG_EC_OVERFLOW:
            str = "Invalid Max or Min value.";
            break;

        default:
            str = "Unknown";
            break;
    }
}







void CSignal::GetErrorAction(string& str)
{
    switch(m_uiError)
    {
        case SIG_EC_OVERFLOW:
            str = "Value Set to default";
            break;

        default:
            str = "Signal Discarded";
            break;
    }
}












bool CSignal::WriteSignaltofile(fstream& fileOutput, list<CSignal> &m_listSignals, int m_ucLength, int m_cDataFormat, bool writeErr)
{
    bool bResult = true;
    list<CSignal>::iterator sig;

    for (sig=m_listSignals.begin(); sig!=m_listSignals.end(); ++sig)
    {
        
        
        if((sig->m_uiError == CSignal::SIG_EC_NO_ERR) || (sig->m_uiError == CSignal::SIG_EC_OVERFLOW) || writeErr)
        {
            
            
            
            fileOutput << "[""START_SIGNALS""]" << " " << sig->m_acName.c_str();
            fileOutput << "," << dec << sig->m_ucLength;
            fileOutput << "," << dec << sig->m_ucWhichByte;
            fileOutput << "," << dec << sig->m_ucStartBit;

            switch(sig->m_ucType)
            {
                case CSignal::SIG_TYPE_BOOL:
                case CSignal::SIG_TYPE_UINT:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << dec << sig->m_MaxValue.uiValue;
                    fileOutput << "," << dec << sig->m_MinValue.uiValue;
                    break;

                case CSignal::SIG_TYPE_INT:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << dec << sig->m_MaxValue.iValue;
                    fileOutput << "," << dec << sig->m_MinValue.iValue;
                    break;

                case CSignal::SIG_TYPE_FLOAT:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << sig->m_MaxValue.fValue;
                    fileOutput << "," << sig->m_MinValue.fValue;
                    break;

                case CSignal::SIG_TYPE_DOUBLE:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << sig->m_MaxValue.dValue;
                    fileOutput << "," << sig->m_MinValue.dValue;
                    break;

                case CSignal::SIG_TYPE_INT64:
                    fileOutput << ",I";
                    fileOutput << "," << dec << sig->m_MaxValue.i64Value;
                    fileOutput << "," << dec << sig->m_MinValue.i64Value;
                    break;

                case CSignal::SIG_TYPE_UINT64:
                    fileOutput << ",U";
                    fileOutput << "," << dec << sig->m_MaxValue.ui64Value;
                    fileOutput << "," << dec << sig->m_MinValue.ui64Value;
                    break;

                default:
                    break;
            }

            fileOutput << "," << sig->m_ucDataFormat;
            fileOutput << "," << sig->m_fOffset;
            fileOutput << "," << sig->m_fScaleFactor;
            fileOutput << "," << sig->m_acUnit.c_str();
            fileOutput << "," << sig->m_acMultiplex.c_str();
            fileOutput << "," << sig->m_rxNode.c_str() << endl;
            CValueDescriptor val;
            val.writeValueDescToFile(fileOutput, sig->m_ucType, sig->m_listValueDescriptor);

            if(sig->m_uiError == CSignal::SIG_EC_OVERFLOW)
            {
                bResult = false;
            }
        }
        else
        {
            bResult = false;
        }
    }

    return bResult;
}
         ™     ™     ”ÿÿÿÿ  ”ÿÿÿÿ    5[¨      expression was true       *pcLine   ™ÿÿÿÿ  ”     ™ÿÿÿÿ  ”      expression was false       *pcLine   ™ÿÿÿÿ  ”     ™ÿÿÿÿ  ”                   ‡     ‡   &  ‚ÿÿÿÿ  ‚ÿÿÿÿ    5K@      expression was true       (*pcLine != ';')   ‡ÿÿÿÿ  ‚     ‡ÿÿÿÿ  ‚   &   expression was false       (*pcLine != ';')   ‡ÿÿÿÿ  ‚     ‡ÿÿÿÿ  ‚   &               5I€        ‡     ‡     ‚ÿÿÿÿ  ‚ÿÿÿÿ    5Jh      expression was true       *pcLine   ‡ÿÿÿÿ  ‚     ‡ÿÿÿÿ  ‚      expression was false       *pcLine   ‡ÿÿÿÿ  ‚     ‡ÿÿÿÿ  ‚                   ‚     ‚   &  }ÿÿÿÿ  }ÿÿÿÿ    5DØ      expression was true       (*pcLine == ' ')   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }   &   expression was false       (*pcLine == ' ')   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }   &               5C        ‚     ‚     }ÿÿÿÿ  }ÿÿÿÿ    5D       expression was true       *pcLine   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }      expression was false       *pcLine   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }              
     O   #  O   4  Jÿÿÿÿ  Jÿÿÿÿ     ôà      expression was true       (*pcToken != ' ')   Oÿÿÿÿ  J   #  Oÿÿÿÿ  J   4   expression was false       (*pcToken != ' ')   Oÿÿÿÿ  J   #  Oÿÿÿÿ  J   4                ô€        O     O     Jÿÿÿÿ  Jÿÿÿÿ     ô€ø      expression was true       (*pcToken != '\r')   Oÿÿÿÿ  J     Oÿÿÿÿ  J      expression was false       (*pcToken != '\r')   Oÿÿÿÿ  J     Oÿÿÿÿ  J                   ô~P        F     F   &  Aÿÿÿÿ  Aÿÿÿÿ     ôx8      expression was true       *pcToken == ' '   Fÿÿÿÿ  A     Fÿÿÿÿ  A   &   expression was false       *pcToken == ' '   Fÿÿÿÿ  A     Fÿÿÿÿ  A   &                ôvˆ        F     F     Aÿÿÿÿ  Aÿÿÿÿ     ôw`      expression was true       *pcToken   Fÿÿÿÿ  A     Fÿÿÿÿ  A      expression was false       *pcToken   Fÿÿÿÿ  A     Fÿÿÿÿ  A                   ;     ;   '  6ÿÿÿÿ  6ÿÿÿÿ     ôo       expression was true       *pcToken != '\"'   ;ÿÿÿÿ  6     ;ÿÿÿÿ  6   '   expression was false       *pcToken != '\"'   ;ÿÿÿÿ  6     ;ÿÿÿÿ  6   '                ômP        ;     ;     6ÿÿÿÿ  6ÿÿÿÿ     ôn(      expression was true       *pcToken   ;ÿÿÿÿ  6     ;ÿÿÿÿ  6      expression was false       *pcToken   ;ÿÿÿÿ  6     ;ÿÿÿÿ  6                   3     3   '  .ÿÿÿÿ  .ÿÿÿÿ     ôi(      expression was true       *pcToken != '\"'   3ÿÿÿÿ  .     3ÿÿÿÿ  .   '   expression was false       *pcToken != '\"'   3ÿÿÿÿ  .     3ÿÿÿÿ  .   '                ôgx        3     3     .ÿÿÿÿ  .ÿÿÿÿ     ôhP      expression was true       *pcToken   3ÿÿÿÿ  .     3ÿÿÿÿ  .      expression was false       *pcToken   3ÿÿÿÿ  .     3ÿÿÿÿ  .                   %     %   &   ÿÿÿÿ   ÿÿÿÿ     ô^@      expression was true       *pcToken != ']'   %ÿÿÿÿ        %ÿÿÿÿ      &   expression was false       *pcToken != ']'   %ÿÿÿÿ        %ÿÿÿÿ      &                ô\        %     %      ÿÿÿÿ   ÿÿÿÿ     ô]h      expression was true       *pcToken   %ÿÿÿÿ        %ÿÿÿÿ         expression was false       *pcToken   %ÿÿÿÿ        %ÿÿÿÿ                              &  ÿÿÿÿ  ÿÿÿÿ     ôS˜      expression was true       *pcToken != '|'   ÿÿÿÿ       ÿÿÿÿ     &   expression was false       *pcToken != '|'   ÿÿÿÿ       ÿÿÿÿ     &                ôQè                   ÿÿÿÿ  ÿÿÿÿ     ôRÀ      expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                "             &  ÿÿÿÿ  ÿÿÿÿ     ôG(      expression was true       *pcToken != ')'   ÿÿÿÿ       ÿÿÿÿ     &   expression was false       *pcToken != ')'   ÿÿÿÿ       ÿÿÿÿ     &                ôEx   $               ÿÿÿÿ  ÿÿÿÿ     ôFP      expression was true       *pcToken   ÿÿÿÿ       ÿÿÿÿ        expression was false       *pcToken   ÿÿÿÿ       ÿÿÿÿ                &             &   ıÿÿÿÿ   ıÿÿÿÿ     êkØ      expression was true       *pcToken != ','   ÿÿÿÿ   ı     ÿÿÿÿ   ı   &   expression was false       *pcToken != ','   ÿÿÿÿ   ı     ÿÿÿÿ   ı   &                êj(   (                ıÿÿÿÿ   ıÿÿÿÿ     êk       expression was true       *pcToken   ÿÿÿÿ   ı     ÿÿÿÿ   ı      expression was false       *pcToken   ÿÿÿÿ   ı     ÿÿÿÿ   ı              *      ú      ú   )   õÿÿÿÿ   õÿÿÿÿ     êd      expression was true       (*(++pcToken) == '-')    úÿÿÿÿ   õ      úÿÿÿÿ   õ   )   expression was false       (*(++pcToken) == '-')    úÿÿÿÿ   õ      úÿÿÿÿ   õ   )                êb   ,      ö      ö   )   ñÿÿÿÿ   ñÿÿÿÿ     ê^È      expression was true       (*(++pcToken) == '-')    öÿÿÿÿ   ñ      öÿÿÿÿ   ñ   )   expression was false       (*(++pcToken) == '-')    öÿÿÿÿ   ñ      öÿÿÿÿ   ñ   )                ê]P   .      ¿      ¿   &   ºÿÿÿÿ   ºÿÿÿÿ     ê/      expression was true       *pcToken != '@'    ¿ÿÿÿÿ   º      ¿ÿÿÿÿ   º   &   expression was false       *pcToken != '@'    ¿ÿÿÿÿ   º      ¿ÿÿÿÿ   º   &                ê-à   0      ¿      ¿      ºÿÿÿÿ   ºÿÿÿÿ     ê.¸      expression was true       *pcToken    ¿ÿÿÿÿ   º      ¿ÿÿÿÿ   º      expression was false       *pcToken    ¿ÿÿÿÿ   º      ¿ÿÿÿÿ   º              2      «      «   &   ¦ÿÿÿÿ   ¦ÿÿÿÿ     4:€      expression was true       *pcToken != '|'    «ÿÿÿÿ   ¦      «ÿÿÿÿ   ¦   &   expression was false       *pcToken != '|'    «ÿÿÿÿ   ¦      «ÿÿÿÿ   ¦   &                48Ğ   4      «      «      ¦ÿÿÿÿ   ¦ÿÿÿÿ     49¨      expression was true       *pcToken    «ÿÿÿÿ   ¦      «ÿÿÿÿ   ¦      expression was false       *pcToken    «ÿÿÿÿ   ¦      «ÿÿÿÿ   ¦              6      Ÿ      Ÿ   &   šÿÿÿÿ   šÿÿÿÿ     4.ø      expression was true       *pcToken != ' '    Ÿÿÿÿÿ   š      Ÿÿÿÿÿ   š   &   expression was false       *pcToken != ' '    Ÿÿÿÿÿ   š      Ÿÿÿÿÿ   š   &                4-H   8      Ÿ      Ÿ      šÿÿÿÿ   šÿÿÿÿ     4.       expression was true       *pcToken    Ÿÿÿÿÿ   š      Ÿÿÿÿÿ   š      expression was false       *pcToken    Ÿÿÿÿÿ   š      Ÿÿÿÿÿ   š              :      “      “   &   ÿÿÿÿ   ÿÿÿÿ     4$¨      expression was true       *pcToken != ' '    “ÿÿÿÿ         “ÿÿÿÿ      &   expression was false       *pcToken != ' '    “ÿÿÿÿ         “ÿÿÿÿ      &                4"ø   <      “      “      ÿÿÿÿ   ÿÿÿÿ     4#Ğ      expression was true       *pcToken    “ÿÿÿÿ         “ÿÿÿÿ         expression was false       *pcToken    “ÿÿÿÿ         “ÿÿÿÿ                 >               &   ˆÿÿÿÿ   ˆÿÿÿÿ     4      expression was true       *pcToken == ' '    ÿÿÿÿ   ˆ      ÿÿÿÿ   ˆ   &   expression was false       *pcToken == ' '    ÿÿÿÿ   ˆ      ÿÿÿÿ   ˆ   &                4`   @                  ˆÿÿÿÿ   ˆÿÿÿÿ     48      expression was true       *pcToken    ÿÿÿÿ   ˆ      ÿÿÿÿ   ˆ      expression was false       *pcToken    ÿÿÿÿ   ˆ      ÿÿÿÿ   ˆ              B     [   %  [   =  Vÿÿÿÿ  Vÿÿÿÿ    +·0      expression was false       sig!=m_listSignals.end()   [ÿÿÿÿ  V   %  [ÿÿÿÿ  V   =               +°   C     ë   2  ë   W  æÿÿÿÿ  æÿÿÿÿ    +c      expression was false       rValDesc!=m_listValueDescriptor.end()   ëÿÿÿÿ  æ   2  ëÿÿÿÿ  æ   W               +OÈ   D     ½   %  ½   0  ¸ÿÿÿÿ  ¸ÿÿÿÿ    +)È      expression was false       i < unPower   ½ÿÿÿÿ  ¸   %  ½ÿÿÿÿ  ¸   0           E     …     …   !  €ÿÿÿÿ  €ÿÿÿÿ     ø0       expression was false       i<unPower   …ÿÿÿÿ  €     …ÿÿÿÿ  €   !           F     º     º     µÿÿÿÿ  µÿÿÿÿ    5z`      expression was false       *pcLine == ' '   ºÿÿÿÿ  µ     ºÿÿÿÿ  µ                  5xp   G     ™     ™   *  ”ÿÿÿÿ  ”ÿÿÿÿ    5\€      expression was true       (*pcLine == ' ')   ™ÿÿÿÿ  ”     ™ÿÿÿÿ  ”   *   expression was false       (*pcLine == ' ')   ™ÿÿÿÿ  ”     ™ÿÿÿÿ  ”   *               5ZÀ   I     ª     ª     ¥ÿÿÿÿ  ¥ÿÿÿÿ    5k      expression was true       *pcLine   ªÿÿÿÿ  ¥     ªÿÿÿÿ  ¥      expression was false       *pcLine   ªÿÿÿÿ  ¥     ªÿÿÿÿ  ¥              K     ª   "  ª   3  ¥ÿÿÿÿ  ¥ÿÿÿÿ    5kè      expression was true       (*pcLine != '\"')   ªÿÿÿÿ  ¥   "  ªÿÿÿÿ  ¥   3   expression was false       (*pcLine != '\"')   ªÿÿÿÿ  ¥   "  ªÿÿÿÿ  ¥   3               5j(   M             '  ÿÿÿÿ  ÿÿÿÿ    5¨      expression was true       m_MaxValue.uiValue == 0   ÿÿÿÿ       ÿÿÿÿ     '   expression was false       m_MaxValue.uiValue == 0   ÿÿÿÿ       ÿÿÿÿ     '               5›°   O     M     M     Hÿÿÿÿ  Hÿÿÿÿ     ô‡¸      expression was false       *pcToken   Mÿÿÿÿ  H     Mÿÿÿÿ  H              P        +     B  ÿÿÿÿ  ÿÿÿÿ    5      expression was true       m_MinValue.uiValue == 0   ÿÿÿÿ     +  ÿÿÿÿ     B   expression was false       m_MinValue.uiValue == 0   ÿÿÿÿ     +  ÿÿÿÿ     B               5œĞ   R             0  ÿÿÿÿ  ÿÿÿÿ     ÷Í       expression was true       (m_MaxValue.uiValue > uiDefault)   ÿÿÿÿ       ÿÿÿÿ     0   expression was false       (m_MaxValue.uiValue > uiDefault)   ÿÿÿÿ       ÿÿÿÿ     0                ÷Ë   T        4     L  ÿÿÿÿ  ÿÿÿÿ     ÷Íè      expression was true       (m_MaxValue.uiValue < 0)   ÿÿÿÿ     4  ÿÿÿÿ     L   expression was false       (m_MaxValue.uiValue < 0)   ÿÿÿÿ     4  ÿÿÿÿ     L                ÷Ì(   V     "     "   (  ÿÿÿÿ  ÿÿÿÿ     ÷ÖÈ      expression was true       (m_MinValue.uiValue < 0)   "ÿÿÿÿ       "ÿÿÿÿ     (   expression was false       (m_MinValue.uiValue < 0)   "ÿÿÿÿ       "ÿÿÿÿ     (                ÷ÔĞ   X     "   ,  "   L  ÿÿÿÿ  ÿÿÿÿ     ÷×°      expression was true       (m_MinValue.uiValue > uiDefault)   "ÿÿÿÿ     ,  "ÿÿÿÿ     L   expression was false       (m_MinValue.uiValue > uiDefault)   "ÿÿÿÿ     ,  "ÿÿÿÿ     L                ÷Õğ   Z     D     D   &  ?ÿÿÿÿ  ?ÿÿÿÿ     ÷öè      expression was true       m_MaxValue.iValue == 0   Dÿÿÿÿ  ?     Dÿÿÿÿ  ?   &   expression was false       m_MaxValue.iValue == 0   Dÿÿÿÿ  ?     Dÿÿÿÿ  ?   &                ÷ôğ   \     D   *  D   @  ?ÿÿÿÿ  ?ÿÿÿÿ     ÷÷Ğ      expression was true       m_MinValue.iValue == 0   Dÿÿÿÿ  ?   *  Dÿÿÿÿ  ?   @   expression was false       m_MinValue.iValue == 0   Dÿÿÿÿ  ?   *  Dÿÿÿÿ  ?   @                ÷ö   ^     L     L   ,  Gÿÿÿÿ  Gÿÿÿÿ     øH      expression was true       m_MaxValue.iValue > iDefault   Lÿÿÿÿ  G     Lÿÿÿÿ  G   ,   expression was false       m_MaxValue.iValue > iDefault   Lÿÿÿÿ  G     Lÿÿÿÿ  G   ,           `     L   0  L   Q  Gÿÿÿÿ  Gÿÿÿÿ     ø       expression was true       m_MaxValue.iValue < (-iDefault-1)   Lÿÿÿÿ  G   0  Lÿÿÿÿ  G   Q   expression was false       m_MaxValue.iValue < (-iDefault-1)   Lÿÿÿÿ  G   0  Lÿÿÿÿ  G   Q           b     S     S   1  Nÿÿÿÿ  Nÿÿÿÿ     ø	@      expression was true       m_MinValue.iValue < (-iDefault-1)   Sÿÿÿÿ  N     Sÿÿÿÿ  N   1   expression was false       m_MinValue.iValue < (-iDefault-1)   Sÿÿÿÿ  N     Sÿÿÿÿ  N   1           d     S   5  S   Q  Nÿÿÿÿ  Nÿÿÿÿ     ø
      expression was true       m_MinValue.iValue > iDefault   Sÿÿÿÿ  N   5  Sÿÿÿÿ  N   Q   expression was false       m_MinValue.iValue > iDefault   Sÿÿÿÿ  N   5  Sÿÿÿÿ  N   Q           f     Œ     Œ   (  ‡ÿÿÿÿ  ‡ÿÿÿÿ     ø4@      expression was true       m_MaxValue.i64Value == 0   Œÿÿÿÿ  ‡     Œÿÿÿÿ  ‡   (   expression was false       m_MaxValue.i64Value == 0   Œÿÿÿÿ  ‡     Œÿÿÿÿ  ‡   (                ø2H   h     Œ   ,  Œ   D  ‡ÿÿÿÿ  ‡ÿÿÿÿ     ø5(      expression was true       m_MinValue.i64Value == 0   Œÿÿÿÿ  ‡   ,  Œÿÿÿÿ  ‡   D   expression was false       m_MinValue.i64Value == 0   Œÿÿÿÿ  ‡   ,  Œÿÿÿÿ  ‡   D                ø3h   j     ”     ”   0  ÿÿÿÿ  ÿÿÿÿ     ø>°      expression was true       m_MaxValue.i64Value > i64Default   ”ÿÿÿÿ       ”ÿÿÿÿ     0   expression was false       m_MaxValue.i64Value > i64Default   ”ÿÿÿÿ       ”ÿÿÿÿ     0           l             :  ˜ÿÿÿÿ  ˜ÿÿÿÿ    +²X      expression was false       sig->m_uiError == CSignal::SIG_EC_OVERFLOW   ÿÿÿÿ  ˜     ÿÿÿÿ  ˜   :               +¯8   m     Û     Û   <  Öÿÿÿÿ  Öÿÿÿÿ    +KÀ      expression was false       m_MaxValue.ui64Value == m_MinValue.ui64Value   Ûÿÿÿÿ  Ö     Ûÿÿÿÿ  Ö   <               +G(   n     ”   4  ”   Y  ÿÿÿÿ  ÿÿÿÿ     ø?ˆ      expression was true       m_MaxValue.i64Value < (-i64Default-1)   ”ÿÿÿÿ     4  ”ÿÿÿÿ     Y   expression was false       m_MaxValue.i64Value < (-i64Default-1)   ”ÿÿÿÿ     4  ”ÿÿÿÿ     Y           p     ›     ›   5  –ÿÿÿÿ  –ÿÿÿÿ     øF°      expression was true       m_MinValue.i64Value < (-i64Default-1)   ›ÿÿÿÿ  –     ›ÿÿÿÿ  –   5   expression was false       m_MinValue.i64Value < (-i64Default-1)   ›ÿÿÿÿ  –     ›ÿÿÿÿ  –   5           r     ›   9  ›   Y  –ÿÿÿÿ  –ÿÿÿÿ     øGˆ      expression was true       m_MinValue.i64Value > i64Default   ›ÿÿÿÿ  –   9  ›ÿÿÿÿ  –   Y   expression was false       m_MinValue.i64Value > i64Default   ›ÿÿÿÿ  –   9  ›ÿÿÿÿ  –   Y           t     ¢     ¢   :  ÿÿÿÿ  ÿÿÿÿ    +      expression was false       m_MaxValue.i64Value == m_MinValue.i64Value   ¢ÿÿÿÿ       ¢ÿÿÿÿ     :               +(   u     Å     Å   )  Àÿÿÿÿ  Àÿÿÿÿ    +-è      expression was true       m_MaxValue.ui64Value == 0   Åÿÿÿÿ  À     Åÿÿÿÿ  À   )   expression was false       m_MaxValue.ui64Value == 0   Åÿÿÿÿ  À     Åÿÿÿÿ  À   )               ++ğ   w     Å   -  Å   F  Àÿÿÿÿ  Àÿÿÿÿ    +.Ğ      expression was true       m_MinValue.ui64Value == 0   Åÿÿÿÿ  À   -  Åÿÿÿÿ  À   F   expression was false       m_MinValue.ui64Value == 0   Åÿÿÿÿ  À   -  Åÿÿÿÿ  À   F               +-   y     Í     Í   2  Èÿÿÿÿ  Èÿÿÿÿ    +7p      expression was true       m_MaxValue.ui64Value > ui64Default   Íÿÿÿÿ  È     Íÿÿÿÿ  È   2   expression was false       m_MaxValue.ui64Value > ui64Default   Íÿÿÿÿ  È     Íÿÿÿÿ  È   2           {     Z     Z   6  Uÿÿÿÿ  Uÿÿÿÿ     ø       expression was false       m_MaxValue.iValue == m_MinValue.iValue   Zÿÿÿÿ  U     Zÿÿÿÿ  U   6                øÀ   |     Í   6  Í   N  Èÿÿÿÿ  Èÿÿÿÿ    +8H      expression was true       m_MaxValue.ui64Value < 0   Íÿÿÿÿ  È   6  Íÿÿÿÿ  È   N   expression was false       m_MaxValue.ui64Value < 0   Íÿÿÿÿ  È   6  Íÿÿÿÿ  È   N           ~     Ô     Ô   (  Ïÿÿÿÿ  Ïÿÿÿÿ    +?p      expression was true       m_MinValue.ui64Value < 0   Ôÿÿÿÿ  Ï     Ôÿÿÿÿ  Ï   (   expression was false       m_MinValue.ui64Value < 0   Ôÿÿÿÿ  Ï     Ôÿÿÿÿ  Ï   (           €     Ô   ,  Ô   N  Ïÿÿÿÿ  Ïÿÿÿÿ    +@H      expression was true       m_MinValue.ui64Value > ui64Default   Ôÿÿÿÿ  Ï   ,  Ôÿÿÿÿ  Ï   N   expression was false       m_MinValue.ui64Value > ui64Default   Ôÿÿÿÿ  Ï   ,  Ôÿÿÿÿ  Ï   N           ‚     +     +   +  &ÿÿÿÿ  &ÿÿÿÿ     ÷ã@      expression was false       m_MaxValue.uiValue == 0   +ÿÿÿÿ  &     +ÿÿÿÿ  &   +                ÷ßĞ   ƒ     )     )   8  $ÿÿÿÿ  $ÿÿÿÿ     ÷ç°      expression was false       m_MaxValue.uiValue == m_MinValue.uiValue   )ÿÿÿÿ  $     )ÿÿÿÿ  $   8                ÷Ş˜   „     _     _   6  Zÿÿÿÿ  Zÿÿÿÿ    +…       expression was true       (sig->m_uiError == CSignal::SIG_EC_NO_ERR)   _ÿÿÿÿ  Z     _ÿÿÿÿ  Z   6   expression was false       (sig->m_uiError == CSignal::SIG_EC_NO_ERR)   _ÿÿÿÿ  Z     _ÿÿÿÿ  Z   6               +ø   †     _   :  _   f  Zÿÿÿÿ  Zÿÿÿÿ    +†      expression was true       (sig->m_uiError == CSignal::SIG_EC_OVERFLOW)   _ÿÿÿÿ  Z   :  _ÿÿÿÿ  Z   f   expression was false       (sig->m_uiError == CSignal::SIG_EC_OVERFLOW)   _ÿÿÿÿ  Z   :  _ÿÿÿÿ  Z   f               +„8   ˆ     _   j  _   r  Zÿÿÿÿ  Zÿÿÿÿ    +‰      expression was true       writeErr   _ÿÿÿÿ  Z   j  _ÿÿÿÿ  Z   r   expression was false       writeErr   _ÿÿÿÿ  Z   j  _ÿÿÿÿ  Z   r           Š     û     û     öÿÿÿÿ  öÿÿÿÿ    5ˆ      expression was false       m_ucLength == 1   ûÿÿÿÿ  ö     ûÿÿÿÿ  ö                  5Šh   ‹     ¬     ¬   (  §ÿÿÿÿ  §ÿÿÿÿ    5p°      expression was false       *pcLine != '\r'   ¬ÿÿÿÿ  §     ¬ÿÿÿÿ  §   (               5mà   Œ     ¦     ¦     ¡ÿÿÿÿ  ¡ÿÿÿÿ    5tp      expression was false       *pcLine != '\"'   ¦ÿÿÿÿ  ¡     ¦ÿÿÿÿ  ¡                  5gH        ¢     ¢     ÿÿÿÿ  ÿÿÿÿ    5wH      expression was false       *pcLine == '\"'   ¢ÿÿÿÿ       ¢ÿÿÿÿ                    5f        ‘     ‘   /  Œÿÿÿÿ  Œÿÿÿÿ    5Uè      expression was false       pcLine[strlen(pcLine)-1] == ';'   ‘ÿÿÿÿ  Œ     ‘ÿÿÿÿ  Œ   /               5RÀ        ‰     ‰     „ÿÿÿÿ  „ÿÿÿÿ    5W¨      expression was false       true_end == false   ‰ÿÿÿÿ  „     ‰ÿÿÿÿ  „                  5M˜        |     |   '  wÿÿÿÿ  wÿÿÿÿ    5AX      expression was false       pcLine[strlen(pcLine)-1] != ';'   |ÿÿÿÿ  w     |ÿÿÿÿ  w   '               5>H   ‘      Ê      Ê   )   Åÿÿÿÿ   Åÿÿÿÿ     êUx      expression was false       SIG_DF_MOTOROLA == m_ucDataFormat    Êÿÿÿÿ   Å      Êÿÿÿÿ   Å   )                ê8    ’     ¨     ¨     £ÿÿÿÿ  £ÿÿÿÿ    +¸       statement executed        return bResult;   ¨ÿÿÿÿ  £     ¨ÿÿÿÿ  £              “     ¥   	  ¥   
   ÿÿÿÿ   ÿÿÿÿ    +µp       statement executed        }   ¥ÿÿÿÿ      	  ¥ÿÿÿÿ      
           ”     ¡   	  ¡   
  œÿÿÿÿ  œÿÿÿÿ    +³@       statement executed        }   ¡ÿÿÿÿ  œ   	  ¡ÿÿÿÿ  œ   
           •                 ›ÿÿÿÿ  ›ÿÿÿÿ    +±€       statement executed        }    ÿÿÿÿ  ›      ÿÿÿÿ  ›              –     ‘     ‘     Œÿÿÿÿ  Œÿÿÿÿ    +§8       statement executed        break;   ‘ÿÿÿÿ  Œ     ‘ÿÿÿÿ  Œ              —               ‰ÿÿÿÿ  ‰ÿÿÿÿ    +¦`       statement executed        break;   ÿÿÿÿ  ‰     ÿÿÿÿ  ‰              ˜     ˆ     ˆ     ƒÿÿÿÿ  ƒÿÿÿÿ    +¢       statement executed        break;   ˆÿÿÿÿ  ƒ     ˆÿÿÿÿ  ƒ              ™     ‚     ‚     }ÿÿÿÿ  }ÿÿÿÿ    +À       statement executed        break;   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }              š     |     |     wÿÿÿÿ  wÿÿÿÿ    +šø       statement executed        break;   |ÿÿÿÿ  w     |ÿÿÿÿ  w              ›     v     v     qÿÿÿÿ  qÿÿÿÿ    +—0       statement executed        break;   vÿÿÿÿ  q     vÿÿÿÿ  q              œ     p     p     kÿÿÿÿ  kÿÿÿÿ    +’è       statement executed        break;   pÿÿÿÿ  k     pÿÿÿÿ  k                   I     I     Dÿÿÿÿ  Dÿÿÿÿ    +zp       statement executed        }   Iÿÿÿÿ  D     Iÿÿÿÿ  D                   G     G     Bÿÿÿÿ  Bÿÿÿÿ    +y˜       statement executed        break;   Gÿÿÿÿ  B     Gÿÿÿÿ  B              Ÿ     C     C     >ÿÿÿÿ  >ÿÿÿÿ    +w¨       statement executed        break;   Cÿÿÿÿ  >     Cÿÿÿÿ  >                    5     5     0ÿÿÿÿ  0ÿÿÿÿ    +t        statement executed        }   5ÿÿÿÿ  0     5ÿÿÿÿ  0              ¡     3     3     .ÿÿÿÿ  .ÿÿÿÿ    +s(       statement executed        break;   3ÿÿÿÿ  .     3ÿÿÿÿ  .              ¢     /     /     *ÿÿÿÿ  *ÿÿÿÿ    +q8       statement executed        break;   /ÿÿÿÿ  *     /ÿÿÿÿ  *              £     +     +     &ÿÿÿÿ  &ÿÿÿÿ    +oH       statement executed        break;   +ÿÿÿÿ  &     +ÿÿÿÿ  &              ¤     '     '     "ÿÿÿÿ  "ÿÿÿÿ    +mX       statement executed        break;   'ÿÿÿÿ  "     'ÿÿÿÿ  "              ¥     #     #     ÿÿÿÿ  ÿÿÿÿ    +kh       statement executed        break;   #ÿÿÿÿ       #ÿÿÿÿ                ¦               ÿÿÿÿ  ÿÿÿÿ    +ix       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                §               ÿÿÿÿ  ÿÿÿÿ    +gˆ       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                ¨               ÿÿÿÿ  ÿÿÿÿ    +cø       statement executed        return (m_uiError);   ÿÿÿÿ       ÿÿÿÿ                ©     
     
     ÿÿÿÿ  ÿÿÿÿ    +b8       statement executed        }   
ÿÿÿÿ       
ÿÿÿÿ                ª               ÿÿÿÿ  ÿÿÿÿ    +a`       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                «                ÿÿÿÿ   ÿÿÿÿ    +`ˆ       statement executed        break;   ÿÿÿÿ        ÿÿÿÿ                 ¬               üÿÿÿÿ  üÿÿÿÿ    +\Ø       statement executed        break;   ÿÿÿÿ  ü     ÿÿÿÿ  ü              ­     ı     ı     øÿÿÿÿ  øÿÿÿÿ    +\        statement executed        break;   ıÿÿÿÿ  ø     ıÿÿÿÿ  ø              ®     ú     ú     õÿÿÿÿ  õÿÿÿÿ    +[(       statement executed        break;   úÿÿÿÿ  õ     úÿÿÿÿ  õ              ¯     ö     ö     ñÿÿÿÿ  ñÿÿÿÿ    +Wˆ       statement executed        break;   öÿÿÿÿ  ñ     öÿÿÿÿ  ñ              °     ò     ò     íÿÿÿÿ  íÿÿÿÿ    +Sè       statement executed        break;   òÿÿÿÿ  í     òÿÿÿÿ  í              ±     å     å     àÿÿÿÿ  àÿÿÿÿ    +M€       statement executed        break;   åÿÿÿÿ  à     åÿÿÿÿ  à              ²     á     á     Üÿÿÿÿ  Üÿÿÿÿ    +L¨       statement executed        break;   áÿÿÿÿ  Ü     áÿÿÿÿ  Ü              ³     ß     ß     Úÿÿÿÿ  Úÿÿÿÿ    +Jè       statement executed        }   ßÿÿÿÿ  Ú     ßÿÿÿÿ  Ú              ´     Ø     Ø     Óÿÿÿÿ  Óÿÿÿÿ    +Dğ       statement executed        }   Øÿÿÿÿ  Ó     Øÿÿÿÿ  Ó              µ     Ñ     Ñ     Ìÿÿÿÿ  Ìÿÿÿÿ    +=8       statement executed        }   Ñÿÿÿÿ  Ì     Ñÿÿÿÿ  Ì              ¶     Ê     Ê     Åÿÿÿÿ  Åÿÿÿÿ    +58       statement executed        }   Êÿÿÿÿ  Å     Êÿÿÿÿ  Å              ·     À     À     »ÿÿÿÿ  »ÿÿÿÿ    +(ğ       statement executed        }   Àÿÿÿÿ  »     Àÿÿÿÿ  »              ¸     ¨   	  ¨     £ÿÿÿÿ  £ÿÿÿÿ    +x       statement executed        break;   ¨ÿÿÿÿ  £   	  ¨ÿÿÿÿ  £              ¹     ¦     ¦     ¡ÿÿÿÿ  ¡ÿÿÿÿ    +¸       statement executed        }   ¦ÿÿÿÿ  ¡     ¦ÿÿÿÿ  ¡              º     Ÿ     Ÿ     šÿÿÿÿ  šÿÿÿÿ    +ğ       statement executed        }   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š              »     ˜     ˜     “ÿÿÿÿ  “ÿÿÿÿ     øDx       statement executed        }   ˜ÿÿÿÿ  “     ˜ÿÿÿÿ  “              ¼     ‘     ‘     Œÿÿÿÿ  Œÿÿÿÿ     ø<x       statement executed        }   ‘ÿÿÿÿ  Œ     ‘ÿÿÿÿ  Œ              ½     ˆ     ˆ     ƒÿÿÿÿ  ƒÿÿÿÿ     ø/H       statement executed        }   ˆÿÿÿÿ  ƒ     ˆÿÿÿÿ  ƒ              ¾     l     l     gÿÿÿÿ  gÿÿÿÿ     ø ˜       statement executed        break;   lÿÿÿÿ  g     lÿÿÿÿ  g              ¿     g     g     bÿÿÿÿ  bÿÿÿÿ     øÀ       statement executed        break;   gÿÿÿÿ  b     gÿÿÿÿ  b              À     `     `     [ÿÿÿÿ  [ÿÿÿÿ     ø       statement executed        break;   `ÿÿÿÿ  [     `ÿÿÿÿ  [              Á     ^     ^     Yÿÿÿÿ  Yÿÿÿÿ     øH       statement executed        }   ^ÿÿÿÿ  Y     ^ÿÿÿÿ  Y              Â     W     W     Rÿÿÿÿ  Rÿÿÿÿ     øˆ       statement executed        }   Wÿÿÿÿ  R     Wÿÿÿÿ  R              Ã     P     P     Kÿÿÿÿ  Kÿÿÿÿ     ø       statement executed        }   Pÿÿÿÿ  K     Pÿÿÿÿ  K              Ä     I     I     Dÿÿÿÿ  Dÿÿÿÿ     ÷ÿ       statement executed        }   Iÿÿÿÿ  D     Iÿÿÿÿ  D              Å     6   	  6     1ÿÿÿÿ  1ÿÿÿÿ     ÷è˜       statement executed        break;   6ÿÿÿÿ  1   	  6ÿÿÿÿ  1              Æ     4     4     /ÿÿÿÿ  /ÿÿÿÿ     ÷æØ       statement executed        }   4ÿÿÿÿ  /     4ÿÿÿÿ  /              Ç     0     0     +ÿÿÿÿ  +ÿÿÿÿ     ÷âh       statement executed        }   0ÿÿÿÿ  +     0ÿÿÿÿ  +              È     &     &     !ÿÿÿÿ  !ÿÿÿÿ     ÷Ü`       statement executed        }   &ÿÿÿÿ  !     &ÿÿÿÿ  !              É               ÿÿÿÿ  ÿÿÿÿ     ÷Òà       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Ê               ÿÿÿÿ  ÿÿÿÿ     ÷É       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Ë     ş     ş     ùÿÿÿÿ  ùÿÿÿÿ    5Œ°       statement executed        }   şÿÿÿÿ  ù     şÿÿÿÿ  ù              Ì     Ï     Ï     Êÿÿÿÿ  Êÿÿÿÿ    5ˆH       statement executed        return 1;   Ïÿÿÿÿ  Ê     Ïÿÿÿÿ  Ê              Í     Í     Í     Èÿÿÿÿ  Èÿÿÿÿ    5†ˆ       statement executed        }   Íÿÿÿÿ  È     Íÿÿÿÿ  È              Î     È   	  È   
  Ãÿÿÿÿ  Ãÿÿÿÿ    5h       statement executed        }   Èÿÿÿÿ  Ã   	  Èÿÿÿÿ  Ã   
           Ï     Ä   	  Ä   
  ¿ÿÿÿÿ  ¿ÿÿÿÿ    5~È       statement executed        }   Äÿÿÿÿ  ¿   	  Äÿÿÿÿ  ¿   
           Ğ     ½   	  ½   
  ¸ÿÿÿÿ  ¸ÿÿÿÿ    5yˆ       statement executed        }   ½ÿÿÿÿ  ¸   	  ½ÿÿÿÿ  ¸   
           Ñ     ¶   	  ¶   
  ±ÿÿÿÿ  ±ÿÿÿÿ    5vp       statement executed        }   ¶ÿÿÿÿ  ±   	  ¶ÿÿÿÿ  ±   
           Ò     ³     ³     ®ÿÿÿÿ  ®ÿÿÿÿ    5s˜       statement executed        }   ³ÿÿÿÿ  ®     ³ÿÿÿÿ  ®              Ó     ²     ²     ­ÿÿÿÿ  ­ÿÿÿÿ    5qØ       statement executed        }   ²ÿÿÿÿ  ­     ²ÿÿÿÿ  ­              Ô     ¯     ¯     ªÿÿÿÿ  ªÿÿÿÿ    5oØ       statement executed        }   ¯ÿÿÿÿ  ª     ¯ÿÿÿÿ  ª              Õ     œ   	  œ   
  —ÿÿÿÿ  —ÿÿÿÿ    5^       statement executed        }   œÿÿÿÿ  —   	  œÿÿÿÿ  —   
           Ö     •   	  •   
  ÿÿÿÿ  ÿÿÿÿ    5VĞ       statement executed        }   •ÿÿÿÿ     	  •ÿÿÿÿ     
           ×     ”     ”     ÿÿÿÿ  ÿÿÿÿ    5U       statement executed        }   ”ÿÿÿÿ       ”ÿÿÿÿ                Ø     …     …     €ÿÿÿÿ  €ÿÿÿÿ    5Fè       statement executed        }   …ÿÿÿÿ  €     …ÿÿÿÿ  €              Ù               zÿÿÿÿ  zÿÿÿÿ    5@€       statement executed        }   ÿÿÿÿ  z     ÿÿÿÿ  z              Ú     e     e     `ÿÿÿÿ  `ÿÿÿÿ    55H       statement executed        return 1;   eÿÿÿÿ  `     eÿÿÿÿ  `              Û     c     c     ^ÿÿÿÿ  ^ÿÿÿÿ    53ˆ       statement executed        }   cÿÿÿÿ  ^     cÿÿÿÿ  ^              Ü     _     _     Zÿÿÿÿ  Zÿÿÿÿ    52       statement executed        }   _ÿÿÿÿ  Z     _ÿÿÿÿ  Z              İ     V   	  V   
  Qÿÿÿÿ  Qÿÿÿÿ     ô…ø       statement executed        }   Vÿÿÿÿ  Q   	  Vÿÿÿÿ  Q   
           Ş     R   	  R   
  Mÿÿÿÿ  Mÿÿÿÿ     ô„à       statement executed        }   Rÿÿÿÿ  M   	  Rÿÿÿÿ  M   
           ß     I     I     Dÿÿÿÿ  Dÿÿÿÿ     ôz`       statement executed        }   Iÿÿÿÿ  D     Iÿÿÿÿ  D              à     >     >     9ÿÿÿÿ  9ÿÿÿÿ     ôqè       statement executed        }   >ÿÿÿÿ  9     >ÿÿÿÿ  9              á     6     6     1ÿÿÿÿ  1ÿÿÿÿ     ôkP       statement executed        }   6ÿÿÿÿ  1     6ÿÿÿÿ  1              â     (     (     #ÿÿÿÿ  #ÿÿÿÿ     ôa@       statement executed        }   (ÿÿÿÿ  #     (ÿÿÿÿ  #              ã               ÿÿÿÿ  ÿÿÿÿ     ôV˜       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ä               ÿÿÿÿ  ÿÿÿÿ     ôJ(       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                å                ÿÿÿÿ   ÿÿÿÿ     ênØ       statement executed        }   ÿÿÿÿ        ÿÿÿÿ                 æ      û      û      öÿÿÿÿ   öÿÿÿÿ     êeØ       statement executed        }    ûÿÿÿÿ   ö      ûÿÿÿÿ   ö              ç      ÷      ÷      òÿÿÿÿ   òÿÿÿÿ     ê`˜       statement executed        }    ÷ÿÿÿÿ   ò      ÷ÿÿÿÿ   ò              è      ì      ì      çÿÿÿÿ   çÿÿÿÿ     êT        statement executed        }    ìÿÿÿÿ   ç      ìÿÿÿÿ   ç              é      ç   	   ç   
   âÿÿÿÿ   âÿÿÿÿ     êK       statement executed        }    çÿÿÿÿ   â   	   çÿÿÿÿ   â   
           ê      ã   	   ã   
   Şÿÿÿÿ   Şÿÿÿÿ     êFÀ       statement executed        }    ãÿÿÿÿ   Ş   	   ãÿÿÿÿ   Ş   
           ë      İ   	   İ   
   Øÿÿÿÿ   Øÿÿÿÿ     ê?€       statement executed        }    İÿÿÿÿ   Ø   	   İÿÿÿÿ   Ø   
           ì      Ù   	   Ù   
   Ôÿÿÿÿ   Ôÿÿÿÿ     ê<`       statement executed        }    Ùÿÿÿÿ   Ô   	   Ùÿÿÿÿ   Ô   
           í      Â      Â      ½ÿÿÿÿ   ½ÿÿÿÿ     ê2       statement executed        }    Âÿÿÿÿ   ½      Âÿÿÿÿ   ½              î      ®      ®      ©ÿÿÿÿ   ©ÿÿÿÿ     4=€       statement executed        }    ®ÿÿÿÿ   ©      ®ÿÿÿÿ   ©              ï      ¢      ¢      ÿÿÿÿ   ÿÿÿÿ     41ø       statement executed        }    ¢ÿÿÿÿ         ¢ÿÿÿÿ                 ğ      –      –      ‘ÿÿÿÿ   ‘ÿÿÿÿ     4'       statement executed        }    –ÿÿÿÿ   ‘      –ÿÿÿÿ   ‘              ñ                  ‹ÿÿÿÿ   ‹ÿÿÿÿ     4!8       statement executed        }    ÿÿÿÿ   ‹      ÿÿÿÿ   ‹              ò      s      s      nÿÿÿÿ   nÿÿÿÿ     4h       statement executed        return (*this);    sÿÿÿÿ   n      sÿÿÿÿ   n              ó      S      S      Nÿÿÿÿ   Nÿÿÿÿ     3ıˆ       statement executed        }    Sÿÿÿÿ   N      Sÿÿÿÿ   N              ô      G      G      Bÿÿÿÿ   Bÿÿÿÿ     3ûh       statement executed        }    Gÿÿÿÿ   B      Gÿÿÿÿ   B           CSignal::CSignal CSignal::CSignal()    +      G      &ÿÿÿÿ   BÿÿÿÿCSignal::~CSignal CSignal::~CSignal()    P      S      Kÿÿÿÿ   NÿÿÿÿCSignal::operator= CSignal& CSignal::operator=(CSignal& signal)    `      t      [ÿÿÿÿ   oÿÿÿÿCSignal::Format int CSignal::Format(char* pcLine)    €     f      {ÿÿÿÿ  aÿÿÿÿCSignal::AddValueDescriptors int CSignal::AddValueDescriptors(char* pcLine, fstream& fileInput)   s     Ğ     nÿÿÿÿ  ËÿÿÿÿCSignal::Validate unsigned int CSignal::Validate(unsigned char ucFormat)   â          İÿÿÿÿ  ÿÿÿÿCSignal::GetErrorString void CSignal::GetErrorString(string& str)        5     ÿÿÿÿ  0ÿÿÿÿCSignal::GetErrorAction void CSignal::GetErrorAction(string& str)   >     I     9ÿÿÿÿ  DÿÿÿÿCSignal::WriteSignaltofile bool CSignal::WriteSignaltofile(fstream& fileOutput, list<CSignal> &m_listSignals, int m_ucLength, int m_cDataFormat, bool writeErr)   W     ©     Rÿÿÿÿ  ¤ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Signal.cpp
 * \brief     Implementation of signal class
 * \authors   Amitesh Bharti, Pemmaiah BD, Mahesh.B.S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the signal class.
 */

/* C++ includes */
#include <algorithm>

/* Project includes */
#include "Converter.h"
#include "Signal.h"
#include "Tag.h"
#include "Utility.h"
#include "Math.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CSignal
 */
CSignal::CSignal()
{
    m_acMultiplex = "";
    m_acName = "";
    m_ucLength = 1; // minimum signal length should be 1 bit
    m_ucWhichByte = 1; // ONE based index
    m_ucStartBit = 0; // ZERO based index
    m_ucType = SIG_TYPE_BOOL; // let default be bool type -- match with default length
    m_MaxValue.iValue = 1; // use unsigned int field for bool also
    m_MaxValue.uiValue = 1;
    m_MaxValue.fValue = 1;
    m_MaxValue.dValue = 1;
    m_MaxValue.cValue = "";
    m_MaxValue.i64Value = 1;
    m_MaxValue.ui64Value = 1;
    m_MinValue.iValue = 0;
    m_MinValue.uiValue = 0;
    m_MinValue.fValue = 0;
    m_MinValue.dValue = 0;
    m_MinValue.cValue = "";
    m_MinValue.i64Value = 0;
    m_MinValue.ui64Value = 0;
    m_ucDataFormat = SIG_DF_INTEL;
    m_fOffset = 0.0f;
    m_fScaleFactor = 1.0f;
    m_acUnit = "";
    m_uiError = SIG_EC_NO_ERR;
    m_rxNode = "";
    m_listValueDescriptor.clear();
}


/**
 * \brief Destructor
 *
 * Destructor of CSignal
 */
CSignal::~CSignal()
{
    // clear the embedded value descriptor list before destroying the signal
    m_listValueDescriptor.clear();
}


/**
 * \brief     overloaded operator =
 * \param[in] signal Data to assign
 * \return    Reference to local object
 *
 * Overload assignment operator. We should clear the existing value descriptor
 * list and copy contents of the argument's list to this signal. The rest of the
 * members are copied by value
 */
CSignal& CSignal::operator=(CSignal& signal)
{
    m_listValueDescriptor.clear(); // clear the list first
    // copy all the data members except the list
    m_acMultiplex = signal.m_acMultiplex;
    m_acName = signal.m_acName;
    m_ucLength = signal.m_ucLength;
    m_ucWhichByte = signal.m_ucWhichByte;
    m_ucStartBit = signal.m_ucStartBit;
    m_ucType = signal.m_ucType;
    m_MaxValue = signal.m_MaxValue;
    m_MinValue = signal.m_MinValue;
    m_ucDataFormat = signal.m_ucDataFormat;
    m_fOffset = signal.m_fOffset;
    m_fScaleFactor = signal.m_fScaleFactor;
    m_acUnit = signal.m_acUnit;
    m_rxNode = signal.m_rxNode;
    m_uiError = signal.m_uiError;
    // now copy the list
    m_listValueDescriptor = signal.m_listValueDescriptor;
    return (*this);
}


/**
 * \brief     Extracts the message data from the given Line
 * \param[in] pcLine the given Line
 * \return    Status code
 *
 * Extracts the message data from the given Line and populates
 * the message structure.
 */
int CSignal::Format(char* pcLine)
{
    char* pcToken;
    char acTemp[defVTAB_MAX_LINE_LEN],*pcTemp,*pcTok;
    pcTemp = acTemp;
    // get signal name
    // in older versions of CANoe it can be in any of this format
    // <SIG_NAME :> -- standard signal
    // <SIG_NAME M :> -- mode signal
    // <SIG_NAME mk :> -- mode dependent signal
    pcToken = strtok_s(pcLine, ":", &pcTok); // get upto colon

    // copy only signal name because we BUSMASTER does not support modes
    // skip leading spaces first
    while(*pcToken && *pcToken == ' ')
    {
        pcToken++;
    }

    // now get the signal name
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; // copy SIG_NAME only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_acName = acTemp; // copy the name to the signal's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer
    //leave blank space
    *pcToken++;

    //Find the signal's multiplexing details
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; // copy SIG_NAME only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_acMultiplex = acTemp; // copy the name to the signal's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer
    // next token (START_BIT|LENGTH@DATA_FORMAT(+/-))
    pcToken = strtok_s(NULL, " :", &pcTok);

    // get start bit
    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip '|'
    // store the start byte and start bit information
    int uiStartBit = atoi(acTemp);
    int uiStartBitX = uiStartBit;
    // rajesh: 21-03-2003: begin:
    // based on INTEL/MOTOROLA - the start bit is represnted differently by CANoe.
    // With motorola format, bits are stored in reverse order. BUSMASTER
    // does not differentiate between INTEL and MOTOROLA at this stage and START_BYTE
    // and START_BIT are not depending on this. So process this after identifying the
    // format. Original code commented - moved down.
    // rajesh: 21-03-2003: end_1: continued below
    // get signal length
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '@')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip '@'
    m_ucLength = strtoul(acTemp, NULL, 10); // store signal length
    // get DATA_FORMAT (intel or motorola)
    m_ucDataFormat = *pcToken;

    if(SIG_DF_MOTOROLA == m_ucDataFormat)
    {
        //The following is done because if signal type is of MOTOROLA
        //THe MSB is stored and will be in Big Endian format.
        //Get the LSB
        /*In CANoe if we view the bits as a 8x8 Matrix, for Motorala signals
        the numbering will be in the reverse order with in the each row. So to get the
        proper MSB we need to again swap the bit position with in the row*/
        //i.e here we need to get the left half of the bits to the right and right
        //to the left with in the same row
        int ntemp;

        if(uiStartBit == 0)
        {
            ntemp = 0;
        }
        else
        {
            ntemp = uiStartBit % 4;    //get the bit position with its the row.
        }

        //swap left bits to the right and right bits to the left.
        if(uiStartBit % 8 <= 3)
        {
            uiStartBit = uiStartBit + 7 - ntemp * 2;
        }
        else
        {
            uiStartBit = uiStartBit - 1 - ntemp * 2;
        }

        uiStartBit = uiStartBit + m_ucLength-1;
        //Invert the bit position (Converting to little endian format)
        uiStartBitX = (CConverter::ucMsg_DLC*8)-1 - uiStartBit;
    }

    m_ucWhichByte = uiStartBit / 8 + 1;
    m_ucStartBit = uiStartBitX % 8;

    // get sign of signal. At this point we know only whether the
    // signal is signed or unsigned. Whether it is float or double
    // will be known later only when we process "SIG_VALTYPE_"
    if(m_ucLength > 32)
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT64 : SIG_TYPE_UINT64;
    }
    else
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT : SIG_TYPE_UINT;
    }

    // next token - (SCALE_FACTOR,OFFSET)
    pcToken = strtok_s(NULL, " (", &pcTok);
    pcTemp = acTemp;

    // get scale factor
    while(*pcToken && *pcToken != ',')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip ','
    m_fScaleFactor = (float)atof(acTemp); // store scale factor
    // Get offset
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ')')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    m_fOffset = (float)atof(acTemp); // store Offset
    // next token [MIN|MAX]
    pcToken = strtok_s(NULL, " [", &pcTok);
    // get MIN
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip '|'
    //venkat
    m_MinValue.dValue = atof(acTemp); // store MIN
    // get MAX value
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ']')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip ']'
    //venkat
    m_MaxValue.dValue = atof(acTemp); // store MAX value
    // next token -- "UNIT", ""
    pcTemp = acTemp;
    pcToken++;

    // go to '"'
    while(*pcToken && *pcToken != '\"')
    {
        pcToken++;
    }

    pcToken++; // skip '"'

    // copy everything, but not including the last <">
    while(*pcToken && *pcToken != '\"')
    {
        *pcTemp++ = *pcToken++;
    }

    pcToken++; // skip '"'
    *pcTemp='\0';
    m_acUnit = acTemp; // copy UNIT to corresponding data member.
    replace(m_acUnit.begin(), m_acUnit.end(), ',', '_'); //" not supported

    // skip ' '
    while(*pcToken && *pcToken == ' ')
    {
        pcToken++;
    }

    pcTemp = acTemp;

    while(*pcToken)
    {
        if ((*pcToken != '\r') && (*pcToken != ' '))
        {
            *pcTemp++ = *pcToken++;
        }
        else
        {
            pcToken++;
        }
    }

    *pcTemp='\0';

    // copy rx nodes
    if(strcmp(acTemp, "Vector__XXX") != 0)
    {
        m_rxNode = acTemp;
    }
    else
    {
        m_rxNode = "";
    }

    return 1;
}


/**
 * \brief Extracts the value descriptor data from the given Line
 * \param[in] pcLine The given Line
 * \param[in] fileInput Input file
 * \return    Status Code
 *
 * Extracts the value descriptor data from the given Line and adds
 * to the signal.
 */
int CSignal::AddValueDescriptors(char* pcLine, fstream& fileInput)
{
    char acValue[300];
    char acDesc[300];
    char acLine[defVTAB_MAX_LINE_LEN] = {'\0'};
    char* pcToken, *pcTok;
    bool true_end = true;
    char* pcValue = acValue;
    char* pcDesc = acDesc;

    if(pcLine[strlen(pcLine)-1] != ';')
    {
        true_end = false;
    }

    // skip leading spaces
    while(*pcLine && (*pcLine == ' '))
    {
        *pcLine++;
    }

    while(*pcLine && (*pcLine != ';'))
    {
        if(true_end == false)
        {
            string pcTemp;
            fileInput.getline(acLine, 1026);
            pcTemp = pcLine;
            pcTemp += acLine;
            strncpy(pcLine, pcTemp.c_str(), sizeof(pcLine));

            if(pcLine[strlen(pcLine)-1] == ';')
            {
                true_end  = true;
            }
        }

        pcDesc = acDesc;

        while(*pcLine && (*pcLine == ' '))
        {
            pcLine++;
        }

        pcToken = strtok_s(pcLine, " ", &pcTok);
        strncpy_s(acValue, pcToken, sizeof(acValue));
        pcLine = pcLine + (strlen(pcToken)) + 1;

        if(*pcLine == '\"')
        {
            pcLine++;

            if(*pcLine != '\"')
            {
                *pcDesc++ = *pcLine++;

                while(*pcLine && (*pcLine != '\"'))
                {
                    if (*pcLine != '\r')
                    {
                        *pcDesc++ = *pcLine;
                    }

                    pcLine++;
                }
            }

            *pcDesc = '\0';
        }

        pcLine++;

        while(*pcLine == ' ')
        {
            pcLine++;
        }

        CValueDescriptor valDesc;

        if(this->m_ucLength <= 32)
        {
            valDesc.m_value.dValue = atof(acValue);
        }
        else
        {
            valDesc.m_value.i64Value = _atoi64(acValue);
        }

        valDesc.m_acDescriptor = acDesc;
        m_listValueDescriptor.push_back(valDesc);
        pcDesc = acDesc;
    }

    return 1;
}


/**
 * \brief     Validate for conformance to BUSMASTER DB format
 * \param[in] ucFormat data format
 * \return    SIG_EC_NO_ERR, SIG_EC_DATA_FORMAT_ERR, SIG_EC_LENGTH_ERR, SIG_EC_STARTBIT_ERR, SIG_EC_TYPE_ERR
 *
 * Convert single bit INT and UINT to BOOL.
 * If MAX_value == MIN_value update MAX_value to MAX_default
 * else if MAX_value == MIN_value == MAX_default, update MIN_value to MIN_default
 * signals with length more than 32 bits shall be discarded.
 *
 * The data format of previous signal is passed as a parameter.
 * For the first one it will be zero, for then on either INTEL or MOTOROLA.
 * If this signals format is not matching with previous signal then this signal to be discarded.
 */
unsigned int CSignal::Validate(unsigned char ucFormat)
{
    // if more than 64 bits should be discarded
    /*if(m_ucLength > 64)
    {
        return (m_uiError = SIG_EC_LENGTH_ERR);
    }

    // validate start bit and byte
    if((m_ucWhichByte < 1) || (m_ucWhichByte > 8))
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }

    if((m_ucWhichByte == 8) && (m_ucStartBit > 7))
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }

    // DOUBLE & FLOAT are not supported right now
    if((m_ucType == SIG_TYPE_DOUBLE) || (m_ucType == SIG_TYPE_FLOAT))
    {
        return (m_uiError = SIG_EC_TYPE_ERR);
    }*/

    // errors eliminated now do necessary conversions
    if(m_ucLength == 1) // single bit - change type to bool
    {
        m_ucType = SIG_TYPE_BOOL;
    }

    m_uiError = SIG_EC_NO_ERR;

    //Conversion from the physical to raw value required.

    // update MAX value and MIN value based on type
    switch(m_ucType)
    {
        case SIG_TYPE_BOOL:
        case SIG_TYPE_UINT:
        {
            unsigned long long int unMaxVal;
            unsigned long long int unMinVal;
            unConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, unMaxVal, unMinVal);
            m_MaxValue.uiValue = (unsigned int)unMaxVal;             //m_MaxValue.dValue;
            m_MinValue.uiValue = (unsigned int)unMinVal;             //m_MinValue.dValue;
            unsigned int uiDefault;
			uiDefault = (unsigned int)(pow((float) 2.0, (int) m_ucLength) - 1);

            //if both max and min value are equal set it to default
            if(m_MaxValue.uiValue == 0 && m_MinValue.uiValue == 0)
            {
                m_MaxValue.uiValue = uiDefault;
                m_MinValue.uiValue = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max value out of range reset it to maximum possible value
            if((m_MaxValue.uiValue > uiDefault) || (m_MaxValue.uiValue < 0))
            {
                m_MaxValue.uiValue = uiDefault;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Min value out of range reset it to minimum possible value
            if((m_MinValue.uiValue < 0) || (m_MinValue.uiValue > uiDefault))
            {
                m_MinValue.uiValue = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max and Min are equal reset min.
            if(m_MaxValue.uiValue == m_MinValue.uiValue)
            {
                if(m_MaxValue.uiValue == 0)
                {
                    //This is because after setting min value to 0 than if max value is also 0
                    //we need to set max value to maximum
                    m_MaxValue.uiValue = uiDefault;
                }

                m_MinValue.uiValue = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }
        }
        break;

        case SIG_TYPE_INT:
        {
            long long int nMaxVal;
            long long int nMinVal;
            nConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, nMaxVal, nMinVal);
            m_MaxValue.iValue = (int)nMaxVal;             //m_MaxValue.dValue;
            m_MinValue.iValue = (int)nMinVal;             //m_MinValue.dValue;
            int iDefault;
            iDefault = (int)(unsigned int)1 << (m_ucLength - 1);
            iDefault -= 1;

            //if both max and min value are equal set it to default
            if(m_MaxValue.iValue == 0 && m_MinValue.iValue == 0)
            {
                m_MaxValue.iValue = iDefault;
                m_MinValue.iValue = -iDefault-1;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max value out of range reset it to maximum possible value
            if(m_MaxValue.iValue > iDefault || m_MaxValue.iValue < (-iDefault-1))
            {
                m_MaxValue.iValue = iDefault;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Min value out of range reset it to minimum possible value
            if(m_MinValue.iValue < (-iDefault-1) || m_MinValue.iValue > iDefault )
            {
                m_MinValue.iValue = (-iDefault-1);
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max and Min are equal reset min.
            if(m_MaxValue.iValue == m_MinValue.iValue)
            {
                m_MinValue.iValue = (-iDefault-1);
                m_uiError = SIG_EC_OVERFLOW;
            }

            break;
        }

        // float is not supported right now, so no validation
        case SIG_TYPE_FLOAT:
            m_MaxValue.fValue = (float)m_MaxValue.dValue;
            m_MinValue.fValue = (float)m_MinValue.dValue;
            break;

            // double is not supported right now, so no validation
        case SIG_TYPE_DOUBLE:
            // no need to update MAX and MIN values, already stored as double
            break;

        case SIG_TYPE_INT64:
        {
            //Testing required - venkat
            // no need to update MAX and MIN values, already stored as i64Value
            long long int nMaxVal;
            long long int nMinVal;
            nConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, nMaxVal, nMinVal);
            m_MaxValue.i64Value = nMaxVal;             //m_MaxValue.dValue;
            m_MinValue.i64Value = nMinVal;             //m_MinValue.dValue;
            unsigned int unPower;
            __int64 i64Default;
            unsigned int i;
            /*if(m_ucLength == 64 )
            {
            unPower = m_ucLength - 2;
            }
            else
            {
            unPower = m_ucLength - 2;
            }*/
            unPower = m_ucLength - 1;
            i64Default = 1;

            for(i = 0; i<unPower; i++)
            {
                i64Default = (__int64)( 2*i64Default);
            }

            i64Default -= 1;

            if(m_MaxValue.i64Value == 0 && m_MinValue.i64Value == 0)
            {
                m_MaxValue.i64Value = i64Default;
                m_MinValue.i64Value = -i64Default-1;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max value out of range reset it to maximum possible value
            if(m_MaxValue.i64Value > i64Default || m_MaxValue.i64Value < (-i64Default-1))
            {
                m_MaxValue.i64Value = i64Default;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Min value out of range reset it to minimum possible value
            if(m_MinValue.i64Value < (-i64Default-1) || m_MinValue.i64Value > i64Default )
            {
                m_MinValue.i64Value = (-i64Default-1);
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max and Min are equal reset min.
            if(m_MaxValue.i64Value == m_MinValue.i64Value)
            {
                m_MinValue.i64Value = (-i64Default-1);
                m_uiError = SIG_EC_OVERFLOW;
            }
        }
        break;

        case SIG_TYPE_UINT64:
        {
            unsigned long long int unMaxVal;
            unsigned long long int unMinVal;
            unConvertPhysicalToRaw(m_MaxValue.dValue, m_MinValue.dValue, m_fOffset, m_fScaleFactor, unMaxVal, unMinVal);
            m_MaxValue.ui64Value = unMaxVal;             //m_MaxValue.dValue;
            m_MinValue.ui64Value = unMinVal;             //m_MinValue.dValue;
            unsigned __int64 ui64Default;
            /*if(m_ucLength == 64 )
            {
            unPower = m_ucLength - 1;
            }
            else
            {
            unPower = m_ucLength - 1;
            }*/
            unsigned int unPower = m_ucLength - 1;
            ui64Default = 1;

            for(unsigned int i = 0; i < unPower; i++)
            {
                ui64Default = (unsigned __int64)( 2*ui64Default);
            }

            ui64Default -= 1;

            //if both max and min value are equal set it to default
            if(m_MaxValue.ui64Value == 0 && m_MinValue.ui64Value == 0)
            {
                m_MaxValue.ui64Value = ui64Default;
                m_MinValue.ui64Value = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max value out of range reset it to maximum possible value
            if(m_MaxValue.ui64Value > ui64Default || m_MaxValue.ui64Value < 0)
            {
                m_MaxValue.ui64Value = ui64Default;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Min value out of range reset it to minimum possible value
            if(m_MinValue.ui64Value < 0 || m_MinValue.ui64Value > ui64Default )
            {
                m_MinValue.ui64Value = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            //if Max and Min are equal reset min.
            if(m_MaxValue.ui64Value == m_MinValue.ui64Value)
            {
                m_MinValue.ui64Value = 0;
                m_uiError = SIG_EC_OVERFLOW;
            }

            break;
        }

        default:
            break;
    }

    // correct value descriptors according to type of signal
    list<CValueDescriptor>::iterator rValDesc;

    for (rValDesc=m_listValueDescriptor.begin(); rValDesc!=m_listValueDescriptor.end(); ++rValDesc)
    {
        switch(m_ucType)
        {
            case SIG_TYPE_BOOL:
            case SIG_TYPE_UINT:
                rValDesc->m_value.uiValue = (unsigned int)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_INT:
                rValDesc->m_value.iValue = (int)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_FLOAT:
                rValDesc->m_value.fValue = (float)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_DOUBLE:
                break;

            case SIG_TYPE_INT64:
                //rValDesc->m_value.i64Value = (long long)rValDesc->m_value.dValue;
                break;

            case SIG_TYPE_UINT64:
                rValDesc->m_value.ui64Value = (unsigned long long)rValDesc->m_value.i64Value;
                break;

            default:
                break;
        }
    }

    return (m_uiError);
}

/**
 * \brief      Get error string
 * \param[out] str The error string
 *
 * This returns an error string in accordance with m_uiError.
 */
void CSignal::GetErrorString(string& str)
{
    switch(m_uiError)
    {
        case SIG_EC_NO_ERR:
            str = "No error";
            break;

        case SIG_EC_DATA_FORMAT_ERR:
            str = "Data format mismatch";
            break;

        case SIG_EC_LENGTH_ERR:
            str = "Invalid signal length";
            break;

        case SIG_EC_STARTBIT_ERR:
            str = "Invalid start bit";
            break;

        case SIG_EC_TYPE_ERR:
            str = "Invalid signal type";
            break;

        case SIG_EC_OVERFLOW:
            str = "Invalid Max or Min value.";
            break;

        default:
            str = "Unknown";
            break;
    }
}

/**
 * \brief      Get error action
 * \param[out] str The error action string
 *
 * This returns a string to describe the action taken in accordance with m_uiError.
 */
void CSignal::GetErrorAction(string& str)
{
    switch(m_uiError)
    {
        case SIG_EC_OVERFLOW:
            str = "Value Set to default";
            break;

        default:
            str = "Signal Discarded";
            break;
    }
}

/**
 * \brief     writes the signals in the given list to the output file
 * \param[in] fileOutput Pointer to the Output file
 * \param[in] m_listSignals List of Signals
 * \param[in] m_ucLength Message length
 * \param[in] m_cDataFormat If 1 dataformat Intel, 0- Motorola
 * \param[in] writeErr If true write error signals also else write onlt correct signals
 * \return    Status code
 *
 * Writes the signals in the given list to the output file.
 */
bool CSignal::WriteSignaltofile(fstream& fileOutput, list<CSignal> &m_listSignals, int m_ucLength, int m_cDataFormat, bool writeErr)
{
    bool bResult = true;
    list<CSignal>::iterator sig;

    for (sig=m_listSignals.begin(); sig!=m_listSignals.end(); ++sig)
    {
        // SIG_NAME,SIG_LENGTH,WHICH_BYTE_IN_MSG,START_BIT,SIG_TYPE,MAX_VAL,MIN_VAL,SIG_DATA_FORMAT,SIG_OFFSET,SIG_FACTOR,SIG_UNIT
        // write signal only if it is valid
        if((sig->m_uiError == CSignal::SIG_EC_NO_ERR) || (sig->m_uiError == CSignal::SIG_EC_OVERFLOW) || writeErr)
        {
            // For signal having motoroal format, the message length could be less
            // then eight byte. so in that case the whichByte needs to be shifted
            // accordingly.
            fileOutput << T_SIG << " " << sig->m_acName.c_str();
            fileOutput << "," << dec << sig->m_ucLength;
            fileOutput << "," << dec << sig->m_ucWhichByte;
            fileOutput << "," << dec << sig->m_ucStartBit;

            switch(sig->m_ucType)
            {
                case CSignal::SIG_TYPE_BOOL:
                case CSignal::SIG_TYPE_UINT:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << dec << sig->m_MaxValue.uiValue;
                    fileOutput << "," << dec << sig->m_MinValue.uiValue;
                    break;

                case CSignal::SIG_TYPE_INT:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << dec << sig->m_MaxValue.iValue;
                    fileOutput << "," << dec << sig->m_MinValue.iValue;
                    break;

                case CSignal::SIG_TYPE_FLOAT:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << sig->m_MaxValue.fValue;
                    fileOutput << "," << sig->m_MinValue.fValue;
                    break;

                case CSignal::SIG_TYPE_DOUBLE:
                    fileOutput << "," << sig->m_ucType;
                    fileOutput << "," << sig->m_MaxValue.dValue;
                    fileOutput << "," << sig->m_MinValue.dValue;
                    break;

                case CSignal::SIG_TYPE_INT64:
                    fileOutput << ",I";
                    fileOutput << "," << dec << sig->m_MaxValue.i64Value;
                    fileOutput << "," << dec << sig->m_MinValue.i64Value;
                    break;

                case CSignal::SIG_TYPE_UINT64:
                    fileOutput << ",U";
                    fileOutput << "," << dec << sig->m_MaxValue.ui64Value;
                    fileOutput << "," << dec << sig->m_MinValue.ui64Value;
                    break;

                default:
                    break;
            }

            fileOutput << "," << sig->m_ucDataFormat;
            fileOutput << "," << sig->m_fOffset;
            fileOutput << "," << sig->m_fScaleFactor;
            fileOutput << "," << sig->m_acUnit.c_str();
            fileOutput << "," << sig->m_acMultiplex.c_str();
            fileOutput << "," << sig->m_rxNode.c_str() << endl;
            CValueDescriptor val;
            val.writeValueDescToFile(fileOutput, sig->m_ucType, sig->m_listValueDescriptor);

            if(sig->m_uiError == CSignal::SIG_EC_OVERFLOW)
            {
                bResult = false;
            }
        }
        else
        {
            bResult = false;
        }
    }

    return bResult;
}





































unsigned int unConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, unsigned long long int& unMaxVal, unsigned long long int& unMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    unMaxVal = (unsigned long long int)unRoundOffdoubleValue(dTempMaxVal);
    unMinVal = (unsigned long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}












int nConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, long long int& nMaxVal, long long int& nMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    nMaxVal = (long long int)unRoundOffdoubleValue(dTempMaxVal);
    nMinVal = (long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}












unsigned int unConvertRawToPhysical(unsigned long long int unMaxRawVal, unsigned long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}












int nConvertRawToPhysical(long long int unMaxRawVal, long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}









unsigned long long int unRoundOffdoubleValue(double dValue)
{
    unsigned long long int unVal = (unsigned long long int)dValue;
    double dTempVal = dValue - (double)unVal;

    if(dTempVal >= 0.5)
    {
        unVal++;
    }

    return unVal;
}
                      €ÿÿÿÿ   €ÿÿÿÿ    0½       expression was false       dTempVal >= 0.5    ÿÿÿÿ   €      ÿÿÿÿ   €                  0ºø         †      †      …ÿÿÿÿ   …ÿÿÿÿ    0½è       statement executed        return unVal;    †ÿÿÿÿ   …      †ÿÿÿÿ   …                    „      „      ƒÿÿÿÿ   ƒÿÿÿÿ    0¼(       statement executed        }    „ÿÿÿÿ   ƒ      „ÿÿÿÿ   ƒ                    q      q      pÿÿÿÿ   pÿÿÿÿ    0±       statement executed        return 0;    qÿÿÿÿ   p      qÿÿÿÿ   p                    Y      Y      Xÿÿÿÿ   Xÿÿÿÿ     ô6(       statement executed        return 0;    Yÿÿÿÿ   X      Yÿÿÿÿ   X                    A      A      @ÿÿÿÿ   @ÿÿÿÿ     +ğ       statement executed        return 0;    Aÿÿÿÿ   @      Aÿÿÿÿ   @                    -      -      ,ÿÿÿÿ   ,ÿÿÿÿ     í³È       statement executed        return 0;    -ÿÿÿÿ   ,      -ÿÿÿÿ   ,           unConvertPhysicalToRaw unsigned int unConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, unsigned long long int& unMaxVal, unsigned long long int& unMinVal)    (      .      'ÿÿÿÿ   -ÿÿÿÿnConvertPhysicalToRaw int nConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, long long int& nMaxVal, long long int& nMinVal)    <      B      ;ÿÿÿÿ   AÿÿÿÿunConvertRawToPhysical unsigned int unConvertRawToPhysical(unsigned long long int unMaxRawVal, unsigned long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)    P      Z      Oÿÿÿÿ   YÿÿÿÿnConvertRawToPhysical int nConvertRawToPhysical(long long int unMaxRawVal, long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)    h      r      gÿÿÿÿ   qÿÿÿÿunRoundOffdoubleValue unsigned long long int unRoundOffdoubleValue(double dValue)    }      ‡      |ÿÿÿÿ   †ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Utility.cpp
 * \brief     Implementation of global utility functions
 * \authors   Venkatanarayana Makam, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of global utility functions.
 */

/* Project includes */
#include "Utility.h"

/**
 * \brief      Converts the DOUBLE physical values to UINT64 RAW values
 * \param[in]  dMaxVal Maximum physical value
 * \param[in]  dMinVal Minimum physical value
 * \param[in]  dOffset Offset value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] unMaxVal Maximum RAW value
 * \param[out] unMinVal Minimum RAW value
 *
 * Converts the DOUBLE physical values to UINT64 RAW values.
 */
unsigned int unConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, unsigned long long int& unMaxVal, unsigned long long int& unMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    unMaxVal = (unsigned long long int)unRoundOffdoubleValue(dTempMaxVal);
    unMinVal = (unsigned long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}

/**
 * \brief      Converts the DOUBLE physical values to INT64 RAW values
 * \param[in]  dMaxVal Maximum physical value
 * \param[in]  dMinVal Minimum physical value
 * \param[in]  dOffset Offset Value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] nMaxVal Maximum RAW value
 * \param[out] nMinVal Minimum RAW value
 *
 * Converts the DOUBLE physical values to INT64 RAW values.
 */
int nConvertPhysicalToRaw(double dMaxVal, double dMinVal, double dOffset, double dScaleFactor, long long int& nMaxVal, long long int& nMinVal)
{
    double dTempMaxVal = ((dMaxVal - dOffset) / dScaleFactor);
    double dTempMinVal = ((dMinVal - dOffset) / dScaleFactor);
    nMaxVal = (long long int)unRoundOffdoubleValue(dTempMaxVal);
    nMinVal = (long long int)unRoundOffdoubleValue(dTempMinVal);
    return 0;
}

/**
 * \brief      Converts the DOUBLE physical values to INT64 RAW values
 * \param[in]  unMaxRawVal Maximum raw value
 * \param[in]  unMinRawVal Minimum raw value
 * \param[in]  dOffset Offset Value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] dMaxPhyVal Maximum physical vlaue
 * \param[out] dMinPhyVal Minimum physical vlaue
 *
 * Converts the DOUBLE physical values to INT64 RAW values.
 */
unsigned int unConvertRawToPhysical(unsigned long long int unMaxRawVal, unsigned long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    //Maximum value
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    //Minimum value
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}

/**
 * \brief      Converts the DOUBLE physical values to INT64 RAW values
 * \param[in]  unMaxRawVal Maximum raw value
 * \param[in]  unMinRawVal Minimum raw value
 * \param[in]  dOffset Offset Value
 * \param[in]  dScaleFactor Scaling Factor
 * \param[out] dMaxPhyVal Maximum physical value
 * \param[out] dMinPhyVal Minimum physical value
 *
 * Converts the DOUBLE physical values to INT64 RAW values.
 */
int nConvertRawToPhysical(long long int unMaxRawVal, long long int unMinRawVal, double dOffset, double dScaleFactor, double& dMaxPhyVal, double& dMinPhyVal)
{
    //Maximum value
    dMaxPhyVal = static_cast<double>(unMaxRawVal);
    dMaxPhyVal *= dScaleFactor;
    dMaxPhyVal += dOffset;
    //Minimum value
    dMinPhyVal = static_cast<double>(unMinRawVal);
    dMinPhyVal *= dScaleFactor;
    dMinPhyVal += dOffset;
    return 0;
}

/**
 * \brief      Convert the double value to UINT64.
 * \param[in]  dValue double value
 * \return     value as UINT64
 *
 * This function will convert the double value to UINT64.
 * If the double value precision is more than 0.5 the unit value will be added 1.
 */
unsigned long long int unRoundOffdoubleValue(double dValue)
{
    unsigned long long int unVal = (unsigned long long int)dValue;
    double dTempVal = dValue - (double)unVal;

    if(dTempVal >= 0.5)
    {
        unVal++;
    }

    return unVal;
}



























using namespace std;






CValueDescriptor::CValueDescriptor()
{
    m_value.iValue = 1;
    m_value.uiValue = 1;
    m_value.fValue = 1;
    m_value.dValue = 1;
    m_value.cValue = "";
    m_value.i64Value = 1;
    m_value.ui64Value = 1;
    m_acDescriptor = "";
}







CValueDescriptor::~CValueDescriptor()
{
}









void CValueDescriptor::writeValueDescToFile(fstream& fileOutput, char m_ucType, list<CValueDescriptor> &m_listValueDescriptor)
{
    list<CValueDescriptor>::iterator desc;

    for (desc=m_listValueDescriptor.begin(); desc!=m_listValueDescriptor.end(); ++desc)
    {
        fileOutput << "[""VALUE_DESCRIPTION""]" " \"";
        fileOutput << desc->m_acDescriptor.c_str();
        fileOutput << "\",";

        switch(m_ucType)
        {
            case CSignal::SIG_TYPE_BOOL:
            case CSignal::SIG_TYPE_UINT:
                fileOutput << dec << desc->m_value.uiValue;
                break;

            case CSignal::SIG_TYPE_INT:
                fileOutput << dec << desc->m_value.iValue;
                break;

            case CSignal::SIG_TYPE_FLOAT:
                fileOutput << dec << desc->m_value.fValue;
                break;

            case CSignal::SIG_TYPE_DOUBLE:
                fileOutput << dec << desc->m_value.dValue;
                break;

            case CSignal::SIG_TYPE_INT64:
                fileOutput << dec << desc->m_value.i64Value;
                break;

            case CSignal::SIG_TYPE_UINT64:
                fileOutput << dec << desc->m_value.ui64Value;
                break;

            default:
                break;
        }

        fileOutput << endl;
    }

    return;
}
          G   .   G   O   Eÿÿÿÿ   Eÿÿÿÿ     í´X      expression was false       desc!=m_listValueDescriptor.end()    Gÿÿÿÿ   E   .   Gÿÿÿÿ   E   O                ô         o      o      mÿÿÿÿ   mÿÿÿÿ     í©@       statement executed        return;    oÿÿÿÿ   m      oÿÿÿÿ   m                    m      m      kÿÿÿÿ   kÿÿÿÿ     í³È       statement executed        }    mÿÿÿÿ   k      mÿÿÿÿ   k                    i      i      gÿÿÿÿ   gÿÿÿÿ     4qè       statement executed        break;    iÿÿÿÿ   g      iÿÿÿÿ   g                    f      f      dÿÿÿÿ   dÿÿÿÿ     í®À       statement executed        break;    fÿÿÿÿ   d      fÿÿÿÿ   d                    b      b      `ÿÿÿÿ   `ÿÿÿÿ     í¾x       statement executed        break;    bÿÿÿÿ   `      bÿÿÿÿ   `                    ^      ^      \ÿÿÿÿ   \ÿÿÿÿ     íÉ˜       statement executed        break;    ^ÿÿÿÿ   \      ^ÿÿÿÿ   \                    Z      Z      Xÿÿÿÿ   Xÿÿÿÿ     4s`       statement executed        break;    Zÿÿÿÿ   X      Zÿÿÿÿ   X                    /      /      -ÿÿÿÿ   -ÿÿÿÿ     )xÀ       statement executed        }    /ÿÿÿÿ   -      /ÿÿÿÿ   -              	      9      9      7ÿÿÿÿ   7ÿÿÿÿ     øM8       statement executed        }    9ÿÿÿÿ   7      9ÿÿÿÿ   7              
      R      R      Pÿÿÿÿ   Pÿÿÿÿ     4x@       statement executed        break;    Rÿÿÿÿ   P      Rÿÿÿÿ   P                    V      V      Tÿÿÿÿ   Tÿÿÿÿ     4W        statement executed        break;    Vÿÿÿÿ   T      Vÿÿÿÿ   T           CValueDescriptor::CValueDescriptor CValueDescriptor::CValueDescriptor()    &      /      $ÿÿÿÿ   -ÿÿÿÿCValueDescriptor::~CValueDescriptor CValueDescriptor::~CValueDescriptor()    8      9      6ÿÿÿÿ   7ÿÿÿÿCValueDescriptor::writeValueDescToFile void CValueDescriptor::writeValueDescToFile(fstream& fileOutput, char m_ucType, list<CValueDescriptor> &m_listValueDescriptor)    D      p      Bÿÿÿÿ   nÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ValueDescriptor.cpp
 * \brief     Implementation of value descriptor class
 * \authors   Ratnadip Choudhury, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the value descriptor class.
 */

/* Project includes */
#include "Signal.h"
#include "Tag.h"
#include "ValueDescriptor.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CValueDescriptor
 */
CValueDescriptor::CValueDescriptor()
{
    m_value.iValue = 1;
    m_value.uiValue = 1;
    m_value.fValue = 1;
    m_value.dValue = 1;
    m_value.cValue = "";
    m_value.i64Value = 1;
    m_value.ui64Value = 1;
    m_acDescriptor = "";
}


/**
 * \brief Destructor
 *
 * Destructor of CValueDescriptor
 */
CValueDescriptor::~CValueDescriptor()
{
}

/**
 * \brief     writes the value descriptors in the given list to the output file
 * \param[in] fileOutput Pointer to the Output file
 * \param[in] m_ucType data type of the value
 * \param[in] m_listValueDescriptor List of Value descriptors
 *
 * Writes the value descriptors in the given list to the output file.
 */
void CValueDescriptor::writeValueDescToFile(fstream& fileOutput, char m_ucType, list<CValueDescriptor> &m_listValueDescriptor)
{
    list<CValueDescriptor>::iterator desc;

    for (desc=m_listValueDescriptor.begin(); desc!=m_listValueDescriptor.end(); ++desc)
    {
        fileOutput << T_VALUE_DESC " \"";
        fileOutput << desc->m_acDescriptor.c_str();
        fileOutput << "\",";

        switch(m_ucType)
        {
            case CSignal::SIG_TYPE_BOOL:
            case CSignal::SIG_TYPE_UINT:
                fileOutput << dec << desc->m_value.uiValue;
                break;

            case CSignal::SIG_TYPE_INT:
                fileOutput << dec << desc->m_value.iValue;
                break;

            case CSignal::SIG_TYPE_FLOAT:
                fileOutput << dec << desc->m_value.fValue;
                break;

            case CSignal::SIG_TYPE_DOUBLE:
                fileOutput << dec << desc->m_value.dValue;
                break;

            case CSignal::SIG_TYPE_INT64:
                fileOutput << dec << desc->m_value.i64Value;
                break;

            case CSignal::SIG_TYPE_UINT64:
                fileOutput << dec << desc->m_value.ui64Value;
                break;

            default:
                break;
        }

        fileOutput << endl;
    }

    return;
}


























using namespace std;






CValueTable::CValueTable()
{
    m_TableName = "";
}






CValueTable::~CValueTable()
{
}







CValueTable& CValueTable::operator=(CValueTable& Tab)
{
    m_TableName = Tab.m_TableName;
    m_values = Tab.m_values;
    return (*this);
}









int CValueTable::Format(char* pcLine, fstream& fileInput)
{
    char acValue[65];
    char acLine[1026] = {'\0'};
    char acDesc[65];
    char table_Name[65];
    bool true_end = true;
    char* pcValue = acValue;
    char* pcDesc = acDesc;
    char* pcTab = table_Name;

    
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    
    while(*pcLine && *pcLine != ' ')
    {
        if (*pcLine != '\r')
        {
            *pcTab++ = *pcLine;
        }

        pcLine++;
    }

    *pcTab = '\0';
    m_TableName = table_Name;

    
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    if(pcLine[strlen(pcLine)-1] != ';')
    {
        true_end  = false;
    }

    while(*pcLine && *pcLine != ';')
    {
        
        
        
        if(true_end == false)
        {
            string pcTemp;
            fileInput.getline(acLine, 1026);
            pcTemp = pcLine;
            pcTemp += acLine;
            strncpy(pcLine, pcTemp.c_str(), sizeof(pcLine));

            if(pcLine[strlen(pcLine)-1] == ';')
            {
                true_end  = true;
            }
        }

        pcValue = acValue;
        pcDesc = acDesc;
        
        *pcValue = *pcDesc = '\0';

        while(*pcLine && *pcLine != ' ')
        {
            if (*pcLine != '\r')
            {
                *pcValue++ = *pcLine;
            }

            pcLine++;
        }

        *pcValue = '\0'; 

        
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        
        while(*pcLine && *pcLine == '\"')
        {
            *pcLine++;
        }

        
        while(*pcLine && *pcLine != '\"')
        {
            if (*pcLine != '\r')
            {
                *pcDesc++ = *pcLine;
            }

            pcLine++;
        }

        *pcDesc = '\0';
        
        pcLine++;

        
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        
        if(acDesc[0] != '\0')
        {
            CValueDescriptor valDesc;
			valDesc.m_value.i64Value = _atoi64(acValue);
            valDesc.m_acDescriptor = acDesc;
            m_values.push_back(valDesc);
        }
    }

    return 1;
}








void CValueTable::writeValueTabToFile(fstream& fileOutput, list<CValueTable> &vTab)
{
    list<CValueTable>::iterator tab;

    for (tab=vTab.begin(); tab!=vTab.end(); ++tab)
    {
        fileOutput << "[""START_TABLE""]" " ";
        fileOutput << tab->m_TableName.c_str();
        fileOutput << endl;
        CValueDescriptor desc;
        desc.writeValueDescToFile(fileOutput, CSignal::SIG_TYPE_INT64, tab->m_values);
        fileOutput << "[""END_TABLE""]" << endl;
    }
}
          Š      Š      ‡ÿÿÿÿ   ‡ÿÿÿÿ     4yÀ      expression was true       *pcLine    Šÿÿÿÿ   ‡      Šÿÿÿÿ   ‡      expression was false       *pcLine    Šÿÿÿÿ   ‡      Šÿÿÿÿ   ‡                    r      r   $   oÿÿÿÿ   oÿÿÿÿ     4gĞ      expression was true       *pcLine != ';'    rÿÿÿÿ   o      rÿÿÿÿ   o   $   expression was false       *pcLine != ';'    rÿÿÿÿ   o      rÿÿÿÿ   o   $                4f          r      r      oÿÿÿÿ   oÿÿÿÿ     4fø      expression was true       *pcLine    rÿÿÿÿ   o      rÿÿÿÿ   o      expression was false       *pcLine    rÿÿÿÿ   o      rÿÿÿÿ   o                    h      h   $   eÿÿÿÿ   eÿÿÿÿ     4^       expression was true       *pcLine == ' '    hÿÿÿÿ   e      hÿÿÿÿ   e   $   expression was false       *pcLine == ' '    hÿÿÿÿ   e      hÿÿÿÿ   e   $                4\P         h      h      eÿÿÿÿ   eÿÿÿÿ     4](      expression was true       *pcLine    hÿÿÿÿ   e      hÿÿÿÿ   e      expression was false       *pcLine    hÿÿÿÿ   e      hÿÿÿÿ   e              
      Z      Z   $   Wÿÿÿÿ   Wÿÿÿÿ     4Rh      expression was true       *pcLine != ' '    Zÿÿÿÿ   W      Zÿÿÿÿ   W   $   expression was false       *pcLine != ' '    Zÿÿÿÿ   W      Zÿÿÿÿ   W   $                4P¸         Z      Z      Wÿÿÿÿ   Wÿÿÿÿ     4Q      expression was true       *pcLine    Zÿÿÿÿ   W      Zÿÿÿÿ   W      expression was false       *pcLine    Zÿÿÿÿ   W      Zÿÿÿÿ   W                    T      T   $   Qÿÿÿÿ   Qÿÿÿÿ     4LĞ      expression was true       *pcLine == ' '    Tÿÿÿÿ   Q      Tÿÿÿÿ   Q   $   expression was false       *pcLine == ' '    Tÿÿÿÿ   Q      Tÿÿÿÿ   Q   $                4K          T      T      Qÿÿÿÿ   Qÿÿÿÿ     4Kø      expression was true       *pcLine    Tÿÿÿÿ   Q      Tÿÿÿÿ   Q      expression was false       *pcLine    Tÿÿÿÿ   Q      Tÿÿÿÿ   Q                    Ï      Ï   +   Ìÿÿÿÿ   Ìÿÿÿÿ     íÊp      expression was false       tab!=vTab.end()    Ïÿÿÿÿ   Ì      Ïÿÿÿÿ   Ì   +                íÅ          Š      Š   (   ‡ÿÿÿÿ   ‡ÿÿÿÿ     4z˜      expression was true       *pcLine != ' '    Šÿÿÿÿ   ‡      Šÿÿÿÿ   ‡   (   expression was false       *pcLine != ' '    Šÿÿÿÿ   ‡      Šÿÿÿÿ   ‡   (                4xè         —      —      ”ÿÿÿÿ   ”ÿÿÿÿ     í@      expression was true       *pcLine    —ÿÿÿÿ   ”      —ÿÿÿÿ   ”      expression was false       *pcLine    —ÿÿÿÿ   ”      —ÿÿÿÿ   ”                    —      —   (   ”ÿÿÿÿ   ”ÿÿÿÿ     íŸ      expression was true       *pcLine == ' '    —ÿÿÿÿ   ”      —ÿÿÿÿ   ”   (   expression was false       *pcLine == ' '    —ÿÿÿÿ   ”      —ÿÿÿÿ   ”   (                íh                     šÿÿÿÿ   šÿÿÿÿ     í£À      expression was true       *pcLine    ÿÿÿÿ   š      ÿÿÿÿ   š      expression was false       *pcLine    ÿÿÿÿ   š      ÿÿÿÿ   š                             )   šÿÿÿÿ   šÿÿÿÿ     í¤˜      expression was true       *pcLine == '\"'    ÿÿÿÿ   š      ÿÿÿÿ   š   )   expression was false       *pcLine == '\"'    ÿÿÿÿ   š      ÿÿÿÿ   š   )                í¢è         £      £       ÿÿÿÿ    ÿÿÿÿ     í©@      expression was true       *pcLine    £ÿÿÿÿ          £ÿÿÿÿ          expression was false       *pcLine    £ÿÿÿÿ          £ÿÿÿÿ                        £      £   )    ÿÿÿÿ    ÿÿÿÿ     íª      expression was true       *pcLine != '\"'    £ÿÿÿÿ          £ÿÿÿÿ       )   expression was false       *pcLine != '\"'    £ÿÿÿÿ          £ÿÿÿÿ       )                í¨h   !      ²      ²      ¯ÿÿÿÿ   ¯ÿÿÿÿ     í³È      expression was true       *pcLine    ²ÿÿÿÿ   ¯      ²ÿÿÿÿ   ¯      expression was false       *pcLine    ²ÿÿÿÿ   ¯      ²ÿÿÿÿ   ¯              #      ²      ²   (   ¯ÿÿÿÿ   ¯ÿÿÿÿ     í´       expression was true       *pcLine == ' '    ²ÿÿÿÿ   ¯      ²ÿÿÿÿ   ¯   (   expression was false       *pcLine == ' '    ²ÿÿÿÿ   ¯      ²ÿÿÿÿ   ¯   (                í²ğ   %      ¸      ¸      µÿÿÿÿ   µÿÿÿÿ     í¾è      expression was false       acDesc[0] != '\0'    ¸ÿÿÿÿ   µ      ¸ÿÿÿÿ   µ                   í¸°   &      ¥      ¥       ¢ÿÿÿÿ   ¢ÿÿÿÿ     í®°      expression was false       *pcLine != '\r'    ¥ÿÿÿÿ   ¢      ¥ÿÿÿÿ   ¢                    í«ø   '      Œ      Œ       ‰ÿÿÿÿ   ‰ÿÿÿÿ     40      expression was false       *pcLine != '\r'    Œÿÿÿÿ   ‰      Œÿÿÿÿ   ‰                    4|x   (               /   |ÿÿÿÿ   |ÿÿÿÿ     4rx      expression was false       pcLine[strlen(pcLine)-1] == ';'    ÿÿÿÿ   |      ÿÿÿÿ   |   /                4oP   )      (      (      %ÿÿÿÿ   %ÿÿÿÿ     .X       statement executed        }    (ÿÿÿÿ   %      (ÿÿÿÿ   %              *      1      1      .ÿÿÿÿ   .ÿÿÿÿ     .         statement executed        }    1ÿÿÿÿ   .      1ÿÿÿÿ   .              +      =      =      :ÿÿÿÿ   :ÿÿÿÿ     .$X       statement executed        return (*this);    =ÿÿÿÿ   :      =ÿÿÿÿ   :              ,      W      W      Tÿÿÿÿ   Tÿÿÿÿ     4Nø       statement executed        }    Wÿÿÿÿ   T      Wÿÿÿÿ   T              -      _   	   _   
   \ÿÿÿÿ   \ÿÿÿÿ     4V@       statement executed        }    _ÿÿÿÿ   \   	   _ÿÿÿÿ   \   
           .      b      b      _ÿÿÿÿ   _ÿÿÿÿ     4X@       statement executed        }    bÿÿÿÿ   _      bÿÿÿÿ   _              /      k      k      hÿÿÿÿ   hÿÿÿÿ     4`(       statement executed        }    kÿÿÿÿ   h      kÿÿÿÿ   h              0      p      p      mÿÿÿÿ   mÿÿÿÿ     4d`       statement executed        }    pÿÿÿÿ   m      pÿÿÿÿ   m              1      ‚      ‚      ÿÿÿÿ   ÿÿÿÿ     4q        statement executed        }    ‚ÿÿÿÿ         ‚ÿÿÿÿ                 2      ƒ   	   ƒ   
   €ÿÿÿÿ   €ÿÿÿÿ     4s`       statement executed        }    ƒÿÿÿÿ   €   	   ƒÿÿÿÿ   €   
           3                  Œÿÿÿÿ   Œÿÿÿÿ     4~X       statement executed        }    ÿÿÿÿ   Œ      ÿÿÿÿ   Œ              4      ’   	   ’   
   ÿÿÿÿ   ÿÿÿÿ     íš       statement executed        }    ’ÿÿÿÿ      	   ’ÿÿÿÿ      
           5      š   	   š   
   —ÿÿÿÿ   —ÿÿÿÿ     í¡(       statement executed        }    šÿÿÿÿ   —   	   šÿÿÿÿ   —   
           6          	       
   ÿÿÿÿ   ÿÿÿÿ     í¦¨       statement executed        }     ÿÿÿÿ      	    ÿÿÿÿ      
           7      ¨      ¨      ¥ÿÿÿÿ   ¥ÿÿÿÿ     í­Ø       statement executed        }    ¨ÿÿÿÿ   ¥      ¨ÿÿÿÿ   ¥              8      «   	   «   
   ¨ÿÿÿÿ   ¨ÿÿÿÿ     í¯Ø       statement executed        }    «ÿÿÿÿ   ¨   	   «ÿÿÿÿ   ¨   
           9      µ   	   µ   
   ²ÿÿÿÿ   ²ÿÿÿÿ     í¶°       statement executed        }    µÿÿÿÿ   ²   	   µÿÿÿÿ   ²   
           :      ¾   	   ¾   
   »ÿÿÿÿ   »ÿÿÿÿ     í¾       statement executed        }    ¾ÿÿÿÿ   »   	   ¾ÿÿÿÿ   »   
           ;      ¿      ¿      ¼ÿÿÿÿ   ¼ÿÿÿÿ     í¿Ğ       statement executed        }    ¿ÿÿÿÿ   ¼      ¿ÿÿÿÿ   ¼              <      Á      Á      ¾ÿÿÿÿ   ¾ÿÿÿÿ     íÁ       statement executed        return 1;    Áÿÿÿÿ   ¾      Áÿÿÿÿ   ¾              =      ×      ×      Ôÿÿÿÿ   Ôÿÿÿÿ     íÉ˜       statement executed        }    ×ÿÿÿÿ   Ô      ×ÿÿÿÿ   Ô              >      Ø      Ø      Õÿÿÿÿ   Õÿÿÿÿ     íËX       statement executed        }    Øÿÿÿÿ   Õ      Øÿÿÿÿ   Õ              ?      w      w      tÿÿÿÿ   tÿÿÿÿ     4t8      expression was false       true_end == false    wÿÿÿÿ   t      wÿÿÿÿ   t                   4j(   @      m      m   '   jÿÿÿÿ   jÿÿÿÿ     4e8      expression was false       pcLine[strlen(pcLine)-1] != ';'    mÿÿÿÿ   j      mÿÿÿÿ   j   '                4b(   A      \      \      Yÿÿÿÿ   Yÿÿÿÿ     4W      expression was false       *pcLine != '\r'    \ÿÿÿÿ   Y      \ÿÿÿÿ   Y                   4THCValueTable::CValueTable CValueTable::CValueTable()    &      (      #ÿÿÿÿ   %ÿÿÿÿCValueTable::~CValueTable CValueTable::~CValueTable()    0      1      -ÿÿÿÿ   .ÿÿÿÿCValueTable::operator= CValueTable& CValueTable::operator=(CValueTable& Tab)    :      >      7ÿÿÿÿ   ;ÿÿÿÿCValueTable::Format int CValueTable::Format(char* pcLine, fstream& fileInput)    I      Â      Fÿÿÿÿ   ¿ÿÿÿÿCValueTable::writeValueTabToFile void CValueTable::writeValueTabToFile(fstream& fileOutput, list<CValueTable> &vTab)    Ì      Ø      Éÿÿÿÿ   Õÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ValueTable.cpp
 * \brief     Implementation of the value table class
 * \authors   Mahesh.B.S, Tobias Lorenz
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation of the value table class.
 */

/* Project includes */
#include "Signal.h"
#include "Tag.h"
#include "ValueTable.h"

using namespace std;

/**
 * \brief Constructor
 *
 * Constructor of CValueTable
 */
CValueTable::CValueTable()
{
    m_TableName = "";
}

/**
 * \brief Destructor
 *
 * Destructor of CValueTable
 */
CValueTable::~CValueTable()
{
}

/**
 * \brief     = operator overloading
 * \param[in] Tab Data to assign
 *
 * Copyies the contents of Tab to the local instance.
 */
CValueTable& CValueTable::operator=(CValueTable& Tab)
{
    m_TableName = Tab.m_TableName;
    m_values = Tab.m_values;
    return (*this);
}

/**
 * \brief     Extracts Values and value descriptors from the line
 * \param[in] pcLine String having the value table name followed by the
 *            value, value descriptor as in canoe format
 * \param[in] fileInput Input file
 *
 * Extracts Values and value descriptors from the line.
 */
int CValueTable::Format(char* pcLine, fstream& fileInput)
{
    char acValue[defVTAB_MAX_VALU_LEN];
    char acLine[defVTAB_MAX_LINE_LEN] = {'\0'};
    char acDesc[defVTAB_MAX_DESC_LEN];
    char table_Name[defVTAB_MAX_TNAM_LEN];
    bool true_end = true;
    char* pcValue = acValue;
    char* pcDesc = acDesc;
    char* pcTab = table_Name;

    // skip leading spaces
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    // get table name
    while(*pcLine && *pcLine != ' ')
    {
        if (*pcLine != '\r')
        {
            *pcTab++ = *pcLine;
        }

        pcLine++;
    }

    *pcTab = '\0';
    m_TableName = table_Name;

    // skip spaces
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    if(pcLine[strlen(pcLine)-1] != ';')
    {
        true_end  = false;
    }

    while(*pcLine && *pcLine != ';')
    {
        //Value table can be of more than 1024 char. So when the we have almost reached
        //the end of the buffer check if we have reached the correct end i.e ";".If not than
        //read the next line and proceed.
        if(true_end == false)
        {
            string pcTemp;
            fileInput.getline(acLine, defVTAB_MAX_LINE_LEN);
            pcTemp = pcLine;
            pcTemp += acLine;
            strncpy(pcLine, pcTemp.c_str(), sizeof(pcLine));

            if(pcLine[strlen(pcLine)-1] == ';')
            {
                true_end  = true;
            }
        }

        pcValue = acValue;
        pcDesc = acDesc;
        // get value
        *pcValue = *pcDesc = '\0';

        while(*pcLine && *pcLine != ' ')
        {
            if (*pcLine != '\r')
            {
                *pcValue++ = *pcLine;
            }

            pcLine++;
        }

        *pcValue = '\0'; // terminate the string

        // skip spaces
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        // skip '"'
        while(*pcLine && *pcLine == '\"')
        {
            *pcLine++;
        }

        // get description
        while(*pcLine && *pcLine != '\"')
        {
            if (*pcLine != '\r')
            {
                *pcDesc++ = *pcLine;
            }

            pcLine++;
        }

        *pcDesc = '\0';
        // skip trailing '"'
        pcLine++;

        // skip spaces if any before next iteration.
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        // if any value read then add it to list
        if(acDesc[0] != '\0')
        {
            CValueDescriptor valDesc;
			valDesc.m_value.i64Value = _atoi64(acValue);
            valDesc.m_acDescriptor = acDesc;
            m_values.push_back(valDesc);
        }
    }

    return 1;
}

/**
 * \brief     writes the value tebles in the given list to the output file
 * \param[in] fileOutput Pointer to the Output file
 * \param[in] vTab List of Value tables
 *
 * Writes the value tebles in the given list to the output file.
 */
void CValueTable::writeValueTabToFile(fstream& fileOutput, list<CValueTable> &vTab)
{
    list<CValueTable>::iterator tab;

    for (tab=vTab.begin(); tab!=vTab.end(); ++tab)
    {
        fileOutput << T_ST_TAB " ";
        fileOutput << tab->m_TableName.c_str();
        fileOutput << endl;
        CValueDescriptor desc;
        desc.writeValueDescToFile(fileOutput, CSignal::SIG_TYPE_INT64, tab->m_values);
        fileOutput << T_END_TAB << endl;
    }
}

CCAPL2CConverter::CCAPL2CConverter(void)
{
}

HRESULT CCAPL2CConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the CANoe CAPL(.can) file to BUSMASTER Node Simulation(.c) file";
    return ((HRESULT)1L);
}

HRESULT CCAPL2CConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "CAPL TO C Conversion";
    return ((HRESULT)1L);
}

HRESULT CCAPL2CConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case ((HRESULT)0L):
            m_omstrConversionStatus = "Conversion success";
            break;

        case ((HRESULT)1L):
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return ((HRESULT)1L);
}

HRESULT CCAPL2CConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    return ((HRESULT)1L);
}

HRESULT CCAPL2CConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    return ((HRESULT)1L);
}

HRESULT CCAPL2CConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    return ((HRESULT)1L);
}

HRESULT CCAPL2CConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    return ((HRESULT)1L);
}

BOOL CCAPL2CConverter::bHaveOwnWindow()
{
    return 1;
}

CCAPL2CConverter::~CCAPL2CConverter(void)
{
};

HRESULT CCAPL2CConverter::GetPropertyPage(CPropertyPage*& pPage)
{
    pPage = new CCAPL2CPropertyPage();
    return ((HRESULT)1L);
};
          J      J      Fÿÿÿÿ   Fÿÿÿÿ    –)       statement executed        return ((HRESULT)1L);    Jÿÿÿÿ   F      Jÿÿÿÿ   F                    E      E      Aÿÿÿÿ   Aÿÿÿÿ    –°       statement executed        }    Eÿÿÿÿ   A      Eÿÿÿÿ   A                    @      @      <ÿÿÿÿ   <ÿÿÿÿ    •ÿÈ       statement executed        return 1;    @ÿÿÿÿ   <      @ÿÿÿÿ   <                    ;      ;      7ÿÿÿÿ   7ÿÿÿÿ    – °       statement executed        return ((HRESULT)1L);    ;ÿÿÿÿ   7      ;ÿÿÿÿ   7                    6      6      2ÿÿÿÿ   2ÿÿÿÿ    •ğP       statement executed        return ((HRESULT)1L);    6ÿÿÿÿ   2      6ÿÿÿÿ   2                    1      1      -ÿÿÿÿ   -ÿÿÿÿ    •ñ8       statement executed        return ((HRESULT)1L);    1ÿÿÿÿ   -      1ÿÿÿÿ   -                                ÿÿÿÿ   ÿÿÿÿ    ƒ›0       statement executed        }    ÿÿÿÿ         ÿÿÿÿ                                   	ÿÿÿÿ   	ÿÿÿÿ    „‚¨       statement executed        return ((HRESULT)1L);    ÿÿÿÿ   	      ÿÿÿÿ   	                                ÿÿÿÿ   ÿÿÿÿ    +à        statement executed        return ((HRESULT)1L);    ÿÿÿÿ         ÿÿÿÿ                 	                  ÿÿÿÿ   ÿÿÿÿ    ,        statement executed        break;    ÿÿÿÿ         ÿÿÿÿ                 
                    ÿÿÿÿ   ÿÿÿÿ    ƒP       statement executed        break;     ÿÿÿÿ          ÿÿÿÿ                       $      $       ÿÿÿÿ    ÿÿÿÿ    ƒ(˜       statement executed        break;    $ÿÿÿÿ          $ÿÿÿÿ                        '      '      #ÿÿÿÿ   #ÿÿÿÿ    ƒà       statement executed        return ((HRESULT)1L);    'ÿÿÿÿ   #      'ÿÿÿÿ   #                    ,      ,      (ÿÿÿÿ   (ÿÿÿÿ    •ßÈ       statement executed        return ((HRESULT)1L);    ,ÿÿÿÿ   (      ,ÿÿÿÿ   (           CCAPL2CConverter::CCAPL2CConverter CCAPL2CConverter::CCAPL2CConverter(void)                ÿÿÿÿ   ÿÿÿÿCCAPL2CConverter::GetHelpText HRESULT CCAPL2CConverter::GetHelpText(string& pchHelpText)                ÿÿÿÿ   
ÿÿÿÿCCAPL2CConverter::GetConverterName HRESULT CCAPL2CConverter::GetConverterName(string& strConverterName)                ÿÿÿÿ   ÿÿÿÿCCAPL2CConverter::GetErrorStatus HRESULT CCAPL2CConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)          (      ÿÿÿÿ   $ÿÿÿÿCCAPL2CConverter::GetInputFileFilters HRESULT CCAPL2CConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)    +      -      'ÿÿÿÿ   )ÿÿÿÿCCAPL2CConverter::GetLastConversionStatus HRESULT CCAPL2CConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)    0      2      ,ÿÿÿÿ   .ÿÿÿÿCCAPL2CConverter::GetOutputFileFilters HRESULT CCAPL2CConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)    5      7      1ÿÿÿÿ   3ÿÿÿÿCCAPL2CConverter::ConvertFile HRESULT CCAPL2CConverter::ConvertFile(string& chInputFile, string& chOutputFile)    :      <      6ÿÿÿÿ   8ÿÿÿÿCCAPL2CConverter::bHaveOwnWindow BOOL CCAPL2CConverter::bHaveOwnWindow()    ?      A      ;ÿÿÿÿ   =ÿÿÿÿCCAPL2CConverter::~CCAPL2CConverter CCAPL2CConverter::~CCAPL2CConverter(void)    D      E      @ÿÿÿÿ   AÿÿÿÿCCAPL2CConverter::GetPropertyPage HRESULT CCAPL2CConverter::GetPropertyPage(CPropertyPage*& pPage)    H      K      Dÿÿÿÿ   Gÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ#include "CAPL2CConverter.h"
#include "Definitions.h"
#include "Converter.h"
#include "CAPL2CPropertyPage.h"

CCAPL2CConverter::CCAPL2CConverter(void)
{
}

HRESULT CCAPL2CConverter::GetHelpText(string& pchHelpText)
{
    pchHelpText = "Converts the CANoe CAPL(.can) file to BUSMASTER Node Simulation(.c) file";
    return S_FALSE;
}

HRESULT CCAPL2CConverter::GetConverterName(string& strConverterName)
{
    strConverterName = "CAPL TO C Conversion";
    return S_FALSE;
}

HRESULT CCAPL2CConverter::GetErrorStatus(HRESULT hResult, string& omstrStatus)
{
    switch( hResult )
    {
        case S_OK:
            m_omstrConversionStatus = "Conversion success";
            break;

        case S_FALSE:
            m_omstrConversionStatus = "Conversion failed";
            break;

        default:
            m_omstrConversionStatus = "Unknown";
            break;
    }

    return S_FALSE;
}

HRESULT CCAPL2CConverter::GetInputFileFilters(string& pchInputDefFilters, string& pchInputFilters)
{
    return S_FALSE;
}

HRESULT CCAPL2CConverter::GetLastConversionStatus(HRESULT& hResult, string& omstrStatus)
{
    return S_FALSE;
}

HRESULT CCAPL2CConverter::GetOutputFileFilters(string& pchOutputDefFilters, string& pchOutputFilters)
{
    return S_FALSE;
}

HRESULT CCAPL2CConverter::ConvertFile(string& chInputFile, string& chOutputFile)
{
    return S_FALSE;
}

BOOL CCAPL2CConverter::bHaveOwnWindow()
{
    return TRUE;
}

CCAPL2CConverter::~CCAPL2CConverter(void)
{
};

HRESULT CCAPL2CConverter::GetPropertyPage(CPropertyPage*& pPage)
{
    pPage = new CCAPL2CPropertyPage();
    return S_FALSE;
};





















static AFX_EXTENSION_MODULE CAPL2CConverterDLL = { 0, 0 };





extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
    (lpReserved);

    if (dwReason == 1)
    {
        ;

        
        if (!AfxInitExtensionModule(CAPL2CConverterDLL, hInstance))
        {
            return 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        new CDynLinkLibrary(CAPL2CConverterDLL);
    }
    else if (dwReason == 0)
    {
        ;
        
        AfxTermExtensionModule(CAPL2CConverterDLL);
    }

    return 1;   
}







extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CCAPL2CConverter();
    return ((HRESULT)0L);
}
          B      B      9ÿÿÿÿ   9ÿÿÿÿ    ,       expression was false       dwReason == 0    Bÿÿÿÿ   9      Bÿÿÿÿ   9                  +Ş`         2      2      )ÿÿÿÿ   )ÿÿÿÿ    ƒœ       statement executed        return 0;    2ÿÿÿÿ   )      2ÿÿÿÿ   )                    A      A      8ÿÿÿÿ   8ÿÿÿÿ    +à        statement executed        }    Aÿÿÿÿ   8      Aÿÿÿÿ   8                    G      G      >ÿÿÿÿ   >ÿÿÿÿ    +Ü        statement executed        }    Gÿÿÿÿ   >      Gÿÿÿÿ   >                    I      I      @ÿÿÿÿ   @ÿÿÿÿ    „‚¨       statement executed        return 1;    Iÿÿÿÿ   @      Iÿÿÿÿ   @                    U      U      Lÿÿÿÿ   Lÿÿÿÿ    Õà       statement executed        return ((HRESULT)0L);    Uÿÿÿÿ   L      Uÿÿÿÿ   L                    0      0   C   'ÿÿÿÿ   'ÿÿÿÿ    ƒ›0      expression was false       !AfxInitExtensionModule(CAPL2CConverterDLL, hInstance)    0ÿÿÿÿ   '      0ÿÿÿÿ   '   C               ƒPDllMain extern "C" int __stdcall
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)    '      J      ÿÿÿÿ   AÿÿÿÿGetBaseConverter extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)    S      V      Jÿÿÿÿ   Mÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ// CAPL2CConverter.cpp : Defines the initialization routines for the DLL.
//

#define VC_EXTRALEAN        /* Exclude rarely-used stuff from Windows headers */
#include <afxwin.h>         /* MFC core and standard components */
#include <afxext.h>         /* MFC extensions */
#include <afxdisp.h>        /* MFC Automation classes */
#include <afxdtctl.h>       /* MFC support for Internet Explorer 4 Common Controls */
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         /* MFC support for Windows Common Controls */
#endif /* _AFX_NO_AFXCMN_SUPPORT */
#include <afxdlgs.h>
#include <afxdllx.h>
#include "CAPL2CConverter.h"

#ifdef _MANAGED
#error Please read instructions in CAPL2CConverter.cpp to compile with /clr
// If you want to add /clr to your project you must do the following:
//  1. Remove the above include for afxdllx.h
//  2. Add a .cpp file to your project that does not have /clr thrown and has
//     Precompiled headers disabled, with the following text:
//          #include <afxwin.h>
//          #include <afxdllx.h>
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


static AFX_EXTENSION_MODULE CAPL2CConverterDLL = { NULL, NULL };

#ifdef _MANAGED
#pragma managed(push, off)
#endif

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("CAPL2CConverter.DLL Initializing!\n");

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(CAPL2CConverterDLL, hInstance))
        {
            return 0;
        }

        // Insert this DLL into the resource chain
        // NOTE: If this Extension DLL is being implicitly linked to by
        //  an MFC Regular DLL (such as an ActiveX Control)
        //  instead of an MFC application, then you will want to
        //  remove this line from DllMain and put it in a separate
        //  function exported from this Extension DLL.  The Regular DLL
        //  that uses this Extension DLL should then explicitly call that
        //  function to initialize this Extension DLL.  Otherwise,
        //  the CDynLinkLibrary object will not be attached to the
        //  Regular DLL's resource chain, and serious problems will
        //  result.
        new CDynLinkLibrary(CAPL2CConverterDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("CAPL2CConverter.DLL Terminating!\n");
        // Terminate the library before destructors are called
        AfxTermExtensionModule(CAPL2CConverterDLL);
    }

    return 1;   // ok
}

#ifdef _MANAGED
#pragma managed(pop)
#endif



extern "C" __declspec(dllexport) HRESULT GetBaseConverter(CBaseConverter*& pouConverter)
{
    pouConverter = new CCAPL2CConverter();
    return S_OK;
}





























class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    
    
    enum { IDD = 100 };
    

    
    
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    

    
protected:
    
    
    
    private: static const AFX_MSGMAP_ENTRY _messageEntries[]; protected: static  const AFX_MSGMAP messageMap; static const AFX_MSGMAP* __stdcall _GetBaseMessageMap(); virtual const AFX_MSGMAP* GetMessageMap() const;
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    
    
    
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    
    
}

const AFX_MSGMAP* __stdcall CAboutDlg::_GetBaseMessageMap() { return &CDialog::messageMap; } const AFX_MSGMAP* CAboutDlg::GetMessageMap() const { return &CAboutDlg::messageMap; }   const AFX_MSGMAP CAboutDlg::messageMap = { &CAboutDlg::_GetBaseMessageMap, &CAboutDlg::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CAboutDlg::_messageEntries[] = {
    
    
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };




CCAPL2CPropertyPage::CCAPL2CPropertyPage(CWnd* pParent )
    : CPropertyPage(CCAPL2CPropertyPage::IDD)
{
    
    m_check = 0;
    m_savedb = 0;
    
    
    m_hIcon = AfxGetApp()->LoadIconA(128);
}

void CCAPL2CPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    
    DDX_Check(pDX, 1018, m_check);
    DDX_Check(pDX, 1045, m_savedb);
    
}

const AFX_MSGMAP* __stdcall CCAPL2CPropertyPage::_GetBaseMessageMap() { return &CPropertyPage::messageMap; } const AFX_MSGMAP* CCAPL2CPropertyPage::GetMessageMap() const { return &CCAPL2CPropertyPage::messageMap; }   const AFX_MSGMAP CCAPL2CPropertyPage::messageMap = { &CCAPL2CPropertyPage::_GetBaseMessageMap, &CCAPL2CPropertyPage::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CCAPL2CPropertyPage::_messageEntries[] = {
    
    { 0x0112, 0, 0, 0, AfxSig_vwl, (AFX_PMSG)(AFX_PMSGW)(void ( CWnd::*)(UINT, LPARAM))&OnSysCommand },
    { 0x000F, 0, 0, 0, AfxSig_vv, (AFX_PMSG)(AFX_PMSGW)(void ( CWnd::*)(void))&OnPaint },
    { 0x0037, 0, 0, 0, AfxSig_hv, (AFX_PMSG)(AFX_PMSGW)(HCURSOR ( CWnd::*)())&OnQueryDragIcon },
    { 0x0111, (WORD)0, (WORD)1011, (WORD)1011, AfxSig_vv, (AFX_PMSG)&OnBrowseSource },
    { 0x0111, (WORD)0, (WORD)1012, (WORD)1012, AfxSig_vv, (AFX_PMSG)&OnBrowseDest },
    { 0x0111, (WORD)0, (WORD)1008, (WORD)1008, AfxSig_vv, (AFX_PMSG)&OnShowLog },
    { 0x0111, (WORD)0, (WORD)1013, (WORD)1013, AfxSig_vv, (AFX_PMSG)&OnConvert },
    { 0x0111, (WORD)0x0300, (WORD)1006, (WORD)1006, AfxSig_vv, (AFX_PMSG)&OnChangeEditInput },
    { 0x0111, (WORD)0, (WORD)1018, (WORD)1018, AfxSig_vv, (AFX_PMSG)&OnChkbOptn },
    { 0x0111, (WORD)0, (WORD)1004, (WORD)1004, AfxSig_vv, (AFX_PMSG)&OnBrowseCANoeDb },
    { 0x0111, (WORD)0, (WORD)1005, (WORD)1005, AfxSig_vv, (AFX_PMSG)&OnBrowseBUSMASTERDb },
    { 0x0111, (WORD)0, (WORD)1014, (WORD)1014, AfxSig_vv, (AFX_PMSG)&OnCancel },
    { 0x0111, (WORD)0, (WORD)1045, (WORD)1045, AfxSig_vv, (AFX_PMSG)&OnChkbSavedb },
    
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };




BOOL CCAPL2CPropertyPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    
    
    ((void)0);
    ((void)0);
    CMenu* pSysMenu = GetSystemMenu(0);

    if (pSysMenu != 0)
    {
        CString strAboutMenu;
        strAboutMenu.LoadStringA(101);

        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenuA(0x00000800L);
            pSysMenu->AppendMenuA(0x00000000L, 0x0010, strAboutMenu);
        }
    }

    
    
    SetIcon(m_hIcon, 1);         
    SetIcon(m_hIcon, 0);        
    
    return 1;  
}

void CCAPL2CPropertyPage::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == 0x0010)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CPropertyPage::OnSysCommand(nID, lParam);
    }
}





void CCAPL2CPropertyPage::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); 
        SendMessageA(0x0027, (WPARAM) dc.GetSafeHdc(), 0);
        
        int cxIcon = GetSystemMetrics(11);
        int cyIcon = GetSystemMetrics(12);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;
        
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CPropertyPage::OnPaint();
    }
}



HCURSOR CCAPL2CPropertyPage::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}














BOOL List::OnInitDialog()
{
    try
    {
        int Flag = 0;
        int m = 0;
        char allkey[]= {'a','b','c','d','e','f','g','h','i','j','k','l','m','n',
                        'o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E',
                        'F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
                        'W','X','Y','Z','0','1','2','3','4','5','6','7','8','9',0
                       };
        CDialog::OnInitDialog();

        for(m = 0; m < ouUnSptdKey.nGetSize(); m++)
        {
            m_UnSupKeys.AddString( ouUnSptdKey.omGetAt(m) );
        }

        for( m = 0; m < 62 ; m++ )
        {
            Flag = 0;

            for( int p = 0; p <= cIndex2-1; p++)
            {
                if(allkey[m] == acSptdKey[p])
                {
                    Flag = 1;
                    break;
                }
            }

            if( Flag == 0)
            {
                m_AltKeys.AddString( CString( allkey[m] ) );
            }
        }

        m_UnSupKeys.SetCurSel(0);
        m_AltKeys.SetCurSel(0);

        if( m_AltKeys.GetCount() == 0)
        {
            
            GetDlgItem( 1004 )->EnableWindow(0);
            ShowWindow(5);
            MessageBoxA("No Key is avilable",0,0x00000000L);
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"OnInitDialog\"",".\\CAPL2CPropertyPage.cpp",260);
        MessageBoxA(cs);
        exit(0);
    }

    return 1;
}














void List::OnAdd()
{
    int m = 0;
    CString uns,alt,uns1;
    m = m_UnSupKeys.GetCurSel();
    m_UnSupKeys.GetText( m,uns );
    m_UnSupKeys.GetText( m,uns1 );
    m_UnSupKeys.DeleteString( m );
    m = m_AltKeys.GetCurSel();
    m_AltKeys.GetText( m,alt );
    m_AltKeys.DeleteString( m );
    uns = uns+" --->  ";
    uns = uns + alt;
    m_EquiKeys.AddString( uns );
    acAltKey[ouUnSptdKey.nFind(uns1)] = alt[0];
    m_UnSupKeys.SetCurSel(0);
    m_AltKeys.SetCurSel(0);
    m_EquiKeys.SetCurSel(0);

    if(m_UnSupKeys.GetCount() == 0 || m_AltKeys.GetCount() == 0 )
    {
        GetDlgItem( 1004 )->EnableWindow(0);
    }
    else
    {
        GetDlgItem( 1004 )->EnableWindow(1);
    }

    GetDlgItem( 1016 )->EnableWindow(1);
}













void List::OnRemove()
{
    CString ekey;

    if((m = m_EquiKeys.GetCurSel()) != (-1))
    {
        GetDlgItem( 1004 )->EnableWindow(1);
        m_EquiKeys.GetText( m,ekey );
        int k = ekey.Find(' ',0);

        if( k != -1)
        {
            m_UnSupKeys.AddString(ekey.Left(k));
            m_AltKeys.AddString(ekey.Right(1));
        }

        acAltKey [ ouUnSptdKey.nFind( ekey.Left( k)) ] = -1;
        m_EquiKeys.DeleteString(m);
        m_UnSupKeys.SetCurSel(0);
        m_AltKeys.SetCurSel(0);
        m_EquiKeys.SetCurSel(0);
    }

    if(m_EquiKeys.GetCount()==0)
    {
        GetDlgItem(1016)->EnableWindow(0);
    }
}














void List::OnTerminate()
{
    CString buffer;
    CString uns,alt,uns1;

    if(m_UnSupKeys.GetCount()>0)
    {
        if ( m_AltKeys.GetCount() > 0 )
        {
            MessageBoxA("Default combination will be used for rest of the keys","Warning",0x00000000L);
        }

        while(m_UnSupKeys.GetCount()!=0)
        {
            if(m_AltKeys.GetCount()>0)
            {
                m_UnSupKeys.GetText(0,uns);
                m_UnSupKeys.GetText(0,uns1);
                m_UnSupKeys.DeleteString(0);
                m_AltKeys.GetText(0,alt);
                m_AltKeys.DeleteString(0);
                uns = uns+" --->  ";
                uns = uns + alt;
                m_EquiKeys.AddString(uns);
                acAltKey[ ouUnSptdKey.nFind(uns1) ] = alt[0];
            }
            else
            {
                m_UnSupKeys.DeleteString(0);
            }
        }
    }

    if( m_EquiKeys.GetCount() > 0 )
    {
        fprintf(logfile,"---***********************************---");
        fprintf(logfile,"\n---*****List Of User Intervention*****---");
        fprintf(logfile,"\n---***********************************---");
        fprintf(logfile,"\n Unsupported Key -->Equivalent Key");
        fprintf(logfile,"\n ---------------    ---------------\n");
    }

    for(int m = 0; m <= m_EquiKeys.GetCount()-1; m++ )
    {
        m_EquiKeys.GetText( m,buffer );
        fprintf(logfile,"\t%s\n",buffer);
    }

    m_UnSupKeys.ResetContent();
    m_EquiKeys.ResetContent();
    m_AltKeys.ResetContent();
    List::OnOK();
}














void CCAPL2CPropertyPage::OnBrowseSource()
{
    CString omStrPath;
    int nIndex = -1;
    CFileDialog cfd(1,"can",0,0x00000002|0x00001000|
                    0x00000800,"CAN Files(*.can)|*.can||",this);
    cfd.m_ofn.lpstrTitle = "Select CAN File";
    GetDlgItemTextA( 1006,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileStringA("Files","CAPL file","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==1)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemTextA(1006, omStrPath );
    }
}












void CCAPL2CPropertyPage::OnBrowseDest()
{
    CFileDialog cfd(1,"c",0,0x00000002|
                    0x00000004,"BUSMASTER  Files(*.c)|*.c||",this);
    cfd.m_ofn.lpstrTitle = "Select BUSMASTER File";
    CString omStrPath;
    int nIndex;
    GetDlgItemTextA( 1007,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileStringA("Files","CAPL file","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==1)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemTextA(1007,omStrPath);
    }
}











void CCAPL2CPropertyPage::OnShowLog()
{
    CString cs ;
    cs = getenv("windir");
    cs = cs + "\\notepad.exe " + dest1;
    WinExec(cs,5);
}

void CCAPL2CPropertyPage::OnCancel()
{
    CPropertyPage::OnCancel();
}

void CCAPL2CPropertyPage::OnChangeEditInput()
{
    
    
    CString omStrPath;
    GetDlgItemTextA( 1006,omStrPath );

    if( omStrPath.GetLength() > 0 )
    {
        GetDlgItem( 1013 )->EnableWindow(1);
    }
    else
    {
        GetDlgItem( 1013 )->EnableWindow(0);
    }
}

void CCAPL2CPropertyPage::OnChkbOptn()
{
    
    UpdateData();

    if( m_check )
    {
        cFlagH = 1;
        GetDlgItem( 1042 )->EnableWindow(1);
        GetDlgItem( 1004 )->EnableWindow(1);
        GetDlgItem( 1045 )->EnableWindow(1);
    }
    else
    {
        cFlagH = 0;
        SetDlgItemTextA(1042," " );
        SetDlgItemTextA(1043," " );
        
        GetDlgItem( 1042 )->EnableWindow(0);
        GetDlgItem( 1004 )->EnableWindow(0);
        GetDlgItem( 1045 )->EnableWindow(0);
        GetDlgItem( 1043 )->EnableWindow(0);
        GetDlgItem( 1005 )->EnableWindow(0);
    }
}













void CCAPL2CPropertyPage::OnBrowseCANoeDb()
{
    CString omStrPath;
    CFileDialog cfd(1,"dbc",0,0x00000002|0x00001000|
                    0x00000800,"CANoe Database Files(*.dbc)|*.dbc||",this);
    cfd.m_ofn.lpstrTitle = "Select CANoe Database File";
    GetDlgItemTextA( 1042,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if( omStrPath.Find(".dbc",0) != -1)
    {
        omStrPath = omStrPath.Left( omStrPath.GetLength() - 4);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==1)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemTextA(1042, omStrPath );
    }
}














void CCAPL2CPropertyPage::OnBrowseBUSMASTERDb()
{
    CString omStrPath;
    CFileDialog cfd( 1,"dbf",0,0x00000002|
                     0x00000800,"BUSMASTER Database Files(*.dbf)|*.dbf||",this);
    cfd.m_ofn.lpstrTitle = "Select BUSMASTER Database File";
    GetDlgItemTextA( 1043,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if( omStrPath.Find(".dbc",0) != -1)
    {
        omStrPath = omStrPath.Left( omStrPath.GetLength() - 4);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==1)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemTextA(1043, omStrPath );
    }
}

void CCAPL2CPropertyPage::OnChkbSavedb()
{
    UpdateData();

    if( m_savedb )
    {
        cFlagLog = 2;
        GetDlgItem( 1043 )->EnableWindow(1);
        GetDlgItem( 1005 )->EnableWindow(1);
    }
    else
    {
        cFlagLog = 0;
        SetDlgItemTextA(1043," " );
        GetDlgItem( 1043 )->EnableWindow(0);
        GetDlgItem( 1005 )->EnableWindow(0);
    }
}

void CCAPL2CPropertyPage::SaveSettings()
{
    
    CString strSection       = "Files";
    CString strStringItem    = "CAPL File";
    CWinApp* pApp = AfxGetApp();
    CString omStrCAPLName;
    CWnd* pCAPL = GetDlgItem(1006);
    pCAPL->GetWindowTextA(omStrCAPLName);
    pApp->WriteProfileStringA(strSection, strStringItem,omStrCAPLName);
}

void List::OnCancel()
{
    List::OnTerminate();
}

void List::OnClose()
{
    OnTerminate();
    CDialog::OnClose();
}







































void vKeyStoreHeader()
{
    
    try
    {
        char acKeyName[80];

        if( yytext[8] == '\'' )
        {
            
            if( !isalnum( yytext[9] ) )
            {
                char cTemp[2];
                cTemp[0] = yytext[9];
                cTemp[1] = 0;
                ouUnSptdKey.bAdd(cTemp);
            }
            else
            {
                
                acSptdKey[cIndex2++] = yytext[9];
            }
        }
        else
        {
            int m = 8; 

            if( yytext[m] != '*')
            {
                int n = 0;

                while( yytext[m] != 0 && yytext[m] != ':')
                {
                    acKeyName[n++] = yytext[m++];
                }

                acKeyName[n] = 0;
                ouUnSptdKey.bAdd(acKeyName);
            }

            
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vKeyStoreHeader\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",91);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}





void vEnvVar()
{
    
    try
    {
        CString val ;
        int start = 0 ;
        val = yytext ;
        start = val.Find(':',0);
        val = val.Right( val.GetLength() - start - 1 );
        start = val.Find(':',0);
        val = val.Left( start  );
        val.TrimLeft();
        val.TrimRight();
        ouUnSptdKey.bAdd( val );
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vEnvVar\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",120);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}





void vCaplFunc()
{
    
    try
    {
        int start ;
        CString val ;
        val = yytext;
        start = val.Find(':',0);
        val = val.Right( val.GetLength() - start - 1 );
        start = val.Find('(',0);
        val = val.Left( start );
        val.TrimLeft();
        val.TrimRight();
        ouFuncName.bAdd (val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCaplFunc\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",149);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}









void vKeyStoreCase()
{
    
    try
    {
        CString keyname;
        int start ;
        static  char* UnSptdKeyList[] = {    "pageup","pagedown","end","home","f1",
                                             "f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","ctrlpageup",
                                             "ctrlpagedown","ctrlhome","ctrlend","ctrlf1","ctrlf2","ctrlf3","ctrlf4",
                                             "ctrlf5","ctrlf6","ctrlf7","ctrlf8","ctrlf9","ctrlf10","ctrlf11",
                                             "ctrlf12","CursorDown","CursorUp","CursorRight","CursorLeft",
                                             "ctrlCursorDown","ctrlCursorUp","ctrlCursorLeft","ctrlCursorRight"
                                        };
        keyname = yytext;
        start = keyname.FindOneOf("cC");
        keyname = keyname.Right( keyname.GetLength() - start );
        start = keyname.Find(' ',0);
        keyname = keyname.Right( keyname.GetLength() - start - 1 );
        keyname.TrimLeft();
        keyname = keyname.Left( keyname.GetLength() - 1 );
        keyname.TrimRight();

        if( keyname[0] =='\'' )
        {
            keyname = keyname.Mid(1,keyname.GetLength() - 1);
        }

        if( keyname.GetLength() > 1 ) 
        {
            for (int i = 0; i < 40; i++)
            {
                if( _stricmp(UnSptdKeyList[i],keyname) == 0 )
                {
                    ouUnSptdKey.bAdd(keyname);
                    i = 40 ;
                }
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vKeyStoreCase\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",206);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vHeader()
{
    try
    {
        CString val;
        CString HandlerType, HandlerVal;
        val = yytext;

        
        if( val == "/*@@var:*/" )
        {
            
            fprintf(yyout,"/* Start BUSMASTER include header */\n");
            fprintf(yyout,"#include<windows.h>\n");
            fprintf(yyout,"#include<struct.h>\n");
            fprintf(yyout,"/* End BUSMASTER include header */\n");
            fprintf(yyout,"/* Start BUSMASTER global variable */\n");
            fprintf(yyout," typedef unsigned char byte ;\n");
            fprintf(yyout," typedef long word ;\n");
            fprintf(yyout," #define Rx  1\n");
            fprintf(yyout,"char %s[1000];  /*using for Trace*/", " GlobalTrace ");
            nSourceLine = nSourceLine + 6;
            cFlagHeader = 1; 
        }
        else
        {
            
            int start;
            val = val.Left( val.GetLength() - 2);
            val = val.Right( val.GetLength() - 4);
            start = val.Find(':',0);
            HandlerType = val.Left( start  );
            val = val.Right( val.GetLength() - start - 1);
            HandlerVal = val.Left( val.GetLength() - 1 );
            fprintf(yyout,"/* Start BUSMASTER generated function - ");

            if( HandlerType == "timer" )
            {
                
                Footer = "OnTimer_" ;
                Footer += HandlerVal + "_100 */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnTimer_%s_100()\n{",HandlerVal);
            }

            if( HandlerType == "startStart" )
            {
                Footer = "OnDLL_Load */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnDLL_Load()\n{");

                if( fprestart == 1 )
                {
                    fprintf(yyout,"\nUtils_PreStart();");
                    nSourceLine += 1;
                }
            }

            if( HandlerType == "preStart" )
            {
                if( fstart == 0 )
                {
                    
                    Footer = "OnDLL_Load */\n";
                    fprintf(yyout,Footer);
                    fprintf(yyout,"void OnDLL_Load()\n{");
                }
                else
                {
                    
                    Footer = "Utils_PreStart */\n";
                    fprintf(yyout,Footer);
                    fprintf(yyout,"void Utils_PreStart()\n{");
                }
            }

            if(  HandlerType == "stop" )
            {
                Footer = "OnDLL_Unload */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnDLL_Unload()\n{");
            }

            if( HandlerType == "busOff" )
            {
                Footer = "OnError_Bus_Off */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnError_Bus_Off()\n{");
            }

            if( HandlerType == "caplFunc"  )
            {
                Footer = "Utils_";
                int start;
                start = HandlerVal.Find('(',0);

                if( start == -1 )
                {
                    MessageBoxA(0,"Header of caplFunc Handler is wrong","Warning",0x00000000L);
                    exit( 0 );
                }

                HandlerVal = HandlerVal.Left( start );
                Footer += HandlerVal + " */\n";
                fprintf(yyout,Footer);
            }

            if( HandlerType == "errorFrameErrorFrame"  )
            {
                Footer = "OnError_Frame */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnError_Frame()\n{");
            }

            if( HandlerType == "errorActive" )
            {
                Footer = "OnError_Active */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnError_Active()\n{");
            }

            if( HandlerType == "errorPassive"  )
            {
                Footer = "OnError_Passive */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnError_Passive()\n{");
            }

            if( HandlerType == "warningLimit"  )
            {
                Footer = "OnError_Warning_Limit */\n";
                fprintf(yyout,Footer);
                fprintf(yyout,"void OnError_Warning_Limit()\n{");
            }

            if(HandlerType == "key"|| HandlerType == "envVar")
            {
                
                cFlagHeader = 3;

                if(HandlerType == "envVar" )
                {
                    
                    fprintf(logfile,"Environment handler : @ Line No. %d has been replaced with Key Handler\n",nSourceLine );
                }

                if( yytext[8] == '*' )
                {
                    
                    Footer = "OnKey_All */\n";
                    fprintf(yyout,Footer);
                    fprintf(yyout,"void OnKey_All(unsigned char KeyValue)\n{");
                }
                else
                {
                    
                    if( HandlerVal[0] =='\'')
                    {
                        HandlerVal = HandlerVal.Right( HandlerVal.GetLength() - 1 );
                        HandlerVal = HandlerVal.Left( HandlerVal.GetLength() - 1);
                    }

                    int index = ouUnSptdKey.nFind( HandlerVal );

                    if( index == -1)
                    {
                        
                        Footer = "OnKey_";
                        Footer += HandlerVal + " */\n";
                        fprintf(yyout,Footer);
                        fprintf(yyout,"void OnKey_%s(unsigned char KeyValue)\n{",HandlerVal);
                    }
                    else
                    {
                        
                        Footer = "OnKey_";

                        if(  acAltKey[index] == -1)
                        {
                            
                            
                            Footer += HandlerVal + " */\n";
                            fprintf(yyout,Footer);
                            fprintf(yyout,"void OnKey_%s(unsigned char KeyValue)\n{",HandlerVal);
                            fprintf(logfile,"Unsupported Key:%s @ Line No. %d has not been converted\n",HandlerVal,nSourceLine);
                            nUnCnvrtdLine = nUnCnvrtdLine + 2;
                        }
                        else
                        {
                            Footer += CString( acAltKey[index])+" */\n";
                            fprintf(yyout,Footer);
                            fprintf(yyout,"void OnKey_%s(unsigned char KeyValue)\n{",
                                    CString( acAltKey[index] ));
                            fprintf(logfile,"Unsupported Key :'%s' @ %d has been replaced with '%c'\n",HandlerVal,
                                    nSourceLine,acAltKey[index]);
                        }
                    }
                }
            }

            if( HandlerType == "msg" )
            {
                
                cFlagHeader = 4;

                if(yytext[8]=='*')
                {
                    Footer = "OnMsg_All */\n";
                    fprintf(yyout,Footer);
                    fprintf(yyout,"void OnMsg_All(STCAN_MSG RxMsg)\n{");
                }
                else if( !isdigit( HandlerVal[0] ) )
                {
                    
                    start = HandlerVal.FindOneOf("' ':");

                    if( start != -1 )
                    {
                        HandlerVal = HandlerVal.Left( start );
                    }

                    Footer = "OnMsgName_";
                    Footer += HandlerVal + " */\n";
                    fprintf(yyout,Footer);
                    fprintf(yyout,"void OnMsgName_%s(%s RxMsg )\n{",HandlerVal,HandlerVal);
                    
                }
                else
                {
                    if( HandlerVal[ HandlerVal.GetLength() - 1] == 'x' ||
                            HandlerVal[ HandlerVal.GetLength() - 1] == 'X' )
                    {
                        
                        HandlerVal = HandlerVal.Left( HandlerVal.GetLength() - 1 );
                    }

                    start = HandlerVal.Find('-',0);

                    if ( start == -1 )
                    {
                        
                        Footer = "OnMsgID_" ;

                        if( HandlerVal[1] =='x' || HandlerVal[1] =='X')
                        {
                            HandlerVal = HandlerVal.Right( HandlerVal.GetLength() - 2);
                        }
                        else
                        {
                            char* stop;
                            HandlerVal.Format("%x",strtol( HandlerVal, &stop, 10)) ;
                        }

                        Footer += HandlerVal + " */\n";
                        fprintf(yyout,Footer);
                        fprintf(yyout,"void OnMsgID_%s(STCAN_MSG RxMsg)\n{",HandlerVal);
                    }
                    else
                    {
                        
                        Footer = "OnMsgIDRange_";
                        CString id;
                        id = HandlerVal.Left( start );

                        if( id[1] == 'x' || id[1] == 'X')
                        {
                            
                            id = id.Right( id.GetLength() - 2 );
                        }
                        else
                        {
                            
                            char* stop;
                            id.Format("%x",strtol( id, &stop, 10 ));
                            
                        }

                        Footer += id + '_';
                        id = HandlerVal.Right( HandlerVal.GetLength() - start- 1);

                        if( id[1] == 'x' || id[1] == 'X')
                        {
                            
                            id = id.Right( id.GetLength() - 2 );
                        }
                        else
                        {
                            
                            char* stop;
                            id.Format("%x",strtol( id, &stop, 10 ));
                            
                        }

                        Footer +=id + " */\n";
                        fprintf( yyout,Footer);
                        start = Footer.Find('_',0);
                        id = Footer.Right( Footer.GetLength() - start - 1 );
                        id = id.Left( id.GetLength() - 3 );
                        fprintf(yyout,"void OnMsgIDRange_%s(STCAN_MSG RxMsg)\n{",id);
                    }
                }
            }
        }

        nSourceLine = nSourceLine + 2;

        if( HandlerType == "caplFunc"  )
        {
            yy_push_state( 8);
        }
        else
        {
            yy_push_state(4);
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vHeader\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",533);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}





void vDelete()
{
    
    try
    {
        if(cFlagHeader == 1)
        {
            
            yy_push_state(3);
            cFlagHeader = 0;
        }
        else
        {
            
            yy_pop_state();
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vDelete\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",563);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}






void vEndBody()
{
    try
    {
        if(yytext[0]=='{')
        {
            (void) fwrite( yytext, yyleng, 1, yyout );
            counter++;
        }
        else
        {
            counter--;

            if(counter != 0)
            {
                (void) fwrite( yytext, yyleng, 1, yyout );
            }
            else
            {
                counter = 1;
                yy_push_state(11);
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vEndBody\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",601);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}






void vTimerFunc()
{
    try
    {
        CString val, name ;
        int start;

        if( yytext[0] == ';')
        {
            fprintf(yyout,";");
        }

        val = yytext;
        start = val.Find(' ',0);
        name = val.Left(start  );
        name.MakeLower();

        if( name.Find("mstimer") == -1 )
        {
            
            val = val.Right( val.GetLength() - start - 1);
            val.TrimLeft();

            while(val.GetLength() != 0 )
            {
                start = val.FindOneOf(",;");
                name = val.Left( start);
                name.TrimLeft();
                name.TrimRight();
                ouTimerName.bAdd( name );
                val = val.Right( val.GetLength() - start - 1 );
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vTimerFunc\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",649);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vCnvrtByte()
{
    try
    {
        
        
        
        CString val,name,type,index;
        int start , end ;
        val = yytext;
        start = val.Find(".",0);
        name = val.Left(start);
        name.TrimLeft();
        name.TrimRight();
        end = val.Find("(",start);
        type = val.Mid(start+1,end-start-1);
        type.TrimLeft();
        type.TrimRight();
        type.MakeLower();
        start = end;
        end = val.Find(")",start);
        index = val.Mid( start + 1 , end - start - 1 );
        index.TrimLeft();
        index.TrimRight();

        if(name == "this" )
        {
            
            name = "RxMsg";
        }

        if( type == "long" )
        {
            
            fprintf(yyout,"%s.m_sWhichBit.m_aulData[%s]",name,index);
        }

        if( type == "byte" )
        {
            
            fprintf(yyout,"%s.m_sWhichBit.m_aucData[%s]",name,index);
        }

        if( type == "word" )
        {
            
            fprintf(yyout,"%s.m_sWhichBit.m_auwData[%s]",name,index);
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCnvrtByte\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",710);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}









void vPutKeyCase()
{
    try
    {
        
        CString keyname;
        int start ;

        if( yytext[0] == ';' || yytext[0] == ',')
        {
            fprintf(yyout,"%c",yytext[0]);
        }

        keyname = yytext;
        start = keyname.FindOneOf("cC");
        keyname = keyname.Right( keyname.GetLength() - start );
        start = keyname.Find(' ',0);
        keyname = keyname.Right( keyname.GetLength() - start - 1 );
        keyname.TrimLeft();
        keyname = keyname.Left( keyname.GetLength() - 1 );
        keyname.TrimRight();

        if( keyname[0] =='\'' )
        {
            keyname = keyname.Mid(1,keyname.GetLength() - 1);
        }

        if( keyname.GetLength() > 1 )
        {
            int nPos = ouUnSptdKey.nFind(keyname);

            if( nPos != -1 )
            {
                
                if( acAltKey[ nPos ] != -1)
                {
                    fprintf(yyout,"case '%c' :",acAltKey[nPos]);
                    fprintf(logfile,"Unsupported Key :'%s' @ %d has been replaced with '%c'\n",keyname,nSourceLine,
                            acAltKey[nPos]);
                }
                else
                {
                    
                    (void) fwrite( yytext, yyleng, 1, yyout );
                    fprintf(logfile,"Unsupported Key : @ Line No. %d has not been changed.\n",nSourceLine);
                    nUnCnvrtdLine = float( nUnCnvrtdLine + 0.5 );
                }
            }
            else
            {
                
                (void) fwrite( yytext, yyleng, 1, yyout );
            }
        }
        else
        {
            
            (void) fwrite( yytext, yyleng, 1, yyout );
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vPutKeyCase\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",787);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}





void vWrite()
{
    try
    {
        
        cFlag = 1 ;
        cFlagH = 0;  
        cFlagLog = 1;
        CString val;
        val = yytext;
        val.MakeLower();

        if( val.Find("writetolog",0) == -1)
        {
            cFlagLog = 0;
        }  

        while( !isalpha(yytext[cFlagH] ) )
        {
            cFlagH++;
        }

        for ( int n = 0; n < cFlagH; n++)
        {
            fprintf(yyout,"%c",' ');
        }

        fprintf(yyout,"sprintf( %s,"," GlobalTrace ");
        yy_push_state(5);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWrite\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",830);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}





void vMsgID()
{
    try
    {
        CString val , name , type;
        int start;
        val = yytext;
        start = val.Find(".",0);
        name = val.Mid(0,start);
        type = val.Mid(start+1,val.GetLength()-2);
        type.MakeLower();
        type.TrimRight();

        if(name == "this")
        {
            name = "RxMsg";
        }

        if(type == "id")
        {
            name = name + ".m_unMsgID" ;
        }
        else if (type == "dlc")
        {
            name = name + ".m_ucDLC" ;
        }

        if(type == "dir")
        {
            
            fprintf(yyout,"Rx");
        }

        if( type.CompareNoCase("can") == 0)
        {
            fprintf(yyout,"%s./*CAN */", name);
        }
        else
        {
            fprintf(yyout,"%s",name);
        }

        fprintf(yyout,"%c",yytext[yyleng-1]);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vMsgID\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",887);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vWriteDot()
{
    try
    {
        
        CString val;
        int a;
        val = yytext;
        a = val.Find(".",0);
        val = val.Mid(0,a);
        val.TrimRight();

        if( val == "this" )
        {
            
            val = "RxMsg" ;
        }

        fprintf(yyout,"%s.m_sWhichBit.",val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWriteDot\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",919);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}

void vRemovePhys()
{
    try
    {
        
        CString omStrParse;
        omStrParse = yytext;
        int nIndex = omStrParse.Find(".",0);

        if( nIndex != -1 )
        {
            fprintf( yyout, "%s/*%s */", omStrParse.Mid( 0, nIndex),
                     omStrParse.Mid(nIndex));
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWriteDot\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",943);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vCnvrtThis()
{
    try
    {
        if( cFlagHeader == 4 )
        {
            
            fprintf(yyout,"RxMsg");
        }

        if( cFlagHeader == 3 )
        {
            
            fprintf(yyout,"KeyValue");
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCnvrtThis\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",971);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vWriteTerminator()
{
    try
    {
        
        if(yytext[0] == '(')
        {
            cFlag++;
            (void) fwrite( yytext, yyleng, 1, yyout );
        }
        else if(yytext[0]==')')
        {
            
            cFlag--;
            (void) fwrite( yytext, yyleng, 1, yyout );
        }

        if(  yytext[0] == ';' || ( yytext[0] == ',' && cFlag == 0 ) )
        {
            int n = 0;
            
            fprintf(yyout,",\n");

            for(n = 0; n < cFlagH; n++ )
            {
                
                fprintf(yyout,"%c",' ');
            }

            if ( cFlagLog == 0 )
            {
                fprintf(yyout,"Trace(%s%s "," GlobalTrace ",");");
            }
            else
            {
                fprintf(yyout,"WriteToLogFile(%s%s"," GlobalTrace ",");");
            }

            nSourceLine++;  
            yy_pop_state();
        }
        else
        {
            if(yytext[0] == ',')
            {
                (void) fwrite( yytext, yyleng, 1, yyout );
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWriteTerminator\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",1032);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}









void vSetTimer()
{
    try
    {
        
        CString text,name , val;
        int start , end;
        char wsp;
        int index = 0;

        while( !isalpha(yytext [index] ) )
        {
            
            index++;
        }

        text = yytext;
        start = text.Find("(",7);
        end = text.Find(",",8);
        name = text.Mid(start+1,end-start-1);
        start = end;
        end = text.Find(")",start);
        val = text.Mid(start+1, end -start -1);
        name.TrimLeft();
        name.TrimRight();
        val.TrimLeft();
        val.TrimRight();

        for( wsp = 0 ; wsp <= index ; wsp ++)
        {
            
            fprintf(yyout,"%c",' ');
        }

        fprintf(yyout,"SetTimerVal(\"OnTimer_%s_100\",",name);

        if(ouTimerName.nFind(name) != -1)
        {
            
            val = val + "*1000";
        }

        fprintf(yyout,"%s),\n",val);

        for( wsp = 0 ; wsp <= index ; wsp ++)
        {
            
            fprintf(yyout,"%c",' ');
        }

        fprintf(yyout,"StartTimer(\"OnTimer_%s_100\",0)",name);
        nSourceLine++;
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vSetTimer\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",1102);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}





void vOutput()
{
    try
    {
        
        CString val ;
        int start;
        val = yytext ;
        start = val.Find("(",0);
        val = val.Right( val.GetLength() - start - 1);
        start = val.Find(")",0);
        val = val.Left( start );
        val.TrimLeft();
        val.TrimRight();
        fprintf(yyout,"SendMsg( %s )" ,val );
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vOutput\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",1131);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vCancelTimer()
{
    try
    {
        
        CString val  ;
        int start ;
        val = yytext ;
        start = val.Find("(",10); 
        val = val.Mid( start+1, val.GetLength() - start - 2);
        val.TrimLeft();
        val.TrimRight();
        fprintf(yyout,"StopTimer(\"OnTimer_%s_100\")" , val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCancelTimer\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",1157);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vOnLine()
{
    fprintf(yyout,"GoOnline()");
}




void vOffLine()
{
    fprintf(yyout,"GoOffline()");
}




void vTrigger()
{
    fprintf(yyout,"EnableLogging()");
}




void vResetCan()
{
    fprintf(yyout,"ResetController()");
}




void vDisconnect()
{
    fprintf(yyout,"Disconnect()");
}





void vUnSptdFunc()
{
    fprintf(yyout,"/*");
    (void) fwrite( yytext, yyleng, 1, yyout );
    fprintf(yyout,"*/");
    fprintf(logfile,"Unsupported Function : %s @ Line No. %d\n",yytext,nSourceLine);
    nUnCnvrtdLine = nUnCnvrtdLine + 1 ; 
}






void vFuncCall()
{
    try
    {
        
        CString val ;
        int start;
        val = yytext ;
        start = val.Find("(",0);
        val = val.Left(start);
        val.TrimRight();

        if( ouFuncName.nFind( val ) != -1)
        {
            fprintf(yyout,"Utils_");
        }

        val = val + "(";
        fprintf(yyout,"%s",val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vFuncCall\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",1244);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}




void vAddLine()
{
    
    nSourceLine++;
    (void) fwrite( yytext, yyleng, 1, yyout );
}




void vFooter()
{
    if( yy_top_state() == 3 )
    {
        fprintf(yyout,"/* End BUSMASTER global variable */\n");
        fprintf(yyout,"/* Start BUSMASTER Function Prototype  */\n");
        fprintf(yyout,"/* End BUSMASTER Function Prototype  */");
        nSourceLine = nSourceLine + 2;
        yy_pop_state();
        yy_pop_state();
    }
    else
    {
        fprintf(yyout,"}/* End BUSMASTER generated function - ");
        fprintf(yyout,"%s",Footer);
        nSourceLine += 1; 
    }

    yy_pop_state();
}










int nConvert( CString srs,CString dest ,CString dest1)
{
    yyin = fopen(srs,"r");
    yy_start = 1 + 2 *( 1 ); 
    yylex();
    yyout = fopen (dest,"w");
    logfile = fopen( dest1,"w" );
    fprintf( logfile,"Input File : %s\n",srs );
    fprintf( logfile,"Output File : %s\n",dest );

    if( ouUnSptdKey.nGetSize() > 0)
    {
        
        List d;
        d.DoModal();
    }

    if( cFlagH != 1 && counter == 2 && canoedb.IsEmpty() == 1)
    {
        
        CSelectdb  dialog;
        dialog.DoModal();
    }

    convert.Convert(canoedb);

    if (cFlagLog == 2 )
    {
        
        convert.WriteToOutputFile(busmasterdb);
    }

    cFlagLog = 1;
    counter = 1;
    
    fseek( yyin,0,0 );
    yy_start = 1 + 2 *( 2 );
    yylex();
    nSourceLine = nSourceLine - 1;
    float per = 0;
    per = float((nSourceLine - nUnCnvrtdLine )*100/ nSourceLine);
    fprintf( logfile,"%s%f\n","Percentage of File Converted =",per );
    fclose( yyin );
    fclose( yyout );
    fclose( logfile );
    nSourceLine = 0, nUnCnvrtdLine = 0;
    cIndex2 = 0,cFlag = 0;
    cFlagH = 0, cFlagHeader = 0;
    counter = 1;
    fprestart = 0;
    fstart = 0;
    return( int( per ));
}





void CSelectdb::OnBrowseBUSMASTERDb()
{
    CString omStrPath;
    int nIndex;
    CFileDialog cfd(1,"dbf",0,0x00000002|
                    0x00000800,"BUSMASTER Database Files(*.dbf)|*.dbf||",this);
    cfd.m_ofn.lpstrTitle = "Select BUSMASTER Database File";
    GetDlgItemTextA( 1007,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileStringA("Files","Database File","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==1)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemTextA(1007, omStrPath );
    }
}





void CSelectdb::OnBrowseCANoeDb()
{
    CString omStrPath;
    int nIndex;
    CFileDialog cfd(1,"dbf",0,0x00000002|
                    0x00000800,"CANoe Database Files(*.dbc)|*.dbc||",this);
    cfd.m_ofn.lpstrTitle = "Select CANoe Database File";
    GetDlgItemTextA( 1006,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileStringA("Files","Database File","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==1)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemTextA(1006, omStrPath );
    }
}





void CSelectdb::OnChkbOption()
{
    UpdateData();

    if( m_option )
    {
        
        cFlagLog = 2;
        GetDlgItem( 1007 )->EnableWindow(1);
        GetDlgItem( 1005 )->EnableWindow(1);
    }
    else
    {
        
        cFlagLog = 1;
        SetDlgItemTextA(1007, "");
        GetDlgItem( 1007 )->EnableWindow(0);
        GetDlgItem( 1005 )->EnableWindow(0);
    }
}





void CSelectdb::OnOK()
{
    
    int flag = 1;
    CString extn;
    GetDlgItemTextA( 1006,canoedb );
    canoedb.TrimRight();
    extn = canoedb.Right(4);
    extn.MakeLower();

    if( extn != ".dbc")
    {
        MessageBoxA("Wrong CANoe Database File","Warning",0x00000000L);
        SetDlgItemTextA( 1006,"" );
        GetDlgItem( 1006)->SetFocus();
        flag = 0;
    }
    else
    {
        CFile fdatabase;

        if ( fdatabase.Open( canoedb,CFile::modeRead ) == 0 )
        {
            
            MessageBoxA( "This file does not exist","Warning",0x00000030L|0x00000000L );
            SetDlgItemTextA( 1006,"" );
            GetDlgItem( 1006)->SetFocus();
            flag = 0;
        }
        else
        {
            fdatabase.Close();
        }
    }

    if( cFlagLog == 2)
    {
        GetDlgItemTextA( 1007,busmasterdb );
        busmasterdb.TrimRight();
        extn = busmasterdb.Right(4);
        extn.MakeLower();

        if( extn != ".dbf")
        {
            MessageBoxA("Wrong BUSMASTER Database File","Warning",0x00000000L);
            SetDlgItemTextA( 1007,"" );
            GetDlgItem( 1007)->SetFocus();
            flag = 0;
        }
        else
        {
            CFile fdatabase;

            if ( fdatabase.Open( busmasterdb,CFile::modeCreate|CFile::modeWrite )
                    == 0 )
            {
                
                MessageBoxA( "Output file is in read mode","Warning",0x00000030L|0x00000000L );
                SetDlgItemTextA( 1007,"" );
                GetDlgItem( 1007)->SetFocus();
                flag = 0;
            }
            else
            {
                fdatabase.Close();
            }
        }
    }

    if ( flag == 1 )
    {
        
        CDialog::OnOK();
    }
}










void CCAPL2CPropertyPage::OnConvert()
{
    CString dest , srs ;
    CFile fsrs, fdest, flog; 
    CString extn;
    int flag = 1;

    for( m = 0; m < 254; m++)
    {
        
        acAltKey[m]= -1;
    }

    GetDlgItem(1008)->EnableWindow(0);
    GetDlgItemTextA( 1006,srs );
    GetDlgItemTextA( 1007,dest );
    srs.TrimRight();
    extn = srs.Right(4);
    extn.MakeLower();

    if( extn != ".can" )
    {
        
        MessageBoxA( "Invalid input file","Warning",0x00000030L|0x00000000L );
        SetDlgItemTextA( 1006,"" );
        GetDlgItem( 1006)->SetFocus();
        flag = 0;
    }
    else if( fsrs.Open( srs,CFile::modeRead ) == 0 )
    {
        
        MessageBoxA( "This file does not exist","Warning",0x00000030L|0x00000000L );
        SetDlgItemTextA( 1006,"" );
        GetDlgItem( 1006)->SetFocus();
        flag = 0;
    }
    else
    {
        
        fsrs.Close();
    }

    if(dest == "")
    {
        
        dest = srs.Left( srs.GetLength() - 4 );
        dest += ".c";
    }
    else
    {
        dest.TrimRight();
        extn = dest.Right(2);
        extn.MakeLower();

        if ( extn != ".c")
        {
            MessageBoxA("Invalid Output File","Warning",0x00000030L|0x00000000L );
            SetDlgItemTextA( 1007,"" );
            GetDlgItem( 1007)->SetFocus();
            flag = 0;
        }
    }

    if(fdest.Open(dest,CFile::modeCreate|CFile::modeWrite)==0)
    {
        
        MessageBoxA( "Output file is in read mode","Warning",0x00000030L|0x00000000L );
        SetDlgItemTextA( 1007,"" );
        GetDlgItem( 1007)->SetFocus();
        flag = 0;
    }
    else
    {
        
        fdest.Close();
    }

    if ( cFlagH == 1)
    {
        GetDlgItemTextA( 1042,canoedb );
        canoedb.TrimRight();
        extn = canoedb.Right(4);
        extn.MakeLower();

        if( extn != ".dbc")
        {
            MessageBoxA("Wrong CANoe Database File","Warning",0x00000000L);
            SetDlgItemTextA( 1042,"" );
            GetDlgItem( 1042)->SetFocus();
            flag = 0;
        }
        else
        {
            CFile fdatabase;

            if ( fdatabase.Open( canoedb,CFile::modeRead ) == 0 )
            {
                
                MessageBoxA( "This file does not exist","Warning",0x00000030L|0x00000000L );
                SetDlgItemTextA( 1042,"" );
                GetDlgItem( 1042)->SetFocus();
                flag = 0;
            }
            else
            {
                fdatabase.Close();
            }
        }

        if( cFlagLog == 2)
        {
            GetDlgItemTextA( 1043,busmasterdb );
            busmasterdb.TrimRight();
            extn = busmasterdb.Right(4);
            extn.MakeLower();

            if( extn != ".dbf")
            {
                MessageBoxA("Wrong BUSMASTER Database File","Warning",0x00000000L);
                SetDlgItemTextA( 1043,"" );
                GetDlgItem( 1043)->SetFocus();
                flag = 0;
            }
            else
            {
                CFile fdatabase;

                if ( fdatabase.Open( busmasterdb,CFile::modeCreate|CFile::modeWrite ) == 0 )
                {
                    
                    MessageBoxA( "Output file is in read mode","Warning",0x00000030L|0x00000000L );
                    SetDlgItemTextA( 1043,"" );
                    GetDlgItem( 1043)->SetFocus();
                    flag = 0;
                }
                else
                {
                    fdatabase.Close();
                }
            }
        }
    }

    dest1 = dest;
    dest1 = dest.Left( dest.GetLength() -  2 );
    dest1 +=  "log.txt";

    if(flog.Open(dest1,CFile::modeCreate|CFile::modeWrite)== 0)
    {
        MessageBoxA( "Log file is in read mode","Warning",0x00000030L|0x00000000L );
        flag = 0;
    }
    else
    {
        flog.Close();
    }

    if( flag == 1)
    {
        
        float value;
        value = float( nConvert(srs , dest ,dest1) );
        
        convert.m_listMessages.RemoveAll();
        CWnd* pPercent = GetDlgItem(1016);

        if( pPercent)
        {
            
            CString omStrPercent;
            omStrPercent.Format("%.2f",value);
            pPercent->SetWindowTextA(omStrPercent+ " % ");
            SaveSettings();
        }

        ouUnSptdKey.vClearArray();
        GetDlgItem( 1008 )->EnableWindow(1);
    }
}






void CSelectdb::OnChangeEditAdcanoe()
{
    CString omStrPath;
    GetDlgItemTextA( 1006,omStrPath );

    if( omStrPath.GetLength() > 0 )
    {
        GetDlgItem( 1 )->EnableWindow(1);
    }
    else
    {
        GetDlgItem( 1 )->EnableWindow(0);
    }
}

void CSelectdb::OnCancel()
{
    fprintf(logfile,"You have not assigned the Database.\n");
    CDialog::OnCancel();
}










void vMsgDecl()
{
    try
    {
        CString val , ident , name ;
        int start  ;
        char extndd = 0;
        CMessage msg;
        int flag = 0;
        unsigned int decid;

        if( yytext[0] == ';')
        {
            fprintf(yyout,";");
        }

        val = yytext;
        val.TrimLeft();
        val = val.Right( val.GetLength() - 5 );
        start = val.Find(' ',0);
        val = val.Right(val.GetLength() - start  );
        val.TrimLeft();
        start = val.Find(' ',0 );
        ident = val.Left( start );
        val = val.Right( val.GetLength() - start );
        val.TrimLeft();
        start = val.FindOneOf(" ;=");
        name = val.Left( start );
        val = val.Right( val.GetLength() - start );

        if( ( start = ident.Find('.',0) ) != -1 )
        {
            
            ident = ident.Right( ident.GetLength() - start - 1 );
        }

        if( isdigit( ident[0]) )
        {
            
            flag = 1;

            if( ident[ ident.GetLength() - 1 ] =='x'||
                    ident[ ident.GetLength() - 1 ] =='X')
            {
                
                extndd = 1;
                ident = ident.Left( ident.GetLength() - 1 );
            }

            












            int nIndex = ident.Find("0x");

            if( nIndex == -1 )
            {
                nIndex = ident.Find("0X");
            }

            if( nIndex != -1 )
            {
                nIndex +=2;
                
                char* stop;
                ident = ident.Right(ident.GetLength() - nIndex);
                decid = strtol(ident,&stop,16);
            }
            else
            {
                
                decid = atoi(ident);
            }

            msg = convert.ouFindMessage(decid);
        }
        else
        {
            
            msg = convert.ouFindMessage(ident);
        }

        if( val.Find('{',0) == -1 )
        {
            
            if( flag == 0 )
            {
                if( msg.m_uiMsgID == 0xffffffff )
                {
                    
                    fprintf(logfile,"Message : %s not found in database.\n",ident);
                    nUnCnvrtdLine += 1;
                    
                }

                fprintf(yyout,"%s  %s = { 0x%x,%d,%c,%d };",ident,name,
                        msg.m_uiMsgID,msg.m_cFrameFormat == 'S'? 0 : 1,
                        msg.m_cDataFormat,msg.m_ucLength );
            }
            else
            {
                flag = 0;

                if( msg.m_uiMsgID != 0xffffffff )
                {
                    
                    fprintf(yyout,"%s  %s = { 0x%x,%d,%c,%d };",msg.m_acName,name,
                            msg.m_uiMsgID,extndd,msg.m_cDataFormat,
                            msg.m_ucLength );
                }
                else
                {
                    
                    fprintf(yyout,"STCAN_MSG %s ={ 0x%x,%d,0,8,{0,0,0,0,0,0,0,0}};",name,decid,extndd);
                }
            }
        }
        else
        {
            
            int  end = 0 ;
            char dlc = 8;
            CStringArray csa , msgbyte;
            
            int i;

            for ( i = 0; i< 8; i++)
            {
                
                msgbyte.SetAtGrow(i,'0');
            }

            start = val.Find('{',0);
            val = val.Right( val.GetLength() - start - 1);
            start = 0;

            while((end = val.Find(",",start)) != -1 )
            {
                CString cs = val.Mid(start, end - start);
                csa.Add(cs);
                start = end + 1;
            }

            csa.Add(val.Right( val.GetLength() - start  ));

            for(  i = 0; i < csa.GetSize(); i++)
            {
                CString cs = csa.GetAt( i );
                CString key, value;
                cs.TrimLeft();
                cs.TrimRight();
                int pos = cs.Find("=",0);
                key = cs.Left(pos);
                value = cs.Right(cs.GetLength() - pos - 1 );
                key.TrimLeft();
                key.TrimRight();
                key.MakeLower();
                value.TrimLeft();

                if( ( start =value.FindOneOf("\t\n}") ) != -1 )
                {
                    value = value.Left( start );
                }

                if(key == "dlc")
                {
                    dlc = atoi(value);
                }

                if(cs.Find("byte",0) != -1)
                {
                    
                    CString index;
                    start = key.Find('(',4);
                    end = key.Find(')',6);
                    index = key.Mid( start + 1, end - 2 );
                    index.TrimLeft();
                    index.TrimRight();
                    start = atoi( index );

                    for( int i = 0; i <= 7; i++)
                    {
                        if( i == start )
                        {
                            msgbyte.SetAtGrow(i, value);
                            break;
                        }
                    }
                }

                if(cs.Find("word",0) != -1)
                {
                    CString index;
                    int flag = 0;

                    if ( value[0]=='0'&& (value[1]=='x'||value[1]=='X') )
                    {
                        value = value.Right( value.GetLength() - 2 );
                        flag = 1;
                    }

                    start = key.Find('(',4);
                    end = key.Find(')',6);
                    index = key.Mid( start + 1, end - 2 );
                    index.TrimLeft();
                    index.TrimRight();
                    start = atoi( index );

                    if ( flag == 1 )
                    {
                        CString hex = "0x";
                        msgbyte.SetAtGrow( start*2, hex + value.Left(2) );
                        msgbyte.SetAtGrow( start*2 + 1, hex + value.Right(2) );
                        flag = 0;
                    }
                    else
                    {
                        msgbyte.SetAtGrow( start*2, value.Left(2) );
                        msgbyte.SetAtGrow( start*2 + 1, value.Right(2) );
                    }
                }

                if( cs.Find("long",0) != -1)
                {
                    CString index;
                    int flag = 0;

                    if ( value[0]=='0'&& (value[1]=='x'||value[1]=='X') )
                    {
                        value = value.Right( value.GetLength() - 2 );
                        flag = 1;
                    }

                    start = key.Find('(',4);
                    end = key.Find(')',6);
                    index = key.Mid( start + 1, end - 2 );
                    index.TrimLeft();
                    index.TrimRight();
                    start = atoi( index );

                    if( start == 0 )
                    {
                        if ( flag == 1 )
                        {
                            
                            CString hex = "0x";
                            msgbyte.SetAtGrow(0, hex + value.Left(2) );
                            msgbyte.SetAtGrow(1, hex + value.Mid(2,2) );
                            msgbyte.SetAtGrow(2, hex + value.Mid(4,2) );
                            msgbyte.SetAtGrow(3, hex + value.Right(2) );
                            flag = 0;
                        }
                        else
                        {
                            
                            msgbyte.SetAtGrow(0,value.Left(2) );
                            msgbyte.SetAtGrow(1,value.Mid(2,2) );
                            msgbyte.SetAtGrow(2,value.Mid(4,2) );
                            msgbyte.SetAtGrow(3,value.Right(2) );
                        }
                    }
                    else
                    {
                        
                        if ( flag == 1 )
                        {
                            
                            CString hex = "0x";
                            msgbyte.SetAtGrow(4, hex + value.Left(2) );
                            msgbyte.SetAtGrow(5, hex + value.Mid(2,2) );
                            msgbyte.SetAtGrow(6, hex + value.Mid(4,2) );
                            msgbyte.SetAtGrow(7, hex + value.Right(2) );
                            flag = 0;
                        }
                        else
                        {
                            
                            msgbyte.SetAtGrow(4,value.Left(2) );
                            msgbyte.SetAtGrow(5,value.Mid(2,2) );
                            msgbyte.SetAtGrow(6,value.Mid(4,2) );
                            msgbyte.SetAtGrow(7,value.Right(2) );
                        }
                    }
                }
            }

            if( flag == 0 )
            {
                if( msg.m_uiMsgID == 0xffffffff )
                {
                    fprintf(logfile,"Message : %s not found in database.\n",ident);
                    nUnCnvrtdLine += 1;
                    
                }

                fprintf(yyout,"%s  %s = { 0x%x,%d,0,%d,{",ident,name,
                        msg.m_uiMsgID,msg.m_cFrameFormat == 'S'? 0 : 1,dlc );

                for( int  m = 0; m < dlc; m++)
                {
                    fprintf(yyout,"%s",msgbyte.GetAt( m ));

                    if(m < dlc - 1)
                    {
                        fprintf(yyout,",");
                    }
                }

                fprintf(yyout,"}};");
            }
            else
            {
                flag = 0;

                if( msg.m_uiMsgID != 0xffffffff )
                {
                    fprintf(yyout,"%s  %s = { 0x%x,%d,0,%d,{",msg.m_acName,name,
                            msg.m_uiMsgID,extndd,dlc );

                    for( int  m = 0; m < dlc; m++)
                    {
                        fprintf(yyout,"%s",msgbyte.GetAt( m ));

                        if(m < dlc - 1)
                        {
                            fprintf(yyout,",");
                        }
                    }

                    fprintf(yyout,"}};");
                }
                else
                {
                    fprintf(yyout,"STCAN_MSG %s ={ 0x%x,%d,0,%d,{"
                            ,name,decid,extndd,dlc);

                    for( int  m = 0; m < dlc; m++)
                    {
                        fprintf(yyout,"%s",msgbyte.GetAt(m ));

                        if(m < dlc - 1)
                        {
                            fprintf(yyout,",");
                        }
                    }

                    fprintf(yyout,"}};");
                }
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vMsgDecl\"","d:\\busmaster oss\\sources\\format converter\\capl2cconverter\\Functions.hpp",2107);
        MessageBoxA(0,cs,"Warning",0x00000000L);
        exit(0);
    }
}






void vMsgCpy()
{
    
    CString val;
    int start;

    if( yytext[0] == ';' || yytext[0] == ',')
    {
        fprintf( yyout,"%c",yytext[0] );
    }

    val = yytext;
    start = val.Find("=",0);
    val = val.Left( start );
    val.TrimLeft();
    val.TrimRight();
    fprintf(yyout,"memcpy( &%s, &RxMsg , sizeof( RxMsg ) );",val);
}




void velCount()
{
    
    
    CString val;
    int start ;
    val = yytext;
    start = val.Find('(',0);
    val = val.Right( val.GetLength() - start - 1 );
    val = val.Left( val.GetLength() - 1 );
    
    
    val.TrimLeft();
    val.TrimRight();
    fprintf(yyout,"( sizeof(%s)/sizeof(%s[0]) )",val,val);
}

void CSelectdb::OnClose()
{
    OnCancel();
    CDialog::OnClose();
}





void vUtilFunc()
{
    CString val, parameter;
    int start,end;
    val = yytext;
    val.TrimLeft();
    start = val.Find("(",0);
    end = val.Find(")",start);
    parameter = val.Mid( start+1 ,end - start - 1);
    parameter.TrimLeft();
    parameter.TrimRight();
    val = val.Left( start - 1 );
    val.MakeReverse();
    val.TrimLeft();
    start = val.Find(" ",0);
    val = val.Right( val.GetLength() - start );
    val.TrimLeft();
    val.Find("",0);
    val = val.Left( start );
    val.TrimLeft();
    val.MakeReverse();

    if( val.IsEmpty() )
    {
        
        fprintf(yyout,"void ");
    }
    else
    {
        fprintf(yyout,"%s ",val);
    }

    val = Footer;
    
    val = val.Left( val.GetLength() - 3);
    fprintf(yyout,"%s(",val);
    fprintf(yyout,"%s)\n{",parameter);
    yy_pop_state();
}































































































typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;





































typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		
	char *yy_buf_pos;		

	


	yy_size_t yy_buf_size;

	


	int yy_n_chars;

	



	int yy_is_our_buffer;

	




	int yy_is_interactive;

	



	int yy_at_bol;

	


	int yy_fill_buffer;

	int yy_buffer_status;


	










	};

static YY_BUFFER_STATE yy_current_buffer = 0;









static char yy_hold_char;

static int yy_n_chars;		


int yyleng;


static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		
static int yy_start = 0;	




static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file );

void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer );
void yy_load_buffer_state ( void );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size );
void yy_delete_buffer ( YY_BUFFER_STATE b );
void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file );
void yy_flush_buffer ( YY_BUFFER_STATE b );


YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size );
YY_BUFFER_STATE yy_scan_string ( const char *str );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len );

static void *yy_flex_alloc ( yy_size_t );
static void *yy_flex_realloc ( void *, yy_size_t );
static void yy_flex_free ( void * );



















typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;


static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state );
static int yy_get_next_buffer ( void );
static void yy_fatal_error ( const char msg[] );













static const short int yy_accept[1326] =
    {   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   56,   55,   55,    1,   55,   55,
       55,   55,   48,   33,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   20,   55,   48,   55,   55,   55,   55,   55,
       53,   50,   53,   15,   52,   33,   32,   52,   52,   52,
       52,   52,   52,   52,   52,   52,   52,   52,   52,   52,
       52,   52,   35,   52,   55,   53,    3,   55,   53,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,   47,   54,    0,   46,   29,    0,    0,    0,    0,
       29,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   47,    0,    0,
        0,    0,   17,   16,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   51,   34,    0,   19,   18,    2,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   54,   29,    0,
       27,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       16,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   31,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   31,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   25,    0,    0,    0,
        0,   30,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   46,   30,   30,    0,    0,    0,    0,

        0,    0,    0,   30,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   30,   30,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   28,    0,   30,   30,    0,    0,    0,    0,
        0,    0,   46,   23,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       45,   30,    0,    0,   24,    0,    0,    0,    0,    0,
        0,    0,   30,   30,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   30,    0,    0,    0,    0,    4,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       24,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   30,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   46,    0,    0,    0,    0,   46,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   45,
       30,    0,   24,    0,    0,    0,    0,    0,    0,    0,
        0,   30,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   30,    0,    0,    0,    0,    0,    0,
        0,    9,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   30,    0,    0,

        0,    0,    0,    0,    0,   46,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   26,    0,    0,    0,    0,
        0,   39,    0,    0,    0,    0,    0,    0,    0,    0,
       30,    0,   46,    0,    0,    0,    0,   21,    0,    0,
       30,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   30,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   22,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   26,   26,    0,    0,
        0,    0,   46,    0,    0,    0,   39,    0,    0,   46,
        0,    0,    0,    0,   46,    0,   30,   30,    0,   43,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   30,   30,    0,   49,    0,    0,    0,    0,    0,
        8,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,   12,    0,    0,    0,    0,    0,    0,   46,    0,
        0,   36,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   14,    0,    0,    0,    0,    0,
        0,   44,    0,    0,    0,    0,   37,    0,   30,   43,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   30,    0,    0,    0,    5,    0,    0,    0,    0,
        0,    0,    0,   12,    0,    0,    0,    0,    0,    0,

        0,   46,    0,   41,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   44,    0,    0,   37,    0,   30,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   30,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   46,    0,   42,   41,   41,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,   38,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   40,   42,   42,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   38,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    6,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   40,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    7,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   13,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   13,    0,    0,    0,   11,    0,    0,    0,   13,
       10,    0,    0,   13,    0
    } ;

static const int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    6,    5,    5,    5,    5,    1,    7,
        8,    9,   10,   11,   10,   12,   13,   14,   14,   14,
       14,   14,   14,   14,   14,   14,   14,   15,   16,    1,
       17,    5,    1,   18,   22,   23,   24,   25,   26,   27,
       28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
       21,   38,   39,   40,   41,   42,   43,   44,   45,   46,
       19,   20,   19,    5,   21,    5,   22,   23,   24,   25,

       26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
       36,   37,   21,   38,   39,   40,   41,   42,   43,   44,
       45,   46,   47,    1,   48,    5,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const int yy_meta[49] =
    {   0,
        1,    2,    3,    4,    5,    6,    7,    6,    5,    8,
        9,   10,    5,   11,    5,   12,   13,    5,   14,    1,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,    5,    5
    } ;

static const short int yy_base[1359] =
    {   0,
        0,    0,    0,   35,   71,    0,  119,    0,    2,    5,
      167,    0,    0,   11,    4,   20,   11,  215,   16,   19,
       15,   23,   29,   41, 3529, 4660, 3501, 4660, 3515, 3486,
     3470,  261, 4660, 4660,  216,   44,  303,  217,  235, 3474,
       12,    0, 3460, 3428, 3436, 3429,   18, 3401, 3413,   24,
       27, 3398, 4660,  242,  220,  253,   53,  276,  342,  204,
     4660, 4660,   54, 4660, 4660, 4660, 4660,  216,  287,  309,
      320,  326,  380,  324,  301,  337,  339,  355,  361,  318,
      264, 3419, 4660, 3420, 3370, 3398, 4660, 3394, 3390, 3361,
     3358, 3334,  246,  419,  257,  244,  294,  245, 3330,  277,

      326, 3350,    0,  399, 4660,  461,  405,  422,  429,  442,
     3347,  435,  365,  434,  401,  416,  443,  448,  460,  457,
      468,  479,  476,  484,  487,  492,  500,  507,  508,  515,
        0,  549,  553,    0,  422, 3321, 3323, 4660,  556,  347,
      388,  474, 4660,    0,  559,  564,   56,  383,  516,  558,
      563,  567,  570,  274,  573,  465,  574,  578,  583,  587,
      591,  594, 4660, 4660, 3303, 4660, 4660, 4660, 3328, 3304,
     3319, 3297,  609,  433,  576,  568, 3314,    0, 4660,  626,
     3315, 3280, 3290,  341, 3280, 3265, 3263, 3247,  629,    0,
      635,  645, 3268,  587,  617,  629,  634,  622,  643,  648,

      651,  659,  675,  680,  668,  658,  685,  692,  693,  704,
      721,  701,  714,  734,  735, 3224, 3229,  495,  615,  633,
        0,  742,  663,  764,  697,  765,  768,  798,  769,  774,
      778,  777,  786,  818,  781,  785, 3241, 3213,  807, 3213,
     3202,  663,  745,  777,  839, 3187, 3173, 3169, 3179,    0,
     3167, 3138, 3144,  849, 3151,  769,  797,  833,  853,  887,
      861,  862,  879,  871,  880,  899,  891,  906,  909,  916,
      924,  927,  934,  942,  898,  935,  956,  947,  957,  965,
      972,  979,  919,  980,  987,  995,  998,  981, 1036, 1016,
     1021, 3146, 3147,  848,  716, 1003,  836,  812,  844, 1065,

      855, 1045, 1049,  994,  987, 1050, 1054, 1053, 1058, 1069,
     1070, 1009, 1087, 1078, 1092, 1098, 1099, 1102, 1103, 1107,
     1108,  410, 1111, 3138, 1129, 3132, 3118, 3116, 3090, 3071,
     3074, 3051, 1132, 1112,  859, 3046, 3042,  422, 3030, 2987,
     2987, 2974, 2978, 2985, 2979, 2964, 4660, 2957, 2945, 2950,
     2933, 1150, 1110, 1126, 1133, 1140, 1174, 1147, 1159, 1160,
     1170, 1175, 1178, 1189, 1188, 1196, 1205, 1204, 1212, 1219,
     1226, 1167, 1227, 1235, 1234, 1242, 1245, 1255, 1256, 1263,
     1264, 1272, 1284, 1277, 1291, 1292, 1299, 1302, 1309, 1321,
     1318, 1328, 1362, 1368, 1371, 2934, 1351, 1389, 2925, 2917,

     1294,  901, 1378,  579, 1136, 1220, 1373, 1383, 1386, 1273,
     1393, 1241, 1398, 1402, 1401, 1409, 1419, 1420, 1423, 1410,
     1429, 1424, 1430, 1440, 1441, 1447, 1448, 1453, 1460, 1461,
     1464, 1465, 1472, 1483, 1484, 1034, 1115, 1487, 2905, 1485,
     2892, 2883, 2877, 2892, 2890, 2883, 2865, 1504, 1186, 1513,
     2862, 2860, 2850, 2848, 2806, 2793, 2794,  304, 2771, 2757,
     2741, 1523, 4660, 2727, 1529, 2733, 1505, 1510, 1521, 1528,
      375, 1568,  541,  908, 1574, 1547, 1555, 1529, 1558, 1566,
     1569, 1581, 1580, 1588, 1595, 1605, 1610, 1613, 1620, 1625,
     1634, 1633, 1641, 1681, 1642, 1661, 1656, 1664, 1704, 1679,

     1680, 1719, 1697, 1702, 1705, 1713, 1716, 1724, 1725, 1764,
     1767, 2708, 1740, 1778, 1784, 1758, 1765, 2708, 1803, 1047,
     1430, 1806, 1144, 1650, 1778, 1499, 1523, 1762, 1713, 1800,
     1803, 1543, 1625, 1804, 1807, 1810, 1814, 1815, 1818, 1822,
     1825, 1829, 1850, 1836, 1847, 1853, 1854, 2704, 1857, 1860,
     1869, 1864, 1873, 1876, 1288, 1877, 2695, 1201, 1897, 1233,
     2682, 2664, 2684, 2653, 2651, 1903, 2659, 1915, 1144, 1918,
     1924, 1310, 2639, 2633, 2623, 2623, 2641, 2612, 2603, 2593,
     2592, 2597, 2571, 1934,    0, 2569, 2550, 1907, 1915, 1922,
     1875, 1956, 1962, 1966, 1946, 1914, 1951, 1965, 1954, 1972,

     1973, 1980, 1983, 1990, 1991, 1998, 1999, 2007, 2010, 2022,
     2023, 2030, 2033, 2071, 2571, 2044, 2078, 2058, 2092, 2098,
     2072, 2075, 2080, 2088, 2100, 2089, 2097, 2107, 2115, 2083,
     2535, 2149, 2155, 2127, 2132, 2524, 2166, 2170, 2173, 2545,
     2176, 1987, 2040, 2170, 1917, 2174, 2173, 2179, 2186, 1980,
     2190, 2193, 2198, 2202, 2203, 2207, 2208, 2211, 2214, 2215,
     2220, 2223, 2250, 2538, 2230, 2244, 2247, 2250, 2251, 2254,
     2262, 2263, 2267, 1572, 2270, 2536, 2492, 2486, 2485, 2453,
     2447, 2295, 2440, 1454, 1329, 2433, 2432, 2433, 2411, 2431,
     2400, 2390, 2376, 2386, 2359, 2366, 2338,    0, 2269, 2276,

     2279, 2287, 2321, 1592, 2325, 2331, 2304, 2305, 2315, 2318,
     2357, 2332, 2346, 2345, 2357, 2358, 2365, 2366, 2377, 2374,
     2382, 2385, 2393, 2400, 2355, 2434, 2408, 2450, 2423, 2461,
     2354, 2468,  606, 2471, 2409, 2446, 2447, 2463, 2487, 2470,
     2508, 2514, 2520, 2499, 2494, 2533, 2537, 4660, 2540, 2548,
     1689, 2335, 2541, 2275, 2483, 2545, 2327, 2546, 2551, 2554,
     2558, 2293, 1880, 2394, 2363, 2563, 2581, 2582, 2555, 2586,
     2587, 2590, 2492, 2591, 2595, 2602, 2605, 1744, 2609, 2339,
     2305, 2292, 2301,  310, 2278, 2256, 2260, 2636, 1363, 2245,
     2230, 2212, 1614, 2231,  326, 2217, 2194, 2211, 2166, 4660,

     2169, 2611, 2619, 2622, 2660, 1774, 2666, 2675, 2647, 2614,
     2655, 2662, 2669, 2670, 2677, 2678, 2689, 2696, 2697, 2707,
     2710, 2715, 2718, 2725, 2730, 2735, 2769, 1531, 2177, 2742,
     2780, 2165, 2148, 2786, 2765, 2768, 2806,  788, 2809, 2815,
     2789, 2792, 2804, 2831, 2147, 2814, 2838, 2114, 2854, 2857,
     2833, 2836, 2877, 2880,  240, 2659, 2620, 2764, 2862, 2873,
     2832, 2840, 2780, 2876, 2610, 2876, 2853, 2307, 2893, 2684,
     2896, 2713, 2905, 2909, 2912, 2916, 2920, 2924, 2927, 2931,
     2932, 1833, 1884, 2935, 4660, 2099, 2102, 2134, 2065, 2052,
     4660, 2949, 2081, 2922, 2036, 2043, 2026, 2038, 2279, 2006,

     2001, 4660, 2008, 2966, 2938, 2941, 2979, 2985, 2027, 1936,
     2991, 4660, 3001, 2977, 2978, 2988, 2989, 2996, 2997, 3004,
     3012, 3019, 3007, 3020, 3027, 3030, 3035, 3038, 3045, 3046,
     3056, 3053, 3071, 3061, 4660, 3105, 3111, 3083, 3090,  632,
     3128, 2994, 3104, 3105, 3064, 2001, 3144, 3116, 1942, 3155,
     3127,  868,  450, 3149, 3112, 3153, 2948, 3105, 3156, 3157,
     3160, 3166, 3167, 3173, 3174, 3177, 3178, 3184, 3187, 3199,
     3200, 3204, 3207, 3193, 3210, 3219, 3222, 3228, 3232, 3233,
     3236, 3008, 3237, 1943, 1918, 1908, 1863, 1875, 1842, 1853,
     1820, 1833, 1781, 1788, 1759, 1761, 1728, 3251, 3223, 3265,

     3271, 1735, 1734, 3277, 1683, 3251, 3256, 3263, 3264, 3271,
     3278, 3312, 3288, 3287, 3295, 3300, 3309, 3316, 3323, 3324,
     3331, 3332, 3339, 3346, 3347, 3354, 3362, 3388,  292, 3363,
     3370, 3404, 3305, 3411, 3394, 3417, 3395,    0, 3405, 1019,
     3423, 3431, 3434, 3435, 3438, 3439, 3442,    0, 3445, 3446,
     3454, 3457, 3462, 3465, 3466, 3470, 3471, 3475, 3480, 3481,
     3487, 3490, 3494, 3495, 3499,   31, 3505, 3509, 1922, 3514,
     1702, 1694,  750, 1677, 1640, 1633, 1608, 1586, 1579, 1576,
     3529, 3508, 3542, 1588, 1584, 3549, 3552, 3532, 1973, 3528,
     3529, 3537, 3538, 3545, 3546, 3554, 3561, 3566, 3573, 3576,

     3583, 3586, 3593, 3598, 3601, 3608, 1125, 3616, 3654, 3657,
     3631, 3642,  785, 3632, 3590, 3638, 3659, 3666, 3670, 3674,
     3677, 3678, 3681, 3583, 3684, 3685, 3690, 3693, 3696, 3697,
     3704, 3708, 3709, 3703, 1559, 3725, 1529, 1489, 1476, 1483,
     1472, 1443, 1430, 3742, 3749, 3725, 1420, 3753, 3763, 3766,
     2252, 3739, 3773, 3751, 3758, 3748, 3759, 3766, 3769, 3781,
     3784, 3791, 1409, 3807, 3792, 3799, 3800, 1506, 3829, 3830,
      376, 3833, 3834, 3838, 3842, 3729, 3843, 3846, 3851, 3850,
     3862, 3867, 3870, 1403, 1430, 1388, 1356, 1314, 1283, 1250,
     1230, 1133, 3883, 1095, 3855, 3895, 3902, 3874, 3879, 3887,

     3896, 3895, 3903, 3904, 3912, 1610, 3917, 3922, 3925,  618,
     3877, 3953, 3954, 3957, 3960, 3961, 3964, 3965, 3968, 3971,
     3977, 3981, 3977, 1072, 1056, 1049, 1043, 1012,  980, 4009,
     3987, 3992, 4000, 1828, 3999, 4007, 4041, 3994, 4035, 4036,
     3982, 4039,  979,  940,  921,  897,  845, 4052, 4035, 4038,
      654, 4043, 4046, 4084, 4051, 4077, 4078, 4082,  824,  825,
      802, 4095, 4099, 4117, 4073, 4089, 4127, 4105, 4133, 4133,
     4134, 4138,  799,  728,  713, 4151, 4660, 4156, 2568, 4139,
     4173, 4177, 4184, 4178,  703,  693,  661, 2101, 4129, 4195,
     4202, 1158, 4195,  611,  610,  536, 2874, 4212, 4219, 1075,

      491,  471,  357, 4228, 4234, 1172, 1512,  346,  296,  240,
     4237, 1999, 1329, 4244,  213, 4660,  191, 1723, 4252, 4660,
     4660, 4259, 4262, 4660, 4660, 4278, 4292, 4306, 4320, 4333,
     4344, 4356, 4366, 4380, 4394, 4408, 4421, 1231, 4433, 4446,
     1282, 4460, 4473,  942, 4485, 4497, 4511, 4525, 4538, 4551,
     4564, 1646, 4576, 4590, 4604, 4618, 4631, 4645
    } ;

static const short int yy_def[1359] =
    {   0,
     1326, 1326, 1326, 1326, 1325,    5, 1325,    7, 1327, 1327,
     1325,   11, 1328, 1328, 1328, 1328, 1329, 1329, 1327, 1327,
     1326, 1326, 1327, 1327, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1330, 1325, 1325, 1330, 1325, 1331, 1330, 1331,   39,
       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
       39,   39, 1325, 1330, 1325, 1330, 1325, 1330, 1330,   59,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1332, 1332,
     1332, 1332, 1332,   73,   73,   73,   73,   73,   73,   73,
       73, 1325, 1325, 1325, 1333, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1330, 1330,   59,   94,   59,   59,   59,

       59, 1325, 1334, 1325, 1325, 1325,   39, 1325,   39,   39,
      106,   39,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
       54, 1325, 1330,   59,   59, 1325, 1325, 1325, 1325,   59,
       59,   59, 1325, 1335, 1325, 1332,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146, 1325, 1325, 1333, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325,   59,   59,   59, 1325, 1334, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,  106,
     1325, 1325,  106,  112,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      203,  112,  112,  112,  112, 1325, 1325,   59,   59,   59,
     1335,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  228,  146,  146, 1325, 1325, 1325, 1325,
     1325,   59,   59,   59, 1325, 1325, 1325, 1325, 1325, 1336,
     1325, 1325, 1325, 1325, 1325,  112,  112,  112,  112,   39,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,   39, 1337,  112,
      112, 1325, 1325,   59,   59,   59,  146,  146,  146,  146,

      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146, 1338,  146, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325,   59,   59,   59, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1339,  112,  112,  112,  112, 1340,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112, 1325, 1325, 1337,  395,  112,   39, 1325, 1325,

       59,   59,   59, 1341,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146, 1338, 1338,  146, 1325, 1342,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1340,   59,   59,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1339,  465,  112,  112,  112,  112,
     1340, 1340, 1340, 1340, 1340,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,   39,  112,  112,  112,  112,   39,  112,

      112,   39,  112,  112,  112,  112,  112,  112,  112, 1325,
     1325,  395,  112, 1325, 1325,  112,  112, 1325, 1325,   59,
       59, 1343, 1341, 1341,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  543,  146,  146,
      146,  146,  146,  146, 1338,  146, 1325, 1342, 1342, 1342,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1340,   59, 1325,
     1325,   59, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1344, 1325,  465,  112,  112,  112,
      112, 1340, 1340,   39,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112, 1325, 1345,  112,   39,  112, 1325, 1346,
      112,  112,  112,  112,  112,  112,  112,  112,  112, 1325,
      395,   39, 1325,  112,  112, 1325, 1343,   59, 1343, 1343,
     1343, 1341,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146, 1325, 1345,  146,  146,  146,  146,  146,  146,
      146,  146,  146, 1338,  146, 1325, 1325, 1325, 1347, 1325,
     1325, 1325, 1325,   59,   59, 1325, 1325, 1325, 1325, 1348,
     1325, 1325, 1325, 1325, 1325, 1344, 1325,  465,  112,  112,

      112,  112, 1340, 1340, 1325, 1349,  112,  112,  112,  112,
       39,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112, 1345, 1325,  112, 1350,  112, 1346,
     1346, 1346, 1346,   39,  112,  112,  112,  112,   39,  112,
     1351, 1325, 1325,  112,  112, 1343, 1350, 1325, 1343, 1343,
     1341,  146,  146,  146,  146,  146,  543,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146, 1352,  146, 1325,
     1325, 1325, 1347, 1347, 1325, 1325, 1325,  450,   59, 1325,
     1325, 1325, 1325, 1348, 1348, 1325, 1325, 1325, 1325, 1325,

     1325,  112,  112,  112,   39, 1340, 1349, 1349,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112, 1325, 1325, 1325,  112,
     1350, 1350, 1350, 1350,  112,  112, 1346, 1346, 1325, 1325,
      112,  112,  112, 1325, 1353,  112, 1351,  847, 1325, 1325,
      112,  112, 1350, 1343, 1343,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  759,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146, 1352, 1352,  146, 1325, 1325, 1325, 1347, 1325, 1325,
     1325, 1325, 1353,   59, 1325, 1325, 1325, 1325, 1348, 1325,

     1325, 1325, 1325, 1325,  112,  112,   39, 1325, 1354, 1340,
     1349, 1325, 1349,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112, 1325, 1350, 1350,  112,  112, 1346,
     1325, 1325,  112,  112,  112, 1353, 1353,  112,  847, 1325,
      112,  398, 1343,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  759,  146,  146,  146,  146,  146,  146,
      146, 1352,  146, 1325, 1355, 1347, 1325, 1325,  450, 1325,
     1325, 1325, 1325, 1348, 1325, 1325, 1325, 1325,  112,   39,

     1325, 1356, 1354, 1354, 1340,  112,  112,  112,  112,  112,
      112,   39,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112, 1350, 1350,  112,
      112, 1346, 1325,   39,  112, 1353,  112,  847,  112, 1343,
      146,  146,  146,  146,  146,  146,  146,  543,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  543,  146,  146, 1352,  146,
     1325, 1355, 1355, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325,  112, 1325, 1357, 1356, 1356, 1354, 1325, 1340,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  112,  112, 1350,  112, 1346, 1346,
      112,  112, 1343,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  759, 1358, 1355, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325,  112, 1357, 1357, 1356, 1325,
     1340,  112,   39,  112,  112,  112,  112,  112,  112,  112,
      112,  112, 1350, 1346,  112,  112,  112, 1343,  146,  146,
      543,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146, 1358, 1358, 1355, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325,  112, 1357, 1340,  112,  112,  112,

      112,  112,  112,  112,  112, 1350,  112,  112,  112, 1343,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146, 1358, 1325, 1325, 1325, 1325, 1325, 1325, 1340,
      112,  112,  112, 1350,  112,  112, 1343,  146,  146,  146,
      146,  146, 1358, 1325, 1325, 1325, 1325, 1340,  112,  112,
     1350,  112,  112, 1343,  146,  146,  146,  146, 1325, 1325,
     1325, 1325, 1340, 1340,  112,  112, 1350,  112, 1343,  146,
      146,  146, 1325, 1325, 1325, 1325, 1325, 1340, 1340,  112,
     1350, 1343, 1343,  146, 1325, 1325, 1325, 1340,  112, 1350,
     1343, 1343,  146, 1325, 1325, 1325, 1340, 1350, 1350, 1343,

     1325, 1325, 1325, 1340, 1350, 1350, 1343, 1325, 1325, 1325,
     1340, 1340, 1350, 1343, 1325, 1325, 1325, 1350, 1343, 1325,
     1325, 1350, 1350, 1325,    0, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325
    } ;

static const short int yy_nxt[4709] =
    {   0,
     1325,   27,   33,   27,   62,   28,   33,   62,   82,   83,
       27,   26,   29,   33,   63,   27, 1325,   63,   62,   82,
       87,   62,   33,   84,   86,   83,   26,   86,   87,  115,
       26,   62,  116,   30,   88,   31,   27,  117,   27,   84,
       28,   89,   88,   62,  113,   27,  114,   29,   64,  126,
       27,   64,  102,   89,  122,  128,  103,   26,  123,  147,
      297,  138,  143,  127,  129,  103,  144,  193,   30,  147,
       31,   26,   32,   33,   32,   26,   34,   26,   26,   26,
       26,   35,   26,   36,   37,   26,   38,   26,   26,   26,
       26,   39,   39,   39,   40,   39,   41,   42,   43,   39,

       44,   39,   45,   39,   46,   39,   47,   48,   49,   50,
       51,   39,   39,   52,   39,   39,   39,   53,   53,   26,
       54,   55,   54,   26,   26,   26,   26,   26,   26,   56,
       26,   57,   58,   26,   54,   26,   26,   26,   26,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   59,   58,   58,   58,   58,   58,   60,   58,
       58,   58,   58,   58,   58,   53,   53,   65,   65,   33,
       65,   65,   66,   67,   67,   65,   65,   67,   65,   68,
       69,   65,   67,   65,   65,   65,   65,   70,   70,   70,
       71,   70,   72,   73,   74,   70,   75,   70,   76,   70,

       70,   70,   77,   78,   70,   79,   80,   70,   70,   81,
       70,   70,   70,   65,   65,   26,  577,   95,   97,   95,
       97,  132,  132,  132,  138, 1321,   95,   95,  103,   96,
       26,   95,   97,  142,   26,  132,  104,  104,  104,   98,
       98,  105,   96,  131,  132,  131,  111,  173,  173,  173,
       99,  108,  133,  136,  133,  748,  133,  131,   95,  137,
       95,   26,   94,  133,   94,  953,  174,   95,  133,   96,
       96,   95,   95, 1317,  110,  134,   97,  139,  139,  139,
       98,  135,   96,   96,   98,  193, 1325,  147,  145,  145,
      145, 1325,  108,  147,   99,   97,  147,   97,  106,  100,

      146,  162,  175,  101,  104,  104,  104,  935, 1316,  105,
      145,  145,  145,  228,  106,   96,  107, 1107,  888,  108,
      111,  145,  145,  145,  784,  579,  148,  145,  145,  145,
      147,  111,   96,  147,  899,  155,   96,  111,  147,  580,
      795,  149,  110,  139,  139,  139,  161,  147,  148,  154,
      147,   96, 1325,  147, 1315,  147,  147, 1325,  108,  148,
      150,  147,  156,  176,   96,  148,  147,  140,  147,  147,
      248,  147,   96,  249,  147,  157,  147, 1325, 1310,  158,
      141,  145,  145,  145,  147,  218,  160,  147,  198,  474,
      147,  111,  147,  147,  193,  159,  147,  109,  147,  109,

      104,  104,  104,  109,  147,  105,  189,  189,  189,  151,
      179,  222,  152,   96, 1213,  108,  190,  153,  107,  148,
       94,  193,   94,  191,  191,  191,   96,  219,  192,   95,
      189,  189,  189,  200,   97,  109,  189,  189,  189,  109,
      193,  201,   98,  189,  189,  189,  193,   96,  109,  437,
      109,  142,   99,  193,  109,  199,  453,  100,   96,  454,
       96,  101,  180,  180,  180,  748,  109,  195,  109,  196,
      194,  242,  109,  197,  181,  109,  193,  109,  147, 1309,
      109,  202,  109,  182,  183,  184,  109,  203, 1040,  109,
      185,  109,  109,  186,  109,  109,  204,  187,  109,   96,

      109,  205,  109,  188,  207, 1308,  206,  220,  109,  230,
      109,  109,   96,  109,  109,  208,  109,  109,  109,  109,
       96,  109,  109,  209,  109,  210,  109,  193,  194,  147,
      109,  211,  109,  294,  109,  212,  213,  214,  109,  109,
      109,  109,  109, 1325,  215,  109,  109,  109,  223,  109,
      132,  132,  132,  109,  133,  474,  133,  139,  139,  139,
      145,  145,  145,  133,  132, 1325, 1325, 1325,  133,  193,
      179,  147,  108, 1303,  193,  190,  147,  146,  193,  224,
      147,  193,  136,  147,  193,  193,  147,  147,  137,  193,
      193,  147,  226,   96,  193,  225,  147,  244,  193,  231,

      147,   96,  193,  148,  147,  193,   96,  147,  227,  229,
      173,  173,  173,  732,   96,  243,  256,  232,  524,  109,
      235,  109,  233,  236, 1302,  109,  234,  180,  180,  180,
      189,  189,  189,  748,  838,  105,  191,  191,  191,  732,
       96,  192,  241, 1237,  295,  108,  254,  254,  254,  257,
     1301,  109,  258,   96,  109,  109,  109,  261,  296,  260,
      109,  109,  187,  109,  259,  262,  109,  109,  109,  935,
     1032,   96,  109,  263,  193,  109,  147,  109,  255, 1267,
      109,  109,  109,  109,  265,  109,  109, 1296,  333,  109,
      109,  109,  109,  109,  264,  298,  274,  109,  266,  267,

      109,   96,  109,  194,  273,  268,  109,  109,  193,  109,
      147,  269,  109,  270,  109,  272,  271,  109,  109,  275,
      194,  194,  300,  109,  109,  109,  109,  109,  276,  278,
      109,  109, 1295,  109,  277,  109,  109,  288,  109,  109,
     1294,   96,  109,  279,  109,  280,  109,  281,  109,  402,
     1287,  282,  289,  193,   96,  147,  283,  284, 1136,  285,
      286,  290,  109,  287, 1073, 1286,  109,  109,  109,  109,
       96,  297,  109,  109,  291,  193,  193,  147,  147,  193,
      193,  147,  147,   96,  334,  193,  299,  147,  193,  193,
      147,  147,  193,  302,  147,  732,  193,  193,  147,  147,

      748,  109,   96,  109,  309,  222, 1168,  352,  301,  193,
      310,  147,  311,  312,  222,   96,  335,  940,  353,  322,
     1285,  303,  304,  193,  323,  147,  222,  313,  305,  109,
      326,  109,  327,  405,  306,  109,  307, 1275,  328,  308,
      314,  147,  315,  329,  316,  330, 1274,  193,  317,  147,
      254,  254,  254,  318,  319,  193,  320,  147,  354,  147,
      321,  336,  337, 1273,  338,  109,  193,  109,  147,  401,
      339,  109,  340,   96,  404,  341,  406,  342,  343,  355,
      344,  345,  255, 1262,  450,  109,   96,  356,  357,  357,
      357,  109,  413,  109,  359,  109,  109,   96,  193,  109,

      109,  358,  360,  109,  109,  109,  361,  110,  366,  109,
     1325,  109,  109,  362,  367,  363,  364,  109,  109,  368,
      369,  365,  474,  109,  379,  109,  521,  370,  371,  109,
      109,  109,  109,  109, 1261,  372,  109,  109,  109,   96,
      109,  109,  388,  109,  109,  375,  373,  109,  109,  696,
      109,  109,  696,  109,  109,  374,  109,  109,  109,  109,
     1260,  109,  109,  378,  376,  109,  109,  109,  109,  109,
      380,  377,  109,  109,  109,  381,  109,  382, 1259,  109,
      109,  109,  393,  393,  393,  109,  383,  394,  109,  109,
      109,  109,  193, 1185,  109,  109,  384,  109,  193,  109,

      147,  386,  385,  109,  109,  193,  109,  147,  387, 1247,
      109,  109,  109,  109,  109,  389,  419,  109,  109,  109,
      193,  109,  147,  194,  391,  109,  390,  109,   96,  109,
      109,  418,  109,  109,  748,  392,  109,  189,  189,  189,
      403,   96,  105,  397,  426,  193,  398,  193,  109,  194,
      109,  577,  108,  109,  109,  109,  193, 1113,  147,  109,
      193,  193,  147,  147,  193,  193,  147,  147,  577,  193,
      416,  147,  638,  437,  422,  396,  193,  417,  147,  414,
      193,  193,  147,  147,  415,   96, 1246,  420,  407,  193,
      748,  147,  408,  421, 1245,  423,  425, 1244,  193,  409,

      147,  410,  411,  193, 1307,  147,  424,  412,  427,  193,
      193,  147,  147,  193,  193,  147,  147,  428,  193,  193,
      147,  147,  193, 1229,  147,  432,  193,  430,  431,  429,
      440,  440,  440,  448,  448,  448,  438,   96,  433,  222,
      935,  449,  467,  555,  109,  435,  434,  193,  109,  147,
       96,  189,  189,  189,  437,  193,  105,   96,  468,  469,
      109,  193, 1228, 1163,  109,  109,  108,  109,  525,  684,
       96,  109,  470,  748,  109,  472,  357,  472,  109,  109,
      473,  476,   96,  524,  477,  109, 1300,  935,  474,  466,
      475,  109,  478,  109,  109,  479,  480,  109,  109,  109,

     1313,  109,  109, 1325,  109,  109,  490,  109,  109,  109,
      109,   96,  109,  109,  482,  560,  109,  484,  481,  569,
      109,  109,  109,  109,   96,  483,  109,  109,  109,  485,
      109,  193,  194,  147,  109, 1325,  109,  109,  109,  109,
      436,  436,  486,  109,  109,  526,  109,  560,  488,  487,
      109,  109,  193,  109,  147,  489,  492,  109,  109,  109,
      109,  109,  491,  194,  109,  109,  493,  109,  109,  109,
      495, 1227,  109,  109,  109, 1226,  109,  109,  532,  109,
      109,  494,  496,  109,  193,  497,  147,  109,  109,  109,
      109,  523,  523,  109,  109,  109,  109,  109,  109,  193,

      498,  109,  109,  499,  500,  194,  109,  501,  577,  109,
      109,  109,  194,  530,  502,  109,  109,  674,  109,   96,
      503,  520,  109,  109,  504,  109,  109,  437, 1225,  109,
      109,  109,   96,  109,  109,   96,  109,  109,  505,  502,
      109,  109,  507,  109,  935,  685,  506,  109,   96,  194,
      109,  508,  109,  109,   96,  109,  109,  509, 1318,  109,
      109,  789,  109,  393,  393,  393,  109,   96,  394,  510,
      510,  510,  189,  189,  189,  511,  513,  105,  108,  522,
      522,  522,  193,  109,  193,  109,  147,  108,   96,  109,
      514,  514,  514, 1224,  193,  515,  147,  193,  894,  147,

      193,   96, 1073,   96,  193,  527,  147,  529,  528,  193,
      396,  147,  193,  193,  147,  147,   96, 1185,  531,  533,
      193,  193,  147,  147,  935,  516,  534, 1148,  517,  222,
      193,  193,  147,  147,  193,  193,  147,  147, 1223,  535,
      193,  193,  147,  147, 1185,  540,  536, 1206,  537,  538,
      541,  193,  193,  147,  147,   96,  542,  222,  193,  193,
      147,  147,  539, 1192,  193,  544,  147,  403,   96,  543,
      545,  193,  193,  147,  147,  193,  193,  147,  147,   96,
      547,  222,  577,  193,  546,  147,  559,  440,  559,  549,
      548,  788,   96,  550,  193,  193,  147,  147,  193,  560,

      147, 1191,  548,  551,  553,  568,  448,  568, 1190,  552,
      193,  222,  147,  554,  570,  570,  570, 1189,  474,  571,
      475,  748,  644,  556,  584,  584,  584,  748, 1188,  585,
      189,  189,  189, 1210,  193,  105,  147,  588,   96,  109,
      193,  828,  109,  109,  109,  108,  828,  829,  109,  589,
     1314,   96,  572,  590,  193,  109,  147,  591,  645,  109,
      109,  109,  109,  109,  596, 1187,  109,  109,  466,  472,
      357,  472,  651, 1185,  473,  592,  191,  592,  595,  109,
      593,  109,  474,  193,  475,  109,  594,  109,  474,  109,
      109, 1086,  109,  109, 1325, 1148,  109,  597,  109,  598,

      109,  109,  600,  109,  109, 1143,  474,  109,  599,  602,
      778,  437,  109,  109,  109,  109, 1142,  806,  109,  109,
      109,  604,  109,  601, 1141,  935,  109,  109,  605,  109,
      606, 1234,  603,  109,  607,  896,  193,  109,  147,  109,
      897, 1140,  109,  109,  109,  109,  609,  109,  109,  608,
      898,  109,  109,  194,  109,  882,  882,  109,  109,  109,
      611,  193, 1139,  109,  610,  109,  109,  109,  109,  652,
      612,  109,  109,  109,  109,  109,  109, 1138,  642,  109,
      616,  613,  614,  614,  614, 1325,  617,  615,  618,  524,
      109, 1137,  193,  109,  109,  109,  109,  474,  109,  109,

      193,  622,  109,  494, 1089,  619,  619,  619, 1073,  194,
      620,  109,  109,  109,  109,  193, 1135,  109,  109,  621,
      614,  614,  614,  623,  193,  615,  147,  624,  524,  109,
      193,  109,  194,  194,  109,  109,  109,  109,  935,  109,
      109, 1004, 1086,  109,  625,  109,  647,  109,  109,  628,
      109,  109,  626,  627,  109,  193,  109,  109,  109,  109,
     1080, 1322,  109,  109,  629,  510,  510,  510,  630,  630,
      630,  511,  109,  193,  109,  147, 1325,  632,  109,  514,
      514,  514, 1079,  883,  515,  633,  633,  633,  474,  193,
      109,  147,  109,  194,  108,  634,  109,  109,  577,  109,

      635,  646,  795,  109,  637,  637,  637,  639,  639,  639,
      643,  193,  910,  147,  193,  193,  147,  147,  193, 1078,
      147,  193,  641,  147,  649,  193,  193,  147,  147,  193,
      653,  147,  655,  193,  656,  147,  193,  654,  147,  648,
      193,  658,  147,  935,  193,  650,  222,  193,  660,  147,
      657,  663,  663,  663, 1077, 1251,  664,  659,  193, 1076,
      147,  193,  661,  147,  193,  193,  147,  147,  193,  662,
      147,  193,  883,  147,  665,  193,  577,  147,  222,  666,
      193,   96,  147,  668,  193,  669,  147,  193,  193,  147,
      147,  193,  543,  147,  667,  193, 1075,  222,  559,  440,

      559,  868, 1074,  671,  682,  682,  682,  109,  670,  702,
      672,  560,  982,  109,  675,  673,  568,  448,  568,  570,
      570,  570,  784,  883,  571,  633,  633,  633,  193,  474,
      147,  475, 1073,  193,  108,  584,  584,  584, 1325,  109,
      585,  109,  699,  194,  700,  109,  109,  109,  109,  109,
      474,  701,  708,  109,  109,  754,  109,  592,  191,  592,
      109,  883,  593,  703,  254,  703, 1071,  705,  705,  705,
      474, 1038,  706,  709, 1005, 1325,  474,  193,  109,  194,
      109,  707,  194,  109,  109,  109,  109,  474,  109,  710,
      711,  193,  712,  147,  194,  704,  713,  109,  193,  109,

     1151, 1325,  714,  109,  109,  109,  109,  109,  947,  760,
      109,  109,  109,  474,  109,  109,  751,  109,  109,  715,
      716,  109,  109,  109,  109,  109,  524,  717,  109,  718,
      109,  109,  719,  109, 1004,  997,  109,  109,  720,  109,
      996,  109,  109,  995,  109,  109,  721,  722,  109,  494,
      194,  193,  723,  147,  109,  109,  109,  109,  502,  993,
      109,  109,  109,  992,  109,  109,  991,  109,  109,  724,
      990,  109,  614,  614,  614,  752,  109,  615,  109,  728,
      728,  728,  727,  729,  630,  630,  630,  108,  947,  193,
      109,  988,  109,  619,  619,  619,  109,  502,  620,  730,

      730,  730,  987, 1325,  109,  732,  109,  109,  108,  734,
      109,  737,  109,  109,  109,  474,  985,  194,  109,  494,
      109,  109,  109,  109,  735,  736,  109,  109,  194,  109,
     1297,  109,  109,  984,  109,  109,  738,  733,  109,  109,
      740,  109,  949,  194,  739,  109,  986,  109,  784,  109,
      742,  742,  742,  109,  947,  743,  633,  633,  633,  109,
      193,  109,  744,  935,  745,  109,  109,  746,  746,  746,
      109,  747,  747,  747,  639,  639,  639,  749,  749,  749,
      935,  193,  750,  147,  193,  193,  147,  147,  748,  641,
      193,  748,  147,  828,  904,   96,  755,  193,  757,  147,

      903,  193,  222,  147,  193,  753,  147,  222,   96,  193,
      759,  147,  756,  193,  193,  147,  147,  758,  193,  193,
      147,  147,  193,  902,  147,  193,  193,  147,  147,  761,
      762,  193,  901,  147,  193,  763,  147,  765,  900,  768,
      764,  193,  222,  147,  769,  795,  766,  767,  548,  577,
      543,  663,  663,  663, 1325,  193,  664,  147,  193,  770,
      147,  193,  193,  147,  147,  193,  474,  147,  771,  772,
      895,  577,  548,  193,  193,  147,  147, 1197,  193,  774,
      147,  193,  222,  147,  775,  891,  193,  773,  147,  543,
      222,  994,  777,  795,  890,  222,  682,  682,  682,  889,

      757,  109,  776,  802,  193,  779,  147,  109,  109,  803,
      109,  109,  805,  804,  109,  784,  867,  109,  193,  109,
      147,  109,  703,  254,  703,  109,  705,  705,  705,  887,
      711,  706,  807,  807,  807,  474,  109,  109,  809,  109,
      968,  108,  109,  109,  810,  886,  193,  109,  147,  109,
      109,  885,  109,  109,  704,  147,  109,  811,  614,  614,
      614,  732,  726,  615,  109,  801,  109,  813,  193,  856,
      109,  812,  814,  800,  193,  815,  147,  109,  109,  817,
      109,  819,  818,  109,  816,  194,  820,  869,  799,  109,
      109,  109,  109,  711,  798,  109,  109,  109,  109,  109,

      109,  821,  194,  109,  109,  193,  109,  147,  109,  109,
      194,  109,  109,  577,  109,  109,  109,  109,  822,  109,
      109,  757,  824,  109,  826,  825,  823,  109,  194,  797,
      841,  109,  109,  830,  109,  827,  827,  827,  109,  796,
      109,  109,  109,  109,  828,  795,  109,  109,  793,  828,
      829,  831,  831,  831,  792,  109,  833,  109,  791,  790,
      835,  109,  730,  730,  730,  836,  834,  787,  732,  837,
      837,  837,  839,  839,  839,  732,  842,  840,  109,  109,
      109,  109,  193,  502,  109,  109,  786,  843,  844,  844,
      844,  194,  785,  845,  193,  109,  147,  109,  193,  784,

      733,  109,  109,  193,  109,  147,  846,  782,  109,  189,
      189,  189,  858,  878,  105,  742,  742,  742,  781,  193,
      743,  849,  849,  849,  108,  851,  109,  850,  109,  852,
      108,  109,  109,  109,  746,  746,  746,  109,  853,  853,
      853,  749,  749,  749,  780,  726,  750,  848,  748,  854,
      854,  854,  193,  834,  147,  748,  193,  193,  147,  147,
      748,  519,  193,  748,  147,  193,  193,  147,  147,  193,
     1325,  147,  861,  741,  193,  857,  147,  862,  726,  698,
      863,  855,  474,  866,  859,  860,  222,  873,  865,  864,
      697,  222,  193,  193,  147,  147, 1288,  193,  193,  147,

      147,  193,  193,  147,  147,  695,  193,  870,  147,  222,
      874,  694,  875,  193,  222,  147,  193,  693,  147,  872,
      193,  193,  147,  147,  879,  871,  880,  876,  548,  577,
      222,  193,  877,  147,  757,  884,  905,  892,  892,  892,
      692,  881,  893,  109,  906,  109,  109,  907,  915,  109,
      691,  109,  109,  109,  109,  690,  109,  109,  689,  955,
      109,  908,  908,  908,  688,  687,  909,  911,  911,  911,
      193,  193,  147,  912,  686,   96,  913,  913,  913,  109,
      683,  109,  912,  194,  954,  109,  914,  109,  681,  109,
      194,  680,  916,  109,  109,  193,  109,  147,  679,  917,

      109,  109,  919,  109,  109,  678,  918,  109,  109,  109,
      109,  920,  109,  711,  677,  109,  109,  921,  922,  676,
      971,  109,  923,  109,  193,  924,  147,  109,  109,  109,
      109,  109,  147,  636,  925,  109,  928,  631,  926,  109,
      927,  109,  109,  929,  109,  109,  973,  109,  109,  109,
      109,  930,  109,  109,  931,  933,  109,  109,  932,  109,
      934,  587,  109,  109,  109,  586,  502,  109,  109,  109,
      827,  827,  827,  109,  109,  193,  109,  147,  583,  828,
      109,  831,  831,  831,  828,  829,  833,  936,  936,  936,
      938,  193,  937,  147,  582,  935,  834,  109,  956,  109,

      109,  935,  109,  109,  581,  939,  109,  837,  837,  837,
      839,  839,  839,  732,  961,  840,  941,  941,  941,  578,
      577,  109,  942,  109,  109,  108,  109,  109,  943,  945,
      109,  944,  844,  844,  844,  948,  109,  845,  109,  189,
      189,  189,  109,  193,  105,  147,  109,  108,  109,  193,
      577,  193,  109,  147,  108,  849,  849,  849,  950,  950,
      950,  850,  951,  952,  193,  109,  147,  109,  109,  959,
      109,  109,  960,  193,  109,  147, 1325,  848,  853,  853,
      853,  854,  854,  854,  193,  576,  147,  193,  474,  147,
      222,  575,  935,  834,  967,  748,  574,  147,  963,  957,

      573,  222,  964,  567,  193,  965,  147,  193,  566,  147,
      958,  565, 1304,  855,  966,  962,  193,  564,  147,  969,
      193,  563,  147,  193,  562,  147,  970,  193,  561,  147,
      974,  193,  972,  147,  975,  193,  548,  147,  193,  557,
      147,  976,  193,  193,  147,  147,  193,   96,  147,  989,
      892,  892,  892,  981,  519,  893,  980,  977,  518,  193,
       96,  147,  512,  978,  983,  108,  979,  998,  998,  998,
      109,  464,  999,  109,  462,  109,  109, 1044, 1000,  109,
     1001, 1001, 1001,  463,  462, 1002,  908,  908,  908,  462,
      193,  909,  911,  911,  911, 1033, 1033, 1033,  912, 1007,

      461,  108,  913,  913,  913,  194,  460,  459,  912,  109,
      109,  109,  109,  458, 1006,  109,  109, 1008, 1009,  193,
      109,  109,  109,  109,  457,  456,  109,  109,  109,  109,
      109,  109, 1011, 1010,  109,  109,  109, 1069,  109, 1015,
      194,  109,  109, 1012,  109,  109,  109,  883, 1014, 1013,
      109,  109,  109,  109, 1016,  455, 1018,  109,  109,  109,
      711,  109,  109,  452,  109,  109, 1017,  109,  109,  109,
      109,  502,  109,  109, 1021, 1019,  109,  109,  109,  109,
      109,  502, 1022, 1020,  109,  109,  451,  109,  109,  447,
      109,  109, 1023, 1027,  109,  109, 1035, 1024,  109,  109,

     1025,  446,  109,  109, 1030,  109,  936,  936,  936, 1026,
      445,  937, 1028, 1028, 1028,  109,  193,  109,  147, 1031,
      935,  109,  109,  193,  109,  147,  935,  444,  109,  941,
      941,  941, 1034,  194, 1045,  942,  109,  109,  109,  109,
      222,  443,  109,  502, 1029, 1036, 1036, 1036,  109, 1042,
      109,  947,  442,  441,  109, 1037,  950,  950,  950, 1039,
      193,  109,  147,  439,  193,  109,  147,  193,  193,  147,
      147,  193,  400,  147, 1043,  399,  351,  193,  193,  147,
      147,  350,  349, 1041,  193,  193,  147,  147,  193,  193,
      147,  147, 1047, 1046,  222,  193, 1050,  147,  193, 1048,

      147,  348,  250, 1049, 1054, 1051,  250,  250, 1052,  757,
      193,  193,  147,  147, 1059,  193, 1053,  147,  193, 1060,
      147,  193, 1061,  147, 1055,  548,  346,  332, 1057,  548,
      193, 1062,  147,  193,  331,  147, 1058, 1056,  325,  193,
     1064,  147, 1063,  193,  193,  147,  147,  193,  193,  147,
      147, 1065,  998,  998,  998,  109, 1066,  109,  324, 1081,
      222,  109,  293,  292, 1082, 1067, 1083, 1083, 1083, 1070,
      548, 1084, 1001, 1001, 1001, 1068,  193, 1002, 1087, 1088,
     1087, 1325,  253,  109, 1004,  109, 1090,  108,  109,  109,
      109,  252, 1094, 1091,  109,  109,  109, 1092, 1093, 1095,

      251,  109,  109,  109,  250,  109, 1033, 1033, 1033,  109,
      109,  247,  109,  614,  614,  614,  109, 1096,  615,  109,
      109, 1097,  109,  193,  246,  109,  109,  109,  181,  109,
     1098,  245,  109,  109,  109,  240,  239,  194,  109, 1012,
      194,  109,  238,  109, 1101,  237, 1099,  109,  109,  166,
      109,  711,  217, 1100,  109,  109,  109,  109,  109,  216,
     1325,  109,  109,  109,  109,  109,  502,  177,   96,  109,
      109,  109,  172,  109,  502,  171, 1102,  109, 1103,  109,
      109, 1104,  170, 1106,  109,  109,  109,  711,  109, 1028,
     1028, 1028,  109, 1105,  109,  109,  109,  109,  169,  168,

      109,  109,  109,  935,  109, 1109, 1109, 1109,  109, 1108,
      167, 1110,  614,  614,  614, 1111,  166,  615, 1036, 1036,
     1036, 1029,  193, 1034,  947,  164,  109,  109,  109,  109,
     1112,  163,  109,  109,  193,  130,  147,  109,  125,  109,
      256,  124,  193,  109,  147,  193,  193,  147,  147,  193,
      193,  147,  147,  193,  121,  147,  193,  193,  147,  147,
     1119,  120,  119, 1120, 1114,  193, 1115,  147,  193, 1117,
      147, 1116, 1118,  193, 1121,  147,  193,  193,  147,  147,
     1122,  193,  193,  147,  147,  118,  193, 1126,  147, 1123,
      222,  193,  193,  147,  147,  112, 1048,  757,  193, 1124,

      147,  193, 1125,  147,   93,  193,  193,  147,  147,  548,
      193,   92,  147, 1128,  548, 1131,  193, 1127,  147,  757,
      193, 1129,  147,   91,   90,  193, 1133,  147, 1325, 1130,
     1144, 1144, 1144, 1088, 1088, 1088, 1145, 1066, 1132, 1134,
      109, 1325,  109, 1083, 1083, 1083,  109, 1325, 1084, 1146,
     1149, 1150, 1149, 1087, 1088, 1087, 1086, 1325,  108, 1004,
      502,  109,  109,  109, 1153,  711,  109,  109, 1325,  109,
      109,  109,  109, 1152, 1325,  109,  109,  109,  109,  109,
      109, 1325, 1155,  109,  109, 1012,  109, 1156, 1154,  711,
     1325, 1325,  109,  109,  193,  109,  147, 1158,  109,  109,

      109,  193, 1157,  147,  109,  109, 1325,  109,  109, 1325,
      109,  109, 1175, 1325,  109,  109, 1159,  109,  109, 1325,
      109,  109,  548, 1160,  109,  109, 1325,  109, 1161,  194,
      109,  109,  109,  109, 1325,  109,  109, 1012, 1162,  109,
      109,  711,  109,  193,  194,  147,  109, 1325,  109,  193,
      109,  147,  502, 1325,  109, 1109, 1109, 1109, 1164, 1164,
     1164, 1110, 1325,  109,  732,  109, 1325, 1325, 1165,  109,
      193, 1166,  147, 1169,  109,  502,  109,  193, 1325,  147,
     1167,  193, 1170,  147, 1325,  193, 1171,  147,  193,  193,
      147,  147,  193,  757,  147,  193,  193,  147,  147, 1173,

     1325,  193, 1174,  147,  193, 1176,  147,  193,  193,  147,
      147, 1172, 1325, 1048,  757,  193, 1325,  147, 1177,  193,
      193,  147,  147, 1325,  147,  222, 1325, 1178, 1179, 1181,
     1325, 1325, 1182,  757, 1180, 1048,  222, 1186, 1325, 1073,
      193, 1183,  147, 1144, 1144, 1144, 1195, 1325,  548, 1145,
     1193, 1193, 1193,  548, 1196, 1196, 1196,  109, 1325,  109,
     1148, 1198, 1216,  109, 1149, 1150, 1149, 1150, 1150, 1150,
     1086,  109, 1325,  109,  614,  614,  614,  109,  711,  615,
      109, 1325,  109,  109,  193,  109,  109, 1012, 1194,  109,
      109,  109,  109, 1201,  711, 1200,  109,  109,  109, 1202,

      109,  109, 1203,  109,  109, 1204, 1325,  109, 1164, 1164,
     1164, 1199, 1325,  109,  732,  109,  109, 1325,  109,  109,
     1205, 1325,  109,  109, 1207,  109,  109, 1325, 1325,  109,
      109,  109,  109, 1208,  109, 1325, 1325,  109,  109, 1209,
      193,  193,  147,  147,  193,  193,  147,  147, 1325,  193,
     1211,  147, 1212,  193,  193,  147,  147,  193, 1325,  147,
      757,  193,  193,  147,  147, 1325, 1325, 1217,  757, 1325,
     1325, 1214, 1218,  193, 1325,  147, 1215, 1048,  193, 1219,
      147,  193, 1325,  147, 1193, 1193, 1193,  109,  193,  109,
      147, 1325,  502,  109, 1220, 1325, 1196, 1196, 1196, 1325,

     1325, 1221, 1148, 1230,  998, 1230, 1231, 1325,  109, 1222,
     1325,  109,  109,  109,  548, 1325,  474,  109, 1325,  109,
      711,  109, 1194,  711,  711,  109, 1325,  109,  109,  109,
      109, 1232, 1325,  109,  109,  109,  109,  109,  109, 1325,
     1325,  109,  109, 1012,  109, 1325, 1233,  711, 1325,  109,
      109,  109, 1235,  194,  109,  109,  109,  109, 1325,  109,
      109, 1012, 1236,  109,  193,  193,  147,  147,  193, 1325,
      147,  193,  193,  147,  147,  193,  193,  147,  147,  193,
     1325,  147,  193, 1325,  147, 1238,  757,  757,  193, 1243,
      147, 1185,  193,  193,  147,  147, 1325, 1325, 1325,  757,

     1325, 1239, 1240, 1257, 1048,  193, 1241,  147,  757,  222,
     1230,  998, 1230, 1325, 1250, 1325, 1048, 1248, 1242,  109,
     1252,  109, 1249,  474,  109,  109,  109,  711, 1325, 1255,
      109,  109,  109,  109,  109, 1325, 1253,  109,  109,  109,
     1325,  109, 1254, 1254, 1254,  109,  193,  193,  147,  147,
      193, 1325,  147, 1263, 1144, 1263,  748, 1256, 1265, 1264,
     1325, 1325,  193,  757,  147, 1325,  474,  109, 1258,  109,
     1266, 1325,  109,  109, 1270,  109,  109,  109,  109, 1325,
     1268,  109, 1012, 1325,  109, 1254, 1254, 1254,  193,  193,
      147,  147, 1269,  193, 1325,  147, 1276, 1276, 1276,  748,

     1263, 1144, 1263, 1325,  711,  109, 1264,  109, 1325, 1271,
     1277,  109, 1325,  474, 1325, 1325, 1272, 1048, 1278, 1193,
     1278,  109, 1325,  109, 1280, 1325, 1325,  109, 1281, 1281,
     1281,  474,  711, 1325, 1282, 1282, 1282,  109, 1325,  109,
     1283, 1325,  935,  109,  193,  193,  147,  147,  748,  193,
     1325,  147, 1276, 1276, 1276, 1325, 1279, 1278, 1193, 1278,
      711,  109, 1289,  109,  757,  757, 1277,  109, 1325, 1284,
      474,  109, 1325,  109, 1281, 1281, 1281,  109, 1282, 1282,
     1282, 1290, 1325, 1325, 1283, 1291, 1291, 1291,  935,  193,
     1325,  147,  748, 1325, 1325, 1279, 1298, 1298, 1298,  748,

     1325, 1293, 1299, 1291, 1291, 1291,  193, 1325,  147, 1325,
      935, 1325, 1325, 1298, 1298, 1298, 1325,  748, 1325, 1299,
     1305, 1305, 1305, 1292, 1325, 1325,  757,  935, 1325, 1311,
     1276, 1311, 1325, 1325,  935, 1305, 1305, 1305, 1311, 1276,
     1311, 1292,  474, 1312, 1325, 1319, 1319, 1319, 1325,  935,
     1325,  474, 1312, 1319, 1319, 1319, 1325, 1325, 1306, 1320,
     1323, 1323, 1323, 1323, 1323, 1323, 1325, 1320, 1325, 1325,
     1325, 1325, 1325, 1306, 1324, 1325, 1325, 1324,   26,   26,
       26,   26,   26,   26,   26,   26,   26,   26,   26,   26,
       26,   26,   61,   61,   61,   61,   61,   61,   61,   61,

       61,   61,   61,   61,   61,   61,   65,   65,   65,   65,
       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
       85,   85,   85,   85,   96, 1325,   96, 1325, 1325, 1325,
     1325,   96, 1325,   96,   96,  109,  109,  109, 1325, 1325,
      109, 1325, 1325,  109,  109, 1325,  109,  147,  147,  147,
     1325, 1325, 1325, 1325, 1325,  147,  147,  165,  165,  165,
      165,  165,  165,  165,  165,  165,  165, 1325,  165,  165,
      178,  178, 1325,  178,  178,  178,  178,  178,  178,  178,
      178,  178,  178,  178,  221,  221, 1325,  221,  221,  221,

      221,  221,  221,  221,  221,  221,  221,  221,  347,  347,
      347,  347,  347,  347,  347,  347,  347,  347, 1325,  347,
      347,  347,  395,  395,  395, 1325, 1325,  395, 1325, 1325,
      395,  395, 1325,  395,  465,  465,  465, 1325, 1325,  465,
     1325, 1325,  465,  465, 1325,  465,  471,  471,  471,  471,
      471,  471,  471,  471,  471,  471,  471,  471,  471,  471,
      558,  558,  558,  558,  558,  558,  558,  558,  558,  558,
      558,  558,  558,  558,  640,  640,  640,  640,  640,  640,
      640,  640,  640,  640, 1325,  640,  640,  725,  725, 1325,
      725, 1325,  725,  725,  725,  725, 1325,  725,  731,  731,

      731,  731,  731,  731,  731,  731,  731,  731, 1325,  731,
      731,  783,  783, 1325,  783,  783,  783,  783,  783,  783,
      783,  783,  783,  783,  783,  794,  794, 1325,  794,  794,
      794,  794,  794,  794,  794,  794,  794,  794,  794,  808,
      808,  808, 1325, 1325, 1325, 1325, 1325, 1325,  808, 1325,
     1325,  808,  832,  832,  832,  832,  832,  832,  832,  832,
      832,  832, 1325,  832,  832,  847,  847,  847, 1325, 1325,
      847, 1325, 1325,  847,  847, 1325,  847,  946,  946,  946,
      946,  946,  946,  946,  946,  946,  946, 1325,  946,  946,
     1003, 1003, 1325, 1003, 1003, 1003, 1003, 1003, 1003, 1003,

     1003, 1003, 1003, 1003, 1072, 1072, 1325, 1072, 1072, 1072,
     1072, 1072, 1072, 1072, 1072, 1072, 1072, 1072, 1085, 1085,
     1325, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085,
     1085, 1085, 1147, 1147, 1147, 1147, 1147, 1147, 1147, 1147,
     1147, 1147, 1325, 1147, 1147, 1184, 1184, 1325, 1184, 1184,
     1184, 1184, 1184, 1184, 1184, 1184, 1184, 1184, 1184,   25,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,

     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325
    } ;

static const short int yy_chk[4709] =
    {   0,
        0,    3,   13,    3,    9,    3,   15,   10,   13,   15,
        3,   17,    3,   14,    9,    3,    0,   10,   19,   14,
       21,   20,   16,   15,   19,   16,   17,   20,   22,   42,
       17,   23,   42,    3,   21,    3,    4,   42,    4,   16,
        4,   23,   22,   24,   41,    4,   41,    4,    9,   50,
        4,   10,   36,   24,   47,   51,   36,   17,   47, 1066,
     1066,   57,   63,   50,   51,   57,   63,  147,    4,  147,
        4,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,

        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,

       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   18, 1317,   35,   38,   35,
       38,   55,   55,   55,   68, 1315,   35,   38,   68,   60,
       18,   35,   38,   60,   18,   55,   39,   39,   39,   35,
       38,   39,   60,   54,   54,   54,   39,   93,   93,   93,
       38,   39,   54,   55,   56,  855,   56,   54,   95,   55,
       95,   18,   32,   56,   32,  855,   98,   95,   56,   96,
       98,   32,   95, 1310,   39,   54,   32,   58,   58,   58,
       95,   54,   96,   98,   32,  154,   58,  154,   69,   69,
       69,   58,   58,   81,   32,   97,   81,   97,   69,   32,

       69,   81,  100,   32,   37,   37,   37, 1029, 1309,   37,
       70,   70,   70,  154,   37,  100,   37, 1029,  784,   37,
       70,   71,   71,   71,  784,  458,   69,   72,   72,   72,
       75,   71,   97,   75,  795,   75,   97,   72,   75,  458,
      795,   71,   37,   59,   59,   59,   80,   80,   70,   74,
       80,  101,   59,   74, 1308,   80,   74,   59,   59,   71,
       72,   74,   76,  101,  101,   72,   76,   59,   77,   76,
      184,   77,  140,  184,   76,   77,   77,  471, 1303,   77,
       59,   73,   73,   73,   78,  140,   79,   78,  113,  471,
       79,   73,   78,   79,  148,   78,  148,  113,   79,  113,

      104,  104,  104,  113, 1171,  104,  107,  107,  107,   73,
      104,  148,   73,  141, 1171,  104,  107,   73,  107,   73,
       94,  322,   94,  108,  108,  108,  141,  141,  108,   94,
      109,  109,  109,  115,   94,  115,  112,  112,  112,  115,
      109,  116,   94,  110,  110,  110,  112,  135,  116,  322,
      116,  135,   94,  110,  116,  114,  338,   94,  174,  338,
      135,   94,  106,  106,  106,  953,  114,  112,  114,  112,
      110,  174,  114,  112,  106,  117,  156,  117,  156, 1302,
      118,  117,  118,  106,  106,  106,  118,  118,  953,  120,
      106,  120,  119,  106,  119,  120,  119,  106,  119,  142,

      121,  120,  121,  106,  122, 1301,  121,  142,  123,  156,
      123,  122,  142,  122,  123,  123,  124,  122,  124,  125,
      218,  125,  124,  124,  126,  125,  126,  149,  127,  149,
      126,  126,  127,  218,  127,  127,  128,  129,  127,  128,
      129,  128,  129,  473,  130,  128,  129,  130,  149,  130,
      132,  132,  132,  130,  133,  473,  133,  139,  139,  139,
      145,  145,  145,  133,  132,  146,  146,  146,  133,  150,
      145,  150,  139, 1296,  151,  146,  151,  146,  152,  150,
      152,  153,  132,  153,  155,  157,  155,  157,  132,  158,
      404,  158,  152,  176,  159,  151,  159,  176,  160,  157,

      160,  175,  161,  146,  161,  162,  176,  162,  153,  155,
      173,  173,  173,  733,  175,  175,  194,  158,  404,  194,
      161,  194,  159,  162, 1295,  194,  160,  180,  180,  180,
      189,  189,  189, 1210,  733,  189,  191,  191,  191,  940,
      219,  191,  173, 1210,  219,  189,  192,  192,  192,  195,
     1294,  195,  196,  219,  198,  195,  198,  198,  220,  197,
      198,  196,  180,  196,  196,  199,  197,  196,  197, 1251,
      940,  220,  197,  200,  223,  199,  223,  199,  192, 1251,
      200,  199,  200,  201,  202,  201,  200, 1287,  242,  201,
      206,  202,  206,  202,  201,  223,  206,  202,  203,  203,

      205,  242,  205,  203,  205,  203,  205,  203,  225,  203,
      225,  203,  204,  203,  204,  204,  203,  207,  204,  207,
      208,  209,  225,  207,  208,  209,  208,  209,  208,  210,
      208,  209, 1286,  212,  209,  212,  210,  212,  210,  212,
     1285,  295,  210,  211,  211,  211,  213,  211,  213,  295,
     1275,  211,  213,  222,  295,  222,  211,  211, 1073,  211,
      211,  214,  211,  211, 1073, 1274,  214,  215,  214,  215,
      243,  222,  214,  215,  215,  224,  226,  224,  226,  227,
      229,  227,  229,  243,  243,  230,  224,  230,  232,  231,
      232,  231,  235,  227,  235,  838,  236,  233,  236,  233,

     1113,  256,  244,  256,  229,  232, 1113,  256,  226,  228,
      230,  228,  231,  232,  233,  244,  244,  838,  257,  235,
     1273,  228,  228,  298,  236,  298,  228,  233,  228,  257,
      239,  257,  239,  298,  228,  257,  228, 1261,  239,  228,
      234,  234,  234,  239,  234,  239, 1260,  297,  234,  297,
      254,  254,  254,  234,  234,  299,  234,  299,  258,  234,
      234,  245,  245, 1259,  245,  258,  301,  258,  301,  294,
      245,  258,  245,  294,  297,  245,  299,  245,  245,  259,
      245,  245,  254, 1247,  335,  259,  294,  259,  260,  260,
      260,  259,  301,  261,  262,  261,  262,  335,  260,  261,

      262,  261,  263,  264,  952,  264,  263,  952,  264,  264,
      474,  263,  265,  263,  265,  263,  263,  263,  265,  265,
      266,  263,  474,  267,  275,  267,  402,  266,  267,  267,
      275,  266,  275,  266, 1246,  268,  275,  266,  268,  402,
      268,  269,  283,  269,  268,  271,  269,  269,  270, 1344,
      270,  283, 1344,  283,  270,  270,  271,  283,  271,  272,
     1245,  272,  271,  274,  272,  272,  273,  276,  273,  276,
      276,  273,  273,  276,  274,  276,  274,  277, 1244,  278,
      274,  278,  288,  288,  288,  278,  278,  288,  277,  279,
      277,  279,  288, 1243,  277,  279,  279,  280,  305,  280,

      305,  281,  280,  280,  281,  304,  281,  304,  282, 1229,
      281,  282,  284,  282,  284,  284,  305,  282,  284,  285,
      312,  285,  312,  286,  286,  285,  285,  286,  296,  286,
      287,  304,  287,  286, 1040,  287,  287,  289,  289,  289,
      296,  296,  289,  290,  312,  436,  291,  289,  290,  291,
      290, 1228,  289,  291,  290,  291,  302, 1040,  302,  291,
      303,  306,  303,  306,  308,  307,  308,  307, 1227,  309,
      303,  309,  520,  436,  308,  289,  300,  303,  300,  302,
      310,  311,  310,  311,  302,  520, 1226,  306,  300,  314,
     1300,  314,  300,  307, 1225,  309,  311, 1224,  313,  300,

      313,  300,  300,  315, 1300,  315,  310,  300,  313,  316,
      317,  316,  317,  318,  319,  318,  319,  314,  320,  321,
      320,  321,  323, 1194,  323,  318,  437,  316,  317,  315,
      325,  325,  325,  333,  333,  333,  323,  334,  319,  323,
     1107,  334,  353,  437,  353,  321,  320,  405,  353,  405,
      334,  352,  352,  352,  437,  523,  352,  333,  354,  355,
      354,  352, 1192, 1107,  354,  355,  352,  355,  405,  569,
      333,  355,  356, 1292,  356,  357,  357,  357,  356,  358,
      357,  358,  569,  523,  359,  358, 1292, 1306,  357,  352,
      357,  359,  360,  359,  360,  361,  362,  359,  360,  372,

     1306,  372,  361,  558,  361,  372,  372,  362,  361,  362,
      363,  449,  363,  362,  364,  558,  363,  366,  363,  449,
      365,  364,  365,  364,  449,  365,  365,  364,  366,  367,
      366,  406,  368,  406,  366,  560,  368,  367,  368,  367,
     1338, 1338,  368,  367,  369,  406,  369,  560,  370,  369,
      369,  370,  412,  370,  412,  371,  374,  370,  371,  373,
      371,  373,  373,  374,  371,  373,  375,  374,  375,  374,
      377, 1191,  375,  374,  376, 1190,  376,  377,  412,  377,
      376,  376,  378,  377,  410,  379,  410,  378,  379,  378,
      379, 1341, 1341,  378,  379,  380,  381,  380,  381,  555,

      380,  380,  381,  381,  382,  384,  382,  383, 1189,  384,
      382,  384,  383,  410,  384,  384,  383,  555,  383,  401,
      385,  401,  383,  385,  386,  385,  386,  555, 1188,  385,
      386,  387,  401,  387,  388,  572,  388,  387,  387,  388,
      388,  389,  390,  389, 1313,  572,  389,  389,  572,  390,
      391,  391,  391,  390,  685,  390,  391,  392, 1313,  390,
      392,  685,  392,  393,  393,  393,  392,  685,  393,  394,
      394,  394,  395,  395,  395,  394,  397,  395,  393,  403,
      403,  403,  395,  397,  407,  397,  407,  395,  789,  397,
      398,  398,  398, 1187,  408,  398,  408,  409,  789,  409,

      398,  789, 1186,  403,  411,  407,  411,  409,  408,  413,
      395,  413,  415,  414,  415,  414,  403, 1184,  411,  413,
      416,  420,  416,  420, 1163,  398,  414, 1147,  398,  415,
      417,  418,  417,  418,  419,  422,  419,  422, 1185,  415,
      421,  423,  421,  423, 1185,  420,  416, 1163,  417,  418,
      421,  424,  425,  424,  425,  521,  422,  421,  426,  427,
      426,  427,  419, 1143,  428,  424,  428,  521,  521,  423,
      425,  429,  430,  429,  430,  431,  432,  431,  432,  684,
      427,  428, 1142,  433,  426,  433,  440,  440,  440,  429,
      428,  684,  684,  430,  434,  435,  434,  435,  438,  440,

      438, 1141,  432,  431,  434,  448,  448,  448, 1140,  433,
      526,  434,  526,  435,  450,  450,  450, 1139,  448,  450,
      448, 1168,  526,  438,  462,  462,  462, 1307, 1138,  462,
      465,  465,  465, 1168,  527,  465,  527,  467,  450,  467,
      465,  828,  468,  467,  468,  465,  828,  828,  468,  468,
     1307,  450,  450,  469,  532,  469,  532,  470,  527,  469,
      470,  478,  470,  478,  478, 1137,  470,  478,  465,  472,
      472,  472,  532, 1135,  472,  475,  475,  475,  477,  476,
      475,  476,  472,  674,  472,  476,  476,  477,  475,  477,
      479, 1085,  479,  477,  704, 1084,  479,  479,  480,  480,

      480,  481,  482,  481,  480, 1080,  704,  481,  481,  483,
      674,  674,  483,  482,  483,  482, 1079,  704,  483,  482,
      484,  485,  484,  482, 1078, 1206,  484,  485,  485,  485,
      486, 1206,  484,  485,  487,  793,  533,  486,  533,  486,
      793, 1077,  487,  486,  487,  488,  489,  488,  487,  488,
      793,  488,  489,  490,  489, 1352, 1352,  490,  489,  490,
      491,  524, 1076,  490,  490,  492,  491,  492,  491,  533,
      492,  492,  491,  493,  495,  493,  495, 1075,  524,  493,
      495,  493,  494,  494,  494, 1005,  496,  494,  497,  524,
      497, 1074,  494,  496,  497,  496,  498, 1005,  498,  496,

      751,  501,  498,  498, 1005,  499,  499,  499, 1072,  494,
      499,  500,  501,  500,  501,  499, 1071,  500,  501,  500,
      502,  502,  502,  503,  529,  502,  529,  504,  751,  503,
      502,  503,  499,  505,  504,  503,  504,  505, 1318,  505,
      504, 1003, 1002,  505,  505,  506,  529,  506,  507,  508,
      507,  506,  506,  507,  507,  778,  508,  509,  508,  509,
      997, 1318,  508,  509,  509,  510,  510,  510,  511,  511,
      511,  510,  513,  528,  513,  528,  806,  513,  513,  514,
      514,  514,  996,  778,  514,  515,  515,  515,  806,  525,
      516,  525,  516,  517,  514,  516,  516,  517,  995,  517,

      517,  528,  994,  517,  519,  519,  519,  522,  522,  522,
      525,  530,  806,  530,  531,  534,  531,  534,  535,  993,
      535,  536,  522,  536,  531,  537,  538,  537,  538,  539,
      534,  539,  535,  540,  536,  540,  541,  534,  541,  530,
      542,  538,  542, 1234,  882,  531,  539,  544,  540,  544,
      537,  543,  543,  543,  992, 1234,  543,  539,  545,  991,
      545,  543,  541,  543,  546,  547,  546,  547,  549,  542,
      549,  550,  882,  550,  544,  552,  990,  552,  543,  545,
      551,  989,  551,  549,  553,  550,  553,  554,  556,  554,
      556,  763,  546,  763,  547,  883,  988,  551,  559,  559,

      559,  763,  987,  552,  566,  566,  566,  591,  551,  591,
      553,  559,  883,  591,  556,  554,  568,  568,  568,  570,
      570,  570,  986,  883,  570,  571,  571,  571,  645,  568,
      645,  568,  985, 1069,  570,  584,  584,  584,  910,  588,
      584,  588,  588,  589,  589,  588,  596,  589,  596,  589,
      910,  590,  596,  589,  590,  645,  590,  592,  592,  592,
      590, 1069,  592,  593,  593,  593,  984,  594,  594,  594,
      592,  949,  594,  597,  910, 1089,  593,  594,  595,  597,
      595,  595,  599,  597,  595,  597,  599, 1089,  599,  597,
      598,  650,  599,  650,  594,  593,  600,  598,  642,  598,

     1089, 1312,  601,  598,  600,  601,  600,  601,  946,  650,
      600,  601,  602, 1312,  602,  603,  642,  603,  602,  602,
      603,  603,  604,  605,  604,  605,  642,  604,  604,  605,
      606,  607,  606,  607,  909,  903,  606,  607,  607,  608,
      901,  608,  609,  900,  609,  608,  608,  610,  609,  609,
      610,  643,  611,  643,  610,  611,  610,  611,  613,  898,
      610,  611,  612,  897,  612,  613,  896,  613,  612,  612,
      895,  613,  614,  614,  614,  643,  616,  614,  616,  617,
      617,  617,  616,  618,  630,  630,  630,  614,  893,  617,
      618,  890,  618,  619,  619,  619,  618,  621,  619,  620,

      620,  620,  889, 1288,  621,  620,  621,  622,  619,  622,
      621,  626,  623,  622,  623, 1288,  887,  626,  623,  623,
      624,  626,  624,  626,  624,  625,  624,  626,  625,  627,
     1288,  627,  625,  886,  625,  627,  627,  620,  625,  628,
      629,  628,  848,  629,  628,  628,  888,  629,  888,  629,
      632,  632,  632,  629,  845,  632,  633,  633,  633,  634,
      632,  634,  634,  833,  635,  634,  635,  637,  637,  637,
      635,  638,  638,  638,  639,  639,  639,  641,  641,  641,
      832,  644,  641,  644,  647,  646,  647,  646,  639,  639,
      648,  641,  648,  829,  801,  638,  646,  649,  647,  649,

      799,  651,  646,  651,  652,  644,  652,  648,  638,  653,
      649,  653,  646,  654,  655,  654,  655,  648,  656,  657,
      656,  657,  658,  798,  658,  659,  660,  659,  660,  651,
      652,  661,  797,  661,  662,  653,  662,  655,  796,  659,
      654,  665,  659,  665,  660,  794,  656,  657,  662,  792,
      658,  663,  663,  663, 1151,  666,  663,  666,  667,  661,
      667,  668,  669,  668,  669,  670, 1151,  670,  665,  666,
      791,  790,  667,  671,  672,  671,  672, 1151,  673,  670,
      673,  675,  670,  675,  671,  787,  754,  669,  754,  668,
      671,  899,  673,  899,  786,  673,  682,  682,  682,  785,

      754,  699,  672,  699,  762,  675,  762,  699,  700,  700,
      700,  701,  702,  701,  700,  783,  762,  701,  868,  702,
      868,  702,  703,  703,  703,  702,  705,  705,  705,  782,
      708,  705,  706,  706,  706,  703,  707,  708,  707,  708,
      868,  705,  707,  708,  709,  781,  752,  709,  752,  709,
      710,  780,  710,  709,  703,  757,  710,  710,  711,  711,
      711,  731,  725,  711,  712,  697,  712,  713,  711,  752,
      712,  712,  713,  696,  765,  713,  765,  714,  713,  714,
      713,  716,  715,  714,  713,  715,  717,  765,  695,  715,
      716,  715,  716,  718,  694,  715,  716,  717,  718,  717,

      718,  719,  720,  717,  718,  764,  720,  764,  720,  719,
      721,  719,  720,  693,  721,  719,  721,  722,  720,  722,
      721,  764,  722,  722,  724,  723,  721,  723,  724,  692,
      735,  723,  724,  727,  724,  726,  726,  726,  724,  691,
      727,  735,  727,  735,  726,  690,  727,  735,  689,  726,
      726,  728,  728,  728,  688,  729,  728,  729,  687,  686,
      729,  729,  730,  730,  730,  729,  728,  683,  730,  732,
      732,  732,  734,  734,  734,  732,  737,  734,  736,  737,
      736,  737,  734,  736,  736,  737,  681,  738,  739,  739,
      739,  738,  680,  739,  755,  738,  755,  738,  739,  679,

      730,  738,  740,  773,  740,  773,  740,  678,  740,  741,
      741,  741,  755,  773,  741,  742,  742,  742,  677,  741,
      742,  743,  743,  743,  741,  744,  745,  743,  745,  745,
      742,  744,  745,  744,  746,  746,  746,  744,  747,  747,
      747,  749,  749,  749,  676,  664,  749,  741,  746,  750,
      750,  750,  753,  747,  753,  749,  756,  758,  756,  758,
      640,  636,  759,  750,  759,  760,  769,  760,  769,  761,
     1279,  761,  759,  631,  766,  753,  766,  759,  615,  587,
      759,  750, 1279,  761,  756,  758,  761,  769,  760,  759,
      586,  766,  767,  768,  767,  768, 1279,  770,  771,  770,

      771,  772,  774,  772,  774,  583,  775,  766,  775,  767,
      770,  582,  771,  776,  770,  776,  777,  581,  777,  768,
      779,  865,  779,  865,  775,  767,  776,  772,  774,  580,
      776,  857,  772,  857,  865,  779,  802,  788,  788,  788,
      579,  777,  788,  802,  803,  802,  810,  804,  810,  802,
      578,  803,  810,  803,  804,  577,  804,  803,  576,  857,
      804,  805,  805,  805,  575,  574,  805,  807,  807,  807,
      856,  805,  856,  807,  573,  788,  808,  808,  808,  809,
      567,  809,  808,  811,  856,  809,  809,  811,  565,  811,
      812,  564,  811,  811,  812,  870,  812,  870,  563,  812,

      812,  813,  814,  813,  814,  562,  813,  813,  814,  815,
      816,  815,  816,  817,  561,  815,  816,  816,  818,  557,
      870,  817,  818,  817,  872,  818,  872,  817,  818,  819,
      818,  819,  548,  518,  818,  819,  821,  512,  819,  820,
      820,  820,  821,  821,  821,  820,  872,  822,  821,  822,
      823,  822,  823,  822,  823,  825,  823,  824,  824,  824,
      826,  466,  825,  824,  825,  464,  830,  826,  825,  826,
      827,  827,  827,  826,  830,  858,  830,  858,  461,  827,
      830,  831,  831,  831,  827,  827,  831,  834,  834,  834,
      835,  863,  834,  863,  460,  831,  831,  835,  858,  835,

      836,  834,  836,  835,  459,  836,  836,  837,  837,  837,
      839,  839,  839,  837,  863,  839,  840,  840,  840,  457,
      456,  841,  840,  841,  842,  839,  842,  841,  841,  843,
      842,  842,  844,  844,  844,  846,  843,  844,  843,  847,
      847,  847,  843,  861,  847,  861,  846,  844,  846,  847,
      455,  862,  846,  862,  847,  849,  849,  849,  850,  850,
      850,  849,  851,  852,  867,  851,  867,  851,  852,  861,
      852,  851,  862,  859,  852,  859, 1297,  847,  853,  853,
      853,  854,  854,  854,  860,  454,  860,  864, 1297,  864,
      859,  453,  853,  853,  867,  854,  452,  866,  866,  859,

      451,  860,  866,  447,  869,  866,  869,  871,  446,  871,
      860,  445, 1297,  854,  866,  864,  873,  444,  873,  869,
      874,  443,  874,  875,  442,  875,  869,  876,  441,  876,
      873,  877,  871,  877,  874,  878,  875,  878,  879,  439,
      879,  876,  880,  881,  880,  881,  884,  894,  884,  894,
      892,  892,  892,  881,  400,  892,  880,  877,  399,  957,
      894,  957,  396,  878,  884,  892,  879,  904,  904,  904,
      905,  351,  905,  906,  350,  906,  905,  957,  906,  906,
      907,  907,  907,  349,  348,  907,  908,  908,  908,  346,
      907,  908,  911,  911,  911,  942,  942,  942,  911,  915,

      345,  908,  913,  913,  913,  914,  344,  343,  913,  914,
      915,  914,  915,  342,  914,  914,  915,  916,  917,  982,
      916,  917,  916,  917,  341,  340,  916,  917,  918,  919,
      918,  919,  919,  918,  918,  919,  920,  982,  920,  923,
      921,  923,  920,  920,  921,  923,  921,  982,  922,  921,
      921,  922,  924,  922,  924,  339,  926,  922,  924,  925,
      927,  925,  926,  337,  926,  925,  925,  927,  926,  927,
      928,  930,  928,  927,  932,  928,  928,  929,  930,  929,
      930,  931,  932,  929,  930,  932,  336,  932,  931,  332,
      931,  932,  933,  934,  931,  934,  945,  933,  945,  934,

      933,  331,  945,  933,  938,  933,  936,  936,  936,  933,
      330,  936,  937,  937,  937,  938,  958,  938,  958,  939,
      936,  938,  939,  955,  939,  955,  937,  329,  939,  941,
      941,  941,  943,  944,  958,  941,  943,  944,  943,  944,
      955,  328,  943,  944,  937,  947,  947,  947,  948,  955,
      948,  947,  327,  326,  948,  948,  950,  950,  950,  951,
      954,  951,  954,  324,  956,  951,  956,  959,  960,  959,
      960,  961,  293,  961,  956,  292,  255,  962,  963,  962,
      963,  253,  252,  954,  964,  965,  964,  965,  966,  967,
      966,  967,  960,  959,  962,  968,  963,  968,  969,  961,

      969,  251,  249,  962,  967,  964,  248,  247,  965,  968,
      970,  971,  970,  971,  974,  972,  966,  972,  973,  974,
      973,  975,  974,  975,  969,  971,  246,  241,  973,  972,
      976,  974,  976,  977,  240,  977,  973,  970,  238,  978,
      976,  978,  975,  979,  980,  979,  980,  981,  983,  981,
      983,  977,  998,  998,  998,  999,  978,  999,  237,  998,
      979,  999,  217,  216,  999,  980, 1000, 1000, 1000,  983,
      979, 1000, 1001, 1001, 1001,  981, 1000, 1001, 1004, 1004,
     1004,  193,  188, 1006, 1004, 1006, 1006, 1001, 1007, 1006,
     1007,  187, 1010, 1007, 1007, 1008, 1009, 1008, 1009, 1011,

      186, 1008, 1009, 1010,  185, 1010, 1033, 1033, 1033, 1010,
     1011,  183, 1011, 1012, 1012, 1012, 1011, 1013, 1012, 1014,
     1013, 1014, 1013, 1012,  182, 1014, 1013, 1015,  181, 1015,
     1015,  177, 1016, 1015, 1016,  172,  171, 1017, 1016, 1016,
     1012, 1017,  170, 1017, 1019,  169, 1017, 1017, 1018,  165,
     1018, 1020,  137, 1018, 1018, 1019, 1020, 1019, 1020,  136,
      111, 1019, 1020, 1021, 1022, 1021, 1022,  102,   99, 1021,
     1022, 1023,   92, 1023, 1021,   91, 1023, 1023, 1024, 1025,
     1024, 1025,   90, 1027, 1024, 1025, 1026, 1030, 1026, 1028,
     1028, 1028, 1026, 1026, 1027, 1030, 1027, 1030,   89,   88,

     1027, 1030, 1031, 1028, 1031, 1032, 1032, 1032, 1031, 1031,
       86, 1032, 1034, 1034, 1034, 1035,   85, 1034, 1036, 1036,
     1036, 1028, 1034, 1037, 1036,   84, 1035, 1037, 1035, 1037,
     1039,   82, 1035, 1037, 1041,   52, 1041, 1039,   49, 1039,
     1034,   48, 1042, 1039, 1042, 1043, 1044, 1043, 1044, 1045,
     1046, 1045, 1046, 1047,   46, 1047, 1049, 1050, 1049, 1050,
     1046,   45,   44, 1047, 1041, 1051, 1042, 1051, 1052, 1044,
     1052, 1043, 1045, 1053, 1049, 1053, 1054, 1055, 1054, 1055,
     1050, 1056, 1057, 1056, 1057,   43, 1058, 1055, 1058, 1051,
     1053, 1059, 1060, 1059, 1060,   40, 1052, 1056, 1061, 1053,

     1061, 1062, 1054, 1062,   31, 1063, 1064, 1063, 1064, 1058,
     1065,   30, 1065, 1060, 1057, 1063, 1067, 1059, 1067, 1064,
     1068, 1061, 1068,   29,   27, 1070, 1067, 1070,   25, 1062,
     1081, 1081, 1081, 1088, 1088, 1088, 1081, 1068, 1065, 1070,
     1082,    0, 1082, 1083, 1083, 1083, 1082,    0, 1083, 1082,
     1086, 1086, 1086, 1087, 1087, 1087, 1086,    0, 1083, 1087,
     1090, 1091, 1090, 1091, 1092, 1093, 1090, 1091,    0, 1092,
     1093, 1092, 1093, 1091,    0, 1092, 1093, 1094, 1095, 1094,
     1095,    0, 1097, 1094, 1095, 1095, 1096, 1098, 1096, 1094,
        0,    0, 1096, 1097, 1124, 1097, 1124, 1100, 1098, 1097,

     1098, 1115, 1099, 1115, 1098, 1099,    0, 1099, 1100,    0,
     1100, 1099, 1124,    0, 1100, 1101, 1101, 1101, 1102,    0,
     1102, 1101, 1115, 1102, 1102, 1103,    0, 1103, 1103, 1105,
     1104, 1103, 1104, 1105,    0, 1105, 1104, 1104, 1105, 1105,
     1106, 1108, 1106, 1114, 1108, 1114, 1106,    0, 1108, 1116,
     1108, 1116, 1106,    0, 1108, 1109, 1109, 1109, 1110, 1110,
     1110, 1109,    0, 1111, 1110, 1111,    0,    0, 1112, 1111,
     1117, 1112, 1117, 1114, 1112, 1111, 1112, 1118,    0, 1118,
     1112, 1119, 1116, 1119,    0, 1120, 1117, 1120, 1121, 1122,
     1121, 1122, 1123, 1118, 1123, 1125, 1126, 1125, 1126, 1122,

        0, 1127, 1123, 1127, 1128, 1125, 1128, 1129, 1130, 1129,
     1130, 1121,    0, 1120, 1119, 1131,    0, 1131, 1126, 1132,
     1133, 1132, 1133,    0, 1134, 1130,    0, 1127, 1128, 1134,
        0,    0, 1134, 1132, 1130, 1129, 1132, 1136,    0, 1136,
     1176, 1134, 1176, 1144, 1144, 1144, 1146,    0, 1131, 1144,
     1145, 1145, 1145, 1133, 1148, 1148, 1148, 1146,    0, 1146,
     1148, 1152, 1176, 1146, 1149, 1149, 1149, 1150, 1150, 1150,
     1149, 1152,    0, 1152, 1153, 1153, 1153, 1152, 1154, 1153,
     1156,    0, 1156, 1154, 1153, 1154, 1156, 1156, 1145, 1154,
     1155, 1157, 1155, 1157, 1159, 1155, 1155, 1157, 1158, 1158,

     1158, 1159, 1160, 1159, 1158, 1161,    0, 1159, 1164, 1164,
     1164, 1153,    0, 1160, 1164, 1160, 1161,    0, 1161, 1160,
     1162,    0, 1161, 1162, 1165, 1162, 1165,    0,    0, 1162,
     1165, 1166, 1167, 1166, 1167,    0,    0, 1166, 1167, 1167,
     1169, 1170, 1169, 1170, 1172, 1173, 1172, 1173,    0, 1174,
     1169, 1174, 1170, 1175, 1177, 1175, 1177, 1178,    0, 1178,
     1172, 1180, 1179, 1180, 1179,    0,    0, 1178, 1177,    0,
        0, 1173, 1179, 1181,    0, 1181, 1175, 1174, 1182, 1180,
     1182, 1183,    0, 1183, 1193, 1193, 1193, 1195, 1211, 1195,
     1211,    0, 1195, 1195, 1181,    0, 1196, 1196, 1196,    0,

        0, 1182, 1196, 1197, 1197, 1197, 1198,    0, 1198, 1183,
        0, 1199, 1198, 1199, 1211,    0, 1197, 1199,    0, 1200,
     1202, 1200, 1193, 1201, 1199, 1200,    0, 1202, 1201, 1202,
     1201, 1200,    0, 1202, 1201, 1203, 1204, 1203, 1204,    0,
        0, 1203, 1204, 1204, 1205,    0, 1205, 1203,    0, 1207,
     1205, 1207, 1207, 1209, 1208, 1207, 1208, 1209,    0, 1209,
     1208, 1208, 1209, 1209, 1212, 1213, 1212, 1213, 1214,    0,
     1214, 1215, 1216, 1215, 1216, 1217, 1218, 1217, 1218, 1219,
        0, 1219, 1220,    0, 1220, 1212, 1216, 1215, 1221, 1223,
     1221, 1223, 1222, 1241, 1222, 1241,    0,    0,    0, 1213,

        0, 1214, 1219, 1241, 1218, 1238, 1220, 1238, 1217, 1222,
     1230, 1230, 1230,    0, 1232,    0, 1221, 1230, 1222, 1231,
     1235, 1231, 1231, 1230, 1232, 1231, 1232, 1233,    0, 1238,
     1232, 1235, 1233, 1235, 1233,    0, 1236, 1235, 1233, 1236,
        0, 1236, 1237, 1237, 1237, 1236, 1239, 1240, 1239, 1240,
     1242,    0, 1242, 1248, 1248, 1248, 1237, 1239, 1249, 1248,
        0,    0, 1255, 1240, 1255,    0, 1248, 1249, 1242, 1249,
     1250,    0, 1250, 1249, 1255, 1252, 1250, 1252, 1253,    0,
     1253, 1252, 1252,    0, 1253, 1254, 1254, 1254, 1256, 1257,
     1256, 1257, 1254, 1258,    0, 1258, 1262, 1262, 1262, 1254,

     1263, 1263, 1263,    0, 1265, 1265, 1263, 1265,    0, 1256,
     1262, 1265,    0, 1263,    0,    0, 1258, 1257, 1264, 1264,
     1264, 1266,    0, 1266, 1266,    0,    0, 1266, 1267, 1267,
     1267, 1264, 1268,    0, 1269, 1269, 1269, 1268,    0, 1268,
     1269,    0, 1267, 1268, 1270, 1271, 1270, 1271, 1269, 1272,
        0, 1272, 1276, 1276, 1276,    0, 1264, 1278, 1278, 1278,
     1289, 1289, 1280, 1289, 1270, 1272, 1276, 1289,    0, 1271,
     1278, 1280,    0, 1280, 1281, 1281, 1281, 1280, 1282, 1282,
     1282, 1281,    0,    0, 1282, 1283, 1283, 1283, 1281, 1284,
        0, 1284, 1282,    0,    0, 1278, 1290, 1290, 1290, 1283,

        0, 1284, 1290, 1291, 1291, 1291, 1293,    0, 1293,    0,
     1290,    0,    0, 1298, 1298, 1298,    0, 1291,    0, 1298,
     1299, 1299, 1299, 1283,    0,    0, 1293, 1298,    0, 1304,
     1304, 1304,    0,    0, 1299, 1305, 1305, 1305, 1311, 1311,
     1311, 1291, 1304, 1304,    0, 1314, 1314, 1314,    0, 1305,
        0, 1311, 1311, 1319, 1319, 1319,    0,    0, 1299, 1314,
     1322, 1322, 1322, 1323, 1323, 1323,    0, 1319,    0,    0,
        0,    0,    0, 1305, 1322,    0,    0, 1323, 1326, 1326,
     1326, 1326, 1326, 1326, 1326, 1326, 1326, 1326, 1326, 1326,
     1326, 1326, 1327, 1327, 1327, 1327, 1327, 1327, 1327, 1327,

     1327, 1327, 1327, 1327, 1327, 1327, 1328, 1328, 1328, 1328,
     1328, 1328, 1328, 1328, 1328, 1328, 1328, 1328, 1328, 1328,
     1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329,
     1329, 1329, 1329, 1329, 1330,    0, 1330,    0,    0,    0,
        0, 1330,    0, 1330, 1330, 1331, 1331, 1331,    0,    0,
     1331,    0,    0, 1331, 1331,    0, 1331, 1332, 1332, 1332,
        0,    0,    0,    0,    0, 1332, 1332, 1333, 1333, 1333,
     1333, 1333, 1333, 1333, 1333, 1333, 1333,    0, 1333, 1333,
     1334, 1334,    0, 1334, 1334, 1334, 1334, 1334, 1334, 1334,
     1334, 1334, 1334, 1334, 1335, 1335,    0, 1335, 1335, 1335,

     1335, 1335, 1335, 1335, 1335, 1335, 1335, 1335, 1336, 1336,
     1336, 1336, 1336, 1336, 1336, 1336, 1336, 1336,    0, 1336,
     1336, 1336, 1337, 1337, 1337,    0,    0, 1337,    0,    0,
     1337, 1337,    0, 1337, 1339, 1339, 1339,    0,    0, 1339,
        0,    0, 1339, 1339,    0, 1339, 1340, 1340, 1340, 1340,
     1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340,
     1342, 1342, 1342, 1342, 1342, 1342, 1342, 1342, 1342, 1342,
     1342, 1342, 1342, 1342, 1343, 1343, 1343, 1343, 1343, 1343,
     1343, 1343, 1343, 1343,    0, 1343, 1343, 1345, 1345,    0,
     1345,    0, 1345, 1345, 1345, 1345,    0, 1345, 1346, 1346,

     1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346,    0, 1346,
     1346, 1347, 1347,    0, 1347, 1347, 1347, 1347, 1347, 1347,
     1347, 1347, 1347, 1347, 1347, 1348, 1348,    0, 1348, 1348,
     1348, 1348, 1348, 1348, 1348, 1348, 1348, 1348, 1348, 1349,
     1349, 1349,    0,    0,    0,    0,    0,    0, 1349,    0,
        0, 1349, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350,
     1350, 1350,    0, 1350, 1350, 1351, 1351, 1351,    0,    0,
     1351,    0,    0, 1351, 1351,    0, 1351, 1353, 1353, 1353,
     1353, 1353, 1353, 1353, 1353, 1353, 1353,    0, 1353, 1353,
     1354, 1354,    0, 1354, 1354, 1354, 1354, 1354, 1354, 1354,

     1354, 1354, 1354, 1354, 1355, 1355,    0, 1355, 1355, 1355,
     1355, 1355, 1355, 1355, 1355, 1355, 1355, 1355, 1356, 1356,
        0, 1356, 1356, 1356, 1356, 1356, 1356, 1356, 1356, 1356,
     1356, 1356, 1357, 1357, 1357, 1357, 1357, 1357, 1357, 1357,
     1357, 1357,    0, 1357, 1357, 1358, 1358,    0, 1358, 1358,
     1358, 1358, 1358, 1358, 1358, 1358, 1358, 1358, 1358, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,

     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;







char *yytext;
































extern "C" int yywrap ( void );




static void yyunput ( int c, char *buf_ptr );







static int yyinput ( void );




static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;

static void yy_push_state ( int new_state );

static void yy_pop_state ( void );

static int yy_top_state ( void );





















































































int yylex ( void )
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;





		if ( ! yy_start )
			yy_start = 1;	

		if ( ! yyin )
			yyin = (&__iob_func()[0]);

		if ( ! yyout )
			yyout = (&__iob_func()[1]);

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, 16384 );

		yy_load_buffer_state();
		}

	while ( 1 )		
		{
		yy_cp = yy_c_buf_p;

		
		*yy_cp = yy_hold_char;

		


		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[((unsigned int) (unsigned char) *yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1326 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 4660 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ 
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		yytext = yy_bp; yyleng = (int) (yy_cp - yy_bp); yy_hold_char = *yy_cp; *yy_cp = '\0'; yy_c_buf_p = yy_cp;;


do_action:	


		switch ( yy_act )
	{ 
			case 0: 
			
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:

yy_push_state(10);
	break;
case 2:


	break;
case 3:

yy_pop_state();
	break;
case 4:

vKeyStoreCase();
	break;
case 5:

vKeyStoreHeader();
	break;
case 6:

vEnvVar();
	break;
case 7:

vCaplFunc();
	break;
case 8:


	break;
case 9:

counter = 2;
	break;
case 10:

fprestart = 1;
	break;
case 11:

fstart = 1;
	break;
case 12:

vHeader();  
	break;
case 13:

vMsgCpy();
	break;
case 14:

vMsgDecl();
	break;
case 15:

vDelete(); 
	break;
case 16:


	break;
case 17:

yy_push_state(9);
	break;
case 18:

yy_pop_state();
	break;
case 19:

vUtilFunc();
	break;
case 20:

vEndBody();                          
	break;
case 21:

vTimerFunc();  
	break;
case 22:

vCnvrtByte();  
	break;
case 23:

vPutKeyCase(); 
	break;
case 24:

vWrite();  
	break;
case 25:

vMsgID(); 
	break;
case 26:

vUnSptdFunc();
	break;
case 27:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case 28:

vRemovePhys();
	break;
case 29:

vWriteDot();
	break;
case 30:

(void) fwrite( yytext, yyleng, 1, yyout );  
	break;
case 31:

vCnvrtThis();  
	break;
case 32:

vWriteTerminator(); 
	break;
case 33:

(void) fwrite( yytext, yyleng, 1, yyout ) ,   yy_push_state(7);
	break;
case 34:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case 35:

(void) fwrite( yytext, yyleng, 1, yyout );   yy_pop_state();
	break;
case 36:

velCount(); 
	break;
case 37:

vSetTimer();   
	break;
case 38:

fprintf(yyout,"SendMsg(RxMsg)");
	break;
case 39:

vOutput();
	break;
case 40:

vCancelTimer();
	break;
case 41:

vOnLine();
	break;
case 42:

vOffLine();
	break;
case 43:

vTrigger();
	break;
case 44:

vResetCan();
	break;
case 45:

vDisconnect();
	break;
case 46:

vFuncCall();  
	break;
case 47:

(void) fwrite( yytext, yyleng, 1, yyout ),   yy_push_state(6);
	break;
case 48:

vAddLine();
	break;
case 49:

vFooter();	
	break;
case 50:


	break;
case 51:

(void) fwrite( yytext, yyleng, 1, yyout ),  yy_pop_state(); 
	break;
case 52:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case 53:


	break;
case 54:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case 55:

(void) fwrite( yytext, yyleng, 1, yyout );
	break;
case (56 + 0 + 1):
case (56 + 1 + 1):
case (56 + 2 + 1):
case (56 + 3 + 1):
case (56 + 4 + 1):
case (56 + 5 + 1):
case (56 + 6 + 1):
case (56 + 7 + 1):
case (56 + 8 + 1):
case (56 + 9 + 1):
case (56 + 10 + 1):
case (56 + 11 + 1):
	return 0;

	case 56:
		{
		
		int yy_amount_of_matched_text = (int) (yy_cp - yytext) - 1;

		
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == 0 )
			{
			








			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = 1;
			}

		






		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ 
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			








			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext + 0;

			if ( yy_next_state )
				{
				
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case 1:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					








					yy_c_buf_p = yytext + 0;

					yy_act = (56 + ((yy_start - 1) / 2) + 1);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );
					}
				break;
				}

			case 0:
				yy_c_buf_p =
					yytext + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_match;

			case 2:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext + 0;
				goto yy_find_action;
			}
		break;
		}

	default:
		yy_fatal_error( "fatal flex scanner internal error--no action found" );
	} 
		} 
	} 










static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ 
		if ( yy_c_buf_p - yytext - 0 == 1 )
			{
			


			return 1;
			}

		else
			{
			


			return 2;
			}
		}

	

	
	number_to_move = (int) (yy_c_buf_p - yytext) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == 2 )
		


		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ 





			
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				yy_fatal_error( "fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
			}

		if ( num_to_read > 8192 )
			num_to_read = 8192;

		
		if ( yy_current_buffer->yy_is_interactive ) { int c = '*', n; for ( n = 0; n < num_to_read && (c = getc( yyin )) != (-1) && c != '\n'; ++n ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c; if ( c == '\n' ) (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c; if ( c == (-1) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" ); yy_n_chars = n; } else if ( ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0) && ferror( yyin ) ) yy_fatal_error( "input in flex scanner failed" );;
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == 0 )
			{
			ret_val = 1;
			yyrestart( yyin );
			}

		else
			{
			ret_val = 2;
			yy_current_buffer->yy_buffer_status =
				2;
			}
		}

	else
		ret_val = 0;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = 0;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = 0;

	yytext = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}




static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext + 0; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[((unsigned int) (unsigned char) *yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1326 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}









static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )



	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1326 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 1325);

	return yy_is_jam ? 0 : yy_current_state;
	}




static void yyunput( int c, register char *yy_bp )




	{
	register char *yy_cp = yy_c_buf_p;

	
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ 
		
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			yy_fatal_error( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}



static int yyinput()


	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == 0 )
		{
		



		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			
			*yy_c_buf_p = '\0';

		else
			{ 
			yytext = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case 1:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext + 0;
						return (-1);
						}

					if ( ! yy_did_buffer_switch_on_eof )
						yyrestart( yyin );

					return yyinput();


					}

				case 0:
					yy_c_buf_p = yytext + 0;
					break;

				case 2:

					yy_fatal_error( "unexpected last match in yyinput()" );



				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	
	*yy_c_buf_p = '\0';	
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}



void yyrestart( FILE *input_file )



	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, 16384 );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}



void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )



	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	




	yy_did_buffer_switch_on_eof = 1;
	}



void yy_load_buffer_state( void )


	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}



YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )




	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	


	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}



void yy_delete_buffer( YY_BUFFER_STATE b )



	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}








void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )






	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;




	b->yy_is_interactive = 0;


	}



void yy_flush_buffer( YY_BUFFER_STATE b )




	{
	b->yy_n_chars = 0;

	



	b->yy_ch_buf[0] = 0;
	b->yy_ch_buf[1] = 0;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = 0;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}




YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )




	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != 0 ||
	     base[size-1] != 0 )
		
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = 0;

	yy_switch_to_buffer( b );

	return b;
	}




YY_BUFFER_STATE yy_scan_string( const char *str )



	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}




YY_BUFFER_STATE yy_scan_bytes( const char *bytes, int len )




	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = 0;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		yy_fatal_error( "bad buffer in yy_scan_bytes()" );

	


	b->yy_is_our_buffer = 1;

	return b;
	}




static void yy_push_state( int new_state )



	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += 25;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			yy_fatal_error( "out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = ((yy_start - 1) / 2);

	yy_start = 1 + 2 *(new_state);
	}



static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		yy_fatal_error( "start-condition stack underflow" );

	yy_start = 1 + 2 *(yy_start_stack[yy_start_stack_ptr]);
	}



static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}





static void yy_fatal_error( const char msg[] )



	{
	(void) fprintf( (&__iob_func()[2]), "%s\n", msg );
	exit( 2 );
	}







































static void *yy_flex_alloc( yy_size_t size )



	{
	return (void *) malloc( size );
	}


static void *yy_flex_realloc( void *ptr, yy_size_t size )




	{
	






	return (void *) realloc( (char *) ptr, size );
	}


static void yy_flex_free( void *ptr )



	{
	free( ptr );
	}








int yywrap()
{
return 1;
}

   2     ˜     ˜   0  ”ÿÿÿÿ  ”ÿÿÿÿ     +Æ˜      expression was false       m <= m_EquiKeys.GetCount()-1   ˜ÿÿÿÿ  ”     ˜ÿÿÿÿ  ”   0                +Ä   3      ç      ç   +   ãÿÿÿÿ   ãÿÿÿÿ     +k˜      expression was false       p <= cIndex2-1    çÿÿÿÿ   ã      çÿÿÿÿ   ã   +                +ep   4      ã      ã      ßÿÿÿÿ   ßÿÿÿÿ     +p¨      expression was false       m < 62    ãÿÿÿÿ   ß      ãÿÿÿÿ   ß              5      Ş      Ş   .   Úÿÿÿÿ   Úÿÿÿÿ     +aè      expression was false       m < ouUnSptdKey.nGetSize()    Şÿÿÿÿ   Ú      Şÿÿÿÿ   Ú   .           H     z     z   (  vÿÿÿÿ  vÿÿÿÿ     +½      expression was false       m_UnSupKeys.GetCount()!=0   zÿÿÿÿ  v     zÿÿÿÿ  v   (                +¯@   a     |     |     xÿÿÿÿ  xÿÿÿÿ     óçˆ      expression was false       cfd.DoModal()==1   |ÿÿÿÿ  x     |ÿÿÿÿ  x                   óä   b     u   	  u   '  qÿÿÿÿ  qÿÿÿÿ     óá       expression was false       omStrPath.Find(".dbc",0) != -1   uÿÿÿÿ  q   	  uÿÿÿÿ  q   '                óİğ   c     W     W     Sÿÿÿÿ  Sÿÿÿÿ     óÖ°      expression was false       cfd.DoModal()==1   Wÿÿÿÿ  S     Wÿÿÿÿ  S                   óÓ@   d     P   	  P   '  Lÿÿÿÿ  Lÿÿÿÿ     óĞH      expression was false       omStrPath.Find(".dbc",0) != -1   Pÿÿÿÿ  L   	  Pÿÿÿÿ  L   '                óÍ   e     ñ     ñ     íÿÿÿÿ  íÿÿÿÿ     ó¬(      expression was false       cfd.DoModal()==1   ñÿÿÿÿ  í     ñÿÿÿÿ  í                   ó¨¸   f     ê   	  ê   5  æÿÿÿÿ  æÿÿÿÿ     ó¥À      expression was false       (nIndex = omStrPath.ReverseFind('\\') )!= -1   êÿÿÿÿ  æ   	  êÿÿÿÿ  æ   5                ó¢€   g     å     å     áÿÿÿÿ  áÿÿÿÿ     ó `      expression was false       omStrPath.IsEmpty()   åÿÿÿÿ  á     åÿÿÿÿ  á              h     È     È     Äÿÿÿÿ  Äÿÿÿÿ     ó–¸      expression was false       cfd.DoModal()==1   Èÿÿÿÿ  Ä     Èÿÿÿÿ  Ä                   +Ü(   i     Á   	  Á   5  ½ÿÿÿÿ  ½ÿÿÿÿ     +Ù0      expression was false       (nIndex = omStrPath.ReverseFind('\\') )!= -1   Áÿÿÿÿ  ½   	  Áÿÿÿÿ  ½   5                +Õğ   j     ¼     ¼     ¸ÿÿÿÿ  ¸ÿÿÿÿ     +ÓĞ      expression was false       omStrPath.IsEmpty()   ¼ÿÿÿÿ  ¸     ¼ÿÿÿÿ  ¸              k        	     "  ‹ÿÿÿÿ  ‹ÿÿÿÿ     +Áğ      expression was false       m_EquiKeys.GetCount() > 0   ÿÿÿÿ  ‹   	  ÿÿÿÿ  ‹   "           l     u     u   &  qÿÿÿÿ  qÿÿÿÿ     +®8      expression was false       m_AltKeys.GetCount() > 0   uÿÿÿÿ  q     uÿÿÿÿ  q   &           m     s     s      oÿÿÿÿ  oÿÿÿÿ     +¾Ğ      expression was false       m_UnSupKeys.GetCount()>0   sÿÿÿÿ  o     sÿÿÿÿ  o               n     [     [      Wÿÿÿÿ  Wÿÿÿÿ     +§È      expression was false       m_EquiKeys.GetCount()==0   [ÿÿÿÿ  W     [ÿÿÿÿ  W                    +¥¸   o     N     N     Jÿÿÿÿ  Jÿÿÿÿ     +Ÿ˜      expression was false       k != -1   Nÿÿÿÿ  J     Nÿÿÿÿ  J                   +œ°   p     H     H   ,  Dÿÿÿÿ  Dÿÿÿÿ     +¤       expression was false       (m = m_EquiKeys.GetCurSel()) != (-1)   Hÿÿÿÿ  D     Hÿÿÿÿ  D   ,                +™   q      ù      ù   &   õÿÿÿÿ   õÿÿÿÿ     +uX      expression was false       m_AltKeys.GetCount() == 0    ùÿÿÿÿ   õ      ùÿÿÿÿ   õ   &                +r¸   r      ğ      ğ      ìÿÿÿÿ   ìÿÿÿÿ     +nè      expression was false       Flag == 0    ğÿÿÿÿ   ì      ğÿÿÿÿ   ì                   +lÀ   s      é      é   -   åÿÿÿÿ   åÿÿÿÿ     +iØ      expression was false       allkey[m] == acSptdKey[p]    éÿÿÿÿ   å      éÿÿÿÿ   å   -                +fø   t      ‡      ‡   $   ƒÿÿÿÿ   ƒÿÿÿÿ     +8h      expression was false       !strAboutMenu.IsEmpty()    ‡ÿÿÿÿ   ƒ      ‡ÿÿÿÿ   ƒ   $                +5€   u      ‚   	   ‚      ~ÿÿÿÿ   ~ÿÿÿÿ     +:(      expression was false       pSysMenu != 0    ‚ÿÿÿÿ   ~   	   ‚ÿÿÿÿ   ~                   +30   ä     ,     ,   #  (ÿÿÿÿ  (ÿÿÿÿ     +ğ      expression was true       m_UnSupKeys.GetCount() == 0   ,ÿÿÿÿ  (     ,ÿÿÿÿ  (   #   expression was false       m_UnSupKeys.GetCount() == 0   ,ÿÿÿÿ  (     ,ÿÿÿÿ  (   #                +‹ø   æ     ,   '  ,   @  (ÿÿÿÿ  (ÿÿÿÿ     +Ø      expression was true       m_AltKeys.GetCount() == 0   ,ÿÿÿÿ  (   '  ,ÿÿÿÿ  (   @   expression was false       m_AltKeys.GetCount() == 0   ,ÿÿÿÿ  (   '  ,ÿÿÿÿ  (   @                +   ÷     «     «     §ÿÿÿÿ  §ÿÿÿÿ     ô         statement executed        }   «ÿÿÿÿ  §     «ÿÿÿÿ  §              ø     ¥     ¥     ¡ÿÿÿÿ  ¡ÿÿÿÿ     óı       statement executed        }   ¥ÿÿÿÿ  ¡     ¥ÿÿÿÿ  ¡              ù                 œÿÿÿÿ  œÿÿÿÿ     óú`       statement executed        }    ÿÿÿÿ  œ      ÿÿÿÿ  œ              ú     “     “     ÿÿÿÿ  ÿÿÿÿ     óïø       statement executed        }   “ÿÿÿÿ       “ÿÿÿÿ                û     Œ     Œ     ˆÿÿÿÿ  ˆÿÿÿÿ     óí(       statement executed        }   Œÿÿÿÿ  ˆ     Œÿÿÿÿ  ˆ              ü               }ÿÿÿÿ  }ÿÿÿÿ     óèp       statement executed        }   ÿÿÿÿ  }     ÿÿÿÿ  }              ı     €     €     |ÿÿÿÿ  |ÿÿÿÿ     óæ°       statement executed        }   €ÿÿÿÿ  |     €ÿÿÿÿ  |              ş     x     x     tÿÿÿÿ  tÿÿÿÿ     óàH       statement executed        }   xÿÿÿÿ  t     xÿÿÿÿ  t              ÿ     \     \     Xÿÿÿÿ  Xÿÿÿÿ     ó×˜       statement executed        }   \ÿÿÿÿ  X     \ÿÿÿÿ  X                   [     [     Wÿÿÿÿ  Wÿÿÿÿ     óÕØ       statement executed        }   [ÿÿÿÿ  W     [ÿÿÿÿ  W                  S     S     Oÿÿÿÿ  Oÿÿÿÿ     óÏp       statement executed        }   Sÿÿÿÿ  O     Sÿÿÿÿ  O                  7     7     3ÿÿÿÿ  3ÿÿÿÿ     óÅ        statement executed        }   7ÿÿÿÿ  3     7ÿÿÿÿ  3                  +     +     'ÿÿÿÿ  'ÿÿÿÿ     óÁ¸       statement executed        }   +ÿÿÿÿ  '     +ÿÿÿÿ  '                            ÿÿÿÿ  ÿÿÿÿ     ó¼`       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                              ÿÿÿÿ  ÿÿÿÿ     ó»@       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                              	ÿÿÿÿ  	ÿÿÿÿ     ó·h       statement executed        }   ÿÿÿÿ  	     ÿÿÿÿ  	                            ÿÿÿÿ  ÿÿÿÿ     ó´€       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                    ö     ö     òÿÿÿÿ  òÿÿÿÿ     ó­       statement executed        }   öÿÿÿÿ  ò     öÿÿÿÿ  ò             	     õ     õ     ñÿÿÿÿ  ñÿÿÿÿ     ó«P       statement executed        }   õÿÿÿÿ  ñ     õÿÿÿÿ  ñ             
     í     í     éÿÿÿÿ  éÿÿÿÿ     ó¤è       statement executed        }   íÿÿÿÿ  é     íÿÿÿÿ  é                  è     è     äÿÿÿÿ  äÿÿÿÿ     óŸˆ       statement executed        }   èÿÿÿÿ  ä     èÿÿÿÿ  ä                  Í     Í     Éÿÿÿÿ  Éÿÿÿÿ     ó—H       statement executed        }   Íÿÿÿÿ  É     Íÿÿÿÿ  É                  Ì     Ì     Èÿÿÿÿ  Èÿÿÿÿ     +ŞÀ       statement executed        }   Ìÿÿÿÿ  È     Ìÿÿÿÿ  È                  Ä     Ä     Àÿÿÿÿ  Àÿÿÿÿ     +ØX       statement executed        }   Äÿÿÿÿ  À     Äÿÿÿÿ  À                  ¿     ¿     »ÿÿÿÿ  »ÿÿÿÿ     +Òø       statement executed        }   ¿ÿÿÿÿ  »     ¿ÿÿÿÿ  »                  ¢     ¢     ÿÿÿÿ  ÿÿÿÿ     +É˜       statement executed        }   ¢ÿÿÿÿ       ¢ÿÿÿÿ                    œ     œ     ˜ÿÿÿÿ  ˜ÿÿÿÿ     +ÅÀ       statement executed        }   œÿÿÿÿ  ˜     œÿÿÿÿ  ˜                  –     –     ’ÿÿÿÿ  ’ÿÿÿÿ     +Á       statement executed        }   –ÿÿÿÿ  ’     –ÿÿÿÿ  ’                            ‰ÿÿÿÿ  ‰ÿÿÿÿ     +½ø       statement executed        }   ÿÿÿÿ  ‰     ÿÿÿÿ  ‰                  ‹     ‹     ‡ÿÿÿÿ  ‡ÿÿÿÿ     +»`       statement executed        }   ‹ÿÿÿÿ  ‡     ‹ÿÿÿÿ  ‡                  ‡     ‡     ƒÿÿÿÿ  ƒÿÿÿÿ     +¹ø       statement executed        }   ‡ÿÿÿÿ  ƒ     ‡ÿÿÿÿ  ƒ                  x   	  x   
  tÿÿÿÿ  tÿÿÿÿ     +­`       statement executed        }   xÿÿÿÿ  t   	  xÿÿÿÿ  t   
               _     _     [ÿÿÿÿ  [ÿÿÿÿ     +¨°       statement executed        }   _ÿÿÿÿ  [     _ÿÿÿÿ  [                  ^     ^     Zÿÿÿÿ  Zÿÿÿÿ     +¦ğ       statement executed        }   ^ÿÿÿÿ  Z     ^ÿÿÿÿ  Z                  Y     Y     Uÿÿÿÿ  Uÿÿÿÿ     +£È       statement executed        }   Yÿÿÿÿ  U     Yÿÿÿÿ  U                  R   	  R   
  Nÿÿÿÿ  Nÿÿÿÿ     +À       statement executed        }   Rÿÿÿÿ  N   	  Rÿÿÿÿ  N   
               6     6     2ÿÿÿÿ  2ÿÿÿÿ     +”       statement executed        }   6ÿÿÿÿ  2     6ÿÿÿÿ  2                  3     3     /ÿÿÿÿ  /ÿÿÿÿ     +’(       statement executed        }   3ÿÿÿÿ  /     3ÿÿÿÿ  /                  /     /     +ÿÿÿÿ  +ÿÿÿÿ     +‘       statement executed        }   /ÿÿÿÿ  +     /ÿÿÿÿ  +                  	     	     ÿÿÿÿ  ÿÿÿÿ     +y`       statement executed        return 1;   	ÿÿÿÿ       	ÿÿÿÿ                       	       ÿÿÿÿ  ÿÿÿÿ     +xˆ       statement executed        exit(0);   ÿÿÿÿ     	  ÿÿÿÿ                                  üÿÿÿÿ   üÿÿÿÿ     +v@       statement executed        }    ÿÿÿÿ   ü      ÿÿÿÿ   ü             !      ÿ   	   ÿ   
   ûÿÿÿÿ   ûÿÿÿÿ     +t€       statement executed        }    ÿÿÿÿÿ   û   	   ÿÿÿÿÿ   û   
          "      ô   	   ô   
   ğÿÿÿÿ   ğÿÿÿÿ     +oĞ       statement executed        }    ôÿÿÿÿ   ğ   	   ôÿÿÿÿ   ğ   
          #      ó      ó      ïÿÿÿÿ   ïÿÿÿÿ     +n       statement executed        }    óÿÿÿÿ   ï      óÿÿÿÿ   ï             $      î      î      êÿÿÿÿ   êÿÿÿÿ     +jÀ       statement executed        }    îÿÿÿÿ   ê      îÿÿÿÿ   ê             %      ì      ì      èÿÿÿÿ   èÿÿÿÿ     +i        statement executed        break;    ìÿÿÿÿ   è      ìÿÿÿÿ   è             &      á   	   á   
   İÿÿÿÿ   İÿÿÿÿ     +a       statement executed        }    áÿÿÿÿ   İ   	   áÿÿÿÿ   İ   
          '      Á      Á      ½ÿÿÿÿ   ½ÿÿÿÿ     +Z€       statement executed        return (HCURSOR) m_hIcon;    Áÿÿÿÿ   ½      Áÿÿÿÿ   ½             (      º      º      ¶ÿÿÿÿ   ¶ÿÿÿÿ     +Vğ       statement executed        }    ºÿÿÿÿ   ¶      ºÿÿÿÿ   ¶             )      ¶      ¶      ²ÿÿÿÿ   ²ÿÿÿÿ     +U       statement executed        }    ¶ÿÿÿÿ   ²      ¶ÿÿÿÿ   ²             *                    œÿÿÿÿ   œÿÿÿÿ     +B        statement executed        }     ÿÿÿÿ   œ       ÿÿÿÿ   œ             +      œ      œ      ˜ÿÿÿÿ   ˜ÿÿÿÿ     +@˜       statement executed        }    œÿÿÿÿ   ˜      œÿÿÿÿ   ˜             ,      “      “      ÿÿÿÿ   ÿÿÿÿ     +;       statement executed        return 1;    “ÿÿÿÿ         “ÿÿÿÿ                -      Œ      Œ      ˆÿÿÿÿ   ˆÿÿÿÿ     +9P       statement executed        }    Œÿÿÿÿ   ˆ      Œÿÿÿÿ   ˆ             .      ‹   	   ‹   
   ‡ÿÿÿÿ   ‡ÿÿÿÿ     +7       statement executed        }    ‹ÿÿÿÿ   ‡   	   ‹ÿÿÿÿ   ‡   
          /      d   ­   d   Õ   `ÿÿÿÿ   `ÿÿÿÿ     +-H       statement executed        return &CCAPL2CPropertyPage::messageMap;    dÿÿÿÿ   `   ­   dÿÿÿÿ   `   Õ          0      d   I   d   k   `ÿÿÿÿ   `ÿÿÿÿ     ++X       statement executed        return &CPropertyPage::messageMap;    dÿÿÿÿ   `   I   dÿÿÿÿ   `   k          1      b      b      ^ÿÿÿÿ   ^ÿÿÿÿ     +(Ğ       statement executed        }    bÿÿÿÿ   ^      bÿÿÿÿ   ^             2      Y      Y      Uÿÿÿÿ   Uÿÿÿÿ     +%8       statement executed        }    Yÿÿÿÿ   U      Yÿÿÿÿ   U             3      H   “   H   ±   Dÿÿÿÿ   Dÿÿÿÿ     +Ø       statement executed        return &CAboutDlg::messageMap;    Hÿÿÿÿ   D   “   Hÿÿÿÿ   D   ±          4      H   ?   H   [   Dÿÿÿÿ   Dÿÿÿÿ     +€       statement executed        return &CDialog::messageMap;    Hÿÿÿÿ   D   ?   Hÿÿÿÿ   D   [          5      F      F      Bÿÿÿÿ   Bÿÿÿÿ     +       statement executed        }    Fÿÿÿÿ   B      Fÿÿÿÿ   B             6      ?      ?      ;ÿÿÿÿ   ;ÿÿÿÿ     +À       statement executed        }    ?ÿÿÿÿ   ;      ?ÿÿÿÿ   ;                    ï   -  ï   9  êÿÿÿÿ  êÿÿÿÿ    ƒl€      expression was true       id[1] == 'X'   ïÿÿÿÿ  ê   -  ïÿÿÿÿ  ê   9   expression was false       id[1] == 'X'   ïÿÿÿÿ  ê   -  ïÿÿÿÿ  ê   9               ƒjÀ        ï     ï   )  êÿÿÿÿ  êÿÿÿÿ    ƒk˜      expression was true       id[1] == 'x'   ïÿÿÿÿ  ê     ïÿÿÿÿ  ê   )   expression was false       id[1] == 'x'   ïÿÿÿÿ  ê     ïÿÿÿÿ  ê   )               ƒi¨        ß   -  ß   9  Úÿÿÿÿ  Úÿÿÿÿ    !¿      expression was true       id[1] == 'X'   ßÿÿÿÿ  Ú   -  ßÿÿÿÿ  Ú   9   expression was false       id[1] == 'X'   ßÿÿÿÿ  Ú   -  ßÿÿÿÿ  Ú   9               !½H        ß     ß   )  Úÿÿÿÿ  Úÿÿÿÿ    !¾       expression was true       id[1] == 'x'   ßÿÿÿÿ  Ú     ßÿÿÿÿ  Ú   )   expression was false       id[1] == 'x'   ßÿÿÿÿ  Ú     ßÿÿÿÿ  Ú   )               !¼0        Ê   4  Ê   G  Åÿÿÿÿ  Åÿÿÿÿ    1Şh      expression was true       HandlerVal[1] =='X'   Êÿÿÿÿ  Å   4  Êÿÿÿÿ  Å   G   expression was false       HandlerVal[1] =='X'   Êÿÿÿÿ  Å   4  Êÿÿÿÿ  Å   G               1Ü¨   
     Ê     Ê   0  Åÿÿÿÿ  Åÿÿÿÿ    1İ€      expression was true       HandlerVal[1] =='x'   Êÿÿÿÿ  Å     Êÿÿÿÿ  Å   0   expression was false       HandlerVal[1] =='x'   Êÿÿÿÿ  Å     Êÿÿÿÿ  Å   0               1Ûˆ        ½     ½   K  ¸ÿÿÿÿ  ¸ÿÿÿÿ    !¨      expression was true       HandlerVal[ HandlerVal.GetLength() - 1] == 'X'   ½ÿÿÿÿ  ¸     ½ÿÿÿÿ  ¸   K   expression was false       HandlerVal[ HandlerVal.GetLength() - 1] == 'X'   ½ÿÿÿÿ  ¸     ½ÿÿÿÿ  ¸   K               !¦H        ¼     ¼   G  ·ÿÿÿÿ  ·ÿÿÿÿ    !§       expression was true       HandlerVal[ HandlerVal.GetLength() - 1] == 'x'   ¼ÿÿÿÿ  ·     ¼ÿÿÿÿ  ·   G   expression was false       HandlerVal[ HandlerVal.GetLength() - 1] == 'x'   ¼ÿÿÿÿ  ·     ¼ÿÿÿÿ  ·   G               !¥(        ^   '  ^   >  Yÿÿÿÿ  Yÿÿÿÿ    !là      expression was true       HandlerType == "envVar"   ^ÿÿÿÿ  Y   '  ^ÿÿÿÿ  Y   >   expression was false       HandlerType == "envVar"   ^ÿÿÿÿ  Y   '  ^ÿÿÿÿ  Y   >               !k         ^     ^   $  Yÿÿÿÿ  Yÿÿÿÿ    !kø      expression was true       HandlerType == "key"   ^ÿÿÿÿ  Y     ^ÿÿÿÿ  Y   $   expression was false       HandlerType == "key"   ^ÿÿÿÿ  Y     ^ÿÿÿÿ  Y   $               !j          L   *   L   :   Gÿÿÿÿ   Gÿÿÿÿ    5Zğ      expression was true       yytext[m] != ':'    Lÿÿÿÿ   G   *   Lÿÿÿÿ   G   :   expression was false       yytext[m] != ':'    Lÿÿÿÿ   G   *   Lÿÿÿÿ   G   :               5Y0         L      L   &   Gÿÿÿÿ   Gÿÿÿÿ    5Z      expression was true       yytext[m] != 0    Lÿÿÿÿ   G      Lÿÿÿÿ   G   &   expression was false       yytext[m] != 0    Lÿÿÿÿ   G      Lÿÿÿÿ   G   &               5X        Ü     Ü     ×ÿÿÿÿ  ×ÿÿÿÿ    +Âh      expression was true       yytext[0] == ';'   Üÿÿÿÿ  ×     Üÿÿÿÿ  ×      expression was false       yytext[0] == ';'   Üÿÿÿÿ  ×     Üÿÿÿÿ  ×                  +Àx   0     Ü   !  Ü   1  ×ÿÿÿÿ  ×ÿÿÿÿ    +ÃP      expression was true       yytext[0] == ','   Üÿÿÿÿ  ×   !  Üÿÿÿÿ  ×   1   expression was false       yytext[0] == ','   Üÿÿÿÿ  ×   !  Üÿÿÿÿ  ×   1               +Á   6     )   &  )   -  $ÿÿÿÿ  $ÿÿÿÿ    !!˜      expression was false       m < dlc   )ÿÿÿÿ  $   &  )ÿÿÿÿ  $   -           7        &     -  ÿÿÿÿ  ÿÿÿÿ    !ø      expression was false       m < dlc   ÿÿÿÿ     &  ÿÿÿÿ     -           8        "     )  şÿÿÿÿ  şÿÿÿÿ    !      expression was false       m < dlc   ÿÿÿÿ  ş   "  ÿÿÿÿ  ş   )           9        %     +  ˆÿÿÿÿ  ˆÿÿÿÿ     ´       expression was false       i <= 7   ÿÿÿÿ  ˆ   %  ÿÿÿÿ  ˆ   +                ®`   :     j     j   +  eÿÿÿÿ  eÿÿÿÿ    !P      expression was false       i < csa.GetSize()   jÿÿÿÿ  e     jÿÿÿÿ  e   +           ;     W     W     Rÿÿÿÿ  Rÿÿÿÿ     „ğ      expression was false       i< 8   Wÿÿÿÿ  R     Wÿÿÿÿ  R              <                 ûÿÿÿÿ  ûÿÿÿÿ    –˜      expression was false       m < 254    ÿÿÿÿ  û      ÿÿÿÿ  û              =     B     B   $  =ÿÿÿÿ  =ÿÿÿÿ    ƒQ`      expression was false       wsp <= index   Bÿÿÿÿ  =     Bÿÿÿÿ  =   $               ƒOp   >     2     2   $  -ÿÿÿÿ  -ÿÿÿÿ    ƒHh      expression was false       wsp <= index   2ÿÿÿÿ  -     2ÿÿÿÿ  -   $               ƒF`   ?     ë     ë   "  æÿÿÿÿ  æÿÿÿÿ    ƒ$p      expression was false       n < cFlagH   ëÿÿÿÿ  æ     ëÿÿÿÿ  æ   "           @     3     3   $  .ÿÿÿÿ  .ÿÿÿÿ    +ó(      expression was false       n < cFlagH   3ÿÿÿÿ  .     3ÿÿÿÿ  .   $           A      Á      Á   #   ¼ÿÿÿÿ   ¼ÿÿÿÿ     +íğ      expression was false       i < 40    Áÿÿÿÿ   ¼      Áÿÿÿÿ   ¼   #           E     å     å     àÿÿÿÿ  àÿÿÿÿ    ƒ°      expression was true       yytext[0] == ';'   åÿÿÿÿ  à     åÿÿÿÿ  à      expression was false       yytext[0] == ';'   åÿÿÿÿ  à     åÿÿÿÿ  à                  ƒ   I     a     a   4  \ÿÿÿÿ  \ÿÿÿÿ     ‘       expression was false       (end = val.Find(",",start)) != -1   aÿÿÿÿ  \     aÿÿÿÿ  \   4                Šè   J               )  ÿÿÿÿ  ÿÿÿÿ    ƒ9ˆ      expression was false       !isalpha(yytext [index] )    ÿÿÿÿ        ÿÿÿÿ     )               ƒ7€   K     .     .   )  )ÿÿÿÿ  )ÿÿÿÿ    +ğè      expression was false       !isalpha(yytext[cFlagH] )   .ÿÿÿÿ  )     .ÿÿÿÿ  )   )               +îø   L     {     {   '  vÿÿÿÿ  vÿÿÿÿ    ƒ´À      expression was false       val.GetLength() != 0   {ÿÿÿÿ  v     {ÿÿÿÿ  v   '               ƒ­X   M     å   $  å   4  àÿÿÿÿ  àÿÿÿÿ    ƒ      expression was true       yytext[0] == ','   åÿÿÿÿ  à   $  åÿÿÿÿ  à   4   expression was false       yytext[0] == ','   åÿÿÿÿ  à   $  åÿÿÿÿ  à   4               ƒ    W     å   8  å   B  àÿÿÿÿ  àÿÿÿÿ    ƒø      expression was true       cFlag == 0   åÿÿÿÿ  à   8  åÿÿÿÿ  à   B   expression was false       cFlag == 0   åÿÿÿÿ  à   8  åÿÿÿÿ  à   B               ƒ8   Y        	       ÿÿÿÿ  ÿÿÿÿ     ç'¸      expression was true       cFlagH != 1   ÿÿÿÿ     	  ÿÿÿÿ        expression was false       cFlagH != 1   ÿÿÿÿ     	  ÿÿÿÿ                     ç%È   [             $  ÿÿÿÿ  ÿÿÿÿ     ç(       expression was true       counter == 2   ÿÿÿÿ       ÿÿÿÿ     $   expression was false       counter == 2   ÿÿÿÿ       ÿÿÿÿ     $                ç&à   ]        (     >  ÿÿÿÿ  ÿÿÿÿ     ç,p      expression was true       canoedb.IsEmpty() == 1   ÿÿÿÿ     (  ÿÿÿÿ     >   expression was false       canoedb.IsEmpty() == 1   ÿÿÿÿ     (  ÿÿÿÿ     >                ç*°   _     ù     ù   5  ôÿÿÿÿ  ôÿÿÿÿ     VX      expression was true       ident[ ident.GetLength() - 1 ] =='x'   ùÿÿÿÿ  ô     ùÿÿÿÿ  ô   5   expression was false       ident[ ident.GetLength() - 1 ] =='x'   ùÿÿÿÿ  ô     ùÿÿÿÿ  ô   5                Th   v     ú     ú   9  õÿÿÿÿ  õÿÿÿÿ     W@      expression was true       ident[ ident.GetLength() - 1 ] =='X'   úÿÿÿÿ  õ     úÿÿÿÿ  õ   9   expression was false       ident[ ident.GetLength() - 1 ] =='X'   úÿÿÿÿ  õ     úÿÿÿÿ  õ   9                U€   x     -     -   '  (ÿÿÿÿ  (ÿÿÿÿ    !Ø      expression was false       m < dlc - 1   -ÿÿÿÿ  (     -ÿÿÿÿ  (   '               !è   y             '  ÿÿÿÿ  ÿÿÿÿ    !8      expression was false       m < dlc - 1   ÿÿÿÿ       ÿÿÿÿ     '               !0   z             #  ÿÿÿÿ  ÿÿÿÿ    !P      expression was false       m < dlc - 1   ÿÿÿÿ       ÿÿÿÿ     #               !`   {     ù     ù   0  ôÿÿÿÿ  ôÿÿÿÿ    !x      expression was false       msg.m_uiMsgID == 0xffffffff   ùÿÿÿÿ  ô     ùÿÿÿÿ  ô   0               !	€   |     œ     œ   '  —ÿÿÿÿ  —ÿÿÿÿ     Á       expression was true       value[0]=='0'   œÿÿÿÿ  —     œÿÿÿÿ  —   '   expression was false       value[0]=='0'   œÿÿÿÿ  —     œÿÿÿÿ  —   '                ºx   ~     ·     ·   ,  ²ÿÿÿÿ  ²ÿÿÿÿ    !      expression was false       cs.Find("long",0) != -1   ·ÿÿÿÿ  ²     ·ÿÿÿÿ  ²   ,                ×È        œ   +  œ   8  —ÿÿÿÿ  —ÿÿÿÿ     ½€      expression was true       value[1]=='x'   œÿÿÿÿ  —   +  œÿÿÿÿ  —   8   expression was false       value[1]=='x'   œÿÿÿÿ  —   +  œÿÿÿÿ  —   8                »        —     —   +  ’ÿÿÿÿ  ’ÿÿÿÿ     Ö       expression was false       cs.Find("word",0) != -1   —ÿÿÿÿ  ’     —ÿÿÿÿ  ’   +                ·ˆ   ‚             '  Šÿÿÿÿ  Šÿÿÿÿ     ²à      expression was false       i == start   ÿÿÿÿ  Š     ÿÿÿÿ  Š   '                °È   ƒ     ‚     ‚   +  }ÿÿÿÿ  }ÿÿÿÿ     ¶`      expression was false       cs.Find("byte",0) != -1   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }   +                ¦X   „     }     }      xÿÿÿÿ  xÿÿÿÿ     ¥0      expression was false       key == "dlc"   }ÿÿÿÿ  x     }ÿÿÿÿ  x                    ¢(   …     x     x   >  sÿÿÿÿ  sÿÿÿÿ     ¡       expression was false       ( start =value.FindOneOf("\t\n}") ) != -1   xÿÿÿÿ  s     xÿÿÿÿ  s   >                Ğ   †     0     0   0  +ÿÿÿÿ  +ÿÿÿÿ     w@      expression was false       msg.m_uiMsgID == 0xffffffff   0ÿÿÿÿ  +     0ÿÿÿÿ  +   0                t   ‡               ÿÿÿÿ  ÿÿÿÿ     b8      expression was false       nIndex == -1   ÿÿÿÿ       ÿÿÿÿ                     _0   ˆ     œ   :  œ   G  —ÿÿÿÿ  —ÿÿÿÿ     ¾h      expression was true       value[1]=='X'   œÿÿÿÿ  —   :  œÿÿÿÿ  —   G   expression was false       value[1]=='X'   œÿÿÿÿ  —   :  œÿÿÿÿ  —   G                ¼¨   Š     î     î   0  éÿÿÿÿ  éÿÿÿÿ     Qè      expression was false       ( start = ident.Find('.',0) ) != -1   îÿÿÿÿ  é     îÿÿÿÿ  é   0                N¸   ‹     Û     Û     Öÿÿÿÿ  Öÿÿÿÿ     =ˆ      expression was false       yytext[0] == ';'   Ûÿÿÿÿ  Ö     Ûÿÿÿÿ  Ö                   ;€   Œ     Ÿ     Ÿ     šÿÿÿÿ  šÿÿÿÿ     'x      expression was false       pPercent   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š                   –   	  –     ‘ÿÿÿÿ  ‘ÿÿÿÿ     )è      expression was false       flag == 1   –ÿÿÿÿ  ‘   	  –ÿÿÿÿ  ‘                   `        f     f     aÿÿÿÿ  aÿÿÿÿ     8      expression was false       cFlagLog == 2   fÿÿÿÿ  a     fÿÿÿÿ  a                   H        F   
  F     Aÿÿÿÿ  Aÿÿÿÿ     ø      expression was false       cFlagH == 1   Fÿÿÿÿ  A   
  Fÿÿÿÿ  A                  –0H        /     /     *ÿÿÿÿ  *ÿÿÿÿ    –'X      expression was false       extn != ".c"   /ÿÿÿÿ  *     /ÿÿÿÿ  *                  –#    ‘     é   
  é     äÿÿÿÿ  äÿÿÿÿ    –ğ      expression was false       flag == 1   éÿÿÿÿ  ä   
  éÿÿÿÿ  ä                  –À   ’     Ç   	  Ç     Âÿÿÿÿ  Âÿÿÿÿ    –˜      expression was false       cFlagLog == 2   Çÿÿÿÿ  Â   	  Çÿÿÿÿ  Â                  •òP   “     €     €     {ÿÿÿÿ  {ÿÿÿÿ    •Ö€      expression was false       cfd.DoModal()==1   €ÿÿÿÿ  {     €ÿÿÿÿ  {                  •Ó   ”     y   	  y   5  tÿÿÿÿ  tÿÿÿÿ    •Ğ      expression was false       (nIndex = omStrPath.ReverseFind('\\') )!= -1   yÿÿÿÿ  t   	  yÿÿÿÿ  t   5               •ÌØ   •     t     t     oÿÿÿÿ  oÿÿÿÿ    •Ê¸      expression was false       omStrPath.IsEmpty()   tÿÿÿÿ  o     tÿÿÿÿ  o              –     ^     ^     Yÿÿÿÿ  Yÿÿÿÿ    •À0      expression was false       cfd.DoModal()==1   ^ÿÿÿÿ  Y     ^ÿÿÿÿ  Y                  •¼À   —     W   	  W   5  Rÿÿÿÿ  Rÿÿÿÿ    •¹È      expression was false       (nIndex = omStrPath.ReverseFind('\\') )!= -1   Wÿÿÿÿ  R   	  Wÿÿÿÿ  R   5               •¶ˆ   ˜     R     R     Mÿÿÿÿ  Mÿÿÿÿ    •´h      expression was false       omStrPath.IsEmpty()   Rÿÿÿÿ  M     Rÿÿÿÿ  M              ™     '   	  '     "ÿÿÿÿ  "ÿÿÿÿ    ‘@      expression was false       cFlagLog == 2   'ÿÿÿÿ  "   	  'ÿÿÿÿ  "                  şè   š     ¼     ¼   '  ·ÿÿÿÿ  ·ÿÿÿÿ     á`      expression was true       value[0]=='0'   ¼ÿÿÿÿ  ·     ¼ÿÿÿÿ  ·   '   expression was false       value[0]=='0'   ¼ÿÿÿÿ  ·     ¼ÿÿÿÿ  ·   '                Ú¸   œ        	     #  ÿÿÿÿ  ÿÿÿÿ     ç$°      expression was false       ouUnSptdKey.nGetSize() > 0   ÿÿÿÿ     	  ÿÿÿÿ     #                Ñ     Ñ   *  Ìÿÿÿÿ  Ìÿÿÿÿ    Ã(      expression was false       ouFuncName.nFind( val ) != -1   Ñÿÿÿÿ  Ì     Ñÿÿÿÿ  Ì   *               Á         :     :   )  5ÿÿÿÿ  5ÿÿÿÿ    ƒMÈ      expression was false       ouTimerName.nFind(name) != -1   :ÿÿÿÿ  5     :ÿÿÿÿ  5   )               ƒIÀ   Ÿ     ÿ     ÿ      úÿÿÿÿ  úÿÿÿÿ    ƒ,Ø      expression was false       yytext[0] == ','   ÿÿÿÿÿ  ú     ÿÿÿÿÿ  ú                   ƒ+         Ş     Ş     Ùÿÿÿÿ  Ùÿÿÿÿ    ƒ       expression was false       yytext[0]==')'   Şÿÿÿÿ  Ù     Şÿÿÿÿ  Ù                  ƒ0   ¡     Â     Â     ½ÿÿÿÿ  ½ÿÿÿÿ    ƒ
¨      expression was false       cFlagHeader == 3   Âÿÿÿÿ  ½     Âÿÿÿÿ  ½                  ƒ    ¢     ¼     ¼     ·ÿÿÿÿ  ·ÿÿÿÿ    ƒˆ      expression was false       cFlagHeader == 4   ¼ÿÿÿÿ  ·     ¼ÿÿÿÿ  ·                  ƒ€   £     ¦     ¦     ¡ÿÿÿÿ  ¡ÿÿÿÿ    ‚ÿ@      expression was false       nIndex != -1   ¦ÿÿÿÿ  ¡     ¦ÿÿÿÿ  ¡                  ‚ı8   ¤     Œ     Œ     ‡ÿÿÿÿ  ‡ÿÿÿÿ    ‚ó8      expression was false       val == "this"   Œÿÿÿÿ  ‡     Œÿÿÿÿ  ‡                  ‚ğX   ¥     c     c     ^ÿÿÿÿ  ^ÿÿÿÿ    ,¸      expression was false       type == "dir"   cÿÿÿÿ  ^     cÿÿÿÿ  ^                  ,È   ¦     ^     ^     Yÿÿÿÿ  Yÿÿÿÿ    ,à      expression was false       type == "dlc"   ^ÿÿÿÿ  Y     ^ÿÿÿÿ  Y                  ,	ğ   §     U     U     Pÿÿÿÿ  Pÿÿÿÿ    ,˜      expression was false       name == "this"   Uÿÿÿÿ  P     Uÿÿÿÿ  P                  ,¸   ¨     )     )   +  $ÿÿÿÿ  $ÿÿÿÿ    +íĞ      expression was false       val.Find("writetolog",0) == -1   )ÿÿÿÿ  $     )ÿÿÿÿ  $   +               +êè   ©     ê     ê     åÿÿÿÿ  åÿÿÿÿ    +Ó       expression was false       keyname[0] =='\''   êÿÿÿÿ  å     êÿÿÿÿ  å                  +Ğ€   ª     ¼   +  ¼   8  ·ÿÿÿÿ  ·ÿÿÿÿ     İÀ      expression was true       value[1]=='x'   ¼ÿÿÿÿ  ·   +  ¼ÿÿÿÿ  ·   8   expression was false       value[1]=='x'   ¼ÿÿÿÿ  ·   +  ¼ÿÿÿÿ  ·   8                ÛĞ   ¬     ½     ½     ¸ÿÿÿÿ  ¸ÿÿÿÿ    +¹@      expression was false       type == "word"   ½ÿÿÿÿ  ¸     ½ÿÿÿÿ  ¸                  +·P   ­     ·     ·     ²ÿÿÿÿ  ²ÿÿÿÿ    +¶(      expression was false       type == "byte"   ·ÿÿÿÿ  ²     ·ÿÿÿÿ  ²                  +´8   ®     ±     ±     ¬ÿÿÿÿ  ¬ÿÿÿÿ    +³      expression was false       type == "long"   ±ÿÿÿÿ  ¬     ±ÿÿÿÿ  ¬                  +±    ¯     «     «     ¦ÿÿÿÿ  ¦ÿÿÿÿ    +°      expression was false       name == "this"   «ÿÿÿÿ  ¦     «ÿÿÿÿ  ¦                  ƒÍ   °     u     u   '  pÿÿÿÿ  pÿÿÿÿ    ƒ¶€      expression was false       name.Find("mstimer") == -1   uÿÿÿÿ  p     uÿÿÿÿ  p   '               ƒªH   ±     k     k     fÿÿÿÿ  fÿÿÿÿ    ƒ¤¨      expression was false       yytext[0] == ';'   kÿÿÿÿ  f     kÿÿÿÿ  f                  ƒ¢    ²     ¼   :  ¼   G  ·ÿÿÿÿ  ·ÿÿÿÿ     Ş¨      expression was true       value[1]=='X'   ¼ÿÿÿÿ  ·   :  ¼ÿÿÿÿ  ·   G   expression was false       value[1]=='X'   ¼ÿÿÿÿ  ·   :  ¼ÿÿÿÿ  ·   G                Üè   ´     ¯     ¯   $  ªÿÿÿÿ  ªÿÿÿÿ    !ŸX      expression was false       start != -1   ¯ÿÿÿÿ  ª     ¯ÿÿÿÿ  ª   $               !œ(   µ     Ÿ     Ÿ   %  šÿÿÿÿ  šÿÿÿÿ    ƒ}°      expression was false       HandlerType == "msg"   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š   %               !”   ¶     s     s   -  nÿÿÿÿ  nÿÿÿÿ    !{ˆ      expression was false       HandlerVal[0] =='\''   sÿÿÿÿ  n     sÿÿÿÿ  n   -               !vğ   ·     c     c   +  ^ÿÿÿÿ  ^ÿÿÿÿ    !r8      expression was false       HandlerType == "envVar"   cÿÿÿÿ  ^     cÿÿÿÿ  ^   +               !p0   ¸     L   	  L     Gÿÿÿÿ  Gÿÿÿÿ    !-ˆ      expression was true       yytext[0] == ';'   Lÿÿÿÿ  G   	  Lÿÿÿÿ  G      expression was false       yytext[0] == ';'   Lÿÿÿÿ  G   	  Lÿÿÿÿ  G                  !+˜   º     W     W   .  Rÿÿÿÿ  Rÿÿÿÿ    !hè      expression was false       HandlerType == "warningLimit"   Wÿÿÿÿ  R     Wÿÿÿÿ  R   .               !eˆ   »     P     P   .  Kÿÿÿÿ  Kÿÿÿÿ    !dp      expression was false       HandlerType == "errorPassive"   Pÿÿÿÿ  K     Pÿÿÿÿ  K   .               !a   ¼     I     I   -  Dÿÿÿÿ  Dÿÿÿÿ     ,?(      expression was false       HandlerType == "errorActive"   Iÿÿÿÿ  D     Iÿÿÿÿ  D   -                ,;È   ½     B     B   6  =ÿÿÿÿ  =ÿÿÿÿ     ,:°      expression was false       HandlerType == "errorFrameErrorFrame"   Bÿÿÿÿ  =     Bÿÿÿÿ  =   6                ,7P   ¾     7     7      2ÿÿÿÿ  2ÿÿÿÿ     ,0       expression was false       start == -1   7ÿÿÿÿ  2     7ÿÿÿÿ  2                    ,.P   ¿     1     1   *  ,ÿÿÿÿ  ,ÿÿÿÿ     ,68      expression was false       HandlerType == "caplFunc"   1ÿÿÿÿ  ,     1ÿÿÿÿ  ,   *                ,*(   À     *     *   (  %ÿÿÿÿ  %ÿÿÿÿ     ,)      expression was false       HandlerType == "busOff"   *ÿÿÿÿ  %     *ÿÿÿÿ  %   (                ,%°   Á     #     #   '  ÿÿÿÿ  ÿÿÿÿ     ,$˜      expression was false       HandlerType == "stop"   #ÿÿÿÿ       #ÿÿÿÿ     '                ,!P   Â             *  ÿÿÿÿ  ÿÿÿÿ     , 8      expression was false       HandlerType == "preStart"   ÿÿÿÿ       ÿÿÿÿ     *                ,h   Ã     
     
   #  ÿÿÿÿ  ÿÿÿÿ     ,      expression was false       fprestart == 1   
ÿÿÿÿ       
ÿÿÿÿ     #                ,h   Ä             ,   ÿÿÿÿÿ   ÿÿÿÿÿ     ,P      expression was false       HandlerType == "startStart"   ÿÿÿÿ   ÿ     ÿÿÿÿ   ÿ   ,                ,˜   Å      û      û   '   öÿÿÿÿ   öÿÿÿÿ     ,€      expression was false       HandlerType == "timer"    ûÿÿÿÿ   ö      ûÿÿÿÿ   ö   '                ,Ø   Æ      Ã      Ã   <   ¾ÿÿÿÿ   ¾ÿÿÿÿ     +ì0      expression was false       _stricmp(UnSptdKeyList[i],keyname) == 0    Ãÿÿÿÿ   ¾      Ãÿÿÿÿ   ¾   <                +èÈ   Ç      ¿      ¿   $   ºÿÿÿÿ   ºÿÿÿÿ     +ï       expression was false       keyname.GetLength() > 1    ¿ÿÿÿÿ   º      ¿ÿÿÿÿ   º   $           È      º      º      µÿÿÿÿ   µÿÿÿÿ     +ç       expression was false       keyname[0] =='\''    ºÿÿÿÿ   µ      ºÿÿÿÿ   µ                   +ãà   É      H      H   !   Cÿÿÿÿ   Cÿÿÿÿ    5b`      expression was false       yytext[m] != '*'    Hÿÿÿÿ   C      Hÿÿÿÿ   C   !               ?   Ğ     L     L   -  Gÿÿÿÿ  Gÿÿÿÿ    !.p      expression was true       yytext[0] == ','   Lÿÿÿÿ  G     Lÿÿÿÿ  G   -   expression was false       yytext[0] == ','   Lÿÿÿÿ  G     Lÿÿÿÿ  G   -               !,°  7               ˜ÿÿÿÿ  ˜ÿÿÿÿ    !]¨       statement executed        }   ÿÿÿÿ  ˜     ÿÿÿÿ  ˜             8     •     •     ÿÿÿÿ  ÿÿÿÿ    !X˜       statement executed        }   •ÿÿÿÿ       •ÿÿÿÿ               9     ‘     ‘     Œÿÿÿÿ  Œÿÿÿÿ    !W€       statement executed        }   ‘ÿÿÿÿ  Œ     ‘ÿÿÿÿ  Œ             :     q     q     lÿÿÿÿ  lÿÿÿÿ    !Cè       statement executed        }   qÿÿÿÿ  l     qÿÿÿÿ  l             ;     k     k     fÿÿÿÿ  fÿÿÿÿ    !@Ğ       statement executed        }   kÿÿÿÿ  f     kÿÿÿÿ  f             <     W     W     Rÿÿÿÿ  Rÿÿÿÿ    !7h       statement executed        }   Wÿÿÿÿ  R     Wÿÿÿÿ  R             =     O     O     Jÿÿÿÿ  Jÿÿÿÿ    !0€       statement executed        }   Oÿÿÿÿ  J     Oÿÿÿÿ  J             >     ?     ?     :ÿÿÿÿ  :ÿÿÿÿ    !(ˆ       statement executed        }   ?ÿÿÿÿ  :     ?ÿÿÿÿ  :             ?     =   	  =     8ÿÿÿÿ  8ÿÿÿÿ    !'°       statement executed        exit(0);   =ÿÿÿÿ  8   	  =ÿÿÿÿ  8             @     4     4     /ÿÿÿÿ  /ÿÿÿÿ    !"°       statement executed        }   4ÿÿÿÿ  /     4ÿÿÿÿ  /             A     1     1     ,ÿÿÿÿ  ,ÿÿÿÿ    ! À       statement executed        }   1ÿÿÿÿ  ,     1ÿÿÿÿ  ,             B     0     0     +ÿÿÿÿ  +ÿÿÿÿ    !        statement executed        }   0ÿÿÿÿ  +     0ÿÿÿÿ  +             C     #     #     ÿÿÿÿ  ÿÿÿÿ    !       statement executed        }   #ÿÿÿÿ       #ÿÿÿÿ               D                 ÿÿÿÿ  ÿÿÿÿ    !        statement executed        }    ÿÿÿÿ        ÿÿÿÿ               E               ÿÿÿÿ  ÿÿÿÿ    !`       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               F               	ÿÿÿÿ  	ÿÿÿÿ    !(       statement executed        }   ÿÿÿÿ  	     ÿÿÿÿ  	             G               ÿÿÿÿ  ÿÿÿÿ    !8       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               H     
     
     ÿÿÿÿ  ÿÿÿÿ    !x       statement executed        }   
ÿÿÿÿ       
ÿÿÿÿ               I     ş     ş     ùÿÿÿÿ  ùÿÿÿÿ    !        statement executed        }   şÿÿÿÿ  ù     şÿÿÿÿ  ù             J     õ     õ     ğÿÿÿÿ  ğÿÿÿÿ    !x       statement executed        }   õÿÿÿÿ  ğ     õÿÿÿÿ  ğ             K     ò     ò     íÿÿÿÿ  íÿÿÿÿ    !è       statement executed        }   òÿÿÿÿ  í     òÿÿÿÿ  í             L     ê     ê     åÿÿÿÿ  åÿÿÿÿ     ÿğ       statement executed        }   êÿÿÿÿ  å     êÿÿÿÿ  å             M     Ü     Ü     ×ÿÿÿÿ  ×ÿÿÿÿ     øˆ       statement executed        }   Üÿÿÿÿ  ×     Üÿÿÿÿ  ×             N     Ô     Ô     Ïÿÿÿÿ  Ïÿÿÿÿ     õ       statement executed        }   Ôÿÿÿÿ  Ï     Ôÿÿÿÿ  Ï             O     À     À     »ÿÿÿÿ  »ÿÿÿÿ     æˆ       statement executed        }   Àÿÿÿÿ  »     Àÿÿÿÿ  »             P     ´     ´     ¯ÿÿÿÿ  ¯ÿÿÿÿ     Ôà       statement executed        }   ´ÿÿÿÿ  ¯     ´ÿÿÿÿ  ¯             Q     ¯     ¯     ªÿÿÿÿ  ªÿÿÿÿ     Òø       statement executed        }   ¯ÿÿÿÿ  ª     ¯ÿÿÿÿ  ª             R                 ›ÿÿÿÿ  ›ÿÿÿÿ     ÆH       statement executed        }    ÿÿÿÿ  ›      ÿÿÿÿ  ›             S     •     •     ÿÿÿÿ  ÿÿÿÿ     µˆ       statement executed        }   •ÿÿÿÿ       •ÿÿÿÿ               T     ”     ”     ÿÿÿÿ  ÿÿÿÿ     ³È       statement executed        }   ”ÿÿÿÿ       ”ÿÿÿÿ               U     ’     ’   #  ÿÿÿÿ  ÿÿÿÿ     ²       statement executed        break;   ’ÿÿÿÿ       ’ÿÿÿÿ     #          V     €     €     {ÿÿÿÿ  {ÿÿÿÿ     ¤X       statement executed        }   €ÿÿÿÿ  {     €ÿÿÿÿ  {             W     {     {     vÿÿÿÿ  vÿÿÿÿ      (       statement executed        }   {ÿÿÿÿ  v     {ÿÿÿÿ  v             X     f     f     aÿÿÿÿ  aÿÿÿÿ     (       statement executed        }   fÿÿÿÿ  a     fÿÿÿÿ  a             Y     [     [     Vÿÿÿÿ  Vÿÿÿÿ     „       statement executed        }   [ÿÿÿÿ  V     [ÿÿÿÿ  V             Z     K     K     Fÿÿÿÿ  Fÿÿÿÿ     |È       statement executed        }   Kÿÿÿÿ  F     Kÿÿÿÿ  F             [     F     F     Aÿÿÿÿ  Aÿÿÿÿ     {°       statement executed        }   Fÿÿÿÿ  A     Fÿÿÿÿ  A             \     ;     ;     6ÿÿÿÿ  6ÿÿÿÿ     xh       statement executed        }   ;ÿÿÿÿ  6     ;ÿÿÿÿ  6             ]     6     6     1ÿÿÿÿ  1ÿÿÿÿ     vh       statement executed        }   6ÿÿÿÿ  1     6ÿÿÿÿ  1             ^     )   	  )   
  $ÿÿÿÿ  $ÿÿÿÿ     oø       statement executed        }   )ÿÿÿÿ  $   	  )ÿÿÿÿ  $   
          _     $   	  $   
  ÿÿÿÿ  ÿÿÿÿ     mÈ       statement executed        }   $ÿÿÿÿ     	  $ÿÿÿÿ     
          `     !     !     ÿÿÿÿ  ÿÿÿÿ     j°       statement executed        }   !ÿÿÿÿ       !ÿÿÿÿ               a               ÿÿÿÿ  ÿÿÿÿ     h€       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               b               ÿÿÿÿ  ÿÿÿÿ     a`       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               c     ÿ     ÿ     úÿÿÿÿ  úÿÿÿÿ     [˜       statement executed        }   ÿÿÿÿÿ  ú     ÿÿÿÿÿ  ú             d     ò   	  ò   
  íÿÿÿÿ  íÿÿÿÿ     Q       statement executed        }   òÿÿÿÿ  í   	  òÿÿÿÿ  í   
          e     Ş   	  Ş   
  Ùÿÿÿÿ  Ùÿÿÿÿ     <°       statement executed        }   Şÿÿÿÿ  Ù   	  Şÿÿÿÿ  Ù   
          f     Å     Å     Àÿÿÿÿ  Àÿÿÿÿ     3°       statement executed        }   Åÿÿÿÿ  À     Åÿÿÿÿ  À             g     ¾     ¾     ¹ÿÿÿÿ  ¹ÿÿÿÿ     /°       statement executed        }   ¾ÿÿÿÿ  ¹     ¾ÿÿÿÿ  ¹             h     º     º     µÿÿÿÿ  µÿÿÿÿ     .       statement executed        }   ºÿÿÿÿ  µ     ºÿÿÿÿ  µ             i     «     «     ¦ÿÿÿÿ  ¦ÿÿÿÿ     *Ğ       statement executed        }   «ÿÿÿÿ  ¦     «ÿÿÿÿ  ¦             j     ª     ª     ¥ÿÿÿÿ  ¥ÿÿÿÿ     )       statement executed        }   ªÿÿÿÿ  ¥     ªÿÿÿÿ  ¥             k     ¦   	  ¦   
  ¡ÿÿÿÿ  ¡ÿÿÿÿ     &        statement executed        }   ¦ÿÿÿÿ  ¡   	  ¦ÿÿÿÿ  ¡   
          l     ”     ”     ÿÿÿÿ  ÿÿÿÿ     `       statement executed        }   ”ÿÿÿÿ       ”ÿÿÿÿ               m               ‹ÿÿÿÿ  ‹ÿÿÿÿ            statement executed        }   ÿÿÿÿ  ‹     ÿÿÿÿ  ‹             n     †     †     ÿÿÿÿ  ÿÿÿÿ             statement executed        }   †ÿÿÿÿ       †ÿÿÿÿ               o     ƒ     ƒ     ~ÿÿÿÿ  ~ÿÿÿÿ            statement executed        }   ƒÿÿÿÿ  ~     ƒÿÿÿÿ  ~             p               zÿÿÿÿ  zÿÿÿÿ     0       statement executed        }   ÿÿÿÿ  z     ÿÿÿÿ  z             q     s     s     nÿÿÿÿ  nÿÿÿÿ     
¨       statement executed        }   sÿÿÿÿ  n     sÿÿÿÿ  n             r     c     c     ^ÿÿÿÿ  ^ÿÿÿÿ    –<Ø       statement executed        }   cÿÿÿÿ  ^     cÿÿÿÿ  ^             s     _     _     Zÿÿÿÿ  Zÿÿÿÿ    –;x       statement executed        }   _ÿÿÿÿ  Z     _ÿÿÿÿ  Z             t     S   	  S   
  Nÿÿÿÿ  Nÿÿÿÿ    –6ğ       statement executed        }   Sÿÿÿÿ  N   	  Sÿÿÿÿ  N   
          u     D     D     ?ÿÿÿÿ  ?ÿÿÿÿ    –.H       statement executed        }   Dÿÿÿÿ  ?     Dÿÿÿÿ  ?             v     ?     ?     :ÿÿÿÿ  :ÿÿÿÿ    –,ğ       statement executed        }   ?ÿÿÿÿ  :     ?ÿÿÿÿ  :             w     6     6     1ÿÿÿÿ  1ÿÿÿÿ    –(@       statement executed        }   6ÿÿÿÿ  1     6ÿÿÿÿ  1             x     5   	  5   
  0ÿÿÿÿ  0ÿÿÿÿ    –&€       statement executed        }   5ÿÿÿÿ  0   	  5ÿÿÿÿ  0   
          y     (     (     #ÿÿÿÿ  #ÿÿÿÿ    –         statement executed        }   (ÿÿÿÿ  #     (ÿÿÿÿ  #             z     !     !     ÿÿÿÿ  ÿÿÿÿ    –ğ       statement executed        }   !ÿÿÿÿ       !ÿÿÿÿ               {               ÿÿÿÿ  ÿÿÿÿ    –˜       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               |               ÿÿÿÿ  ÿÿÿÿ    –¸       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               }               ÿÿÿÿÿ  ÿÿÿÿÿ    –À       statement executed        }   ÿÿÿÿ  ÿ     ÿÿÿÿ  ÿ             ~     î     î     éÿÿÿÿ  éÿÿÿÿ    –Ø       statement executed        }   îÿÿÿÿ  é     îÿÿÿÿ  é                  í     í     èÿÿÿÿ  èÿÿÿÿ    –       statement executed        }   íÿÿÿÿ  è     íÿÿÿÿ  è             €     å     å     àÿÿÿÿ  àÿÿÿÿ    •şğ       statement executed        }   åÿÿÿÿ  à     åÿÿÿÿ  à                  á     á     Üÿÿÿÿ  Üÿÿÿÿ    •ı       statement executed        }   áÿÿÿÿ  Ü     áÿÿÿÿ  Ü             ‚     Ô   	  Ô   
  Ïÿÿÿÿ  Ïÿÿÿÿ    •ù       statement executed        }   Ôÿÿÿÿ  Ï   	  Ôÿÿÿÿ  Ï   
          ƒ     Ä   	  Ä   
  ¿ÿÿÿÿ  ¿ÿÿÿÿ    •ïx       statement executed        }   Äÿÿÿÿ  ¿   	  Äÿÿÿÿ  ¿   
          „     À   	  À   
  »ÿÿÿÿ  »ÿÿÿÿ    •î       statement executed        }   Àÿÿÿÿ  »   	  Àÿÿÿÿ  »   
          …     ´     ´     ¯ÿÿÿÿ  ¯ÿÿÿÿ    •é       statement executed        }   ´ÿÿÿÿ  ¯     ´ÿÿÿÿ  ¯             †               ˜ÿÿÿÿ  ˜ÿÿÿÿ    •Şğ       statement executed        }   ÿÿÿÿ  ˜     ÿÿÿÿ  ˜             ‡     •     •     ÿÿÿÿ  ÿÿÿÿ    •Ü        statement executed        }   •ÿÿÿÿ       •ÿÿÿÿ               ˆ     …     …     €ÿÿÿÿ  €ÿÿÿÿ    •×h       statement executed        }   …ÿÿÿÿ  €     …ÿÿÿÿ  €             ‰     „     „     ÿÿÿÿ  ÿÿÿÿ    •Õ¨       statement executed        }   „ÿÿÿÿ       „ÿÿÿÿ               Š     |     |     wÿÿÿÿ  wÿÿÿÿ    •Ï@       statement executed        }   |ÿÿÿÿ  w     |ÿÿÿÿ  w             ‹     w     w     rÿÿÿÿ  rÿÿÿÿ    •Éà       statement executed        }   wÿÿÿÿ  r     wÿÿÿÿ  r             Œ     c     c     ^ÿÿÿÿ  ^ÿÿÿÿ    •Á       statement executed        }   cÿÿÿÿ  ^     cÿÿÿÿ  ^                  b     b     ]ÿÿÿÿ  ]ÿÿÿÿ    •¿X       statement executed        }   bÿÿÿÿ  ]     bÿÿÿÿ  ]                  Z     Z     Uÿÿÿÿ  Uÿÿÿÿ    •¸ğ       statement executed        }   Zÿÿÿÿ  U     Zÿÿÿÿ  U                  U     U     Pÿÿÿÿ  Pÿÿÿÿ    •³       statement executed        }   Uÿÿÿÿ  P     Uÿÿÿÿ  P                  @     @     ;ÿÿÿÿ  ;ÿÿÿÿ    ‘È       statement executed        return( int( per ));   @ÿÿÿÿ  ;     @ÿÿÿÿ  ;             ‘     +     +     &ÿÿÿÿ  &ÿÿÿÿ    ‘ h       statement executed        }   +ÿÿÿÿ  &     +ÿÿÿÿ  &             ’     #     #     ÿÿÿÿ  ÿÿÿÿ    üx       statement executed        }   #ÿÿÿÿ       #ÿÿÿÿ               “               ÿÿÿÿ  ÿÿÿÿ     ç#Ø       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               ”               ıÿÿÿÿ  ıÿÿÿÿ    Öø       statement executed        }   ÿÿÿÿ  ı     ÿÿÿÿ  ı             •     ÿ     ÿ     úÿÿÿÿ  úÿÿÿÿ    Õ       statement executed        }   ÿÿÿÿÿ  ú     ÿÿÿÿÿ  ú             –     ù     ù     ôÿÿÿÿ  ôÿÿÿÿ    Ò       statement executed        }   ùÿÿÿÿ  ô     ùÿÿÿÿ  ô             —     ê     ê     åÿÿÿÿ  åÿÿÿÿ    ËĞ       statement executed        }   êÿÿÿÿ  å     êÿÿÿÿ  å             ˜     à     à     Ûÿÿÿÿ  Ûÿÿÿÿ    É°       statement executed        }   àÿÿÿÿ  Û     àÿÿÿÿ  Û             ™     Ş   	  Ş     Ùÿÿÿÿ  Ùÿÿÿÿ    ÈØ       statement executed        exit(0);   Şÿÿÿÿ  Ù   	  Şÿÿÿÿ  Ù             š     Ø     Ø     Óÿÿÿÿ  Óÿÿÿÿ    Æ       statement executed        }   Øÿÿÿÿ  Ó     Øÿÿÿÿ  Ó             ›     Ô   	  Ô   
  Ïÿÿÿÿ  Ïÿÿÿÿ    ÂP       statement executed        }   Ôÿÿÿÿ  Ï   	  Ôÿÿÿÿ  Ï   
          œ     ¾     ¾     ¹ÿÿÿÿ  ¹ÿÿÿÿ    ¹@       statement executed        }   ¾ÿÿÿÿ  ¹     ¾ÿÿÿÿ  ¹                  ±     ±     ¬ÿÿÿÿ  ¬ÿÿÿÿ    ´X       statement executed        }   ±ÿÿÿÿ  ¬     ±ÿÿÿÿ  ¬                  ©     ©     ¤ÿÿÿÿ  ¤ÿÿÿÿ    ²(       statement executed        }   ©ÿÿÿÿ  ¤     ©ÿÿÿÿ  ¤             Ÿ     ¡     ¡     œÿÿÿÿ  œÿÿÿÿ    ¯ø       statement executed        }   ¡ÿÿÿÿ  œ     ¡ÿÿÿÿ  œ                   ™     ™     ”ÿÿÿÿ  ”ÿÿÿÿ    ­È       statement executed        }   ™ÿÿÿÿ  ”     ™ÿÿÿÿ  ”             ¡     ‘     ‘     Œÿÿÿÿ  Œÿÿÿÿ    «¸       statement executed        }   ‘ÿÿÿÿ  Œ     ‘ÿÿÿÿ  Œ             ¢     ‰     ‰     „ÿÿÿÿ  „ÿÿÿÿ    ©x       statement executed        }   ‰ÿÿÿÿ  „     ‰ÿÿÿÿ  „             £     ‡   	  ‡     ‚ÿÿÿÿ  ‚ÿÿÿÿ    ¨        statement executed        exit(0);   ‡ÿÿÿÿ  ‚   	  ‡ÿÿÿÿ  ‚             ¤               |ÿÿÿÿ  |ÿÿÿÿ    ¦@       statement executed        }   ÿÿÿÿ  |     ÿÿÿÿ  |             ¥     o     o     jÿÿÿÿ  jÿÿÿÿ            statement executed        }   oÿÿÿÿ  j     oÿÿÿÿ  j             ¦     m   	  m     hÿÿÿÿ  hÿÿÿÿ    (       statement executed        exit(0);   mÿÿÿÿ  h   	  mÿÿÿÿ  h             §     g     g     bÿÿÿÿ  bÿÿÿÿ    šÈ       statement executed        }   gÿÿÿÿ  b     gÿÿÿÿ  b             ¨     R     R     Mÿÿÿÿ  Mÿÿÿÿ    ƒUğ       statement executed        }   Rÿÿÿÿ  M     Rÿÿÿÿ  M             ©     P   	  P     Kÿÿÿÿ  Kÿÿÿÿ    ƒU       statement executed        exit(0);   Pÿÿÿÿ  K   	  Pÿÿÿÿ  K             ª     J     J     Eÿÿÿÿ  Eÿÿÿÿ    ƒR¸       statement executed        }   Jÿÿÿÿ  E     Jÿÿÿÿ  E             «     F   	  F   
  Aÿÿÿÿ  Aÿÿÿÿ    ƒPˆ       statement executed        }   Fÿÿÿÿ  A   	  Fÿÿÿÿ  A   
          ¬     >   	  >   
  9ÿÿÿÿ  9ÿÿÿÿ    ƒLğ       statement executed        }   >ÿÿÿÿ  9   	  >ÿÿÿÿ  9   
          ­     6   	  6   
  1ÿÿÿÿ  1ÿÿÿÿ    ƒG       statement executed        }   6ÿÿÿÿ  1   	  6ÿÿÿÿ  1   
          ®     $   	  $   
  ÿÿÿÿ  ÿÿÿÿ    ƒ8°       statement executed        }   $ÿÿÿÿ     	  $ÿÿÿÿ     
          ¯               ÿÿÿÿ  ÿÿÿÿ    ƒ1È       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               °     
   	  
     ÿÿÿÿ  ÿÿÿÿ    ƒ0ğ       statement executed        exit(0);   
ÿÿÿÿ     	  
ÿÿÿÿ               ±        	     
  şÿÿÿÿ  şÿÿÿÿ    ƒ-À       statement executed        }   ÿÿÿÿ  ş   	  ÿÿÿÿ  ş   
          ²               ıÿÿÿÿ  ıÿÿÿÿ    ƒ,        statement executed        }   ÿÿÿÿ  ı     ÿÿÿÿ  ı             ³     ü   	  ü   
  ÷ÿÿÿÿ  ÷ÿÿÿÿ    ƒ)ø       statement executed        }   üÿÿÿÿ  ÷   	  üÿÿÿÿ  ÷   
          ´     ø     ø     óÿÿÿÿ  óÿÿÿÿ    ƒ'À       statement executed        }   øÿÿÿÿ  ó     øÿÿÿÿ  ó             µ     ô     ô     ïÿÿÿÿ  ïÿÿÿÿ    ƒ&¨       statement executed        }   ôÿÿÿÿ  ï     ôÿÿÿÿ  ï             ¶     ï     ï     êÿÿÿÿ  êÿÿÿÿ    ƒ#˜       statement executed        }   ïÿÿÿÿ  ê     ïÿÿÿÿ  ê             ·     ã   	  ã   
  Şÿÿÿÿ  Şÿÿÿÿ    ƒH       statement executed        }   ãÿÿÿÿ  Ş   	  ãÿÿÿÿ  Ş   
          ¸     İ   	  İ   
  Øÿÿÿÿ  Øÿÿÿÿ    ƒ       statement executed        }   İÿÿÿÿ  Ø   	  İÿÿÿÿ  Ø   
          ¹     Ï     Ï     Êÿÿÿÿ  Êÿÿÿÿ    ƒ°       statement executed        }   Ïÿÿÿÿ  Ê     Ïÿÿÿÿ  Ê             º     Í   	  Í     Èÿÿÿÿ  Èÿÿÿÿ    ƒØ       statement executed        exit(0);   Íÿÿÿÿ  È   	  Íÿÿÿÿ  È             »     Ç     Ç     Âÿÿÿÿ  Âÿÿÿÿ    ƒ       statement executed        }   Çÿÿÿÿ  Â     Çÿÿÿÿ  Â             ¼     Æ   	  Æ   
  Áÿÿÿÿ  Áÿÿÿÿ    ƒ	Ğ       statement executed        }   Æÿÿÿÿ  Á   	  Æÿÿÿÿ  Á   
          ½     À   	  À   
  »ÿÿÿÿ  »ÿÿÿÿ    ƒ°       statement executed        }   Àÿÿÿÿ  »   	  Àÿÿÿÿ  »   
          ¾     ³     ³     ®ÿÿÿÿ  ®ÿÿÿÿ    ƒH       statement executed        }   ³ÿÿÿÿ  ®     ³ÿÿÿÿ  ®             ¿     ±   	  ±     ¬ÿÿÿÿ  ¬ÿÿÿÿ    ƒp       statement executed        exit(0);   ±ÿÿÿÿ  ¬   	  ±ÿÿÿÿ  ¬             À     «     «     ¦ÿÿÿÿ  ¦ÿÿÿÿ    ƒ (       statement executed        }   «ÿÿÿÿ  ¦     «ÿÿÿÿ  ¦             Á     ª   	  ª   
  ¥ÿÿÿÿ  ¥ÿÿÿÿ    ‚şh       statement executed        }   ªÿÿÿÿ  ¥   	  ªÿÿÿÿ  ¥   
          Â     ›     ›     –ÿÿÿÿ  –ÿÿÿÿ    ‚÷€       statement executed        }   ›ÿÿÿÿ  –     ›ÿÿÿÿ  –             Ã     ™   	  ™     ”ÿÿÿÿ  ”ÿÿÿÿ    ‚ö¨       statement executed        exit(0);   ™ÿÿÿÿ  ”   	  ™ÿÿÿÿ  ”             Ä     “     “     ÿÿÿÿ  ÿÿÿÿ    ‚ô`       statement executed        }   “ÿÿÿÿ       “ÿÿÿÿ               Å        	     
  ‹ÿÿÿÿ  ‹ÿÿÿÿ    ‚ò`       statement executed        }   ÿÿÿÿ  ‹   	  ÿÿÿÿ  ‹   
          Æ     {     {     vÿÿÿÿ  vÿÿÿÿ    ,0       statement executed        }   {ÿÿÿÿ  v     {ÿÿÿÿ  v             Ç     y   	  y     tÿÿÿÿ  tÿÿÿÿ    ,X       statement executed        exit(0);   yÿÿÿÿ  t   	  yÿÿÿÿ  t             È     s     s     nÿÿÿÿ  nÿÿÿÿ    ,       statement executed        }   sÿÿÿÿ  n     sÿÿÿÿ  n             É     p   	  p   
  kÿÿÿÿ  kÿÿÿÿ    ,       statement executed        }   pÿÿÿÿ  k   	  pÿÿÿÿ  k   
          Ê     l   	  l   
  gÿÿÿÿ  gÿÿÿÿ    ,ø       statement executed        }   lÿÿÿÿ  g   	  lÿÿÿÿ  g   
          Ë     g   	  g   
  bÿÿÿÿ  bÿÿÿÿ    ,à       statement executed        }   gÿÿÿÿ  b   	  gÿÿÿÿ  b   
          Ì     a   	  a   
  \ÿÿÿÿ  \ÿÿÿÿ    ,       statement executed        }   aÿÿÿÿ  \   	  aÿÿÿÿ  \   
          Í     ]   	  ]   
  Xÿÿÿÿ  Xÿÿÿÿ    ,Ø       statement executed        }   ]ÿÿÿÿ  X   	  ]ÿÿÿÿ  X   
          Î     X   	  X   
  Sÿÿÿÿ  Sÿÿÿÿ    ,À       statement executed        }   Xÿÿÿÿ  S   	  Xÿÿÿÿ  S   
          Ï     B     B     =ÿÿÿÿ  =ÿÿÿÿ    +÷¨       statement executed        }   Bÿÿÿÿ  =     Bÿÿÿÿ  =             Ğ     @   	  @     ;ÿÿÿÿ  ;ÿÿÿÿ    +öĞ       statement executed        exit(0);   @ÿÿÿÿ  ;   	  @ÿÿÿÿ  ;             Ñ     :     :     5ÿÿÿÿ  5ÿÿÿÿ    +ôp       statement executed        }   :ÿÿÿÿ  5     :ÿÿÿÿ  5             Ò     6   	  6   
  1ÿÿÿÿ  1ÿÿÿÿ    +òP       statement executed        }   6ÿÿÿÿ  1   	  6ÿÿÿÿ  1   
          Ó     1   	  1   
  ,ÿÿÿÿ  ,ÿÿÿÿ    +ğ       statement executed        }   1ÿÿÿÿ  ,   	  1ÿÿÿÿ  ,   
          Ô     ,   	  ,   
  'ÿÿÿÿ  'ÿÿÿÿ    +ìø       statement executed        }   ,ÿÿÿÿ  '   	  ,ÿÿÿÿ  '   
          Õ               ÿÿÿÿ  ÿÿÿÿ    +ã@       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               Ö        	       ÿÿÿÿ  ÿÿÿÿ    +âh       statement executed        exit(0);   ÿÿÿÿ     	  ÿÿÿÿ               ×        	     
  	ÿÿÿÿ  	ÿÿÿÿ    +ßH       statement executed        }   ÿÿÿÿ  	   	  ÿÿÿÿ  	   
          Ø               ÿÿÿÿ  ÿÿÿÿ    +İˆ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               Ù               ıÿÿÿÿ  ıÿÿÿÿ    +ÛÈ       statement executed        }   ÿÿÿÿ  ı     ÿÿÿÿ  ı             Ú     û     û     öÿÿÿÿ  öÿÿÿÿ    +ÙP       statement executed        }   ûÿÿÿÿ  ö     ûÿÿÿÿ  ö             Û     í   	  í   
  èÿÿÿÿ  èÿÿÿÿ    +ÒÈ       statement executed        }   íÿÿÿÿ  è   	  íÿÿÿÿ  è   
          Ü     ß   	  ß   
  Úÿÿÿÿ  Úÿÿÿÿ    +Åx       statement executed        }   ßÿÿÿÿ  Ú   	  ßÿÿÿÿ  Ú   
          İ     Ê     Ê     Åÿÿÿÿ  Åÿÿÿÿ    +½H       statement executed        }   Êÿÿÿÿ  Å     Êÿÿÿÿ  Å             Ş     È   	  È     Ãÿÿÿÿ  Ãÿÿÿÿ    +¼p       statement executed        exit(0);   Èÿÿÿÿ  Ã   	  Èÿÿÿÿ  Ã             ß     Â     Â     ½ÿÿÿÿ  ½ÿÿÿÿ    +º(       statement executed        }   Âÿÿÿÿ  ½     Âÿÿÿÿ  ½             à     Á   	  Á   
  ¼ÿÿÿÿ  ¼ÿÿÿÿ    +¸h       statement executed        }   Áÿÿÿÿ  ¼   	  Áÿÿÿÿ  ¼   
          á     »   	  »   
  ¶ÿÿÿÿ  ¶ÿÿÿÿ    +µP       statement executed        }   »ÿÿÿÿ  ¶   	  »ÿÿÿÿ  ¶   
          â     µ   	  µ   
  °ÿÿÿÿ  °ÿÿÿÿ    +²8       statement executed        }   µÿÿÿÿ  °   	  µÿÿÿÿ  °   
          ã     ¯   	  ¯   
  ªÿÿÿÿ  ªÿÿÿÿ    ƒÏ        statement executed        }   ¯ÿÿÿÿ  ª   	  ¯ÿÿÿÿ  ª   
          ä               ˆÿÿÿÿ  ˆÿÿÿÿ    ƒºˆ       statement executed        }   ÿÿÿÿ  ˆ     ÿÿÿÿ  ˆ             å     ‹   	  ‹     †ÿÿÿÿ  †ÿÿÿÿ    ƒ¹°       statement executed        exit(0);   ‹ÿÿÿÿ  †   	  ‹ÿÿÿÿ  †             æ     …     …     €ÿÿÿÿ  €ÿÿÿÿ    ƒ·h       statement executed        }   …ÿÿÿÿ  €     …ÿÿÿÿ  €             ç     „   	  „   
  ÿÿÿÿ  ÿÿÿÿ    ƒµ¨       statement executed        }   „ÿÿÿÿ     	  „ÿÿÿÿ     
          è     ƒ     ƒ     ~ÿÿÿÿ  ~ÿÿÿÿ    ƒ³è       statement executed        }   ƒÿÿÿÿ  ~     ƒÿÿÿÿ  ~             é     n   	  n   
  iÿÿÿÿ  iÿÿÿÿ    ƒ£Ğ       statement executed        }   nÿÿÿÿ  i   	  nÿÿÿÿ  i   
          ê     ]     ]     Xÿÿÿÿ  Xÿÿÿÿ    ƒŸH       statement executed        }   ]ÿÿÿÿ  X     ]ÿÿÿÿ  X             ë     [   	  [     Vÿÿÿÿ  Vÿÿÿÿ    ƒp       statement executed        exit(0);   [ÿÿÿÿ  V   	  [ÿÿÿÿ  V             ì     S     S     Nÿÿÿÿ  Nÿÿÿÿ    ƒšX       statement executed        }   Sÿÿÿÿ  N     Sÿÿÿÿ  N             í     N     N     Iÿÿÿÿ  Iÿÿÿÿ    ƒ˜        statement executed        }   Nÿÿÿÿ  I     Nÿÿÿÿ  I             î     F   	  F   
  Aÿÿÿÿ  Aÿÿÿÿ    ƒ•Ø       statement executed        }   Fÿÿÿÿ  A   	  Fÿÿÿÿ  A   
          ï     7     7     2ÿÿÿÿ  2ÿÿÿÿ    ƒ’€       statement executed        }   7ÿÿÿÿ  2     7ÿÿÿÿ  2             ğ     5   	  5     0ÿÿÿÿ  0ÿÿÿÿ    ƒ‘¨       statement executed        exit(0);   5ÿÿÿÿ  0   	  5ÿÿÿÿ  0             ñ     .   	  .   
  )ÿÿÿÿ  )ÿÿÿÿ    ƒx       statement executed        }   .ÿÿÿÿ  )   	  .ÿÿÿÿ  )   
          ò     )   	  )   
  $ÿÿÿÿ  $ÿÿÿÿ    ƒX       statement executed        }   )ÿÿÿÿ  $   	  )ÿÿÿÿ  $   
          ó               ÿÿÿÿ  ÿÿÿÿ    ƒˆØ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               ô        	       ÿÿÿÿ  ÿÿÿÿ    ƒˆ        statement executed        exit(0);   ÿÿÿÿ     	  ÿÿÿÿ               õ        	     
  ÿÿÿÿ  ÿÿÿÿ    ƒ„Ğ       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
          ö        	     
  ÿÿÿÿ  ÿÿÿÿ    ƒƒ°       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
          ÷        	     
   ÿÿÿÿ   ÿÿÿÿ    ƒ~˜       statement executed        }   ÿÿÿÿ      	  ÿÿÿÿ      
          ø               ıÿÿÿÿ  ıÿÿÿÿ    ƒz        statement executed        }   ÿÿÿÿ  ı     ÿÿÿÿ  ı             ù     ú     ú     õÿÿÿÿ  õÿÿÿÿ    ƒq˜       statement executed        }   úÿÿÿÿ  õ     úÿÿÿÿ  õ             ú     ó     ó     îÿÿÿÿ  îÿÿÿÿ    ƒoÀ       statement executed        }   óÿÿÿÿ  î     óÿÿÿÿ  î             û     ê     ê     åÿÿÿÿ  åÿÿÿÿ    ƒd        statement executed        }   êÿÿÿÿ  å     êÿÿÿÿ  å             ü     ã     ã     Şÿÿÿÿ  Şÿÿÿÿ    ƒbH       statement executed        }   ãÿÿÿÿ  Ş     ãÿÿÿÿ  Ş             ı     ×     ×     Òÿÿÿÿ  Òÿÿÿÿ    !¸        statement executed        }   ×ÿÿÿÿ  Ò     ×ÿÿÿÿ  Ò             ş     Ò     Ò     Íÿÿÿÿ  Íÿÿÿÿ    !³°       statement executed        }   Òÿÿÿÿ  Í     Òÿÿÿÿ  Í             ÿ     Í     Í     Èÿÿÿÿ  Èÿÿÿÿ    !±Ğ       statement executed        }   Íÿÿÿÿ  È     Íÿÿÿÿ  È                   Á     Á     ¼ÿÿÿÿ  ¼ÿÿÿÿ    !«X       statement executed        }   Áÿÿÿÿ  ¼     Áÿÿÿÿ  ¼                  ¹     ¹     ´ÿÿÿÿ  ´ÿÿÿÿ    !¤       statement executed        }   ¹ÿÿÿÿ  ´     ¹ÿÿÿÿ  ´                  ²     ²     ­ÿÿÿÿ  ­ÿÿÿÿ    !€       statement executed        }   ²ÿÿÿÿ  ­     ²ÿÿÿÿ  ­                  ©     ©     ¤ÿÿÿÿ  ¤ÿÿÿÿ    !˜˜       statement executed        }   ©ÿÿÿÿ  ¤     ©ÿÿÿÿ  ¤                  š     š     •ÿÿÿÿ  •ÿÿÿÿ    !`       statement executed        }   šÿÿÿÿ  •     šÿÿÿÿ  •                  ‘     ‘     Œÿÿÿÿ  Œÿÿÿÿ    !‹ˆ       statement executed        }   ‘ÿÿÿÿ  Œ     ‘ÿÿÿÿ  Œ                  ‚     ‚     }ÿÿÿÿ  }ÿÿÿÿ    !ƒ       statement executed        }   ‚ÿÿÿÿ  }     ‚ÿÿÿÿ  }                  w     w     rÿÿÿÿ  rÿÿÿÿ    !z°       statement executed        }   wÿÿÿÿ  r     wÿÿÿÿ  r                  o     o     jÿÿÿÿ  jÿÿÿÿ    !uĞ       statement executed        }   oÿÿÿÿ  j     oÿÿÿÿ  j             	     g     g     bÿÿÿÿ  bÿÿÿÿ    !q`       statement executed        }   gÿÿÿÿ  b     gÿÿÿÿ  b             
     \     \     Wÿÿÿÿ  Wÿÿÿÿ    !h       statement executed        }   \ÿÿÿÿ  W     \ÿÿÿÿ  W                  U     U     Pÿÿÿÿ  Pÿÿÿÿ    !c˜       statement executed        }   Uÿÿÿÿ  P     Uÿÿÿÿ  P                  N     N     Iÿÿÿÿ  Iÿÿÿÿ     ,>P       statement executed        }   Nÿÿÿÿ  I     Nÿÿÿÿ  I                  G     G     Bÿÿÿÿ  Bÿÿÿÿ     ,9Ø       statement executed        }   Gÿÿÿÿ  B     Gÿÿÿÿ  B                  @     @     ;ÿÿÿÿ  ;ÿÿÿÿ     ,5`       statement executed        }   @ÿÿÿÿ  ;     @ÿÿÿÿ  ;                  :     :     5ÿÿÿÿ  5ÿÿÿÿ     ,/È       statement executed        exit( 0 );   :ÿÿÿÿ  5     :ÿÿÿÿ  5                  /     /     *ÿÿÿÿ  *ÿÿÿÿ     ,(8       statement executed        }   /ÿÿÿÿ  *     /ÿÿÿÿ  *                  (     (     #ÿÿÿÿ  #ÿÿÿÿ     ,#À       statement executed        }   (ÿÿÿÿ  #     (ÿÿÿÿ  #                              ÿÿÿÿ  ÿÿÿÿ     ,x       statement executed        }    ÿÿÿÿ        ÿÿÿÿ                              ÿÿÿÿ  ÿÿÿÿ     ,       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                              
ÿÿÿÿ  
ÿÿÿÿ     ,x       statement executed        }   ÿÿÿÿ  
     ÿÿÿÿ  
                            	ÿÿÿÿ  	ÿÿÿÿ     ,¸       statement executed        }   ÿÿÿÿ  	     ÿÿÿÿ  	                             ıÿÿÿÿ   ıÿÿÿÿ     ,¨       statement executed        }   ÿÿÿÿ   ı     ÿÿÿÿ   ı                   î   	   î   
   éÿÿÿÿ   éÿÿÿÿ     +şØ       statement executed        }    îÿÿÿÿ   é   	   îÿÿÿÿ   é   
                Ò      Ò      Íÿÿÿÿ   Íÿÿÿÿ     +ó˜       statement executed        }    Òÿÿÿÿ   Í      Òÿÿÿÿ   Í                   Ğ   	   Ğ      Ëÿÿÿÿ   Ëÿÿÿÿ     +òÀ       statement executed        exit(0);    Ğÿÿÿÿ   Ë   	   Ğÿÿÿÿ   Ë                   Ê      Ê      Åÿÿÿÿ   Åÿÿÿÿ     +ğx       statement executed        }    Êÿÿÿÿ   Å      Êÿÿÿÿ   Å                   É   	   É   
   Äÿÿÿÿ   Äÿÿÿÿ     +îÈ       statement executed        }    Éÿÿÿÿ   Ä   	   Éÿÿÿÿ   Ä   
                È      È      Ãÿÿÿÿ   Ãÿÿÿÿ     +í       statement executed        }    Èÿÿÿÿ   Ã      Èÿÿÿÿ   Ã                   Ç      Ç      Âÿÿÿÿ   Âÿÿÿÿ     +ëX       statement executed        }    Çÿÿÿÿ   Â      Çÿÿÿÿ   Â                   ½   	   ½   
   ¸ÿÿÿÿ   ¸ÿÿÿÿ     +æ(       statement executed        }    ½ÿÿÿÿ   ¸   	   ½ÿÿÿÿ   ¸   
                ™      ™      ”ÿÿÿÿ   ”ÿÿÿÿ    5„ğ       statement executed        }    ™ÿÿÿÿ   ”      ™ÿÿÿÿ   ”                    —   	   —      ’ÿÿÿÿ   ’ÿÿÿÿ    5„       statement executed        exit(0);    —ÿÿÿÿ   ’   	   —ÿÿÿÿ   ’             !      ‘      ‘      Œÿÿÿÿ   Œÿÿÿÿ    5¸       statement executed        }    ‘ÿÿÿÿ   Œ      ‘ÿÿÿÿ   Œ             "      |      |      wÿÿÿÿ   wÿÿÿÿ    5v€       statement executed        }    |ÿÿÿÿ   w      |ÿÿÿÿ   w             #      z   	   z      uÿÿÿÿ   uÿÿÿÿ    5u¨       statement executed        exit(0);    zÿÿÿÿ   u   	   zÿÿÿÿ   u             $      t      t      oÿÿÿÿ   oÿÿÿÿ    5sH       statement executed        }    tÿÿÿÿ   o      tÿÿÿÿ   o             %      _      _      Zÿÿÿÿ   Zÿÿÿÿ    5gP       statement executed        }    _ÿÿÿÿ   Z      _ÿÿÿÿ   Z             &      ]   	   ]      Xÿÿÿÿ   Xÿÿÿÿ    5fx       statement executed        exit(0);    ]ÿÿÿÿ   X   	   ]ÿÿÿÿ   X             '      V   	   V   
   Qÿÿÿÿ   Qÿÿÿÿ    5cH       statement executed        }    Vÿÿÿÿ   Q   	   Vÿÿÿÿ   Q   
          (      S      S      Nÿÿÿÿ   Nÿÿÿÿ    5aˆ       statement executed        }    Sÿÿÿÿ   N      Sÿÿÿÿ   N             )      O      O      Jÿÿÿÿ   Jÿÿÿÿ    5^8       statement executed        }    Oÿÿÿÿ   J      Oÿÿÿÿ   J             É      =      =      8ÿÿÿÿ   8ÿÿÿÿ    ?€       statement executed        }    =ÿÿÿÿ   8      =ÿÿÿÿ   8             Ê      B      B      =ÿÿÿÿ   =ÿÿÿÿ    ?¸       statement executed        }    Bÿÿÿÿ   =      Bÿÿÿÿ   =                   ˆ     ˆ     Vÿÿÿÿ  Vÿÿÿÿ    |-      expression was true       base[size-1] != 0   ˆÿÿÿÿ  V     ˆÿÿÿÿ  V      expression was false       base[size-1] != 0   ˆÿÿÿÿ  V     ˆÿÿÿÿ  V                  |+P        ‡     ‡     Uÿÿÿÿ  Uÿÿÿÿ    |)@      expression was true       base[size-2] != 0   ‡ÿÿÿÿ  U     ‡ÿÿÿÿ  U      expression was false       base[size-2] != 0   ‡ÿÿÿÿ  U     ‡ÿÿÿÿ  U                  |(         †     †     Tÿÿÿÿ  Tÿÿÿÿ    |(°      expression was true       size < 2   †ÿÿÿÿ  T     †ÿÿÿÿ  T      expression was false       size < 2   †ÿÿÿÿ  T     †ÿÿÿÿ  T                    
*     
*   "  
ÿÿÿÿ  
ÿÿÿÿ    0Là      expression was true       *yy_cp   
*ÿÿÿÿ  
     
*ÿÿÿÿ  
   "   expression was false       *yy_cp   
*ÿÿÿÿ  
     
*ÿÿÿÿ  
   "           "     	ş  ú  	ş    	àÿÿÿÿ  	àÿÿÿÿ    *ˆ¨      expression was true       ferror( yyin )   	şÿÿÿÿ  	à  ú  	şÿÿÿÿ  	à     expression was false       ferror( yyin )   	şÿÿÿÿ  	à  ú  	şÿÿÿÿ  	à             $     	ş  ’  	ş  ö  	àÿÿÿÿ  	àÿÿÿÿ    *‡À      expression was true       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   	şÿÿÿÿ  	à  ’  	şÿÿÿÿ  	à  ö   expression was false       ((yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1, num_to_read, yyin )) == 0)   	şÿÿÿÿ  	à  ’  	şÿÿÿÿ  	à  ö               *†˜   &     	ş  3  	ş  A  	àÿÿÿÿ  	àÿÿÿÿ    *~h      expression was true       ferror( yyin )   	şÿÿÿÿ  	à  3  	şÿÿÿÿ  	à  A   expression was false       ferror( yyin )   	şÿÿÿÿ  	à  3  	şÿÿÿÿ  	à  A           (     	ş  &  	ş  /  	àÿÿÿÿ  	àÿÿÿÿ    *}€      expression was true       c == (-1)   	şÿÿÿÿ  	à  &  	şÿÿÿÿ  	à  /   expression was false       c == (-1)   	şÿÿÿÿ  	à  &  	şÿÿÿÿ  	à  /               *|X   *     	ş     	ş   ˆ  	àÿÿÿÿ  	àÿÿÿÿ    A°      expression was true       c != '\n'   	şÿÿÿÿ  	à     	şÿÿÿÿ  	à   ˆ   expression was false       c != '\n'   	şÿÿÿÿ  	à     	şÿÿÿÿ  	à   ˆ               Ağ   ,     	ş   a  	ş   {  	àÿÿÿÿ  	àÿÿÿÿ    Ağ      expression was true       (c = getc( yyin )) != (-1)   	şÿÿÿÿ  	à   a  	şÿÿÿÿ  	à   {   expression was false       (c = getc( yyin )) != (-1)   	şÿÿÿÿ  	à   a  	şÿÿÿÿ  	à   {               A    .     	ş   N  	ş   ]  	àÿÿÿÿ  	àÿÿÿÿ    A      expression was true       n < num_to_read   	şÿÿÿÿ  	à   N  	şÿÿÿÿ  	à   ]   expression was false       n < num_to_read   	şÿÿÿÿ  	à   N  	şÿÿÿÿ  	à   ]           B     Æ     Æ     ÿÿÿÿ  ÿÿÿÿ     ûP˜      expression was false       i < len   Æÿÿÿÿ       Æÿÿÿÿ                C     ª     ª     vÿÿÿÿ  vÿÿÿÿ     ûAğ      expression was false       str[len]   ªÿÿÿÿ  v     ªÿÿÿÿ  v              D     
(     
(   .  
	ÿÿÿÿ  
	ÿÿÿÿ     5Á      expression was false       yy_cp < yy_c_buf_p   
(ÿÿÿÿ  
	     
(ÿÿÿÿ  
	   .           G     	Â     	Â   !  	¦ÿÿÿÿ  	¦ÿÿÿÿ    „¸      expression was false       i < number_to_move   	Âÿÿÿÿ  	¦     	Âÿÿÿÿ  	¦   !           O     
w     
w   0  
Vÿÿÿÿ  
Vÿÿÿÿ     ù       expression was false       source > yy_current_buffer->yy_ch_buf   
wÿÿÿÿ  
V     
wÿÿÿÿ  
V   0           P     
S   
  
S   F  
3ÿÿÿÿ  
3ÿÿÿÿ     ùP      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   
Sÿÿÿÿ  
3   
  
Sÿÿÿÿ  
3   F                5Í   Q     
0     
0   G  
ÿÿÿÿ  
ÿÿÿÿ     5½à      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   
0ÿÿÿÿ  
     
0ÿÿÿÿ  
   G                5µ    R     	Ğ     	Ğ     	´ÿÿÿÿ  	´ÿÿÿÿ    ìX      expression was false       num_to_read <= 0   	Ğÿÿÿÿ  	´     	Ğÿÿÿÿ  	´                  „À   S     	     	   H  ïÿÿÿÿ  ïÿÿÿÿ    Sˆx      expression was false       yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state   	ÿÿÿÿ  ï     	ÿÿÿÿ  ï   H                )Ÿè   T     ó   
  ó     Ùÿÿÿÿ  Ùÿÿÿÿ    +¥À      expression was false       1   óÿÿÿÿ  Ù   
  óÿÿÿÿ  Ù              U             ,  øÿÿÿÿ  øÿÿÿÿ    ?×(      expression was true       yy_base[yy_current_state] != 4660   ÿÿÿÿ  ø     ÿÿÿÿ  ø   ,   expression was false       yy_base[yy_current_state] != 4660   ÿÿÿÿ  ø     ÿÿÿÿ  ø   ,               ?Ù(   Ê     ş     ş     Äÿÿÿÿ  Äÿÿÿÿ    >î˜      expression was false       --yy_start_stack_ptr < 0   şÿÿÿÿ  Ä     şÿÿÿÿ  Ä              Ë     ï     ï     ·ÿÿÿÿ  ·ÿÿÿÿ     ûjp      expression was false       ! yy_start_stack   ïÿÿÿÿ  ·     ïÿÿÿÿ  ·                   ûgè   Ì     á     á   1  ©ÿÿÿÿ  ©ÿÿÿÿ     ûk       expression was false       yy_start_stack_ptr >= yy_start_stack_depth   áÿÿÿÿ  ©     áÿÿÿÿ  ©   1                û[è   Í     Ì     Ì   
  –ÿÿÿÿ  –ÿÿÿÿ     ûV`      expression was false       ! b   Ìÿÿÿÿ  –     Ìÿÿÿÿ  –   
                ûTh   Î     Ã     Ã     ÿÿÿÿ  ÿÿÿÿ     ûM@      expression was false       ! buf   Ãÿÿÿÿ       Ãÿÿÿÿ                     ûKH   Ï             
  [ÿÿÿÿ  [ÿÿÿÿ    |5       expression was false       ! b   ÿÿÿÿ  [     ÿÿÿÿ  [   
               |3(   Ò     v     v     Eÿÿÿÿ  Eÿÿÿÿ    |#¨      expression was false       b == yy_current_buffer   vÿÿÿÿ  E     vÿÿÿÿ  E                  |!¨   Ó     8     8     ÿÿÿÿ  ÿÿÿÿ    |      expression was false       b->yy_is_our_buffer   8ÿÿÿÿ       8ÿÿÿÿ                Ô     5     5     
ÿÿÿÿ  
ÿÿÿÿ    Sù˜      expression was false       b == yy_current_buffer   5ÿÿÿÿ  
     5ÿÿÿÿ  
                  Sõ   Õ     2     2   
  ÿÿÿÿ  ÿÿÿÿ    Sô      expression was false       ! b   2ÿÿÿÿ       2ÿÿÿÿ     
               Sòø   Ö                 
öÿÿÿÿ  
öÿÿÿÿ    Sí      expression was false       ! b->yy_ch_buf    ÿÿÿÿ  
ö      ÿÿÿÿ  
ö                  Së˜   ×             
  
íÿÿÿÿ  
íÿÿÿÿ    SæH      expression was false       ! b   ÿÿÿÿ  
í     ÿÿÿÿ  
í   
               SäP   Ø     
ë     
ë     
Ãÿÿÿÿ  
Ãÿÿÿÿ    SÔ€      expression was false       yy_current_buffer   
ëÿÿÿÿ  
Ã     
ëÿÿÿÿ  
Ã              Ù     
è     
è   &  
Àÿÿÿÿ  
Àÿÿÿÿ    SÍ˜      expression was false       yy_current_buffer == new_buffer   
èÿÿÿÿ  
À     
èÿÿÿÿ  
À   &               SÌx   Ú     
Ù     
Ù     
²ÿÿÿÿ  
²ÿÿÿÿ     í]       expression was false       ! yy_current_buffer   
Ùÿÿÿÿ  
²     
Ùÿÿÿÿ  
²                   í[   Û     
°     
°   (  
ÿÿÿÿ  
ÿÿÿÿ     íN       expression was false       ! yy_did_buffer_switch_on_eof   
°ÿÿÿÿ  
     
°ÿÿÿÿ  
   (                íL    Ü     
©     
©     
†ÿÿÿÿ  
†ÿÿÿÿ     íK      expression was false       yywrap()   
©ÿÿÿÿ  
†     
©ÿÿÿÿ  
†              İ     
–     
–     
sÿÿÿÿ  
sÿÿÿÿ     íTÀ      expression was false       *yy_c_buf_p == 0   
–ÿÿÿÿ  
s     
–ÿÿÿÿ  
s                   íBx   Ş     
~     
~   0  
]ÿÿÿÿ  
]ÿÿÿÿ     í68      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   
~ÿÿÿÿ  
]     
~ÿÿÿÿ  
]   0                ù   ß     
n     
n   /  
Mÿÿÿÿ  
Mÿÿÿÿ     í7ø      expression was false       yy_cp < yy_current_buffer->yy_ch_buf + 2   
nÿÿÿÿ  
M     
nÿÿÿÿ  
M   /                ùÈ   à     
V     
V      
6ÿÿÿÿ  
6ÿÿÿÿ     ù      expression was false       yy_current_state >= 1326   
Vÿÿÿÿ  
6     
Vÿÿÿÿ  
6                    øşˆ   á     
N     
N   "  
.ÿÿÿÿ  
.ÿÿÿÿ     5Ë°      expression was false       yy_accept[yy_current_state]   
Nÿÿÿÿ  
.     
Nÿÿÿÿ  
.   "           â     
3   	  
3   !  
ÿÿÿÿ  
ÿÿÿÿ     5¼       expression was false       yy_current_state >= 1326   
3ÿÿÿÿ  
   	  
3ÿÿÿÿ  
   !                5¹   ã     
+     
+   #  
ÿÿÿÿ  
ÿÿÿÿ     5´8      expression was false       yy_accept[yy_current_state]   
+ÿÿÿÿ  
     
+ÿÿÿÿ  
   #           è     	ş   Ô  	ş   İ  	àÿÿÿÿ  	àÿÿÿÿ    *zh      expression was false       c == '\n'   	şÿÿÿÿ  	à   Ô  	şÿÿÿÿ  	à   İ               A€   é     	ú     	ú     	Üÿÿÿÿ  	Üÿÿÿÿ    A      expression was false       num_to_read > 8192   	úÿÿÿÿ  	Ü     	úÿÿÿÿ  	Ü              ê     	ï   	  	ï     	Óÿÿÿÿ  	Óÿÿÿÿ    ì‡8      expression was false       ! b->yy_ch_buf   	ïÿÿÿÿ  	Ó   	  	ïÿÿÿÿ  	Ó                  ì„°   ë     	ª     	ª   -  	ÿÿÿÿ  	ÿÿÿÿ    6PØ      expression was false       yy_current_buffer->yy_fill_buffer == 0   	ªÿÿÿÿ  	     	ªÿÿÿÿ  	   -               6JP   ì     	¦     	¦   A  	‹ÿÿÿÿ  	‹ÿÿÿÿ    6Ip      expression was false       yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1]   	¦ÿÿÿÿ  	‹     	¦ÿÿÿÿ  	‹   A           í     	r     	r   (  	Xÿÿÿÿ  	Xÿÿÿÿ    HåH      expression was false       ! yy_did_buffer_switch_on_eof   	rÿÿÿÿ  	X     	rÿÿÿÿ  	X   (               HãP   î     	     	   0  	ÿÿÿÿ  	ÿÿÿÿ    MNp      expression was false       yy_current_buffer->yy_buffer_status == 0   	ÿÿÿÿ  	     	ÿÿÿÿ  	   0               È   ï               üÿÿÿÿ  üÿÿÿÿ    Mf€      expression was false       yy_act == 0   ÿÿÿÿ  ü     ÿÿÿÿ  ü                  MQ8   ğ        
     "  òÿÿÿÿ  òÿÿÿÿ    ÚH      expression was false       yy_current_state >= 1326   ÿÿÿÿ  ò   
  ÿÿÿÿ  ò   "                .
À   ñ        	     $  êÿÿÿÿ  êÿÿÿÿ     )—8      expression was false       yy_accept[yy_current_state]   ÿÿÿÿ  ê   	  ÿÿÿÿ  ê   $           ò     ì     ì     Òÿÿÿÿ  Òÿÿÿÿ     5×x      expression was false       ! yy_current_buffer   ìÿÿÿÿ  Ò     ìÿÿÿÿ  Ò                  ?Ü    ó     é     é     Ïÿÿÿÿ  Ïÿÿÿÿ    ?Şè      expression was false       ! yyout   éÿÿÿÿ  Ï     éÿÿÿÿ  Ï                  MV    ô     æ     æ     Ìÿÿÿÿ  Ìÿÿÿÿ    MY(      expression was false       ! yyin   æÿÿÿÿ  Ì     æÿÿÿÿ  Ì                  Mk0   õ     ã     ã     Éÿÿÿÿ  Éÿÿÿÿ    Mmğ      expression was false       ! yy_start   ãÿÿÿÿ  É     ãÿÿÿÿ  É                   ñÙ0   ö     Û     Û     Áÿÿÿÿ  Áÿÿÿÿ    Ø       expression was false       yy_init   Ûÿÿÿÿ  Á     Ûÿÿÿÿ  Á             *     ä     ä     Êÿÿÿÿ  Êÿÿÿÿ     ñÑ       statement executed        yy_start = 1;   äÿÿÿÿ  Ê     äÿÿÿÿ  Ê             +     ç     ç     Íÿÿÿÿ  Íÿÿÿÿ    M_Ğ       statement executed        yyin = (&__iob_func()[0]);   çÿÿÿÿ  Í     çÿÿÿÿ  Í             ,     ê     ê     Ğÿÿÿÿ  Ğÿÿÿÿ    MEğ       statement executed        yyout = (&__iob_func()[1]);   êÿÿÿÿ  Ğ     êÿÿÿÿ  Ğ             -     í     î   %  Óÿÿÿÿ  Ôÿÿÿÿ    ?ÕÀ       statement executed        yy_current_buffer =
				yy_create_buffer( yyin, 16384 );   íÿÿÿÿ  Ó     îÿÿÿÿ  Ô   %          .     ñ     ñ     ×ÿÿÿÿ  ×ÿÿÿÿ     5ù       statement executed        }   ñÿÿÿÿ  ×     ñÿÿÿÿ  ×             /               îÿÿÿÿ  îÿÿÿÿ     )¢x       statement executed        }   ÿÿÿÿ  î     ÿÿÿÿ  î             0             *  óÿÿÿÿ  óÿÿÿÿ     ¸P       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   ÿÿÿÿ  ó     ÿÿÿÿ  ó   *          1               ôÿÿÿÿ  ôÿÿÿÿ    $ë       statement executed        }   ÿÿÿÿ  ô     ÿÿÿÿ  ô             2               ÷ÿÿÿÿ  ÷ÿÿÿÿ    †h       statement executed        }   ÿÿÿÿ  ÷     ÿÿÿÿ  ÷             3               ÿÿÿÿ  ÿÿÿÿ    M](       statement executed        }   ÿÿÿÿ       ÿÿÿÿ               4     *     *     ÿÿÿÿ  ÿÿÿÿ     ñğH       statement executed        goto yy_find_action;   *ÿÿÿÿ       *ÿÿÿÿ               5     /     /     ÿÿÿÿ  ÿÿÿÿ     ñó`       statement executed        break;   /ÿÿÿÿ       /ÿÿÿÿ               6     3     3     ÿÿÿÿ  ÿÿÿÿ     ñ÷       statement executed        break;   3ÿÿÿÿ       3ÿÿÿÿ               7     7     7     ÿÿÿÿ  ÿÿÿÿ     ñúX       statement executed        break;   7ÿÿÿÿ       7ÿÿÿÿ               8     ;     ;     !ÿÿÿÿ  !ÿÿÿÿ    S˜¨       statement executed        break;   ;ÿÿÿÿ  !     ;ÿÿÿÿ  !             9     ?     ?     %ÿÿÿÿ  %ÿÿÿÿ    SÈ       statement executed        break;   ?ÿÿÿÿ  %     ?ÿÿÿÿ  %             :     C     C     )ÿÿÿÿ  )ÿÿÿÿ    S Ğ       statement executed        break;   Cÿÿÿÿ  )     Cÿÿÿÿ  )             ;     G     G     -ÿÿÿÿ  -ÿÿÿÿ    S¢ˆ       statement executed        break;   Gÿÿÿÿ  -     Gÿÿÿÿ  -             <     K     K     1ÿÿÿÿ  1ÿÿÿÿ    Sµ°       statement executed        break;   Kÿÿÿÿ  1     Kÿÿÿÿ  1             =     O     O     5ÿÿÿÿ  5ÿÿÿÿ    MLX       statement executed        break;   Oÿÿÿÿ  5     Oÿÿÿÿ  5             >     S     S     9ÿÿÿÿ  9ÿÿÿÿ    $éh       statement executed        break;   Sÿÿÿÿ  9     Sÿÿÿÿ  9             ?     W     W     =ÿÿÿÿ  =ÿÿÿÿ    ¯8       statement executed        break;   Wÿÿÿÿ  =     Wÿÿÿÿ  =             @     [     [     Aÿÿÿÿ  Aÿÿÿÿ     )š       statement executed        break;   [ÿÿÿÿ  A     [ÿÿÿÿ  A             A     _     _     Eÿÿÿÿ  Eÿÿÿÿ     5Ñ¸       statement executed        break;   _ÿÿÿÿ  E     _ÿÿÿÿ  E             B     c     c     Iÿÿÿÿ  Iÿÿÿÿ    ?Ø        statement executed        break;   cÿÿÿÿ  I     cÿÿÿÿ  I             C     g     g     Mÿÿÿÿ  Mÿÿÿÿ    Mm       statement executed        break;   gÿÿÿÿ  M     gÿÿÿÿ  M             D     k     k     Qÿÿÿÿ  Qÿÿÿÿ     ñì¸       statement executed        break;   kÿÿÿÿ  Q     kÿÿÿÿ  Q             E     o     o     Uÿÿÿÿ  Uÿÿÿÿ     ÙØ       statement executed        break;   oÿÿÿÿ  U     oÿÿÿÿ  U             F     s     s     Yÿÿÿÿ  Yÿÿÿÿ    ŒMè       statement executed        break;   sÿÿÿÿ  Y     sÿÿÿÿ  Y             G     w     w     ]ÿÿÿÿ  ]ÿÿÿÿ    ŒV        statement executed        break;   wÿÿÿÿ  ]     wÿÿÿÿ  ]             H     {     {     aÿÿÿÿ  aÿÿÿÿ    Ì¨       statement executed        break;   {ÿÿÿÿ  a     {ÿÿÿÿ  a             I               eÿÿÿÿ  eÿÿÿÿ    }        statement executed        break;   ÿÿÿÿ  e     ÿÿÿÿ  e             J     ƒ     ƒ     iÿÿÿÿ  iÿÿÿÿ     .	X       statement executed        break;   ƒÿÿÿÿ  i     ƒÿÿÿÿ  i             K     ‡     ‡     mÿÿÿÿ  mÿÿÿÿ     .        statement executed        break;   ‡ÿÿÿÿ  m     ‡ÿÿÿÿ  m             L     ‹     ‹     qÿÿÿÿ  qÿÿÿÿ     .€       statement executed        break;   ‹ÿÿÿÿ  q     ‹ÿÿÿÿ  q             M               uÿÿÿÿ  uÿÿÿÿ     .è       statement executed        break;   ÿÿÿÿ  u     ÿÿÿÿ  u             N     “     “     yÿÿÿÿ  yÿÿÿÿ     .       statement executed        break;   “ÿÿÿÿ  y     “ÿÿÿÿ  y             O     —     —     }ÿÿÿÿ  }ÿÿÿÿ     »       statement executed        break;   —ÿÿÿÿ  }     —ÿÿÿÿ  }             P     ›     ›     ÿÿÿÿ  ÿÿÿÿ     ¼°       statement executed        break;   ›ÿÿÿÿ       ›ÿÿÿÿ               Q     Ÿ     Ÿ     …ÿÿÿÿ  …ÿÿÿÿ     .à       statement executed        break;   Ÿÿÿÿÿ  …     Ÿÿÿÿÿ  …             R     £     £     ‰ÿÿÿÿ  ‰ÿÿÿÿ     .à       statement executed        break;   £ÿÿÿÿ  ‰     £ÿÿÿÿ  ‰             S     §     §     ÿÿÿÿ  ÿÿÿÿ     .@       statement executed        break;   §ÿÿÿÿ       §ÿÿÿÿ               T     «     «     ‘ÿÿÿÿ  ‘ÿÿÿÿ     .        statement executed        break;   «ÿÿÿÿ  ‘     «ÿÿÿÿ  ‘             U     ¯     ¯     •ÿÿÿÿ  •ÿÿÿÿ     .!        statement executed        break;   ¯ÿÿÿÿ  •     ¯ÿÿÿÿ  •             V     ³     ³     ™ÿÿÿÿ  ™ÿÿÿÿ    S~       statement executed        break;   ³ÿÿÿÿ  ™     ³ÿÿÿÿ  ™             W     ·     ·     ÿÿÿÿ  ÿÿÿÿ     Ğà       statement executed        break;   ·ÿÿÿÿ       ·ÿÿÿÿ               X     »     »     ¡ÿÿÿÿ  ¡ÿÿÿÿ    $ÖÈ       statement executed        break;   »ÿÿÿÿ  ¡     »ÿÿÿÿ  ¡             Y     ¿     ¿     ¥ÿÿÿÿ  ¥ÿÿÿÿ     .à       statement executed        break;   ¿ÿÿÿÿ  ¥     ¿ÿÿÿÿ  ¥             Z     Ã     Ã     ©ÿÿÿÿ  ©ÿÿÿÿ     .(       statement executed        break;   Ãÿÿÿÿ  ©     Ãÿÿÿÿ  ©             [     Ç     Ç     ­ÿÿÿÿ  ­ÿÿÿÿ    f`       statement executed        break;   Çÿÿÿÿ  ­     Çÿÿÿÿ  ­             \     Ë     Ë     ±ÿÿÿÿ  ±ÿÿÿÿ     éà       statement executed        break;   Ëÿÿÿÿ  ±     Ëÿÿÿÿ  ±             ]     Ï     Ï     µÿÿÿÿ  µÿÿÿÿ    M?x       statement executed        break;   Ïÿÿÿÿ  µ     Ïÿÿÿÿ  µ             ^     Ó     Ó     ¹ÿÿÿÿ  ¹ÿÿÿÿ    S       statement executed        break;   Óÿÿÿÿ  ¹     Óÿÿÿÿ  ¹             _     ×     ×     ½ÿÿÿÿ  ½ÿÿÿÿ     òà       statement executed        break;   ×ÿÿÿÿ  ½     ×ÿÿÿÿ  ½             `     Û     Û     Áÿÿÿÿ  Áÿÿÿÿ    MZØ       statement executed        break;   Ûÿÿÿÿ  Á     Ûÿÿÿÿ  Á             a     ß     ß     Åÿÿÿÿ  Åÿÿÿÿ     òø       statement executed        break;   ßÿÿÿÿ  Å     ßÿÿÿÿ  Å             b     ã     ã     Éÿÿÿÿ  Éÿÿÿÿ     ò       statement executed        break;   ãÿÿÿÿ  É     ãÿÿÿÿ  É             c     ç     ç     Íÿÿÿÿ  Íÿÿÿÿ     ò(       statement executed        break;   çÿÿÿÿ  Í     çÿÿÿÿ  Í             d     ë     ë     Ñÿÿÿÿ  Ñÿÿÿÿ    S€¸       statement executed        break;   ëÿÿÿÿ  Ñ     ëÿÿÿÿ  Ñ             e     ï     ï     Õÿÿÿÿ  Õÿÿÿÿ     )–       statement executed        break;   ïÿÿÿÿ  Õ     ïÿÿÿÿ  Õ             f     ó     ó     Ùÿÿÿÿ  Ùÿÿÿÿ     )¦        statement executed        break;   óÿÿÿÿ  Ù     óÿÿÿÿ  Ù             g     ÷     ÷     İÿÿÿÿ  İÿÿÿÿ     ,o°       statement executed        break;   ÷ÿÿÿÿ  İ     ÷ÿÿÿÿ  İ             h     û     û     áÿÿÿÿ  áÿÿÿÿ     ,Pø       statement executed        break;   ûÿÿÿÿ  á     ûÿÿÿÿ  á             i     ÿ     ÿ     åÿÿÿÿ  åÿÿÿÿ     ,BØ       statement executed        break;   ÿÿÿÿÿ  å     ÿÿÿÿÿ  å             j     	     	     éÿÿÿÿ  éÿÿÿÿ     5ê`       statement executed        break;   	ÿÿÿÿ  é     	ÿÿÿÿ  é             k     	     	     íÿÿÿÿ  íÿÿÿÿ    $Ş       statement executed        break;   	ÿÿÿÿ  í     	ÿÿÿÿ  í             l     	     	     úÿÿÿÿ  úÿÿÿÿ     ,GØ       statement executed        return 0;   	ÿÿÿÿ  ú     	ÿÿÿÿ  ú             m     	,     	,     	ÿÿÿÿ  	ÿÿÿÿ     Û        statement executed        }   	,ÿÿÿÿ  	     	,ÿÿÿÿ  	             n     	O     	O     	5ÿÿÿÿ  	5ÿÿÿÿ    «ø       statement executed        goto yy_match;   	Oÿÿÿÿ  	5     	Oÿÿÿÿ  	5             o     	U     	U     	;ÿÿÿÿ  	;ÿÿÿÿ    ®0       statement executed        goto yy_find_action;   	Uÿÿÿÿ  	;     	Uÿÿÿÿ  	;             p     	m     	m     	Sÿÿÿÿ  	Sÿÿÿÿ    HâH       statement executed        goto do_action;   	mÿÿÿÿ  	S     	mÿÿÿÿ  	S             q     	s     	s     	Yÿÿÿÿ  	Yÿÿÿÿ    Häp       statement executed        yyrestart( yyin );   	sÿÿÿÿ  	Y     	sÿÿÿÿ  	Y             r     	t     	t     	Zÿÿÿÿ  	Zÿÿÿÿ    Hæ0       statement executed        }   	tÿÿÿÿ  	Z     	tÿÿÿÿ  	Z             s     	u     	u     	[ÿÿÿÿ  	[ÿÿÿÿ    Hçà       statement executed        break;   	uÿÿÿÿ  	[     	uÿÿÿÿ  	[             t     	€     	€     	fÿÿÿÿ  	fÿÿÿÿ     î´ø       statement executed        goto yy_match;   	€ÿÿÿÿ  	f     	€ÿÿÿÿ  	f             u     	Š     	Š     	pÿÿÿÿ  	pÿÿÿÿ    + à       statement executed        goto yy_find_action;   	Šÿÿÿÿ  	p     	Šÿÿÿÿ  	p             v     	‹     	‹     	qÿÿÿÿ  	qÿÿÿÿ    +¡¸       statement executed        }   	‹ÿÿÿÿ  	q     	‹ÿÿÿÿ  	q             w     	Œ     	Œ   	  	rÿÿÿÿ  	rÿÿÿÿ    +£h       statement executed        break;   	Œÿÿÿÿ  	r     	Œÿÿÿÿ  	r   	          x     	“     	“     	xÿÿÿÿ  	xÿÿÿÿ    +¥0       statement executed        }   	“ÿÿÿÿ  	x     	“ÿÿÿÿ  	x             y     	”     	”     	yÿÿÿÿ  	yÿÿÿÿ    +¦P       statement executed        }   	”ÿÿÿÿ  	y     	”ÿÿÿÿ  	y             z     	§     	§   O  	Œÿÿÿÿ  	Œÿÿÿÿ    6H       statement executed        yy_fatal_error( "fatal flex scanner internal error--end of buffer missed" );   	§ÿÿÿÿ  	Œ     	§ÿÿÿÿ  	Œ   O          {     	±     	±     	•ÿÿÿÿ  	•ÿÿÿÿ    6N@       statement executed        return 1;   	±ÿÿÿÿ  	•     	±ÿÿÿÿ  	•             |     	¹     	¹     	ÿÿÿÿ  	ÿÿÿÿ    6O       statement executed        return 2;   	¹ÿÿÿÿ  	     	¹ÿÿÿÿ  	             }     	Ã     	Ã     	§ÿÿÿÿ  	§ÿÿÿÿ    „à       statement executed        *(dest++) = *(source++);   	Ãÿÿÿÿ  	§     	Ãÿÿÿÿ  	§             ~     	É     	É     	­ÿÿÿÿ  	­ÿÿÿÿ    „À       statement executed        yy_n_chars = 0;   	Éÿÿÿÿ  	­     	Éÿÿÿÿ  	­                  	â     	â   +  	Æÿÿÿÿ  	Æÿÿÿÿ    „‰0       statement executed        b->yy_buf_size += b->yy_buf_size / 8;   	âÿÿÿÿ  	Æ     	âÿÿÿÿ  	Æ   +          €     	ä     	ä     	Èÿÿÿÿ  	Èÿÿÿÿ    „‹h       statement executed        b->yy_buf_size *= 2;   	äÿÿÿÿ  	È     	äÿÿÿÿ  	È                  	ê     	ê     	Îÿÿÿÿ  	Îÿÿÿÿ    ì€ø       statement executed        }   	êÿÿÿÿ  	Î     	êÿÿÿÿ  	Î             ‚     	í     	í     	Ñÿÿÿÿ  	Ñÿÿÿÿ    ì‚À       statement executed        b->yy_ch_buf = 0;   	íÿÿÿÿ  	Ñ     	íÿÿÿÿ  	Ñ             ƒ     	ğ     	ğ   E  	Ôÿÿÿÿ  	Ôÿÿÿÿ    ì…Ğ       statement executed        yy_fatal_error( "fatal error - scanner input buffer overflow" );   	ğÿÿÿÿ  	Ô     	ğÿÿÿÿ  	Ô   E          „     	ø     	ø     	Úÿÿÿÿ  	Úÿÿÿÿ    ìŒÈ       statement executed        }   	øÿÿÿÿ  	Ú     	øÿÿÿÿ  	Ú             …     	û     	û     	İÿÿÿÿ  	İÿÿÿÿ    ìH       statement executed        num_to_read = 8192;   	ûÿÿÿÿ  	İ     	ûÿÿÿÿ  	İ             †     	ş     	ş   Î  	àÿÿÿÿ  	àÿÿÿÿ    A       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c;   	şÿÿÿÿ  	à     	şÿÿÿÿ  	à   Î          ‡     	ş   à  	ş     	àÿÿÿÿ  	àÿÿÿÿ    *y       statement executed        (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c;   	şÿÿÿÿ  	à   à  	şÿÿÿÿ  	à             ˆ     	ş  D  	ş  u  	àÿÿÿÿ  	àÿÿÿÿ    *€p       statement executed        yy_fatal_error( "input in flex scanner failed" );   	şÿÿÿÿ  	à  D  	şÿÿÿÿ  	à  u          ‰     	ş  †  	ş  ‡  	àÿÿÿÿ  	àÿÿÿÿ    *ƒ       statement executed        }   	şÿÿÿÿ  	à  †  	şÿÿÿÿ  	à  ‡          Š     	ş    	ş  <  	àÿÿÿÿ  	àÿÿÿÿ    *Š°       statement executed        yy_fatal_error( "input in flex scanner failed" );   	şÿÿÿÿ  	à    	şÿÿÿÿ  	à  <          ‹     
     
     	éÿÿÿÿ  	éÿÿÿÿ    09¨       statement executed        }   
ÿÿÿÿ  	é     
ÿÿÿÿ  	é             Œ     
     
     	ğÿÿÿÿ  	ğÿÿÿÿ    0=       statement executed        }   
ÿÿÿÿ  	ğ     
ÿÿÿÿ  	ğ                  
     
     	ôÿÿÿÿ  	ôÿÿÿÿ    0?è       statement executed        ret_val = 0;   
ÿÿÿÿ  	ô     
ÿÿÿÿ  	ô                  
     
     	üÿÿÿÿ  	üÿÿÿÿ    0FØ       statement executed        return ret_val;   
ÿÿÿÿ  	ü     
ÿÿÿÿ  	ü                  
/     
/     
ÿÿÿÿ  
ÿÿÿÿ     5³`       statement executed        }   
/ÿÿÿÿ  
     
/ÿÿÿÿ  
                  
4     
4   )  
ÿÿÿÿ  
ÿÿÿÿ     5»H       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   
4ÿÿÿÿ  
     
4ÿÿÿÿ  
   )          ‘     
5     
5     
ÿÿÿÿ  
ÿÿÿÿ     5½       statement executed        }   
5ÿÿÿÿ  
     
5ÿÿÿÿ  
             ’     
7     
7     
ÿÿÿÿ  
ÿÿÿÿ     5À0       statement executed        }   
7ÿÿÿÿ  
     
7ÿÿÿÿ  
             “     
9     
9     
ÿÿÿÿ  
ÿÿÿÿ     5Áà       statement executed        return yy_current_state;   
9ÿÿÿÿ  
     
9ÿÿÿÿ  
             ”     
R     
R     
2ÿÿÿÿ  
2ÿÿÿÿ     5ÊØ       statement executed        }   
Rÿÿÿÿ  
2     
Rÿÿÿÿ  
2             •     
W     
W   (  
7ÿÿÿÿ  
7ÿÿÿÿ     ù ¸       statement executed        yy_c = yy_meta[(unsigned int) yy_c];   
Wÿÿÿÿ  
7     
Wÿÿÿÿ  
7   (          –     
X     
X     
8ÿÿÿÿ  
8ÿÿÿÿ     ùx       statement executed        }   
Xÿÿÿÿ  
8     
Xÿÿÿÿ  
8             —     
\     
\   *  
<ÿÿÿÿ  
<ÿÿÿÿ     ùÈ       statement executed        return yy_is_jam ? 0 : yy_current_state;   
\ÿÿÿÿ  
<     
\ÿÿÿÿ  
<   *          ˜     
x     
x     
Wÿÿÿÿ  
Wÿÿÿÿ     ù(       statement executed        *--dest = *--source;   
xÿÿÿÿ  
W     
xÿÿÿÿ  
W             ™     
     
   8  
^ÿÿÿÿ  
^ÿÿÿÿ     ù(       statement executed        yy_fatal_error( "flex scanner push-back overflow" );   
ÿÿÿÿ  
^     
ÿÿÿÿ  
^   8          š     
€     
€     
_ÿÿÿÿ  
_ÿÿÿÿ     í7        statement executed        }   
€ÿÿÿÿ  
_     
€ÿÿÿÿ  
_             ›     
ˆ     
ˆ     
gÿÿÿÿ  
gÿÿÿÿ     í>à       statement executed        }   
ˆÿÿÿÿ  
g     
ˆÿÿÿÿ  
g             œ     
     
     
{ÿÿÿÿ  
{ÿÿÿÿ     íDˆ       statement executed        *yy_c_buf_p = '\0';   
ÿÿÿÿ  
{     
ÿÿÿÿ  
{                  
­     
­     
Šÿÿÿÿ  
Šÿÿÿÿ     íJ@       statement executed        return (-1);   
­ÿÿÿÿ  
Š     
­ÿÿÿÿ  
Š                  
±     
±     
ÿÿÿÿ  
ÿÿÿÿ     íM(       statement executed        yyrestart( yyin );   
±ÿÿÿÿ  
     
±ÿÿÿÿ  
             Ÿ     
³     
³     
ÿÿÿÿ  
ÿÿÿÿ     íNè       statement executed        return yyinput();   
³ÿÿÿÿ  
     
³ÿÿÿÿ  
                   
»     
»     
—ÿÿÿÿ  
—ÿÿÿÿ     íQğ       statement executed        break;   
»ÿÿÿÿ  
—     
»ÿÿÿÿ  
—             ¡     
Æ     
Æ     
 ÿÿÿÿ  
 ÿÿÿÿ     íS        statement executed        }   
Æÿÿÿÿ  
      
Æÿÿÿÿ  
              ¢     
Î     
Î     
¨ÿÿÿÿ  
¨ÿÿÿÿ     íXĞ       statement executed        return c;   
Îÿÿÿÿ  
¨     
Îÿÿÿÿ  
¨             £     
Ú     
Ú   7  
³ÿÿÿÿ  
³ÿÿÿÿ     í\È       statement executed        yy_current_buffer = yy_create_buffer( yyin, 16384 );   
Úÿÿÿÿ  
³     
Úÿÿÿÿ  
³   7          ¤     
Ş     
Ş     
·ÿÿÿÿ  
·ÿÿÿÿ     í_        statement executed        }   
Şÿÿÿÿ  
·     
Şÿÿÿÿ  
·             ¥     
é     
é   
  
Áÿÿÿÿ  
Áÿÿÿÿ    SÍ       statement executed        return;   
éÿÿÿÿ  
Á     
éÿÿÿÿ  
Á   
          ¦     
ñ     
ñ     
Éÿÿÿÿ  
Éÿÿÿÿ    SÓ¨       statement executed        }   
ñÿÿÿÿ  
É     
ñÿÿÿÿ  
É             §     
ü     
ü     
Ôÿÿÿÿ  
Ôÿÿÿÿ    SØ       statement executed        }   
üÿÿÿÿ  
Ô     
üÿÿÿÿ  
Ô             ¨     	     	     
àÿÿÿÿ  
àÿÿÿÿ    Sß8       statement executed        }   	ÿÿÿÿ  
à     	ÿÿÿÿ  
à             ©             C  
îÿÿÿÿ  
îÿÿÿÿ    Såp       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   ÿÿÿÿ  
î     ÿÿÿÿ  
î   C          ª     !     !   C  
÷ÿÿÿÿ  
÷ÿÿÿÿ    Sì¸       statement executed        yy_fatal_error( "out of dynamic memory in yy_create_buffer()" );   !ÿÿÿÿ  
÷     !ÿÿÿÿ  
÷   C          «     '     '     
ıÿÿÿÿ  
ıÿÿÿÿ    Sğ(       statement executed        return b;   'ÿÿÿÿ  
ı     'ÿÿÿÿ  
ı             ¬     3     3   
  ÿÿÿÿ  ÿÿÿÿ    Sóˆ       statement executed        return;   3ÿÿÿÿ       3ÿÿÿÿ     
          ­     6     6   +  ÿÿÿÿ  ÿÿÿÿ    SøÀ       statement executed        yy_current_buffer = (YY_BUFFER_STATE) 0;   6ÿÿÿÿ       6ÿÿÿÿ     +          ®     9     9   )  ÿÿÿÿ  ÿÿÿÿ    |@       statement executed        yy_flex_free( (void *) b->yy_ch_buf );   9ÿÿÿÿ       9ÿÿÿÿ     )          ¯     <     <     ÿÿÿÿ  ÿÿÿÿ    |8       statement executed        }   <ÿÿÿÿ       <ÿÿÿÿ               °     ]     ]     -ÿÿÿÿ  -ÿÿÿÿ    |p       statement executed        }   ]ÿÿÿÿ  -     ]ÿÿÿÿ  -             ±     w     w     Fÿÿÿÿ  Fÿÿÿÿ    |"Ğ       statement executed        yy_load_buffer_state();   wÿÿÿÿ  F     wÿÿÿÿ  F             ²     x     x     Gÿÿÿÿ  Gÿÿÿÿ    |$       statement executed        }   xÿÿÿÿ  G     xÿÿÿÿ  G             ³     Š     Š     Xÿÿÿÿ  Xÿÿÿÿ    |.ğ       statement executed        return 0;   Šÿÿÿÿ  X     Šÿÿÿÿ  X             ´             A  \ÿÿÿÿ  \ÿÿÿÿ    |4H       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_buffer()" );   ÿÿÿÿ  \     ÿÿÿÿ  \   A          µ     œ     œ     jÿÿÿÿ  jÿÿÿÿ     û>       statement executed        return b;   œÿÿÿÿ  j     œÿÿÿÿ  j             ¶     «     «     wÿÿÿÿ  wÿÿÿÿ     ûA`       statement executed        ;   «ÿÿÿÿ  w     «ÿÿÿÿ  w             ·     ­     ­   #  yÿÿÿÿ  yÿÿÿÿ     ûB€       statement executed        return yy_scan_bytes( str, len );   ­ÿÿÿÿ  y     ­ÿÿÿÿ  y   #          ¸     Ä     Ä   @  ÿÿÿÿ  ÿÿÿÿ     ûLh       statement executed        yy_fatal_error( "out of dynamic memory in yy_scan_bytes()" );   Äÿÿÿÿ       Äÿÿÿÿ     @          ¹     Ç     Ç     ‘ÿÿÿÿ  ‘ÿÿÿÿ     ûOÀ       statement executed        buf[i] = bytes[i];   Çÿÿÿÿ  ‘     Çÿÿÿÿ  ‘             º     Í     Í   5  —ÿÿÿÿ  —ÿÿÿÿ     ûUˆ       statement executed        yy_fatal_error( "bad buffer in yy_scan_bytes()" );   Íÿÿÿÿ  —     Íÿÿÿÿ  —   5          »     Ô     Ô     ÿÿÿÿ  ÿÿÿÿ     ûX°       statement executed        return b;   Ôÿÿÿÿ       Ôÿÿÿÿ               ¼     é     é   7  ±ÿÿÿÿ  ±ÿÿÿÿ     ûbÀ       statement executed        yy_start_stack = (int *) yy_flex_alloc( new_size );   éÿÿÿÿ  ±     éÿÿÿÿ  ±   7          ½     ì     í   *  ´ÿÿÿÿ  µÿÿÿÿ     ûeà       statement executed        yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );   ìÿÿÿÿ  ´     íÿÿÿÿ  µ   *          ¾     ğ     ğ   F  ¸ÿÿÿÿ  ¸ÿÿÿÿ     ûi       statement executed        yy_fatal_error( "out of memory expanding start-condition stack" );   ğÿÿÿÿ  ¸     ğÿÿÿÿ  ¸   F          ¿     ò     ò     ¹ÿÿÿÿ  ¹ÿÿÿÿ     ûk       statement executed        }   òÿÿÿÿ  ¹     òÿÿÿÿ  ¹             À     ÷     ÷     ¾ÿÿÿÿ  ¾ÿÿÿÿ    >ë@       statement executed        }   ÷ÿÿÿÿ  ¾     ÷ÿÿÿÿ  ¾             Á     ÿ     ÿ   7  Åÿÿÿÿ  Åÿÿÿÿ    >î       statement executed        yy_fatal_error( "start-condition stack underflow" );   ÿÿÿÿÿ  Å     ÿÿÿÿÿ  Å   7          Â               Èÿÿÿÿ  Èÿÿÿÿ    >ñ0       statement executed        }   ÿÿÿÿ  È     ÿÿÿÿ  È             Ã     	     	   0  Îÿÿÿÿ  Îÿÿÿÿ    >óÈ       statement executed        return yy_start_stack[yy_start_stack_ptr - 1];   	ÿÿÿÿ  Î     	ÿÿÿÿ  Î   0          Ä               Ûÿÿÿÿ  Ûÿÿÿÿ    >õø       statement executed        exit( 2 );   ÿÿÿÿ  Û     ÿÿÿÿ  Û             Å     H     H   !  	ÿÿÿÿ  	ÿÿÿÿ    >÷è       statement executed        return (void *) malloc( size );   Hÿÿÿÿ  	     Hÿÿÿÿ  	   !          Æ     Z     Z   0  ÿÿÿÿ  ÿÿÿÿ    >ùØ       statement executed        return (void *) realloc( (char *) ptr, size );   Zÿÿÿÿ       Zÿÿÿÿ     0          Ç     e     e     $ÿÿÿÿ  $ÿÿÿÿ    >ü       statement executed        }   eÿÿÿÿ  $     eÿÿÿÿ  $             È     q     q   
  /ÿÿÿÿ  /ÿÿÿÿ    >ş       statement executed        return 1;   qÿÿÿÿ  /     qÿÿÿÿ  /   
        CAboutDlg::CAboutDlg CAboutDlg::CAboutDlg()    ;      ?      7ÿÿÿÿ   ;ÿÿÿÿCAboutDlg::DoDataExchange void CAboutDlg::DoDataExchange(CDataExchange* pDX)    B      F      >ÿÿÿÿ   BÿÿÿÿCAboutDlg::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CAboutDlg::_GetBaseMessageMap()    H   =   H   ]   Dÿÿÿÿ   DÿÿÿÿCAboutDlg::GetMessageMap const AFX_MSGMAP* CAboutDlg::GetMessageMap()    H   ‘   H   ³   Dÿÿÿÿ   DÿÿÿÿCCAPL2CPropertyPage::CCAPL2CPropertyPage CCAPL2CPropertyPage::CCAPL2CPropertyPage(CWnd* pParent )    R      Y      Nÿÿÿÿ   UÿÿÿÿCCAPL2CPropertyPage::DoDataExchange void CCAPL2CPropertyPage::DoDataExchange(CDataExchange* pDX)    \      b      Xÿÿÿÿ   ^ÿÿÿÿCCAPL2CPropertyPage::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CCAPL2CPropertyPage::_GetBaseMessageMap()    d   G   d   m   `ÿÿÿÿ   `ÿÿÿÿCCAPL2CPropertyPage::GetMessageMap const AFX_MSGMAP* CCAPL2CPropertyPage::GetMessageMap()    d   «   d   ×   `ÿÿÿÿ   `ÿÿÿÿCCAPL2CPropertyPage::OnInitDialog BOOL CCAPL2CPropertyPage::OnInitDialog()    z      ”      vÿÿÿÿ   ÿÿÿÿCCAPL2CPropertyPage::OnSysCommand void CCAPL2CPropertyPage::OnSysCommand(UINT nID, LPARAM lParam)    —      ¡      “ÿÿÿÿ   ÿÿÿÿCCAPL2CPropertyPage::OnPaint void CCAPL2CPropertyPage::OnPaint()    ¨      »      ¤ÿÿÿÿ   ·ÿÿÿÿCCAPL2CPropertyPage::OnQueryDragIcon HCURSOR CCAPL2CPropertyPage::OnQueryDragIcon()    À      Â      ¼ÿÿÿÿ   ¾ÿÿÿÿList::OnInitDialog BOOL List::OnInitDialog()    Ò     
      Îÿÿÿÿ  ÿÿÿÿList::OnAdd void List::OnAdd()        6     ÿÿÿÿ  2ÿÿÿÿList::OnRemove void List::OnRemove()   E     _     Aÿÿÿÿ  [ÿÿÿÿList::OnTerminate void List::OnTerminate()   o     ¢     kÿÿÿÿ  ÿÿÿÿCCAPL2CPropertyPage::OnBrowseSource void CCAPL2CPropertyPage::OnBrowseSource()   ²     Í     ®ÿÿÿÿ  ÉÿÿÿÿCCAPL2CPropertyPage::OnBrowseDest void CCAPL2CPropertyPage::OnBrowseDest()   Û     ö     ×ÿÿÿÿ  òÿÿÿÿCCAPL2CPropertyPage::OnShowLog void CCAPL2CPropertyPage::OnShowLog()             ÿÿÿÿÿ  ÿÿÿÿCCAPL2CPropertyPage::OnCancel void CCAPL2CPropertyPage::OnCancel()             ÿÿÿÿ  	ÿÿÿÿCCAPL2CPropertyPage::OnChangeEditInput void CCAPL2CPropertyPage::OnChangeEditInput()             ÿÿÿÿ  ÿÿÿÿCCAPL2CPropertyPage::OnChkbOptn void CCAPL2CPropertyPage::OnChkbOptn()   !     8     ÿÿÿÿ  4ÿÿÿÿCCAPL2CPropertyPage::OnBrowseCANoeDb void CCAPL2CPropertyPage::OnBrowseCANoeDb()   G     \     Cÿÿÿÿ  XÿÿÿÿCCAPL2CPropertyPage::OnBrowseBUSMASTERDb void CCAPL2CPropertyPage::OnBrowseBUSMASTERDb()   l          hÿÿÿÿ  }ÿÿÿÿCCAPL2CPropertyPage::OnChkbSavedb void CCAPL2CPropertyPage::OnChkbSavedb()   „     ”     €ÿÿÿÿ  ÿÿÿÿCCAPL2CPropertyPage::SaveSettings void CCAPL2CPropertyPage::SaveSettings()   —           “ÿÿÿÿ  œÿÿÿÿList::OnCancel void List::OnCancel()   £     ¥     Ÿÿÿÿÿ  ¡ÿÿÿÿList::OnClose void List::OnClose()   ¨     «     ¤ÿÿÿÿ  §ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿvKeyStoreHeader void vKeyStoreHeader()    .      _      )ÿÿÿÿ   ZÿÿÿÿvEnvVar void vEnvVar()    f      |      aÿÿÿÿ   wÿÿÿÿvCaplFunc void vCaplFunc()    ƒ      ™      ~ÿÿÿÿ   ”ÿÿÿÿvKeyStoreCase void vKeyStoreCase()    ¤      Ò      Ÿÿÿÿÿ   ÍÿÿÿÿvHeader void vHeader()    Ø           Óÿÿÿÿ  ÿÿÿÿvDelete void vDelete()         7     ÿÿÿÿ  2ÿÿÿÿvEndBody void vEndBody()   ?     ]     :ÿÿÿÿ  XÿÿÿÿvTimerFunc void vTimerFunc()   e          `ÿÿÿÿ  ˆÿÿÿÿvCnvrtByte void vCnvrtByte()   “     Ê     ÿÿÿÿ  ÅÿÿÿÿvPutKeyCase void vPutKeyCase()   Õ          Ğÿÿÿÿ  ÿÿÿÿvWrite void vWrite()        B     ÿÿÿÿ  =ÿÿÿÿvMsgID void vMsgID()   I     {     Dÿÿÿÿ  vÿÿÿÿvWriteDot void vWriteDot()        ›     |ÿÿÿÿ  –ÿÿÿÿvRemovePhys void vRemovePhys()        ³     ™ÿÿÿÿ  ®ÿÿÿÿvCnvrtThis void vCnvrtThis()   ¹     Ï     ´ÿÿÿÿ  ÊÿÿÿÿvWriteTerminator void vWriteTerminator()   Õ          Ğÿÿÿÿ  ÿÿÿÿvSetTimer void vSetTimer()        R     ÿÿÿÿ  MÿÿÿÿvOutput void vOutput()   Y     o     Tÿÿÿÿ  jÿÿÿÿvCancelTimer void vCancelTimer()   u     ‰     pÿÿÿÿ  „ÿÿÿÿvOnLine void vOnLine()        ‘     Šÿÿÿÿ  ŒÿÿÿÿvOffLine void vOffLine()   —     ™     ’ÿÿÿÿ  ”ÿÿÿÿvTrigger void vTrigger()   Ÿ     ¡     šÿÿÿÿ  œÿÿÿÿvResetCan void vResetCan()   §     ©     ¢ÿÿÿÿ  ¤ÿÿÿÿvDisconnect void vDisconnect()   ¯     ±     ªÿÿÿÿ  ¬ÿÿÿÿvUnSptdFunc void vUnSptdFunc()   ¸     ¾     ³ÿÿÿÿ  ¹ÿÿÿÿvFuncCall void vFuncCall()   Æ     à     Áÿÿÿÿ  ÛÿÿÿÿvAddLine void vAddLine()   æ     ê     áÿÿÿÿ  åÿÿÿÿvFooter void vFooter()   ğ          ëÿÿÿÿ  ıÿÿÿÿnConvert int nConvert( CString srs,CString dest ,CString dest1)        A     	ÿÿÿÿ  <ÿÿÿÿCSelectdb::OnBrowseBUSMASTERDb void CSelectdb::OnBrowseBUSMASTERDb()   H     c     Cÿÿÿÿ  ^ÿÿÿÿCSelectdb::OnBrowseCANoeDb void CSelectdb::OnBrowseCANoeDb()   j     …     eÿÿÿÿ  €ÿÿÿÿCSelectdb::OnChkbOption void CSelectdb::OnChkbOption()   Œ          ‡ÿÿÿÿ  ™ÿÿÿÿCSelectdb::OnOK void CSelectdb::OnOK()   ¥     î      ÿÿÿÿ  éÿÿÿÿCCAPL2CPropertyPage::OnConvert void CCAPL2CPropertyPage::OnConvert()   ú     «     õÿÿÿÿ  ¦ÿÿÿÿCSelectdb::OnChangeEditAdcanoe void CSelectdb::OnChangeEditAdcanoe()   ³     ¿     ®ÿÿÿÿ  ºÿÿÿÿCSelectdb::OnCancel void CSelectdb::OnCancel()   Â     Å     ½ÿÿÿÿ  ÀÿÿÿÿvMsgDecl void vMsgDecl()   Ñ     ?     Ìÿÿÿÿ  :ÿÿÿÿvMsgCpy void vMsgCpy()   G     W     Bÿÿÿÿ  RÿÿÿÿvelCount void velCount()   ]     k     Xÿÿÿÿ  fÿÿÿÿCSelectdb::OnClose void CSelectdb::OnClose()   n     q     iÿÿÿÿ  lÿÿÿÿvUtilFunc void vUtilFunc()   x          sÿÿÿÿ  ˜ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿyylex int yylex ( void )   Ô     	”     ºÿÿÿÿ  	yÿÿÿÿyy_get_next_buffer static int yy_get_next_buffer()   	      
     	…ÿÿÿÿ  	ıÿÿÿÿyy_get_previous_state static yy_state_type yy_get_previous_state()   
"     
:     
ÿÿÿÿ  
ÿÿÿÿyy_try_NUL_trans static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )   
I     
]     
)ÿÿÿÿ  
=ÿÿÿÿyyunput static void yyunput( int c, register char *yy_bp )   
h     
ˆ     
Gÿÿÿÿ  
gÿÿÿÿyyinput static int yyinput()   
‘     
Ï     
nÿÿÿÿ  
©ÿÿÿÿyyrestart void yyrestart( FILE *input_file )   
Ø     
Ş     
±ÿÿÿÿ  
·ÿÿÿÿyy_switch_to_buffer void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )   
ç     
ü     
¿ÿÿÿÿ  
Ôÿÿÿÿyy_load_buffer_state void yy_load_buffer_state( void )        	     
Ûÿÿÿÿ  
àÿÿÿÿyy_create_buffer YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )        (     
éÿÿÿÿ  
şÿÿÿÿyy_delete_buffer void yy_delete_buffer( YY_BUFFER_STATE b )   1     <     ÿÿÿÿ  ÿÿÿÿyy_init_buffer void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )   N     ]     !ÿÿÿÿ  -ÿÿÿÿyy_flush_buffer void yy_flush_buffer( YY_BUFFER_STATE b )   g     x     6ÿÿÿÿ  Gÿÿÿÿyy_scan_buffer YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )   ƒ          Qÿÿÿÿ  kÿÿÿÿyy_scan_string YY_BUFFER_STATE yy_scan_string( const char *str )   ¨     ®     tÿÿÿÿ  zÿÿÿÿyy_scan_bytes YY_BUFFER_STATE yy_scan_bytes( const char *bytes, int len )   º     Õ     „ÿÿÿÿ  Ÿÿÿÿÿyy_push_state static void yy_push_state( int new_state )   à     ÷     ¨ÿÿÿÿ  ¾ÿÿÿÿyy_pop_state static void yy_pop_state()   ı          Ãÿÿÿÿ  Èÿÿÿÿyy_top_state static int yy_top_state()        
     Íÿÿÿÿ  Ïÿÿÿÿyy_fatal_error static void yy_fatal_error( const char msg[] )             Ùÿÿÿÿ  Üÿÿÿÿyy_flex_alloc static void *yy_flex_alloc( yy_size_t size )   G     I     ÿÿÿÿ  
ÿÿÿÿyy_flex_realloc static void *yy_flex_realloc( void *ptr, yy_size_t size )   R     [     ÿÿÿÿ  ÿÿÿÿyy_flex_free static void yy_flex_free( void *ptr )   c     e     "ÿÿÿÿ  $ÿÿÿÿyywrap int yywrap()   p     r     .ÿÿÿÿ  0ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ConverterDlg.cpp
 * \brief     Implementation file for CCAPL2CPropertyPage class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CCAPL2CPropertyPage class
 */

/* C include */
#include <stdlib.h>

/* Project includes */
#include "CAPL2CPropertyPage.h"
#include "ConstString.h"
#include "Functions.hpp"
#include "List.h"

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    // Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
    //  m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCAPL2CPropertyPage dialog

CCAPL2CPropertyPage::CCAPL2CPropertyPage(CWnd* pParent /*=NULL*/)
    : CPropertyPage(CCAPL2CPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CCAPL2CPropertyPage)
    m_check = FALSE;
    m_savedb = FALSE;
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CCAPL2CPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCAPL2CPropertyPage)
    DDX_Check(pDX, IDC_CHKB_OPTN, m_check);
    DDX_Check(pDX, IDC_CHKB_SAVEDB, m_savedb);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCAPL2CPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CCAPL2CPropertyPage)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_CBTN_BINPUT, OnBrowseSource)
    ON_BN_CLICKED(IDC_CBTN_BOUTPUT, OnBrowseDest)
    ON_BN_CLICKED(IDC_CBTN_LOG, OnShowLog)
    ON_BN_CLICKED(IDC_CBTN_CNVRT, OnConvert)
    ON_EN_CHANGE(IDC_EDIT_INPUT, OnChangeEditInput)
    ON_BN_CLICKED(IDC_CHKB_OPTN, OnChkbOptn)
    ON_BN_CLICKED(IDC_CBTN_BCANOEDB, OnBrowseCANoeDb)
    ON_BN_CLICKED(IDC_CBTN_BBUSMASTERDB, OnBrowseBUSMASTERDb)
    ON_BN_CLICKED(IDC_CBTN_CANCEL, OnCancel)
    ON_BN_CLICKED(IDC_CHKB_SAVEDB, OnChkbSavedb)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCAPL2CPropertyPage message handlers

BOOL CCAPL2CPropertyPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    // Add "About..." menu item to system menu.
    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);
    CMenu* pSysMenu = GetSystemMenu(FALSE);

    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);

        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon
    // TODO: Add extra initialization here
    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CCAPL2CPropertyPage::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CPropertyPage::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CCAPL2CPropertyPage::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting
        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;
        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CPropertyPage::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CCAPL2CPropertyPage::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

/*******************************************************************************
 Function Name    : OnInitDialog
 Input(s)         :     -
 Output           :     -
 Functionality    : This will populate the first list box with unsupported
                    keys and environment handlers and the second list box
                    with available keys.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 22.04.2004
 Modifications    :
*******************************************************************************/
BOOL List::OnInitDialog()
{
    try
    {
        int Flag = 0;
        int m = 0;
        char allkey[]= {'a','b','c','d','e','f','g','h','i','j','k','l','m','n',
                        'o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E',
                        'F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
                        'W','X','Y','Z','0','1','2','3','4','5','6','7','8','9',0
                       };
        CDialog::OnInitDialog();

        for(m = 0; m < ouUnSptdKey.nGetSize(); m++)
        {
            m_UnSupKeys.AddString( ouUnSptdKey.omGetAt(m) );
        }

        for( m = 0; m < defINT_SizeofacAltKeyArray ; m++ )
        {
            Flag = 0;

            for( int p = 0; p <= cIndex2-1; p++)
            {
                if(allkey[m] == acSptdKey[p])
                {
                    Flag = 1;
                    break;
                }
            }

            if( Flag == 0)
            {
                m_AltKeys.AddString( CString( allkey[m] ) );
            }
        }

        m_UnSupKeys.SetCurSel(0);
        m_AltKeys.SetCurSel(0);

        if( m_AltKeys.GetCount() == 0)
        {
            //if no key is available
            GetDlgItem( IDC_CBTN_ADD )->EnableWindow(FALSE);
            ShowWindow(SW_SHOW);
            MessageBox("No Key is avilable",NULL,MB_OK);
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"OnInitDialog\"",__FILE__,__LINE__);
        MessageBox(cs);
        exit(0);
    }

    return TRUE;
}
/*******************************************************************************
 Function Name    : OnAdd
 Input(s)         :     -
 Output           :     -
 Functionality    : This will take selected element from first two list and add
                    it to the third one.The element selected from the second
                    list will be added to acAltKey array at the place where the
                    first list element is stored in acUnSptdKey array.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 23.04.2004
 Modifications    :
*******************************************************************************/
void List::OnAdd()
{
    int m = 0;
    CString uns,alt,uns1;
    m = m_UnSupKeys.GetCurSel();
    m_UnSupKeys.GetText( m,uns );//store selected element from first list
    m_UnSupKeys.GetText( m,uns1 );
    m_UnSupKeys.DeleteString( m );//delete it
    m = m_AltKeys.GetCurSel();
    m_AltKeys.GetText( m,alt );//store selected element from second list
    m_AltKeys.DeleteString( m );
    uns = uns+" --->  ";
    uns = uns + alt;
    m_EquiKeys.AddString( uns );//add both to third list
    acAltKey[ouUnSptdKey.nFind(uns1)] = alt[0];//add the key to acAltKeylist
    m_UnSupKeys.SetCurSel(0);//set first item selected
    m_AltKeys.SetCurSel(0);
    m_EquiKeys.SetCurSel(0);

    if(m_UnSupKeys.GetCount() == 0 || m_AltKeys.GetCount() == 0 )
    {
        GetDlgItem( IDC_CBTN_ADD )->EnableWindow(FALSE);
    }
    else
    {
        GetDlgItem( IDC_CBTN_ADD )->EnableWindow(TRUE);
    }

    GetDlgItem( IDC_CBTN_RMV )->EnableWindow(TRUE);
}
/*******************************************************************************
 Function Name    : OnRemove
 Input(s)         :     -
 Output           :     -
 Functionality    : This will will remove the selected item from the third list
                    and will put the first element in the first list and second
                    element in the second list.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 23.04.2004
 Modifications    :
*******************************************************************************/
void List::OnRemove()
{
    CString ekey;

    if((m = m_EquiKeys.GetCurSel()) != LB_ERR)
    {
        GetDlgItem( IDC_CBTN_ADD )->EnableWindow(TRUE);
        m_EquiKeys.GetText( m,ekey );
        int k = ekey.Find(' ',0);

        if( k != -1)
        {
            m_UnSupKeys.AddString(ekey.Left(k));
            m_AltKeys.AddString(ekey.Right(1));
        }

        acAltKey [ ouUnSptdKey.nFind( ekey.Left( k)) ] = -1;
        m_EquiKeys.DeleteString(m);
        m_UnSupKeys.SetCurSel(0);
        m_AltKeys.SetCurSel(0);
        m_EquiKeys.SetCurSel(0);
    }

    if(m_EquiKeys.GetCount()==0)
    {
        GetDlgItem(IDC_CBTN_RMV)->EnableWindow(FALSE);
    }
}
/*******************************************************************************
 Function Name    : OnTerminate
 Input(s)         :     -
 Output           :     -
 Functionality    : This will take first item from list one and first item from
                    list two to make the default selection of available keys for
                    the unsupported keys.This will write the user intervention
                    for the alternate keys in the log file also.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 27.04.2004
 Modifications    :
*******************************************************************************/
void List::OnTerminate()
{
    CString buffer;
    CString uns,alt,uns1;

    if(m_UnSupKeys.GetCount()>0)
    {
        if ( m_AltKeys.GetCount() > 0 )
        {
            MessageBox(defSTR_Warning6,MB_OK);
        }

        while(m_UnSupKeys.GetCount()!=0)
        {
            if(m_AltKeys.GetCount()>0)
            {
                m_UnSupKeys.GetText(0,uns);
                m_UnSupKeys.GetText(0,uns1);
                m_UnSupKeys.DeleteString(0);
                m_AltKeys.GetText(0,alt);
                m_AltKeys.DeleteString(0);
                uns = uns+" --->  ";
                uns = uns + alt;
                m_EquiKeys.AddString(uns);
                acAltKey[ ouUnSptdKey.nFind(uns1) ] = alt[0];
            }
            else
            {
                m_UnSupKeys.DeleteString(0);
            }
        }
    }

    if( m_EquiKeys.GetCount() > 0 )
    {
        fprintf(logfile,"---***********************************---");
        fprintf(logfile,"\n---*****List Of User Intervention*****---");
        fprintf(logfile,"\n---***********************************---");
        fprintf(logfile,"\n Unsupported Key -->Equivalent Key");
        fprintf(logfile,"\n ---------------    ---------------\n");
    }

    for(int m = 0; m <= m_EquiKeys.GetCount()-1; m++ )
    {
        m_EquiKeys.GetText( m,buffer );
        fprintf(logfile,"\t%s\n",buffer);
    }

    m_UnSupKeys.ResetContent();
    m_EquiKeys.ResetContent();
    m_AltKeys.ResetContent();
    List::OnOK();
}

/*******************************************************************************
 Function Name    : OnBrowseSource
 Input(s)         :     -
 Output           :     -
 Functionality    : This will pop-up a comman dialog box to select the input
                    CAN file.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 27.04.2004
 Modifications    :
*******************************************************************************/

void CCAPL2CPropertyPage::OnBrowseSource()
{
    CString omStrPath;
    int nIndex = -1;
    CFileDialog cfd(TRUE,"can",NULL,OFN_OVERWRITEPROMPT|OFN_FILEMUSTEXIST|
                    OFN_PATHMUSTEXIST,"CAN Files(*.can)|*.can||",this);
    cfd.m_ofn.lpstrTitle = "Select CAN File";
    GetDlgItemText( IDC_EDIT_INPUT,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileString("Files","CAPL file","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==IDOK)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemText(IDC_EDIT_INPUT, omStrPath );
    }
}
/*******************************************************************************
 Function Name    : OnBrowseDest
 Input(s)         :     -
 Output           :     -
 Functionality    : This will pop-up a comman dialog box to select the output
                    file.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 27.04.2004
 Modifications    :
*******************************************************************************/
void CCAPL2CPropertyPage::OnBrowseDest()
{
    CFileDialog cfd(TRUE,"c",NULL,OFN_OVERWRITEPROMPT|
                    OFN_HIDEREADONLY,"BUSMASTER  Files(*.c)|*.c||",this);
    cfd.m_ofn.lpstrTitle = "Select BUSMASTER File";
    CString omStrPath;
    int nIndex;
    GetDlgItemText( IDC_EDIT_OUTPUT,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileString("Files","CAPL file","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==IDOK)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemText(IDC_EDIT_OUTPUT,omStrPath);
    }
}
/*******************************************************************************
 Function Name    : OnShowLog
 Input(s)         :     -
 Output           :     -
 Functionality    : This will show the log file of latest converted CAN file.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 27.04.2004
 Modifications    :
*******************************************************************************/
void CCAPL2CPropertyPage::OnShowLog()
{
    CString cs ;
    cs = getenv("windir");
    cs = cs + "\\notepad.exe " + dest1;
    WinExec(cs,SW_SHOW);
}

void CCAPL2CPropertyPage::OnCancel()
{
    CPropertyPage::OnCancel();
}

void CCAPL2CPropertyPage::OnChangeEditInput()
{
    //It will check whether the input edit box is blank or not.If nothing is
    //there "Convert" button will be disabled otherwise enabled.
    CString omStrPath;
    GetDlgItemText( IDC_EDIT_INPUT,omStrPath );

    if( omStrPath.GetLength() > 0 )
    {
        GetDlgItem( IDC_CBTN_CNVRT )->EnableWindow(TRUE);
    }
    else
    {
        GetDlgItem( IDC_CBTN_CNVRT )->EnableWindow(FALSE);
    }
}

void CCAPL2CPropertyPage::OnChkbOptn()
{
    //this will activate if check box is checked
    UpdateData();

    if( m_check )
    {
        cFlagH = 1;
        GetDlgItem( IDC_EDIT_CANOEDB )->EnableWindow(TRUE);
        GetDlgItem( IDC_CBTN_BCANOEDB )->EnableWindow(TRUE);
        GetDlgItem( IDC_CHKB_SAVEDB )->EnableWindow(TRUE);
    }
    else
    {
        cFlagH = 0;
        SetDlgItemText(IDC_EDIT_CANOEDB," " );
        SetDlgItemText(IDC_EDIT_BUSMASTERDB," " );
        //m_savedb = FALSE;
        GetDlgItem( IDC_EDIT_CANOEDB )->EnableWindow(FALSE);
        GetDlgItem( IDC_CBTN_BCANOEDB )->EnableWindow(FALSE);
        GetDlgItem( IDC_CHKB_SAVEDB )->EnableWindow(FALSE);
        GetDlgItem( IDC_EDIT_BUSMASTERDB )->EnableWindow(FALSE);
        GetDlgItem( IDC_CBTN_BBUSMASTERDB )->EnableWindow(FALSE);
    }
}

/*******************************************************************************
 Function Name    : OnBrowseCANoeDb
 Input(s)         :     -
 Output           :     -
 Functionality    : This will pop-up a comman dialog box to select the input
                    CANoe database file.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 15.05.2004
 Modifications    :
*******************************************************************************/
void CCAPL2CPropertyPage::OnBrowseCANoeDb()
{
    CString omStrPath;
    CFileDialog cfd(TRUE,"dbc",NULL,OFN_OVERWRITEPROMPT|OFN_FILEMUSTEXIST|
                    OFN_PATHMUSTEXIST,"CANoe Database Files(*.dbc)|*.dbc||",this);
    cfd.m_ofn.lpstrTitle = "Select CANoe Database File";
    GetDlgItemText( IDC_EDIT_CANOEDB,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if( omStrPath.Find(".dbc",0) != -1)
    {
        omStrPath = omStrPath.Left( omStrPath.GetLength() - 4);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==IDOK)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemText(IDC_EDIT_CANOEDB, omStrPath );
    }
}

/*******************************************************************************
 Function Name    : OnBrowseBUSMASTERDb
 Input(s)         :     -
 Output           :     -
 Functionality    : This will pop-up a comman dialog box to select the input
                    BUSMASTER database file.
 Member of        :     -
 Friend of        :     -
 Author(s)        : Amit Ranjan
 Date Created     : 15.05.2004
 Modifications    :
*******************************************************************************/

void CCAPL2CPropertyPage::OnBrowseBUSMASTERDb()
{
    CString omStrPath;
    CFileDialog cfd( TRUE,"dbf",NULL,OFN_OVERWRITEPROMPT|
                     OFN_PATHMUSTEXIST,"BUSMASTER Database Files(*.dbf)|*.dbf||",this);
    cfd.m_ofn.lpstrTitle = "Select BUSMASTER Database File";
    GetDlgItemText( IDC_EDIT_BUSMASTERDB,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if( omStrPath.Find(".dbc",0) != -1)
    {
        omStrPath = omStrPath.Left( omStrPath.GetLength() - 4);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==IDOK)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemText(IDC_EDIT_BUSMASTERDB, omStrPath );
    }
}

void CCAPL2CPropertyPage::OnChkbSavedb()
{
    UpdateData();

    if( m_savedb )
    {
        cFlagLog = 2;//to check whether to save converted database or not
        GetDlgItem( IDC_EDIT_BUSMASTERDB )->EnableWindow(TRUE);
        GetDlgItem( IDC_CBTN_BBUSMASTERDB )->EnableWindow(TRUE);
    }
    else
    {
        cFlagLog = 0;
        SetDlgItemText(IDC_EDIT_BUSMASTERDB," " );
        GetDlgItem( IDC_EDIT_BUSMASTERDB )->EnableWindow(FALSE);
        GetDlgItem( IDC_CBTN_BBUSMASTERDB )->EnableWindow(FALSE);
    }
}

void CCAPL2CPropertyPage::SaveSettings()
{
    //this function will save the settings in the registry.
    CString strSection       = "Files";
    CString strStringItem    = "CAPL File";
    CWinApp* pApp = AfxGetApp();
    CString omStrCAPLName;
    CWnd* pCAPL = GetDlgItem(IDC_EDIT_INPUT);
    pCAPL->GetWindowText(omStrCAPLName);
    pApp->WriteProfileString(strSection, strStringItem,omStrCAPLName);
}

void List::OnCancel()
{
    List::OnTerminate();
}

void List::OnClose()
{
    OnTerminate();
    CDialog::OnClose();
}
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Functions.hpp
 * \brief     Implementation file for parsing functions
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for parsing functions
 */

#ifndef _LEXER_H
#define _LEXER_H
#define INVALID 0xffffffff
#include "lexer.h"
#endif

/* Project includes */
#include "ConstString.h"
#include "Selectdb.h"
#include "Converter.h"
#include "List.h"
#include "Message.h"
#include "Signal.h"
#include "ValueDescriptor.h"

/**
 * This will extract the name of the key from yytext. If key is
 * supported by BUSMASTER it will be stored in" acSptdKey " else
 * it will be stored in " acUnSptdKey ".
 */
void vKeyStoreHeader()
{
    //yytext-- /*@@key:'a':*/   or /*@@key:pageup:*/
    try
    {
        char acKeyName[defSTR_MaxSizeBreadth];

        if( yytext[8] == '\'' )//if yytext is not /*@@key:*:*/
        {
            // Single char
            if( !isalnum( yytext[9] ) )//if not alpha numeric
            {
                char cTemp[2];
                cTemp[0] = yytext[9];
                cTemp[1] = 0;
                ouUnSptdKey.bAdd(cTemp);
            }
            else
            {
                //if alpha numeric
                acSptdKey[cIndex2++] = yytext[9];
            }
        }
        else
        {
            int m = 8; //length of /*@@key:

            if( yytext[m] != '*')
            {
                int n = 0;

                while( yytext[m] != NULL && yytext[m] != ':')
                {
                    acKeyName[n++] = yytext[m++];
                }

                acKeyName[n] = 0;
                ouUnSptdKey.bAdd(acKeyName);
            }

            // else if it is '*' it will be considered in the second parse
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vKeyStoreHeader\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the name of the Environment Handler from
 * yytext and store it into " auUnSptdKey ".
 */
void vEnvVar()
{
    //yytext--/*@@envVar:.*:*/
    try
    {
        CString val ;
        int start = 0 ;
        val = yytext ;
        start = val.Find(':',0);
        val = val.Right( val.GetLength() - start - 1 );// to avoid "/*@@envVar:"
        start = val.Find(':',0);
        val = val.Left( start  );
        val.TrimLeft();
        val.TrimRight();
        ouUnSptdKey.bAdd( val );
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vEnvVar\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the name of the capl function from
 * yytext and store it into " ouFuncName ".
 */
void vCaplFunc()
{
    //yytext -- /*@@caplFunc:abc(para1,...):*/
    try
    {
        int start ;
        CString val ;
        val = yytext;
        start = val.Find(':',0);
        val = val.Right( val.GetLength() - start - 1 );// to avoid "/*@@caplFunc:"
        start = val.Find('(',0);
        val = val.Left( start );//name of function
        val.TrimLeft();
        val.TrimRight();
        ouFuncName.bAdd (val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCaplFunc\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the name of the key from yytext.If the
 * length is more than one then key will be compared with the
 * menbers of UnSptdKeyList.If it will match then key will be
 * stored in " acUnSptdKey ".Before storing it is checked that
 * whether the key is already existing in the acUnSptdKey array
 * or not.If it is not there then only the key will be stored.
 */
void vKeyStoreCase()
{
    //yytext -- case .* :
    try
    {
        CString keyname;
        int start ;
        static  char* UnSptdKeyList[] = {    "pageup","pagedown","end","home","f1",
                                             "f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","ctrlpageup",
                                             "ctrlpagedown","ctrlhome","ctrlend","ctrlf1","ctrlf2","ctrlf3","ctrlf4",
                                             "ctrlf5","ctrlf6","ctrlf7","ctrlf8","ctrlf9","ctrlf10","ctrlf11",
                                             "ctrlf12","CursorDown","CursorUp","CursorRight","CursorLeft",
                                             "ctrlCursorDown","ctrlCursorUp","ctrlCursorLeft","ctrlCursorRight"
                                        };
        keyname = yytext;
        start = keyname.FindOneOf("cC");
        keyname = keyname.Right( keyname.GetLength() - start );
        start = keyname.Find(' ',0);
        keyname = keyname.Right( keyname.GetLength() - start - 1 );
        keyname.TrimLeft();
        keyname = keyname.Left( keyname.GetLength() - 1 );
        keyname.TrimRight();

        if( keyname[0] =='\'' )
        {
            keyname = keyname.Mid(1,keyname.GetLength() - 1);
        }

        if( keyname.GetLength() > 1 ) //if length of key is more than one
        {
            for (int i = 0; i < 40; i++)
            {
                if( _stricmp(UnSptdKeyList[i],keyname) == 0 )
                {
                    ouUnSptdKey.bAdd(keyname);//add in the array
                    i = 40 ;//to terminate the loop
                }
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vKeyStoreCase\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will take care of header and footer.
 */
void vHeader()
{
    try
    {
        CString val;
        CString HandlerType, HandlerVal;
        val = yytext;

        // yytext -- "/*@@var:*/" /*@@key:'a':*/
        if( val == "/*@@var:*/" )
        {
            // yytext -- /*@@var:*/
            fprintf(yyout,defSTR_StartIncludeHeader);//header for include header
            fprintf(yyout,"#include<windows.h>\n");
            fprintf(yyout,"#include<struct.h>\n");
            fprintf(yyout,defSTR_EndIncludeHeader);//footer for include header
            fprintf(yyout,defSTR_GlobalVarHeader);//header for global variables
            fprintf(yyout,defSTR_TypedefByte);
            fprintf(yyout,defSTR_TypedefWord);
            fprintf(yyout,defSTR_DefRx);
            fprintf(yyout,defSTR_ForTrace, defSTR_TraceBufferName);// for Trace
            nSourceLine = nSourceLine + 6;//2 lines have been increased by other func
            cFlagHeader = 1; //flag for DelForHeader state
        }
        else
        {
            //if not vaiable declaration part then
            int start;
            val = val.Left( val.GetLength() - 2);//remove "*/"
            val = val.Right( val.GetLength() - 4);//remove"/*@@"
            start = val.Find(':',0);
            HandlerType = val.Left( start  );
            val = val.Right( val.GetLength() - start - 1);
            HandlerVal = val.Left( val.GetLength() - 1 );
            fprintf(yyout,defSTR_Header);

            if( HandlerType == defSTR_timer )
            {
                //timer handler
                Footer = defSTR_OnTimer ;
                Footer += HandlerVal + defSTR_TimerFormat;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_TimerStart,HandlerVal);
            }//end of timer

            if( HandlerType == defSTR_startstart )
            {
                Footer = defSTR_DllLoadHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_DllLoadStart);

                if( fprestart == 1 )
                {
                    fprintf(yyout,"\nUtils_PreStart();");
                    nSourceLine += 1;//we are adding one more line
                }
            }//end of dll load

            if( HandlerType == "preStart" )
            {
                if( fstart == 0 )
                {
                    //if dll load is not in the program
                    Footer = defSTR_DllLoadHeader;
                    fprintf(yyout,Footer);
                    fprintf(yyout,defSTR_DllLoadStart);
                }
                else
                {
                    //if dll load is there then replace it with utility function
                    Footer = "Utils_PreStart */\n";
                    fprintf(yyout,Footer);
                    fprintf(yyout,"void Utils_PreStart()\n{");
                }
            }//end of prestart

            if(  HandlerType == "stop" )
            {
                Footer = defSTR_DllUnLoadHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_DllUnLoadStart);
            }//end of dll unload

            if( HandlerType == defSTR_busoff )
            {
                Footer = defSTR_BusOffHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_BusOffStart);
            }//end of busoff

            if( HandlerType == defSTR_caplfunc  )
            {
                Footer = defSTR_Utils;
                int start;
                start = HandlerVal.Find('(',0);

                if( start == -1 )
                {
                    MessageBox(0,"Header of caplFunc Handler is wrong","Warning",MB_OK);
                    exit( 0 );
                }

                HandlerVal = HandlerVal.Left( start );
                Footer += HandlerVal + defSTR_HeaderFormat;
                fprintf(yyout,Footer);
            }//end of capl function

            if( HandlerType == defSTR_errorframe  )
            {
                Footer = defSTR_ErrorFrameHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_ErrorFrameStart);
            }//end of errorframe

            if( HandlerType == defSTR_erroractive )
            {
                Footer = defSTR_ErrorActiveHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_ErrorActiveStart);
            }//end of erroractive

            if( HandlerType == defSTR_errorpassive  )
            {
                Footer = defSTR_ErrorPassiveHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_ErrorPassiveStart);
            }//end of errorpassive

            if( HandlerType == defSTR_warninglimit  )
            {
                Footer = defSTR_WarningLimitHeader;
                fprintf(yyout,Footer);
                fprintf(yyout,defSTR_WarningLimitStart);
            }//end of warninglimit

            if(HandlerType == defSTR_key|| HandlerType == defSTR_envvar)
            {
                //for key handler and environment handler
                cFlagHeader = 3;//to be used to convert "this"

                if(HandlerType == defSTR_envvar )
                {
                    //log entry for environment handler
                    fprintf(logfile,defSTR_EnvVarLogEntry,nSourceLine );
                }

                if( yytext[8] == '*' )
                {
                    //for Key_All
                    Footer = defSTR_KeyAllHeader;
                    fprintf(yyout,Footer);
                    fprintf(yyout,defSTR_KeyAllStart);
                }
                else
                {
                    //check for unsupported kay
                    if( HandlerVal[0] =='\'')
                    {
                        HandlerVal = HandlerVal.Right( HandlerVal.GetLength() - 1 );
                        HandlerVal = HandlerVal.Left( HandlerVal.GetLength() - 1);
                    }

                    int index = ouUnSptdKey.nFind( HandlerVal );

                    if( index == -1)
                    {
                        //means supported key
                        Footer = defSTR_KeyCharHeader;// + HandlerVal + " */\n";
                        Footer += HandlerVal + defSTR_HeaderFormat;
                        fprintf(yyout,Footer);
                        fprintf(yyout,defSTR_KeyCharStart,HandlerVal);
                    }
                    else
                    {
                        //means unsupported key
                        Footer = defSTR_KeyCharHeader;

                        if(  acAltKey[index] == -1)
                        {
                            // if no alternate key is available
                            //array is initialised with -1
                            Footer += HandlerVal + defSTR_HeaderFormat;
                            fprintf(yyout,Footer);
                            fprintf(yyout,defSTR_KeyCharStart,HandlerVal);
                            fprintf(logfile,defSTR_Warning7,HandlerVal,nSourceLine);
                            nUnCnvrtdLine = nUnCnvrtdLine + 2;//wighted 2
                        }
                        else
                        {
                            Footer += CString( acAltKey[index])+defSTR_HeaderFormat;
                            fprintf(yyout,Footer);
                            fprintf(yyout,defSTR_KeyCharStart,
                                    CString( acAltKey[index] ));
                            fprintf(logfile,defSTR_ConvertedkeyInfo,HandlerVal,
                                    nSourceLine,acAltKey[index]);
                        }
                    }
                }
            }//end of keyhandler

            if( HandlerType == defSTR_msg )
            {
                //for message handler
                cFlagHeader = 4;//to be used to convert "this"

                if(yytext[8]=='*')
                {
                    Footer = defSTR_OnMsgAllHeader;
                    fprintf(yyout,Footer);
                    fprintf(yyout,defSTR_OnMsgAllStart);
                }
                else if( !isdigit( HandlerVal[0] ) )
                {
                    //for message name
                    start = HandlerVal.FindOneOf("' ':");

                    if( start != -1 )
                    {
                        HandlerVal = HandlerVal.Left( start );
                    }

                    Footer = defSTR_MsgNameHeader;
                    Footer += HandlerVal + defSTR_HeaderFormat;
                    fprintf(yyout,Footer);
                    fprintf(yyout,defSTR_MsgNameStart,HandlerVal,HandlerVal);
                    //we have replaced "STCAN_MSG" with message name in this case
                }
                else
                {
                    if( HandlerVal[ HandlerVal.GetLength() - 1] == 'x' ||
                            HandlerVal[ HandlerVal.GetLength() - 1] == 'X' )
                    {
                        //avoid x for extended
                        HandlerVal = HandlerVal.Left( HandlerVal.GetLength() - 1 );
                    }

                    start = HandlerVal.Find('-',0);

                    if ( start == -1 )
                    {
                        //means id
                        Footer = defSTR_MsgIdUs ;

                        if( HandlerVal[1] =='x' || HandlerVal[1] =='X')
                        {
                            HandlerVal = HandlerVal.Right( HandlerVal.GetLength() - 2);
                        }
                        else
                        {
                            char* stop;
                            HandlerVal.Format("%x",strtol( HandlerVal, &stop, 10)) ;
                        }

                        Footer += HandlerVal + defSTR_HeaderFormat;
                        fprintf(yyout,Footer);
                        fprintf(yyout,defSTR_MsgIdStart,HandlerVal);
                    }
                    else
                    {
                        //means msgrange
                        Footer = defSTR_MsgIdRangeHeader;
                        CString id;
                        id = HandlerVal.Left( start );

                        if( id[1] == 'x' || id[1] == 'X')
                        {
                            //hex
                            id = id.Right( id.GetLength() - 2 );//avoid"0x"
                        }
                        else
                        {
                            //decimal
                            char* stop;
                            id.Format("%x",strtol( id, &stop, 10 ));
                            //          id = CString( strtol(id,&stop,16) );
                        }

                        Footer += id + '_';
                        id = HandlerVal.Right( HandlerVal.GetLength() - start- 1);

                        if( id[1] == 'x' || id[1] == 'X')
                        {
                            //hex
                            id = id.Right( id.GetLength() - 2 );//avoid"0x"
                        }
                        else
                        {
                            //decimal
                            char* stop;
                            id.Format("%x",strtol( id, &stop, 10 ));
                            //      id = CString( strtol(id,&stop,16) );
                        }

                        Footer +=id + defSTR_HeaderFormat;
                        fprintf( yyout,Footer);
                        start = Footer.Find('_',0);
                        id = Footer.Right( Footer.GetLength() - start - 1 );
                        id = id.Left( id.GetLength() - 3 );//extract the range
                        fprintf(yyout,defSTR_MsgIdRangeStart,id);
                    }
                }
            }//end of msg handler
        }

        nSourceLine = nSourceLine + 2;//since going in different state

        if( HandlerType == defSTR_caplfunc  )
        {
            yy_push_state( CaplFunc);
        }//end of if
        else
        {
            yy_push_state(Delete);
        }//end of else
    }//end of try block
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vHeader\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * On incounter of '{' the function will push the flow into
 * "VarDecl" state or it will come out of the previous state.
 */
void vDelete()
{
    // yytext '{'
    try
    {
        if(cFlagHeader == 1)
        {
            //if coming from /*@@var*/ then go to VarDecl state
            yy_push_state(VarDecl);
            cFlagHeader = 0;
        }
        else
        {
            //go to state2.
            yy_pop_state();
        }
    }//end of try block
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vDelete\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * On encounter of '}' the function will check the value of
 * "counter".If it is not 0 then it will simply echo otherwise
 * it will go in "Footer"state.
 */
void vEndBody()
{
    try
    {
        if(yytext[0]=='{')
        {
            ECHO;
            counter++;
        }
        else
        {
            counter--;

            if(counter != 0)
            {
                ECHO;
            }
            else
            {
                counter = 1;
                yy_push_state(FooterState);
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vEndBody\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will check whether the variable is of type  " timer "
 * or " mstimer ".If it "timer" then it will store the name of
 * variables in "ouTimerName".
 */
void vTimerFunc()
{
    try
    {
        CString val, name ;
        int start;

        if( yytext[0] == ';')
        {
            fprintf(yyout,";");
        }

        val = yytext;
        start = val.Find(' ',0);
        name = val.Left(start  );
        name.MakeLower();//extract the datatype

        if( name.Find("mstimer") == -1 )
        {
            //it is timer
            val = val.Right( val.GetLength() - start - 1);
            val.TrimLeft();

            while(val.GetLength() != 0 )//till end of text
            {
                start = val.FindOneOf(",;");
                name = val.Left( start);
                name.TrimLeft();
                name.TrimRight();
                ouTimerName.bAdd( name );//add in array
                val = val.Right( val.GetLength() - start - 1 );
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vTimerFunc\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replace " byte " , " word " or "long ".
 */
void vCnvrtByte()
{
    try
    {
        //yytext asd.long(1)
        // this.byte(2)
        // abc.word(1);
        CString val,name,type,index;
        int start , end ;
        val = yytext;
        start = val.Find(".",0);
        name = val.Left(start);
        name.TrimLeft();
        name.TrimRight();
        end = val.Find("(",start);
        type = val.Mid(start+1,end-start-1);
        type.TrimLeft();
        type.TrimRight();
        type.MakeLower();//for case insensitive comparison
        start = end;
        end = val.Find(")",start);
        index = val.Mid( start + 1 , end - start - 1 );
        index.TrimLeft();
        index.TrimRight();

        if(name == defSTR_this )
        {
            //replace "this" withe "RxMsg"
            name = defSTR_RxMsg;
        }

        if( type == defSTR_long )
        {
            //if long
            fprintf(yyout,defSTR_LongCnvrt,name,index);
        }

        if( type == defSTR_byte )
        {
            //if byte
            fprintf(yyout,defSTR_ByteCnvrt,name,index);
        }

        if( type == defSTR_word )
        {
            //if word
            fprintf(yyout,defSTR_WordCnvrt,name,index);
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCnvrtByte\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the name of the key from yytext.Then it
 * will match the key with the elements of acUnSptdKey array.
 * If it will match with any element it will replace the key
 * with the element stored at the exact position in acAltKey
 * array .If the key is not in the arrya then it will simply
 * ECHO the yytext.
 */
void vPutKeyCase()
{
    try
    {
        //yytext case 'a':
        CString keyname;
        int start ;

        if( yytext[0] == ';' || yytext[0] == ',')
        {
            fprintf(yyout,"%c",yytext[0]);
        }

        keyname = yytext;
        start = keyname.FindOneOf("cC");
        keyname = keyname.Right( keyname.GetLength() - start );
        start = keyname.Find(' ',0);
        keyname = keyname.Right( keyname.GetLength() - start - 1 );
        keyname.TrimLeft();
        keyname = keyname.Left( keyname.GetLength() - 1 );
        keyname.TrimRight();//extract the key

        if( keyname[0] =='\'' )
        {
            keyname = keyname.Mid(1,keyname.GetLength() - 1);
        }

        if( keyname.GetLength() > 1 )
        {
            int nPos = ouUnSptdKey.nFind(keyname);

            if( nPos != -1 )
            {
                //if it is in acUnSptdKey then
                if( acAltKey[ nPos ] != -1)
                {
                    fprintf(yyout,"case '%c' :",acAltKey[nPos]);
                    fprintf(logfile,defSTR_ConvertedkeyInfo,keyname,nSourceLine,
                            acAltKey[nPos]);
                }
                else
                {
                    //if alternate key is not availabe
                    ECHO;
                    fprintf(logfile,defSTR_UnSptdKeyNotChanged,nSourceLine);
                    nUnCnvrtdLine = float( nUnCnvrtdLine + 0.5 );//weighted 0.5
                }
            }
            else
            {
                //if it is not found in "ouUnSptdKey"
                ECHO;
            }
        }
        else
        {
            //if key length is one
            ECHO;
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vPutKeyCase\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replace write with sprintf.This will also take
 * care of "writetolog" function.
 */
void vWrite()
{
    try
    {
        //yytext "write(" or "writeToLog("
        cFlag = 1 ;//to be used for termination of write
        cFlagH = 0;  //to count the no. of white space
        cFlagLog = 1;//to differentiate "write"and "writetolog" function
        CString val;
        val = yytext;
        val.MakeLower();//for case insensitive comparison

        if( val.Find("writetolog",0) == -1)
        {
            cFlagLog = 0;//used in writeterminate function to differntiate between
        }  // "write" and "writeToLog" function.

        while( !isalpha(yytext[cFlagH] ) )
        {
            cFlagH++;
        }

        for ( int n = 0; n < cFlagH; n++)
        {
            fprintf(yyout,"%c",' ');
        }

        fprintf(yyout,"sprintf( %s,",defSTR_TraceBufferName);
        yy_push_state(Write);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWrite\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replace " id " of message with " m_unMsgID" and
 * "dlc" with "m_ucDLC".
 */
void vMsgID()
{
    try
    {
        CString val , name , type;
        int start;
        val = yytext;
        start = val.Find(".",0);
        name = val.Mid(0,start);
        type = val.Mid(start+1,val.GetLength()-2);
        type.MakeLower();
        type.TrimRight();

        if(name == defSTR_this)
        {
            name = defSTR_RxMsg;
        }

        if(type == "id")//if id
        {
            name = name + defSTR_MuId ;
        }
        else if (type == "dlc")// id dlc
        {
            name = name + defSTR_MuDlc ;
        }

        if(type == "dir")
        {
            //replace "abc.dir" with "Rx".( Rx ~ 1)
            fprintf(yyout,"Rx");
        }

        if( type.CompareNoCase("can") == 0)
        {
            fprintf(yyout,"%s./*CAN */", name);
        }
        else
        {
            fprintf(yyout,"%s",name);
        }

        fprintf(yyout,"%c",yytext[yyleng-1]);//to write the last char
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vMsgID\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replace '.' with m_sWhichBit
 */
void vWriteDot()
{
    try
    {
        // yytext -- "abc."
        CString val;
        int a;
        val = yytext;
        a = val.Find(".",0);
        val = val.Mid(0,a);//name of message
        val.TrimRight();

        if( val == defSTR_this )
        {
            //replace "this" with "RxMsg".
            val = defSTR_RxMsg ;
        }

        fprintf(yyout,defSTR_MWBit,val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWriteDot\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

void vRemovePhys()
{
    try
    {
        // yytext -- "*.phys"
        CString omStrParse;
        omStrParse = yytext;
        int nIndex = omStrParse.Find(".",0);

        if( nIndex != -1 )
        {
            fprintf( yyout, "%s/*%s */", omStrParse.Mid( 0, nIndex),
                     omStrParse.Mid(nIndex));
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWriteDot\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replace "this" keyword .
 */
void vCnvrtThis()
{
    try
    {
        if( cFlagHeader == 4 )
        {
            //if message handler
            fprintf(yyout,defSTR_RxMsg);
        }

        if( cFlagHeader == 3 )
        {
            //if key handler
            fprintf(yyout,defSTR_KeyValue);
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCnvrtThis\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will terminate write() function
 */
void vWriteTerminator()
{
    try
    {
        // yytext -- ';' / ',', /'(' ')'
        if(yytext[0] == '(')
        {
            cFlag++;
            ECHO;
        }
        else if(yytext[0]==')')
        {
            //if ')'
            cFlag--;
            ECHO;
        }

        if(  yytext[0] == ';' || ( yytext[0] == ',' && cFlag == 0 ) )
        {
            int n = 0;
            // cFlag == 0 to check parantheses
            fprintf(yyout,",\n");

            for(n = 0; n < cFlagH; n++ )
            {
                // value of cFlagH is coming from vWrite function
                fprintf(yyout,"%c",' ');//for blank space
            }

            if ( cFlagLog == 0 )
            {
                fprintf(yyout,defSTR_Trace,defSTR_TraceBufferName,");");
            }
            else
            {
                fprintf(yyout,defSTR_WriteToLog,defSTR_TraceBufferName,");");
            }

            nSourceLine++;  //to increase the no. of lines by 1
            yy_pop_state();
        }
        else
        {
            if(yytext[0] == ',')
            {
                ECHO;
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vWriteTerminator\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the name of vaiable and elapse time from
 * the function and match the name with the elements of
 * "ouTimerName".If it will match with any element of that
 * array it means it is of type "timer" and then it will
 * append "*1000" in the value of elapse time.And finally it
 * will call "StartTimer" function.
 */
void vSetTimer()
{
    try
    {
        //yytext--SetTimer( Timer_Variable_Name, Time_delay )
        CString text,name , val;
        int start , end;
        char wsp;
        int index = 0;

        while( !isalpha(yytext [index] ) )
        {
            //to count no. of white spaces
            index++;
        }

        text = yytext;
        start = text.Find("(",7);
        end = text.Find(",",8);
        name = text.Mid(start+1,end-start-1);//name of timer
        start = end;
        end = text.Find(")",start);
        val = text.Mid(start+1, end -start -1);//elapse time
        name.TrimLeft();
        name.TrimRight();
        val.TrimLeft();
        val.TrimRight();

        for( wsp = 0 ; wsp <= index ; wsp ++)
        {
            //printf white space
            fprintf(yyout,"%c",' ');
        }

        fprintf(yyout,defSTR_SetTimerVal,name);

        if(ouTimerName.nFind(name) != -1)
        {
            //if it is "Timer" variable then
            val = val + defSTR_1000;
        }

        fprintf(yyout,"%s),\n",val);

        for( wsp = 0 ; wsp <= index ; wsp ++)
        {
            //printf white space
            fprintf(yyout,"%c",' ');
        }

        fprintf(yyout,defSTR_StartTimer,name);
        nSourceLine++;//increase no. of lines by 0ne
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vSetTimer\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the parameter from yytext and replace
 * "output" with "SendMsg".
 */
void vOutput()
{
    try
    {
        // yytext -- output(asd)
        CString val ;
        int start;
        val = yytext ;
        start = val.Find("(",0);
        val = val.Right( val.GetLength() - start - 1);
        start = val.Find(")",0);
        val = val.Left( start );
        val.TrimLeft();
        val.TrimRight();
        fprintf(yyout,defSTR_SendMessage ,val );
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vOutput\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replce "canceltimer" with "StopTimer".
 */
void vCancelTimer()
{
    try
    {
        // yytext -- canceltimer(asd)
        CString val  ;
        int start ;
        val = yytext ;
        start = val.Find("(",10); //10--length of canceltimer
        val = val.Mid( start+1, val.GetLength() - start - 2);//extract name of timer
        val.TrimLeft();
        val.TrimRight();
        fprintf(yyout,defSTR_StopTimer , val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vCancelTimer\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will replace "canOnline" with "GoOnline".
 */
void vOnLine()
{
    fprintf(yyout,defSTR_GoOnline);
}

/**
 * This will replace "canOffline" with "GoOffline".
 */
void vOffLine()
{
    fprintf(yyout,defSTR_GoOffline);
}

/**
 * This will replace "triger" with "EnableLogging".
 */
void vTrigger()
{
    fprintf(yyout,defSTR_EnableLogging);
}

/**
 * This will replace "resetCan" with "ResetController".
 */
void vResetCan()
{
    fprintf(yyout,defSTR_ResetController);
}

/**
 * This will replace "stop" with "Disconnect".
 */
void vDisconnect()
{
    fprintf(yyout,defSTR_Disconnect);
}

/**
 * This will make unsupported functions as comment and write
 * name of the function and line no. in the log file.
 */
void vUnSptdFunc()
{
    fprintf(yyout,"/*");
    ECHO;
    fprintf(yyout,"*/");
    fprintf(logfile,defSTR_UnSptdFuncLogInfo,yytext,nSourceLine);
    nUnCnvrtdLine = nUnCnvrtdLine + 1 ; //weighted 1
}

/**
 * This will extract the name of function and check with
 * acFuncName arry.If it will match with any entry it will
 * prefix "Utils_".
 */
void vFuncCall()
{
    try
    {
        // yytext asd(
        CString val ;
        int start;
        val = yytext ;
        start = val.Find("(",0);
        val = val.Left(start);
        val.TrimRight();

        if( ouFuncName.nFind( val ) != -1)
        {
            fprintf(yyout,defSTR_Utils);
        }

        val = val + "(";
        fprintf(yyout,"%s",val);
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vFuncCall\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * It will increse the counter on arrival of '\n'.
 */
void vAddLine()
{
    // yytext '\n'
    nSourceLine++;
    ECHO;
}

/**
 * This will take care of footer.
 */
void vFooter()
{
    if( yy_top_state() == VarDecl )//VarDecl State
    {
        fprintf(yyout,defSTR_FooterVar);
        fprintf(yyout,defSTR_FuncProHeader);
        fprintf(yyout,defSTR_FuncProFooter);
        nSourceLine = nSourceLine + 2;
        yy_pop_state();
        yy_pop_state();
    }
    else
    {
        fprintf(yyout,defSTR_Footer);
        fprintf(yyout,"%s",Footer);
        nSourceLine += 1; //since footer contains "\n"
    }

    yy_pop_state();
}

/**
 * This is the function that takes care of conversion.It takes
 * three parameters ( input file name , output file name and
 * log file name) and does conversion.If user has assign
 * database then it cinverts it and if he wants to save it,
 * the function saves the converted database in appropriate
 * output file.This function return the percentage of CANoe
 * file converted into BUSMASTER.
 */
int nConvert( CString srs,CString dest ,CString dest1)
{
    yyin = fopen(srs,"r");
    BEGIN( FirstParse ); //start first parse
    yylex();
    yyout = fopen (dest,"w");
    logfile = fopen( dest1,"w" );
    fprintf( logfile,defSTR_InputFileInfo,srs );//writing to log file
    fprintf( logfile,defSTR_OutputFileInfo,dest );

    if( ouUnSptdKey.nGetSize() > 0)
    {
        //if there is any unsuppoted key then
        List d;
        d.DoModal();
    }

    if( cFlagH != 1 && counter == 2 && canoedb.IsEmpty() == TRUE)
    {
        //if program has any message variable
        CSelectdb  dialog;
        dialog.DoModal();
    }

    convert.Convert(canoedb);//convert database

    if (cFlagLog == 2 )
    {
        //if user wants to save it
        convert.WriteToOutputFile(busmasterdb);
    }

    cFlagLog = 1;
    counter = 1;
    //cFlagH = 0;
    fseek( yyin,0,SEEK_SET );
    BEGIN( SecondParse );//begin second parse
    yylex();
    nSourceLine = nSourceLine - 1;
    float per = 0;//to calculate percentage conversion
    per = float((nSourceLine - nUnCnvrtdLine )*100/ nSourceLine);
    fprintf( logfile,defSTR_CnvrInfo,per );
    fclose( yyin );
    fclose( yyout );
    fclose( logfile );
    nSourceLine = 0, nUnCnvrtdLine = 0;
    cIndex2 = 0,cFlag = 0;
    cFlagH = 0, cFlagHeader = 0;
    counter = 1;
    fprestart = 0;
    fstart = 0;
    return( int( per ));
}

/**
 * This will pop-up a comman dialog box to select the input
 * BUSMASTER database file.
 */
void CSelectdb::OnBrowseBUSMASTERDb()
{
    CString omStrPath;
    int nIndex;
    CFileDialog cfd(TRUE,"dbf",NULL,OFN_OVERWRITEPROMPT|
                    OFN_PATHMUSTEXIST,"BUSMASTER Database Files(*.dbf)|*.dbf||",this);
    cfd.m_ofn.lpstrTitle = "Select BUSMASTER Database File";
    GetDlgItemText( IDC_EDIT_ADBUSMASTER,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileString("Files","Database File","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==IDOK)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemText(IDC_EDIT_ADBUSMASTER, omStrPath );
    }
}

/**
 * This will pop-up a comman dialog box to select the
 * CANoe database file.
 */
void CSelectdb::OnBrowseCANoeDb()
{
    CString omStrPath;
    int nIndex;
    CFileDialog cfd(TRUE,"dbf",NULL,OFN_OVERWRITEPROMPT|
                    OFN_PATHMUSTEXIST,"CANoe Database Files(*.dbc)|*.dbc||",this);
    cfd.m_ofn.lpstrTitle = "Select CANoe Database File";
    GetDlgItemText( IDC_EDIT_ADCANOE,omStrPath );
    omStrPath.TrimLeft();
    omStrPath.TrimRight();

    if(omStrPath.IsEmpty())
    {
        omStrPath = AfxGetApp()->GetProfileString("Files","Database File","");
    }

    if( (nIndex = omStrPath.ReverseFind('\\') )!= -1)
    {
        omStrPath = omStrPath.Left(nIndex);
    }

    cfd.m_ofn.lpstrInitialDir = omStrPath;

    if(cfd.DoModal()==IDOK)
    {
        omStrPath = cfd.GetPathName();
        SetDlgItemText(IDC_EDIT_ADCANOE, omStrPath );
    }
}

/**
 * This will enable or diable the controls according to the
 * state of checkbox button.
 */
void CSelectdb::OnChkbOption()
{
    UpdateData();

    if( m_option )
    {
        //if checked
        cFlagLog = 2;
        GetDlgItem( IDC_EDIT_ADBUSMASTER )->EnableWindow(TRUE);
        GetDlgItem( IDC_CBTN_BUSMASTERDB )->EnableWindow(TRUE);
    }
    else
    {
        //if unchecked
        cFlagLog = 1;
        SetDlgItemText(IDC_EDIT_ADBUSMASTER, "");
        GetDlgItem( IDC_EDIT_ADBUSMASTER )->EnableWindow(FALSE);
        GetDlgItem( IDC_CBTN_BUSMASTERDB )->EnableWindow(FALSE);
    }
}

/**
 * This will verify the correctness of CANoe and BUSMASTER databse
 * files.
 */
void CSelectdb::OnOK()
{
    //  "canoedb" and "busmasterdb" are global CString objects
    int flag = 1;
    CString extn;
    GetDlgItemText( IDC_EDIT_ADCANOE,canoedb );
    canoedb.TrimRight();
    extn = canoedb.Right(4);
    extn.MakeLower();

    if( extn != ".dbc")
    {
        MessageBox(defSTR_Warning8,MB_OK);
        SetDlgItemText( IDC_EDIT_ADCANOE,"" );
        GetDlgItem( IDC_EDIT_ADCANOE)->SetFocus();
        flag = 0;//to avoid conversion
    }
    else
    {
        CFile fdatabase;

        if ( fdatabase.Open( canoedb,CFile::modeRead ) == NULL )
        {
            //if file doesn't exist or in write mode
            MessageBox( defSTR_Warning2,MB_ICONWARNING|MB_OK );
            SetDlgItemText( IDC_EDIT_ADCANOE,"" );
            GetDlgItem( IDC_EDIT_ADCANOE)->SetFocus();
            flag = 0;//to avoid conversion
        }
        else
        {
            fdatabase.Close();
        }
    }

    if( cFlagLog == 2)
    {
        GetDlgItemText( IDC_EDIT_ADBUSMASTER,busmasterdb );
        busmasterdb.TrimRight();
        extn = busmasterdb.Right(4);
        extn.MakeLower();

        if( extn != ".dbf")
        {
            MessageBox(defSTR_Warning9,MB_OK);
            SetDlgItemText( IDC_EDIT_ADBUSMASTER,"" );
            GetDlgItem( IDC_EDIT_ADBUSMASTER)->SetFocus();
            flag = 0;//to avoid conversion
        }
        else
        {
            CFile fdatabase;

            if ( fdatabase.Open( busmasterdb,CFile::modeCreate|CFile::modeWrite )
                    == NULL )
            {
                //if file doesn't exist or in write mode
                MessageBox( defSTR_Warning3,MB_ICONWARNING|MB_OK );
                SetDlgItemText( IDC_EDIT_ADBUSMASTER,"" );
                GetDlgItem( IDC_EDIT_ADBUSMASTER)->SetFocus();
                flag = 0;//to avoid conversion
            }
            else
            {
                fdatabase.Close();
            }
        }
    }

    if ( flag == 1 )
    {
        //if both are correct then
        CDialog::OnOK();
    }
}

/**
 * This will convert the input can file into C file.This will
 * check whether the input file is correct or not.If name of
 * output file is not there then it will  create a default
 * output file with the name of input file with extention C.
 * The log file will be created with default name of input file
 * withe extention "txt".This function will intialize acAltkey
 * with -1.
 */
void CCAPL2CPropertyPage::OnConvert()
{
    CString dest , srs ;//to store the destination file and source file
    CFile fsrs, fdest, flog; //to check files
    CString extn;//to store the extension
    int flag = 1;

    for( m = 0; m < 254; m++)
    {
        //initialize array with -1.
        acAltKey[m]= -1;
    }

    GetDlgItem(IDC_CBTN_LOG)->EnableWindow(FALSE);
    GetDlgItemText( IDC_EDIT_INPUT,srs );//srs will have input file path
    GetDlgItemText( IDC_EDIT_OUTPUT,dest );//dest will have output file path
    srs.TrimRight();
    extn = srs.Right(4);
    extn.MakeLower();

    if( extn != ".can" )
    {
        //if file doesn't exist or in write mode
        MessageBox( defSTR_Warning5,MB_ICONWARNING|MB_OK );
        SetDlgItemText( IDC_EDIT_INPUT,"" );
        GetDlgItem( IDC_EDIT_INPUT)->SetFocus();
        flag = 0;//to avoid conversion
    }
    else if( fsrs.Open( srs,CFile::modeRead ) == NULL )
    {
        //if file doesn't exist or in write mode
        MessageBox( defSTR_Warning2,MB_ICONWARNING|MB_OK );
        SetDlgItemText( IDC_EDIT_INPUT,"" );
        GetDlgItem( IDC_EDIT_INPUT)->SetFocus();
        flag = 0;//to avoid conversion
    }
    else
    {
        //close fsrs file
        fsrs.Close();
    }

    if(dest == "")
    {
        //for default output file name
        dest = srs.Left( srs.GetLength() - 4 );
        dest += ".c";
    }
    else
    {
        dest.TrimRight();
        extn = dest.Right(2);
        extn.MakeLower();

        if ( extn != ".c")
        {
            MessageBox(defSTR_Warning1,MB_ICONWARNING|MB_OK );
            SetDlgItemText( IDC_EDIT_OUTPUT,"" );
            GetDlgItem( IDC_EDIT_OUTPUT)->SetFocus();
            flag = 0;//to avoid conversion
        }
    }

    if(fdest.Open(dest,CFile::modeCreate|CFile::modeWrite)==NULL)
    {
        //if output file is in read mode
        MessageBox( defSTR_Warning3,MB_ICONWARNING|MB_OK );
        SetDlgItemText( IDC_EDIT_OUTPUT,"" );
        GetDlgItem( IDC_EDIT_OUTPUT)->SetFocus();
        flag = 0;//to avoid conversion
    }
    else
    {
        //close fdest file
        fdest.Close();
    }

    if ( cFlagH == 1)
    {
        GetDlgItemText( IDC_EDIT_CANOEDB,canoedb );
        canoedb.TrimRight();
        extn = canoedb.Right(4);
        extn.MakeLower();

        if( extn != ".dbc")
        {
            MessageBox(defSTR_Warning8,MB_OK);
            SetDlgItemText( IDC_EDIT_CANOEDB,"" );
            GetDlgItem( IDC_EDIT_CANOEDB)->SetFocus();
            flag = 0;//to avoid conversion
        }
        else
        {
            CFile fdatabase;

            if ( fdatabase.Open( canoedb,CFile::modeRead ) == NULL )
            {
                //if file doesn't exist or in write mode
                MessageBox( defSTR_Warning2,MB_ICONWARNING|MB_OK );
                SetDlgItemText( IDC_EDIT_CANOEDB,"" );
                GetDlgItem( IDC_EDIT_CANOEDB)->SetFocus();
                flag = 0;//to avoid conversion
            }
            else
            {
                fdatabase.Close();
            }
        }

        if( cFlagLog == 2)
        {
            GetDlgItemText( IDC_EDIT_BUSMASTERDB,busmasterdb );
            busmasterdb.TrimRight();
            extn = busmasterdb.Right(4);
            extn.MakeLower();

            if( extn != ".dbf")
            {
                MessageBox(defSTR_Warning9,MB_OK);
                SetDlgItemText( IDC_EDIT_BUSMASTERDB,"" );
                GetDlgItem( IDC_EDIT_BUSMASTERDB)->SetFocus();
                flag = 0;//to avoid conversion
            }
            else
            {
                CFile fdatabase;

                if ( fdatabase.Open( busmasterdb,CFile::modeCreate|CFile::modeWrite ) == NULL )
                {
                    //if file doesn't exist or in write mode
                    MessageBox( defSTR_Warning3,MB_ICONWARNING|MB_OK );
                    SetDlgItemText( IDC_EDIT_BUSMASTERDB,"" );
                    GetDlgItem( IDC_EDIT_BUSMASTERDB)->SetFocus();
                    flag = 0;//to avoid conversion
                }
                else
                {
                    fdatabase.Close();
                }
            }
        }
    }

    dest1 = dest;
    dest1 = dest.Left( dest.GetLength() -  2 );
    dest1 +=  defSTR_LogName;//default output file name

    if(flog.Open(dest1,CFile::modeCreate|CFile::modeWrite)== NULL)
    {
        MessageBox( defSTR_Warning4,MB_ICONWARNING|MB_OK );
        flag = 0;//to avoid conversion
    }
    else
    {
        flog.Close();
    }

    if( flag == 1)
    {
        //means all the files are correct
        float value;
        value = float( nConvert(srs , dest ,dest1) );
        // Clear database information
        convert.m_listMessages.RemoveAll();
        CWnd* pPercent = GetDlgItem(IDC_STAT_RESULT2);

        if( pPercent)
        {
            //to display the result
            CString omStrPercent;
            omStrPercent.Format("%.2f",value);
            pPercent->SetWindowText(omStrPercent+ " % ");
            SaveSettings();
        }

        ouUnSptdKey.vClearArray();
        GetDlgItem( IDC_CBTN_LOG )->EnableWindow(TRUE);
    }
}

/**
 * this function will be called every time when the user will make any
 * change in the name if input file.If the edit box is blank,"ok" button
 * will be disabled.
 */
void CSelectdb::OnChangeEditAdcanoe()
{
    CString omStrPath;
    GetDlgItemText( IDC_EDIT_ADCANOE,omStrPath );

    if( omStrPath.GetLength() > 0 )
    {
        GetDlgItem( IDOK )->EnableWindow(TRUE);
    }
    else
    {
        GetDlgItem( IDOK )->EnableWindow(FALSE);
    }
}

void CSelectdb::OnCancel()
{
    fprintf(logfile,"You have not assigned the Database.\n");
    CDialog::OnCancel();
}

/**
 * This will convert the input can file into C file.This will
 * check whether the input file is correct or not.If name of
 * output file is not there then it will  create a default
 * output file with the name of input file with extention C.
 * The log file will be created with default name of input file
 * withe extention "txt".This function will intialize acAltkey
 * with -1.
 */
void vMsgDecl()
{
    try
    {
        CString val , ident , name ;
        int start  ;
        char extndd = 0;
        CMessage msg;
        int flag = 0;
        unsigned int decid;

        if( yytext[0] == ';')
        {
            fprintf(yyout,";");
        }

        val = yytext;
        val.TrimLeft();
        val = val.Right( val.GetLength() - 5 );
        start = val.Find(' ',0);
        val = val.Right(val.GetLength() - start  );
        val.TrimLeft();
        start = val.Find(' ',0 );
        ident = val.Left( start );//id or name of message
        val = val.Right( val.GetLength() - start );
        val.TrimLeft();
        start = val.FindOneOf(" ;=");
        name = val.Left( start );//name of the variable
        val = val.Right( val.GetLength() - start );

        if( ( start = ident.Find('.',0) ) != -1 )
        {
            //for "can1.asc" like cases
            ident = ident.Right( ident.GetLength() - start - 1 );
        }

        if( isdigit( ident[0]) )
        {
            //if message is declared with id then
            flag = 1;

            if( ident[ ident.GetLength() - 1 ] =='x'||
                    ident[ ident.GetLength() - 1 ] =='X')
            {
                //if last element is 'x'
                extndd = 1;
                ident = ident.Left( ident.GetLength() - 1 );
            }

            /*if(ident.GetLength() > 2)
            {
                if(ident[1] =='X' || ident[1] == 'x' )
                {//if hex id
                    char *stop;
                    ident = ident.Right(ident.GetLength() - 2);
                    decid = strtol(ident,&stop,16);
                }
            }
            else
            {//if deci id
                decid = atoi(ident);
            }*/
            int nIndex = ident.Find("0x");

            if( nIndex == -1 )
            {
                nIndex = ident.Find("0X");
            }

            if( nIndex != -1 )
            {
                nIndex +=2;
                // remove 0x
                char* stop;
                ident = ident.Right(ident.GetLength() - nIndex);
                decid = strtol(ident,&stop,16);
            }
            else
            {
                //if deci id
                decid = atoi(ident);
            }

            msg = convert.ouFindMessage(decid);
        }
        else
        {
            //message is declared with name
            msg = convert.ouFindMessage(ident);
        }

        if( val.Find('{',0) == -1 )
        {
            //if message is not initialized
            if( flag == 0 )
            {
                if( msg.m_uiMsgID == INVALID )
                {
                    //means unknown message
                    fprintf(logfile,"Message : %s not found in database.\n",ident);
                    nUnCnvrtdLine += 1;
                    // to decrease the percentage of conversion
                }

                fprintf(yyout,defSTR_MsgFormat,ident,name,
                        msg.m_uiMsgID,msg.m_cFrameFormat == 'S'? 0 : 1,
                        msg.m_cDataFormat,msg.m_ucLength );
            }
            else
            {
                flag = 0;

                if( msg.m_uiMsgID != INVALID )
                {
                    //means id is in database
                    fprintf(yyout,defSTR_MsgFormat,msg.m_acName,name,
                            msg.m_uiMsgID,extndd,msg.m_cDataFormat,
                            msg.m_ucLength );
                }
                else
                {
                    //means it is an unknown message
                    fprintf(yyout,defSTR_STCANMsgFormat,name,decid,extndd);
                }
            }
        }
        else
        {
            //if message is initialized
            int  end = 0 ;
            char dlc = 8;//to extract dlc
            CStringArray csa , msgbyte;
            // msgbyte.SetSize(8); //***anish
            int i;

            for ( i = 0; i< 8; i++)
            {
                //initialize array with '0'
                msgbyte.SetAtGrow(i,'0');
            }

            start = val.Find('{',0);
            val = val.Right( val.GetLength() - start - 1);
            start = 0;

            while((end = val.Find(",",start)) != -1 )
            {
                CString cs = val.Mid(start, end - start);
                csa.Add(cs);
                start = end + 1;
            }

            csa.Add(val.Right( val.GetLength() - start  ));//start - 1

            for(  i = 0; i < csa.GetSize(); i++)
            {
                CString cs = csa.GetAt( i );//byte and value
                CString key, value;
                cs.TrimLeft();
                cs.TrimRight();
                int pos = cs.Find("=",0);
                key = cs.Left(pos);
                value = cs.Right(cs.GetLength() - pos - 1 );
                key.TrimLeft();
                key.TrimRight();
                key.MakeLower();//for case insensitive comparision
                value.TrimLeft();

                if( ( start =value.FindOneOf("\t\n}") ) != -1 )
                {
                    value = value.Left( start );
                }

                if(key == "dlc")
                {
                    dlc = atoi(value);//since val is CString so atoi is used
                }

                if(cs.Find(defSTR_byte,0) != -1)
                {
                    //to store the value of particular byte of message
                    CString index;
                    start = key.Find('(',4);
                    end = key.Find(')',6);
                    index = key.Mid( start + 1, end - 2 );
                    index.TrimLeft();
                    index.TrimRight();
                    start = atoi( index );//for comparision

                    for( int i = 0; i <= 7; i++)
                    {
                        if( i == start )
                        {
                            msgbyte.SetAtGrow(i, value);
                            break;
                        }
                    }
                }//end if if(byte)

                if(cs.Find(defSTR_word,0) != -1)
                {
                    CString index;
                    int flag = 0;

                    if ( value[0]=='0'&& (value[1]=='x'||value[1]=='X') )
                    {
                        value = value.Right( value.GetLength() - 2 );
                        flag = 1;
                    }

                    start = key.Find('(',4);
                    end = key.Find(')',6);
                    index = key.Mid( start + 1, end - 2 );
                    index.TrimLeft();
                    index.TrimRight();
                    start = atoi( index );//for comparision

                    if ( flag == 1 )
                    {
                        CString hex = "0x";
                        msgbyte.SetAtGrow( start*2, hex + value.Left(2) );
                        msgbyte.SetAtGrow( start*2 + 1, hex + value.Right(2) );
                        flag = 0;
                    }
                    else
                    {
                        msgbyte.SetAtGrow( start*2, value.Left(2) );
                        msgbyte.SetAtGrow( start*2 + 1, value.Right(2) );
                    }
                }//end of word

                if( cs.Find(defSTR_long,0) != -1)
                {
                    CString index;
                    int flag = 0;

                    if ( value[0]=='0'&& (value[1]=='x'||value[1]=='X') )
                    {
                        value = value.Right( value.GetLength() - 2 );
                        flag = 1;
                    }

                    start = key.Find('(',4);
                    end = key.Find(')',6);
                    index = key.Mid( start + 1, end - 2 );
                    index.TrimLeft();
                    index.TrimRight();
                    start = atoi( index );//for comparision

                    if( start == 0 )
                    {
                        if ( flag == 1 )
                        {
                            //if declared as hex
                            CString hex = "0x";
                            msgbyte.SetAtGrow(0, hex + value.Left(2) );
                            msgbyte.SetAtGrow(1, hex + value.Mid(2,2) );
                            msgbyte.SetAtGrow(2, hex + value.Mid(4,2) );
                            msgbyte.SetAtGrow(3, hex + value.Right(2) );
                            flag = 0;
                        }
                        else
                        {
                            //if declared as dec
                            msgbyte.SetAtGrow(0,value.Left(2) );
                            msgbyte.SetAtGrow(1,value.Mid(2,2) );
                            msgbyte.SetAtGrow(2,value.Mid(4,2) );
                            msgbyte.SetAtGrow(3,value.Right(2) );
                        }
                    }
                    else
                    {
                        //if index  = 1
                        if ( flag == 1 )
                        {
                            //if declared as hex
                            CString hex = "0x";
                            msgbyte.SetAtGrow(4, hex + value.Left(2) );
                            msgbyte.SetAtGrow(5, hex + value.Mid(2,2) );
                            msgbyte.SetAtGrow(6, hex + value.Mid(4,2) );
                            msgbyte.SetAtGrow(7, hex + value.Right(2) );
                            flag = 0;
                        }
                        else
                        {
                            //if declared as dec
                            msgbyte.SetAtGrow(4,value.Left(2) );
                            msgbyte.SetAtGrow(5,value.Mid(2,2) );
                            msgbyte.SetAtGrow(6,value.Mid(4,2) );
                            msgbyte.SetAtGrow(7,value.Right(2) );
                        }
                    }
                }//end of long
            }

            if( flag == 0 )
            {
                if( msg.m_uiMsgID == INVALID )
                {
                    fprintf(logfile,"Message : %s not found in database.\n",ident);
                    nUnCnvrtdLine += 1;
                    // to decrease the percentage of conversion
                }

                fprintf(yyout,defSTR_MsgIniFormat,ident,name,
                        msg.m_uiMsgID,msg.m_cFrameFormat == 'S'? 0 : 1,dlc );

                for( int  m = 0; m < dlc; m++)
                {
                    fprintf(yyout,"%s",msgbyte.GetAt( m ));//each byte of message

                    if(m < dlc - 1)
                    {
                        fprintf(yyout,",");
                    }
                }

                fprintf(yyout,"}};");
            }
            else
            {
                flag = 0;

                if( msg.m_uiMsgID != INVALID )
                {
                    fprintf(yyout,defSTR_MsgIniFormat,msg.m_acName,name,
                            msg.m_uiMsgID,extndd,dlc );

                    for( int  m = 0; m < dlc; m++)
                    {
                        fprintf(yyout,"%s",msgbyte.GetAt( m ));//each byte of message

                        if(m < dlc - 1)
                        {
                            fprintf(yyout,",");
                        }
                    }

                    fprintf(yyout,"}};");
                }
                else
                {
                    fprintf(yyout,"STCAN_MSG %s ={ 0x%x,%d,0,%d,{"
                            ,name,decid,extndd,dlc);

                    for( int  m = 0; m < dlc; m++)
                    {
                        fprintf(yyout,"%s",msgbyte.GetAt(m ));//each byte of message

                        if(m < dlc - 1)
                        {
                            fprintf(yyout,",");
                        }
                    }

                    fprintf(yyout,"}};");
                }
            }
        }
    }
    catch(...)
    {
        CString cs;
        cs.Format(ExceptionFormat,"\"vMsgDecl\"",__FILE__,__LINE__);
        MessageBox(0,cs,"Warning",MB_OK);
        exit(0);
    }
}

/**
 * This will extract the name of the message vaiable from
 * yytext and use "memcpy" function to copy the containts
 * from "rxMsg".
 */
void vMsgCpy()
{
    // yytext  abc = (message *)this;
    CString val;
    int start;

    if( yytext[0] == ';' || yytext[0] == ',')
    {
        fprintf( yyout,"%c",yytext[0] );
    }

    val = yytext;
    start = val.Find("=",0);
    val = val.Left( start );//name of variable
    val.TrimLeft();
    val.TrimRight();
    fprintf(yyout,"memcpy( &%s, &RxMsg , sizeof( RxMsg ) );",val);
}

/**
 * This will replace "elCount" function.
 */
void velCount()
{
    //yytect elCount(ar)
    //yytext elCount(ar[][])
    CString val;
    int start ;
    val = yytext;
    start = val.Find('(',0);
    val = val.Right( val.GetLength() - start - 1 );
    val = val.Left( val.GetLength() - 1 );//name of array
    //  start = val.FindOneOf("[)");
    //  val = val.Left( start );//name of array
    val.TrimLeft();
    val.TrimRight();
    fprintf(yyout,"( sizeof(%s)/sizeof(%s[0]) )",val,val);
}

void CSelectdb::OnClose()
{
    OnCancel();
    CDialog::OnClose();
}

/**
 * This function will extract the return type and parameter of
 * of a caplFunction.
 */
void vUtilFunc()
{
    CString val, parameter;
    int start,end;
    val = yytext;
    val.TrimLeft();
    start = val.Find("(",0);
    end = val.Find(")",start);
    parameter = val.Mid( start+1 ,end - start - 1);
    parameter.TrimLeft();
    parameter.TrimRight();//parameter of function
    val = val.Left( start - 1 );
    val.MakeReverse();
    val.TrimLeft();
    start = val.Find(" ",0);
    val = val.Right( val.GetLength() - start );
    val.TrimLeft();
    val.Find("",0);
    val = val.Left( start );
    val.TrimLeft();
    val.MakeReverse();//return type

    if( val.IsEmpty() )
    {
        //in case of void function
        fprintf(yyout,"void ");
    }
    else
    {
        fprintf(yyout,"%s ",val);//return type
    }

    val = Footer;
    //extract name from footer
    val = val.Left( val.GetLength() - 3);
    fprintf(yyout,"%s(",val);
    fprintf(yyout,"%s)\n{",parameter);
    yy_pop_state();
}
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 55
#define YY_END_OF_BUFFER 56
static yyconst short int yy_accept[1326] =
    {   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   56,   55,   55,    1,   55,   55,
       55,   55,   48,   33,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   20,   55,   48,   55,   55,   55,   55,   55,
       53,   50,   53,   15,   52,   33,   32,   52,   52,   52,
       52,   52,   52,   52,   52,   52,   52,   52,   52,   52,
       52,   52,   35,   52,   55,   53,    3,   55,   53,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,   47,   54,    0,   46,   29,    0,    0,    0,    0,
       29,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   47,    0,    0,
        0,    0,   17,   16,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   51,   34,    0,   19,   18,    2,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   54,   29,    0,
       27,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       16,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   31,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   31,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   25,    0,    0,    0,
        0,   30,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   46,   30,   30,    0,    0,    0,    0,

        0,    0,    0,   30,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   30,   30,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   28,    0,   30,   30,    0,    0,    0,    0,
        0,    0,   46,   23,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       45,   30,    0,    0,   24,    0,    0,    0,    0,    0,
        0,    0,   30,   30,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   30,    0,    0,    0,    0,    4,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       24,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   30,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   46,    0,    0,    0,    0,   46,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   45,
       30,    0,   24,    0,    0,    0,    0,    0,    0,    0,
        0,   30,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   30,    0,    0,    0,    0,    0,    0,
        0,    9,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   30,    0,    0,

        0,    0,    0,    0,    0,   46,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   26,    0,    0,    0,    0,
        0,   39,    0,    0,    0,    0,    0,    0,    0,    0,
       30,    0,   46,    0,    0,    0,    0,   21,    0,    0,
       30,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   30,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   22,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   26,   26,    0,    0,
        0,    0,   46,    0,    0,    0,   39,    0,    0,   46,
        0,    0,    0,    0,   46,    0,   30,   30,    0,   43,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   30,   30,    0,   49,    0,    0,    0,    0,    0,
        8,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,   12,    0,    0,    0,    0,    0,    0,   46,    0,
        0,   36,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   14,    0,    0,    0,    0,    0,
        0,   44,    0,    0,    0,    0,   37,    0,   30,   43,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   30,    0,    0,    0,    5,    0,    0,    0,    0,
        0,    0,    0,   12,    0,    0,    0,    0,    0,    0,

        0,   46,    0,   41,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   44,    0,    0,   37,    0,   30,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   30,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   46,    0,   42,   41,   41,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,   38,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   40,   42,   42,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   38,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    6,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   40,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    7,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   13,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   13,    0,    0,    0,   11,    0,    0,    0,   13,
       10,    0,    0,   13,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    6,    5,    5,    5,    5,    1,    7,
        8,    9,   10,   11,   10,   12,   13,   14,   14,   14,
       14,   14,   14,   14,   14,   14,   14,   15,   16,    1,
       17,    5,    1,   18,   22,   23,   24,   25,   26,   27,
       28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
       21,   38,   39,   40,   41,   42,   43,   44,   45,   46,
       19,   20,   19,    5,   21,    5,   22,   23,   24,   25,

       26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
       36,   37,   21,   38,   39,   40,   41,   42,   43,   44,
       45,   46,   47,    1,   48,    5,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[49] =
    {   0,
        1,    2,    3,    4,    5,    6,    7,    6,    5,    8,
        9,   10,    5,   11,    5,   12,   13,    5,   14,    1,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,    5,    5
    } ;

static yyconst short int yy_base[1359] =
    {   0,
        0,    0,    0,   35,   71,    0,  119,    0,    2,    5,
      167,    0,    0,   11,    4,   20,   11,  215,   16,   19,
       15,   23,   29,   41, 3529, 4660, 3501, 4660, 3515, 3486,
     3470,  261, 4660, 4660,  216,   44,  303,  217,  235, 3474,
       12,    0, 3460, 3428, 3436, 3429,   18, 3401, 3413,   24,
       27, 3398, 4660,  242,  220,  253,   53,  276,  342,  204,
     4660, 4660,   54, 4660, 4660, 4660, 4660,  216,  287,  309,
      320,  326,  380,  324,  301,  337,  339,  355,  361,  318,
      264, 3419, 4660, 3420, 3370, 3398, 4660, 3394, 3390, 3361,
     3358, 3334,  246,  419,  257,  244,  294,  245, 3330,  277,

      326, 3350,    0,  399, 4660,  461,  405,  422,  429,  442,
     3347,  435,  365,  434,  401,  416,  443,  448,  460,  457,
      468,  479,  476,  484,  487,  492,  500,  507,  508,  515,
        0,  549,  553,    0,  422, 3321, 3323, 4660,  556,  347,
      388,  474, 4660,    0,  559,  564,   56,  383,  516,  558,
      563,  567,  570,  274,  573,  465,  574,  578,  583,  587,
      591,  594, 4660, 4660, 3303, 4660, 4660, 4660, 3328, 3304,
     3319, 3297,  609,  433,  576,  568, 3314,    0, 4660,  626,
     3315, 3280, 3290,  341, 3280, 3265, 3263, 3247,  629,    0,
      635,  645, 3268,  587,  617,  629,  634,  622,  643,  648,

      651,  659,  675,  680,  668,  658,  685,  692,  693,  704,
      721,  701,  714,  734,  735, 3224, 3229,  495,  615,  633,
        0,  742,  663,  764,  697,  765,  768,  798,  769,  774,
      778,  777,  786,  818,  781,  785, 3241, 3213,  807, 3213,
     3202,  663,  745,  777,  839, 3187, 3173, 3169, 3179,    0,
     3167, 3138, 3144,  849, 3151,  769,  797,  833,  853,  887,
      861,  862,  879,  871,  880,  899,  891,  906,  909,  916,
      924,  927,  934,  942,  898,  935,  956,  947,  957,  965,
      972,  979,  919,  980,  987,  995,  998,  981, 1036, 1016,
     1021, 3146, 3147,  848,  716, 1003,  836,  812,  844, 1065,

      855, 1045, 1049,  994,  987, 1050, 1054, 1053, 1058, 1069,
     1070, 1009, 1087, 1078, 1092, 1098, 1099, 1102, 1103, 1107,
     1108,  410, 1111, 3138, 1129, 3132, 3118, 3116, 3090, 3071,
     3074, 3051, 1132, 1112,  859, 3046, 3042,  422, 3030, 2987,
     2987, 2974, 2978, 2985, 2979, 2964, 4660, 2957, 2945, 2950,
     2933, 1150, 1110, 1126, 1133, 1140, 1174, 1147, 1159, 1160,
     1170, 1175, 1178, 1189, 1188, 1196, 1205, 1204, 1212, 1219,
     1226, 1167, 1227, 1235, 1234, 1242, 1245, 1255, 1256, 1263,
     1264, 1272, 1284, 1277, 1291, 1292, 1299, 1302, 1309, 1321,
     1318, 1328, 1362, 1368, 1371, 2934, 1351, 1389, 2925, 2917,

     1294,  901, 1378,  579, 1136, 1220, 1373, 1383, 1386, 1273,
     1393, 1241, 1398, 1402, 1401, 1409, 1419, 1420, 1423, 1410,
     1429, 1424, 1430, 1440, 1441, 1447, 1448, 1453, 1460, 1461,
     1464, 1465, 1472, 1483, 1484, 1034, 1115, 1487, 2905, 1485,
     2892, 2883, 2877, 2892, 2890, 2883, 2865, 1504, 1186, 1513,
     2862, 2860, 2850, 2848, 2806, 2793, 2794,  304, 2771, 2757,
     2741, 1523, 4660, 2727, 1529, 2733, 1505, 1510, 1521, 1528,
      375, 1568,  541,  908, 1574, 1547, 1555, 1529, 1558, 1566,
     1569, 1581, 1580, 1588, 1595, 1605, 1610, 1613, 1620, 1625,
     1634, 1633, 1641, 1681, 1642, 1661, 1656, 1664, 1704, 1679,

     1680, 1719, 1697, 1702, 1705, 1713, 1716, 1724, 1725, 1764,
     1767, 2708, 1740, 1778, 1784, 1758, 1765, 2708, 1803, 1047,
     1430, 1806, 1144, 1650, 1778, 1499, 1523, 1762, 1713, 1800,
     1803, 1543, 1625, 1804, 1807, 1810, 1814, 1815, 1818, 1822,
     1825, 1829, 1850, 1836, 1847, 1853, 1854, 2704, 1857, 1860,
     1869, 1864, 1873, 1876, 1288, 1877, 2695, 1201, 1897, 1233,
     2682, 2664, 2684, 2653, 2651, 1903, 2659, 1915, 1144, 1918,
     1924, 1310, 2639, 2633, 2623, 2623, 2641, 2612, 2603, 2593,
     2592, 2597, 2571, 1934,    0, 2569, 2550, 1907, 1915, 1922,
     1875, 1956, 1962, 1966, 1946, 1914, 1951, 1965, 1954, 1972,

     1973, 1980, 1983, 1990, 1991, 1998, 1999, 2007, 2010, 2022,
     2023, 2030, 2033, 2071, 2571, 2044, 2078, 2058, 2092, 2098,
     2072, 2075, 2080, 2088, 2100, 2089, 2097, 2107, 2115, 2083,
     2535, 2149, 2155, 2127, 2132, 2524, 2166, 2170, 2173, 2545,
     2176, 1987, 2040, 2170, 1917, 2174, 2173, 2179, 2186, 1980,
     2190, 2193, 2198, 2202, 2203, 2207, 2208, 2211, 2214, 2215,
     2220, 2223, 2250, 2538, 2230, 2244, 2247, 2250, 2251, 2254,
     2262, 2263, 2267, 1572, 2270, 2536, 2492, 2486, 2485, 2453,
     2447, 2295, 2440, 1454, 1329, 2433, 2432, 2433, 2411, 2431,
     2400, 2390, 2376, 2386, 2359, 2366, 2338,    0, 2269, 2276,

     2279, 2287, 2321, 1592, 2325, 2331, 2304, 2305, 2315, 2318,
     2357, 2332, 2346, 2345, 2357, 2358, 2365, 2366, 2377, 2374,
     2382, 2385, 2393, 2400, 2355, 2434, 2408, 2450, 2423, 2461,
     2354, 2468,  606, 2471, 2409, 2446, 2447, 2463, 2487, 2470,
     2508, 2514, 2520, 2499, 2494, 2533, 2537, 4660, 2540, 2548,
     1689, 2335, 2541, 2275, 2483, 2545, 2327, 2546, 2551, 2554,
     2558, 2293, 1880, 2394, 2363, 2563, 2581, 2582, 2555, 2586,
     2587, 2590, 2492, 2591, 2595, 2602, 2605, 1744, 2609, 2339,
     2305, 2292, 2301,  310, 2278, 2256, 2260, 2636, 1363, 2245,
     2230, 2212, 1614, 2231,  326, 2217, 2194, 2211, 2166, 4660,

     2169, 2611, 2619, 2622, 2660, 1774, 2666, 2675, 2647, 2614,
     2655, 2662, 2669, 2670, 2677, 2678, 2689, 2696, 2697, 2707,
     2710, 2715, 2718, 2725, 2730, 2735, 2769, 1531, 2177, 2742,
     2780, 2165, 2148, 2786, 2765, 2768, 2806,  788, 2809, 2815,
     2789, 2792, 2804, 2831, 2147, 2814, 2838, 2114, 2854, 2857,
     2833, 2836, 2877, 2880,  240, 2659, 2620, 2764, 2862, 2873,
     2832, 2840, 2780, 2876, 2610, 2876, 2853, 2307, 2893, 2684,
     2896, 2713, 2905, 2909, 2912, 2916, 2920, 2924, 2927, 2931,
     2932, 1833, 1884, 2935, 4660, 2099, 2102, 2134, 2065, 2052,
     4660, 2949, 2081, 2922, 2036, 2043, 2026, 2038, 2279, 2006,

     2001, 4660, 2008, 2966, 2938, 2941, 2979, 2985, 2027, 1936,
     2991, 4660, 3001, 2977, 2978, 2988, 2989, 2996, 2997, 3004,
     3012, 3019, 3007, 3020, 3027, 3030, 3035, 3038, 3045, 3046,
     3056, 3053, 3071, 3061, 4660, 3105, 3111, 3083, 3090,  632,
     3128, 2994, 3104, 3105, 3064, 2001, 3144, 3116, 1942, 3155,
     3127,  868,  450, 3149, 3112, 3153, 2948, 3105, 3156, 3157,
     3160, 3166, 3167, 3173, 3174, 3177, 3178, 3184, 3187, 3199,
     3200, 3204, 3207, 3193, 3210, 3219, 3222, 3228, 3232, 3233,
     3236, 3008, 3237, 1943, 1918, 1908, 1863, 1875, 1842, 1853,
     1820, 1833, 1781, 1788, 1759, 1761, 1728, 3251, 3223, 3265,

     3271, 1735, 1734, 3277, 1683, 3251, 3256, 3263, 3264, 3271,
     3278, 3312, 3288, 3287, 3295, 3300, 3309, 3316, 3323, 3324,
     3331, 3332, 3339, 3346, 3347, 3354, 3362, 3388,  292, 3363,
     3370, 3404, 3305, 3411, 3394, 3417, 3395,    0, 3405, 1019,
     3423, 3431, 3434, 3435, 3438, 3439, 3442,    0, 3445, 3446,
     3454, 3457, 3462, 3465, 3466, 3470, 3471, 3475, 3480, 3481,
     3487, 3490, 3494, 3495, 3499,   31, 3505, 3509, 1922, 3514,
     1702, 1694,  750, 1677, 1640, 1633, 1608, 1586, 1579, 1576,
     3529, 3508, 3542, 1588, 1584, 3549, 3552, 3532, 1973, 3528,
     3529, 3537, 3538, 3545, 3546, 3554, 3561, 3566, 3573, 3576,

     3583, 3586, 3593, 3598, 3601, 3608, 1125, 3616, 3654, 3657,
     3631, 3642,  785, 3632, 3590, 3638, 3659, 3666, 3670, 3674,
     3677, 3678, 3681, 3583, 3684, 3685, 3690, 3693, 3696, 3697,
     3704, 3708, 3709, 3703, 1559, 3725, 1529, 1489, 1476, 1483,
     1472, 1443, 1430, 3742, 3749, 3725, 1420, 3753, 3763, 3766,
     2252, 3739, 3773, 3751, 3758, 3748, 3759, 3766, 3769, 3781,
     3784, 3791, 1409, 3807, 3792, 3799, 3800, 1506, 3829, 3830,
      376, 3833, 3834, 3838, 3842, 3729, 3843, 3846, 3851, 3850,
     3862, 3867, 3870, 1403, 1430, 1388, 1356, 1314, 1283, 1250,
     1230, 1133, 3883, 1095, 3855, 3895, 3902, 3874, 3879, 3887,

     3896, 3895, 3903, 3904, 3912, 1610, 3917, 3922, 3925,  618,
     3877, 3953, 3954, 3957, 3960, 3961, 3964, 3965, 3968, 3971,
     3977, 3981, 3977, 1072, 1056, 1049, 1043, 1012,  980, 4009,
     3987, 3992, 4000, 1828, 3999, 4007, 4041, 3994, 4035, 4036,
     3982, 4039,  979,  940,  921,  897,  845, 4052, 4035, 4038,
      654, 4043, 4046, 4084, 4051, 4077, 4078, 4082,  824,  825,
      802, 4095, 4099, 4117, 4073, 4089, 4127, 4105, 4133, 4133,
     4134, 4138,  799,  728,  713, 4151, 4660, 4156, 2568, 4139,
     4173, 4177, 4184, 4178,  703,  693,  661, 2101, 4129, 4195,
     4202, 1158, 4195,  611,  610,  536, 2874, 4212, 4219, 1075,

      491,  471,  357, 4228, 4234, 1172, 1512,  346,  296,  240,
     4237, 1999, 1329, 4244,  213, 4660,  191, 1723, 4252, 4660,
     4660, 4259, 4262, 4660, 4660, 4278, 4292, 4306, 4320, 4333,
     4344, 4356, 4366, 4380, 4394, 4408, 4421, 1231, 4433, 4446,
     1282, 4460, 4473,  942, 4485, 4497, 4511, 4525, 4538, 4551,
     4564, 1646, 4576, 4590, 4604, 4618, 4631, 4645
    } ;

static yyconst short int yy_def[1359] =
    {   0,
     1326, 1326, 1326, 1326, 1325,    5, 1325,    7, 1327, 1327,
     1325,   11, 1328, 1328, 1328, 1328, 1329, 1329, 1327, 1327,
     1326, 1326, 1327, 1327, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1330, 1325, 1325, 1330, 1325, 1331, 1330, 1331,   39,
       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
       39,   39, 1325, 1330, 1325, 1330, 1325, 1330, 1330,   59,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1332, 1332,
     1332, 1332, 1332,   73,   73,   73,   73,   73,   73,   73,
       73, 1325, 1325, 1325, 1333, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1330, 1330,   59,   94,   59,   59,   59,

       59, 1325, 1334, 1325, 1325, 1325,   39, 1325,   39,   39,
      106,   39,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
       54, 1325, 1330,   59,   59, 1325, 1325, 1325, 1325,   59,
       59,   59, 1325, 1335, 1325, 1332,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146, 1325, 1325, 1333, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325,   59,   59,   59, 1325, 1334, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,  106,
     1325, 1325,  106,  112,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      203,  112,  112,  112,  112, 1325, 1325,   59,   59,   59,
     1335,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  228,  146,  146, 1325, 1325, 1325, 1325,
     1325,   59,   59,   59, 1325, 1325, 1325, 1325, 1325, 1336,
     1325, 1325, 1325, 1325, 1325,  112,  112,  112,  112,   39,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,   39, 1337,  112,
      112, 1325, 1325,   59,   59,   59,  146,  146,  146,  146,

      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146, 1338,  146, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325,   59,   59,   59, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1339,  112,  112,  112,  112, 1340,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112, 1325, 1325, 1337,  395,  112,   39, 1325, 1325,

       59,   59,   59, 1341,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146, 1338, 1338,  146, 1325, 1342,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1340,   59,   59,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1339,  465,  112,  112,  112,  112,
     1340, 1340, 1340, 1340, 1340,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,   39,  112,  112,  112,  112,   39,  112,

      112,   39,  112,  112,  112,  112,  112,  112,  112, 1325,
     1325,  395,  112, 1325, 1325,  112,  112, 1325, 1325,   59,
       59, 1343, 1341, 1341,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  543,  146,  146,
      146,  146,  146,  146, 1338,  146, 1325, 1342, 1342, 1342,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1340,   59, 1325,
     1325,   59, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1344, 1325,  465,  112,  112,  112,
      112, 1340, 1340,   39,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112, 1325, 1345,  112,   39,  112, 1325, 1346,
      112,  112,  112,  112,  112,  112,  112,  112,  112, 1325,
      395,   39, 1325,  112,  112, 1325, 1343,   59, 1343, 1343,
     1343, 1341,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146, 1325, 1345,  146,  146,  146,  146,  146,  146,
      146,  146,  146, 1338,  146, 1325, 1325, 1325, 1347, 1325,
     1325, 1325, 1325,   59,   59, 1325, 1325, 1325, 1325, 1348,
     1325, 1325, 1325, 1325, 1325, 1344, 1325,  465,  112,  112,

      112,  112, 1340, 1340, 1325, 1349,  112,  112,  112,  112,
       39,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112, 1345, 1325,  112, 1350,  112, 1346,
     1346, 1346, 1346,   39,  112,  112,  112,  112,   39,  112,
     1351, 1325, 1325,  112,  112, 1343, 1350, 1325, 1343, 1343,
     1341,  146,  146,  146,  146,  146,  543,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146, 1352,  146, 1325,
     1325, 1325, 1347, 1347, 1325, 1325, 1325,  450,   59, 1325,
     1325, 1325, 1325, 1348, 1348, 1325, 1325, 1325, 1325, 1325,

     1325,  112,  112,  112,   39, 1340, 1349, 1349,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112, 1325, 1325, 1325,  112,
     1350, 1350, 1350, 1350,  112,  112, 1346, 1346, 1325, 1325,
      112,  112,  112, 1325, 1353,  112, 1351,  847, 1325, 1325,
      112,  112, 1350, 1343, 1343,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  759,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146, 1352, 1352,  146, 1325, 1325, 1325, 1347, 1325, 1325,
     1325, 1325, 1353,   59, 1325, 1325, 1325, 1325, 1348, 1325,

     1325, 1325, 1325, 1325,  112,  112,   39, 1325, 1354, 1340,
     1349, 1325, 1349,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112, 1325, 1350, 1350,  112,  112, 1346,
     1325, 1325,  112,  112,  112, 1353, 1353,  112,  847, 1325,
      112,  398, 1343,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  759,  146,  146,  146,  146,  146,  146,
      146, 1352,  146, 1325, 1355, 1347, 1325, 1325,  450, 1325,
     1325, 1325, 1325, 1348, 1325, 1325, 1325, 1325,  112,   39,

     1325, 1356, 1354, 1354, 1340,  112,  112,  112,  112,  112,
      112,   39,  112,  112,  112,  112,  112,  112,  112,  112,
      112,  112,  112,  112,  112,  112,  112, 1350, 1350,  112,
      112, 1346, 1325,   39,  112, 1353,  112,  847,  112, 1343,
      146,  146,  146,  146,  146,  146,  146,  543,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  543,  146,  146, 1352,  146,
     1325, 1355, 1355, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325,  112, 1325, 1357, 1356, 1356, 1354, 1325, 1340,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  112,  112, 1350,  112, 1346, 1346,
      112,  112, 1343,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  759, 1358, 1355, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325,  112, 1357, 1357, 1356, 1325,
     1340,  112,   39,  112,  112,  112,  112,  112,  112,  112,
      112,  112, 1350, 1346,  112,  112,  112, 1343,  146,  146,
      543,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146, 1358, 1358, 1355, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325,  112, 1357, 1340,  112,  112,  112,

      112,  112,  112,  112,  112, 1350,  112,  112,  112, 1343,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146, 1358, 1325, 1325, 1325, 1325, 1325, 1325, 1340,
      112,  112,  112, 1350,  112,  112, 1343,  146,  146,  146,
      146,  146, 1358, 1325, 1325, 1325, 1325, 1340,  112,  112,
     1350,  112,  112, 1343,  146,  146,  146,  146, 1325, 1325,
     1325, 1325, 1340, 1340,  112,  112, 1350,  112, 1343,  146,
      146,  146, 1325, 1325, 1325, 1325, 1325, 1340, 1340,  112,
     1350, 1343, 1343,  146, 1325, 1325, 1325, 1340,  112, 1350,
     1343, 1343,  146, 1325, 1325, 1325, 1340, 1350, 1350, 1343,

     1325, 1325, 1325, 1340, 1350, 1350, 1343, 1325, 1325, 1325,
     1340, 1340, 1350, 1343, 1325, 1325, 1325, 1350, 1343, 1325,
     1325, 1350, 1350, 1325,    0, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325
    } ;

static yyconst short int yy_nxt[4709] =
    {   0,
     1325,   27,   33,   27,   62,   28,   33,   62,   82,   83,
       27,   26,   29,   33,   63,   27, 1325,   63,   62,   82,
       87,   62,   33,   84,   86,   83,   26,   86,   87,  115,
       26,   62,  116,   30,   88,   31,   27,  117,   27,   84,
       28,   89,   88,   62,  113,   27,  114,   29,   64,  126,
       27,   64,  102,   89,  122,  128,  103,   26,  123,  147,
      297,  138,  143,  127,  129,  103,  144,  193,   30,  147,
       31,   26,   32,   33,   32,   26,   34,   26,   26,   26,
       26,   35,   26,   36,   37,   26,   38,   26,   26,   26,
       26,   39,   39,   39,   40,   39,   41,   42,   43,   39,

       44,   39,   45,   39,   46,   39,   47,   48,   49,   50,
       51,   39,   39,   52,   39,   39,   39,   53,   53,   26,
       54,   55,   54,   26,   26,   26,   26,   26,   26,   56,
       26,   57,   58,   26,   54,   26,   26,   26,   26,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   59,   58,   58,   58,   58,   58,   60,   58,
       58,   58,   58,   58,   58,   53,   53,   65,   65,   33,
       65,   65,   66,   67,   67,   65,   65,   67,   65,   68,
       69,   65,   67,   65,   65,   65,   65,   70,   70,   70,
       71,   70,   72,   73,   74,   70,   75,   70,   76,   70,

       70,   70,   77,   78,   70,   79,   80,   70,   70,   81,
       70,   70,   70,   65,   65,   26,  577,   95,   97,   95,
       97,  132,  132,  132,  138, 1321,   95,   95,  103,   96,
       26,   95,   97,  142,   26,  132,  104,  104,  104,   98,
       98,  105,   96,  131,  132,  131,  111,  173,  173,  173,
       99,  108,  133,  136,  133,  748,  133,  131,   95,  137,
       95,   26,   94,  133,   94,  953,  174,   95,  133,   96,
       96,   95,   95, 1317,  110,  134,   97,  139,  139,  139,
       98,  135,   96,   96,   98,  193, 1325,  147,  145,  145,
      145, 1325,  108,  147,   99,   97,  147,   97,  106,  100,

      146,  162,  175,  101,  104,  104,  104,  935, 1316,  105,
      145,  145,  145,  228,  106,   96,  107, 1107,  888,  108,
      111,  145,  145,  145,  784,  579,  148,  145,  145,  145,
      147,  111,   96,  147,  899,  155,   96,  111,  147,  580,
      795,  149,  110,  139,  139,  139,  161,  147,  148,  154,
      147,   96, 1325,  147, 1315,  147,  147, 1325,  108,  148,
      150,  147,  156,  176,   96,  148,  147,  140,  147,  147,
      248,  147,   96,  249,  147,  157,  147, 1325, 1310,  158,
      141,  145,  145,  145,  147,  218,  160,  147,  198,  474,
      147,  111,  147,  147,  193,  159,  147,  109,  147,  109,

      104,  104,  104,  109,  147,  105,  189,  189,  189,  151,
      179,  222,  152,   96, 1213,  108,  190,  153,  107,  148,
       94,  193,   94,  191,  191,  191,   96,  219,  192,   95,
      189,  189,  189,  200,   97,  109,  189,  189,  189,  109,
      193,  201,   98,  189,  189,  189,  193,   96,  109,  437,
      109,  142,   99,  193,  109,  199,  453,  100,   96,  454,
       96,  101,  180,  180,  180,  748,  109,  195,  109,  196,
      194,  242,  109,  197,  181,  109,  193,  109,  147, 1309,
      109,  202,  109,  182,  183,  184,  109,  203, 1040,  109,
      185,  109,  109,  186,  109,  109,  204,  187,  109,   96,

      109,  205,  109,  188,  207, 1308,  206,  220,  109,  230,
      109,  109,   96,  109,  109,  208,  109,  109,  109,  109,
       96,  109,  109,  209,  109,  210,  109,  193,  194,  147,
      109,  211,  109,  294,  109,  212,  213,  214,  109,  109,
      109,  109,  109, 1325,  215,  109,  109,  109,  223,  109,
      132,  132,  132,  109,  133,  474,  133,  139,  139,  139,
      145,  145,  145,  133,  132, 1325, 1325, 1325,  133,  193,
      179,  147,  108, 1303,  193,  190,  147,  146,  193,  224,
      147,  193,  136,  147,  193,  193,  147,  147,  137,  193,
      193,  147,  226,   96,  193,  225,  147,  244,  193,  231,

      147,   96,  193,  148,  147,  193,   96,  147,  227,  229,
      173,  173,  173,  732,   96,  243,  256,  232,  524,  109,
      235,  109,  233,  236, 1302,  109,  234,  180,  180,  180,
      189,  189,  189,  748,  838,  105,  191,  191,  191,  732,
       96,  192,  241, 1237,  295,  108,  254,  254,  254,  257,
     1301,  109,  258,   96,  109,  109,  109,  261,  296,  260,
      109,  109,  187,  109,  259,  262,  109,  109,  109,  935,
     1032,   96,  109,  263,  193,  109,  147,  109,  255, 1267,
      109,  109,  109,  109,  265,  109,  109, 1296,  333,  109,
      109,  109,  109,  109,  264,  298,  274,  109,  266,  267,

      109,   96,  109,  194,  273,  268,  109,  109,  193,  109,
      147,  269,  109,  270,  109,  272,  271,  109,  109,  275,
      194,  194,  300,  109,  109,  109,  109,  109,  276,  278,
      109,  109, 1295,  109,  277,  109,  109,  288,  109,  109,
     1294,   96,  109,  279,  109,  280,  109,  281,  109,  402,
     1287,  282,  289,  193,   96,  147,  283,  284, 1136,  285,
      286,  290,  109,  287, 1073, 1286,  109,  109,  109,  109,
       96,  297,  109,  109,  291,  193,  193,  147,  147,  193,
      193,  147,  147,   96,  334,  193,  299,  147,  193,  193,
      147,  147,  193,  302,  147,  732,  193,  193,  147,  147,

      748,  109,   96,  109,  309,  222, 1168,  352,  301,  193,
      310,  147,  311,  312,  222,   96,  335,  940,  353,  322,
     1285,  303,  304,  193,  323,  147,  222,  313,  305,  109,
      326,  109,  327,  405,  306,  109,  307, 1275,  328,  308,
      314,  147,  315,  329,  316,  330, 1274,  193,  317,  147,
      254,  254,  254,  318,  319,  193,  320,  147,  354,  147,
      321,  336,  337, 1273,  338,  109,  193,  109,  147,  401,
      339,  109,  340,   96,  404,  341,  406,  342,  343,  355,
      344,  345,  255, 1262,  450,  109,   96,  356,  357,  357,
      357,  109,  413,  109,  359,  109,  109,   96,  193,  109,

      109,  358,  360,  109,  109,  109,  361,  110,  366,  109,
     1325,  109,  109,  362,  367,  363,  364,  109,  109,  368,
      369,  365,  474,  109,  379,  109,  521,  370,  371,  109,
      109,  109,  109,  109, 1261,  372,  109,  109,  109,   96,
      109,  109,  388,  109,  109,  375,  373,  109,  109,  696,
      109,  109,  696,  109,  109,  374,  109,  109,  109,  109,
     1260,  109,  109,  378,  376,  109,  109,  109,  109,  109,
      380,  377,  109,  109,  109,  381,  109,  382, 1259,  109,
      109,  109,  393,  393,  393,  109,  383,  394,  109,  109,
      109,  109,  193, 1185,  109,  109,  384,  109,  193,  109,

      147,  386,  385,  109,  109,  193,  109,  147,  387, 1247,
      109,  109,  109,  109,  109,  389,  419,  109,  109,  109,
      193,  109,  147,  194,  391,  109,  390,  109,   96,  109,
      109,  418,  109,  109,  748,  392,  109,  189,  189,  189,
      403,   96,  105,  397,  426,  193,  398,  193,  109,  194,
      109,  577,  108,  109,  109,  109,  193, 1113,  147,  109,
      193,  193,  147,  147,  193,  193,  147,  147,  577,  193,
      416,  147,  638,  437,  422,  396,  193,  417,  147,  414,
      193,  193,  147,  147,  415,   96, 1246,  420,  407,  193,
      748,  147,  408,  421, 1245,  423,  425, 1244,  193,  409,

      147,  410,  411,  193, 1307,  147,  424,  412,  427,  193,
      193,  147,  147,  193,  193,  147,  147,  428,  193,  193,
      147,  147,  193, 1229,  147,  432,  193,  430,  431,  429,
      440,  440,  440,  448,  448,  448,  438,   96,  433,  222,
      935,  449,  467,  555,  109,  435,  434,  193,  109,  147,
       96,  189,  189,  189,  437,  193,  105,   96,  468,  469,
      109,  193, 1228, 1163,  109,  109,  108,  109,  525,  684,
       96,  109,  470,  748,  109,  472,  357,  472,  109,  109,
      473,  476,   96,  524,  477,  109, 1300,  935,  474,  466,
      475,  109,  478,  109,  109,  479,  480,  109,  109,  109,

     1313,  109,  109, 1325,  109,  109,  490,  109,  109,  109,
      109,   96,  109,  109,  482,  560,  109,  484,  481,  569,
      109,  109,  109,  109,   96,  483,  109,  109,  109,  485,
      109,  193,  194,  147,  109, 1325,  109,  109,  109,  109,
      436,  436,  486,  109,  109,  526,  109,  560,  488,  487,
      109,  109,  193,  109,  147,  489,  492,  109,  109,  109,
      109,  109,  491,  194,  109,  109,  493,  109,  109,  109,
      495, 1227,  109,  109,  109, 1226,  109,  109,  532,  109,
      109,  494,  496,  109,  193,  497,  147,  109,  109,  109,
      109,  523,  523,  109,  109,  109,  109,  109,  109,  193,

      498,  109,  109,  499,  500,  194,  109,  501,  577,  109,
      109,  109,  194,  530,  502,  109,  109,  674,  109,   96,
      503,  520,  109,  109,  504,  109,  109,  437, 1225,  109,
      109,  109,   96,  109,  109,   96,  109,  109,  505,  502,
      109,  109,  507,  109,  935,  685,  506,  109,   96,  194,
      109,  508,  109,  109,   96,  109,  109,  509, 1318,  109,
      109,  789,  109,  393,  393,  393,  109,   96,  394,  510,
      510,  510,  189,  189,  189,  511,  513,  105,  108,  522,
      522,  522,  193,  109,  193,  109,  147,  108,   96,  109,
      514,  514,  514, 1224,  193,  515,  147,  193,  894,  147,

      193,   96, 1073,   96,  193,  527,  147,  529,  528,  193,
      396,  147,  193,  193,  147,  147,   96, 1185,  531,  533,
      193,  193,  147,  147,  935,  516,  534, 1148,  517,  222,
      193,  193,  147,  147,  193,  193,  147,  147, 1223,  535,
      193,  193,  147,  147, 1185,  540,  536, 1206,  537,  538,
      541,  193,  193,  147,  147,   96,  542,  222,  193,  193,
      147,  147,  539, 1192,  193,  544,  147,  403,   96,  543,
      545,  193,  193,  147,  147,  193,  193,  147,  147,   96,
      547,  222,  577,  193,  546,  147,  559,  440,  559,  549,
      548,  788,   96,  550,  193,  193,  147,  147,  193,  560,

      147, 1191,  548,  551,  553,  568,  448,  568, 1190,  552,
      193,  222,  147,  554,  570,  570,  570, 1189,  474,  571,
      475,  748,  644,  556,  584,  584,  584,  748, 1188,  585,
      189,  189,  189, 1210,  193,  105,  147,  588,   96,  109,
      193,  828,  109,  109,  109,  108,  828,  829,  109,  589,
     1314,   96,  572,  590,  193,  109,  147,  591,  645,  109,
      109,  109,  109,  109,  596, 1187,  109,  109,  466,  472,
      357,  472,  651, 1185,  473,  592,  191,  592,  595,  109,
      593,  109,  474,  193,  475,  109,  594,  109,  474,  109,
      109, 1086,  109,  109, 1325, 1148,  109,  597,  109,  598,

      109,  109,  600,  109,  109, 1143,  474,  109,  599,  602,
      778,  437,  109,  109,  109,  109, 1142,  806,  109,  109,
      109,  604,  109,  601, 1141,  935,  109,  109,  605,  109,
      606, 1234,  603,  109,  607,  896,  193,  109,  147,  109,
      897, 1140,  109,  109,  109,  109,  609,  109,  109,  608,
      898,  109,  109,  194,  109,  882,  882,  109,  109,  109,
      611,  193, 1139,  109,  610,  109,  109,  109,  109,  652,
      612,  109,  109,  109,  109,  109,  109, 1138,  642,  109,
      616,  613,  614,  614,  614, 1325,  617,  615,  618,  524,
      109, 1137,  193,  109,  109,  109,  109,  474,  109,  109,

      193,  622,  109,  494, 1089,  619,  619,  619, 1073,  194,
      620,  109,  109,  109,  109,  193, 1135,  109,  109,  621,
      614,  614,  614,  623,  193,  615,  147,  624,  524,  109,
      193,  109,  194,  194,  109,  109,  109,  109,  935,  109,
      109, 1004, 1086,  109,  625,  109,  647,  109,  109,  628,
      109,  109,  626,  627,  109,  193,  109,  109,  109,  109,
     1080, 1322,  109,  109,  629,  510,  510,  510,  630,  630,
      630,  511,  109,  193,  109,  147, 1325,  632,  109,  514,
      514,  514, 1079,  883,  515,  633,  633,  633,  474,  193,
      109,  147,  109,  194,  108,  634,  109,  109,  577,  109,

      635,  646,  795,  109,  637,  637,  637,  639,  639,  639,
      643,  193,  910,  147,  193,  193,  147,  147,  193, 1078,
      147,  193,  641,  147,  649,  193,  193,  147,  147,  193,
      653,  147,  655,  193,  656,  147,  193,  654,  147,  648,
      193,  658,  147,  935,  193,  650,  222,  193,  660,  147,
      657,  663,  663,  663, 1077, 1251,  664,  659,  193, 1076,
      147,  193,  661,  147,  193,  193,  147,  147,  193,  662,
      147,  193,  883,  147,  665,  193,  577,  147,  222,  666,
      193,   96,  147,  668,  193,  669,  147,  193,  193,  147,
      147,  193,  543,  147,  667,  193, 1075,  222,  559,  440,

      559,  868, 1074,  671,  682,  682,  682,  109,  670,  702,
      672,  560,  982,  109,  675,  673,  568,  448,  568,  570,
      570,  570,  784,  883,  571,  633,  633,  633,  193,  474,
      147,  475, 1073,  193,  108,  584,  584,  584, 1325,  109,
      585,  109,  699,  194,  700,  109,  109,  109,  109,  109,
      474,  701,  708,  109,  109,  754,  109,  592,  191,  592,
      109,  883,  593,  703,  254,  703, 1071,  705,  705,  705,
      474, 1038,  706,  709, 1005, 1325,  474,  193,  109,  194,
      109,  707,  194,  109,  109,  109,  109,  474,  109,  710,
      711,  193,  712,  147,  194,  704,  713,  109,  193,  109,

     1151, 1325,  714,  109,  109,  109,  109,  109,  947,  760,
      109,  109,  109,  474,  109,  109,  751,  109,  109,  715,
      716,  109,  109,  109,  109,  109,  524,  717,  109,  718,
      109,  109,  719,  109, 1004,  997,  109,  109,  720,  109,
      996,  109,  109,  995,  109,  109,  721,  722,  109,  494,
      194,  193,  723,  147,  109,  109,  109,  109,  502,  993,
      109,  109,  109,  992,  109,  109,  991,  109,  109,  724,
      990,  109,  614,  614,  614,  752,  109,  615,  109,  728,
      728,  728,  727,  729,  630,  630,  630,  108,  947,  193,
      109,  988,  109,  619,  619,  619,  109,  502,  620,  730,

      730,  730,  987, 1325,  109,  732,  109,  109,  108,  734,
      109,  737,  109,  109,  109,  474,  985,  194,  109,  494,
      109,  109,  109,  109,  735,  736,  109,  109,  194,  109,
     1297,  109,  109,  984,  109,  109,  738,  733,  109,  109,
      740,  109,  949,  194,  739,  109,  986,  109,  784,  109,
      742,  742,  742,  109,  947,  743,  633,  633,  633,  109,
      193,  109,  744,  935,  745,  109,  109,  746,  746,  746,
      109,  747,  747,  747,  639,  639,  639,  749,  749,  749,
      935,  193,  750,  147,  193,  193,  147,  147,  748,  641,
      193,  748,  147,  828,  904,   96,  755,  193,  757,  147,

      903,  193,  222,  147,  193,  753,  147,  222,   96,  193,
      759,  147,  756,  193,  193,  147,  147,  758,  193,  193,
      147,  147,  193,  902,  147,  193,  193,  147,  147,  761,
      762,  193,  901,  147,  193,  763,  147,  765,  900,  768,
      764,  193,  222,  147,  769,  795,  766,  767,  548,  577,
      543,  663,  663,  663, 1325,  193,  664,  147,  193,  770,
      147,  193,  193,  147,  147,  193,  474,  147,  771,  772,
      895,  577,  548,  193,  193,  147,  147, 1197,  193,  774,
      147,  193,  222,  147,  775,  891,  193,  773,  147,  543,
      222,  994,  777,  795,  890,  222,  682,  682,  682,  889,

      757,  109,  776,  802,  193,  779,  147,  109,  109,  803,
      109,  109,  805,  804,  109,  784,  867,  109,  193,  109,
      147,  109,  703,  254,  703,  109,  705,  705,  705,  887,
      711,  706,  807,  807,  807,  474,  109,  109,  809,  109,
      968,  108,  109,  109,  810,  886,  193,  109,  147,  109,
      109,  885,  109,  109,  704,  147,  109,  811,  614,  614,
      614,  732,  726,  615,  109,  801,  109,  813,  193,  856,
      109,  812,  814,  800,  193,  815,  147,  109,  109,  817,
      109,  819,  818,  109,  816,  194,  820,  869,  799,  109,
      109,  109,  109,  711,  798,  109,  109,  109,  109,  109,

      109,  821,  194,  109,  109,  193,  109,  147,  109,  109,
      194,  109,  109,  577,  109,  109,  109,  109,  822,  109,
      109,  757,  824,  109,  826,  825,  823,  109,  194,  797,
      841,  109,  109,  830,  109,  827,  827,  827,  109,  796,
      109,  109,  109,  109,  828,  795,  109,  109,  793,  828,
      829,  831,  831,  831,  792,  109,  833,  109,  791,  790,
      835,  109,  730,  730,  730,  836,  834,  787,  732,  837,
      837,  837,  839,  839,  839,  732,  842,  840,  109,  109,
      109,  109,  193,  502,  109,  109,  786,  843,  844,  844,
      844,  194,  785,  845,  193,  109,  147,  109,  193,  784,

      733,  109,  109,  193,  109,  147,  846,  782,  109,  189,
      189,  189,  858,  878,  105,  742,  742,  742,  781,  193,
      743,  849,  849,  849,  108,  851,  109,  850,  109,  852,
      108,  109,  109,  109,  746,  746,  746,  109,  853,  853,
      853,  749,  749,  749,  780,  726,  750,  848,  748,  854,
      854,  854,  193,  834,  147,  748,  193,  193,  147,  147,
      748,  519,  193,  748,  147,  193,  193,  147,  147,  193,
     1325,  147,  861,  741,  193,  857,  147,  862,  726,  698,
      863,  855,  474,  866,  859,  860,  222,  873,  865,  864,
      697,  222,  193,  193,  147,  147, 1288,  193,  193,  147,

      147,  193,  193,  147,  147,  695,  193,  870,  147,  222,
      874,  694,  875,  193,  222,  147,  193,  693,  147,  872,
      193,  193,  147,  147,  879,  871,  880,  876,  548,  577,
      222,  193,  877,  147,  757,  884,  905,  892,  892,  892,
      692,  881,  893,  109,  906,  109,  109,  907,  915,  109,
      691,  109,  109,  109,  109,  690,  109,  109,  689,  955,
      109,  908,  908,  908,  688,  687,  909,  911,  911,  911,
      193,  193,  147,  912,  686,   96,  913,  913,  913,  109,
      683,  109,  912,  194,  954,  109,  914,  109,  681,  109,
      194,  680,  916,  109,  109,  193,  109,  147,  679,  917,

      109,  109,  919,  109,  109,  678,  918,  109,  109,  109,
      109,  920,  109,  711,  677,  109,  109,  921,  922,  676,
      971,  109,  923,  109,  193,  924,  147,  109,  109,  109,
      109,  109,  147,  636,  925,  109,  928,  631,  926,  109,
      927,  109,  109,  929,  109,  109,  973,  109,  109,  109,
      109,  930,  109,  109,  931,  933,  109,  109,  932,  109,
      934,  587,  109,  109,  109,  586,  502,  109,  109,  109,
      827,  827,  827,  109,  109,  193,  109,  147,  583,  828,
      109,  831,  831,  831,  828,  829,  833,  936,  936,  936,
      938,  193,  937,  147,  582,  935,  834,  109,  956,  109,

      109,  935,  109,  109,  581,  939,  109,  837,  837,  837,
      839,  839,  839,  732,  961,  840,  941,  941,  941,  578,
      577,  109,  942,  109,  109,  108,  109,  109,  943,  945,
      109,  944,  844,  844,  844,  948,  109,  845,  109,  189,
      189,  189,  109,  193,  105,  147,  109,  108,  109,  193,
      577,  193,  109,  147,  108,  849,  849,  849,  950,  950,
      950,  850,  951,  952,  193,  109,  147,  109,  109,  959,
      109,  109,  960,  193,  109,  147, 1325,  848,  853,  853,
      853,  854,  854,  854,  193,  576,  147,  193,  474,  147,
      222,  575,  935,  834,  967,  748,  574,  147,  963,  957,

      573,  222,  964,  567,  193,  965,  147,  193,  566,  147,
      958,  565, 1304,  855,  966,  962,  193,  564,  147,  969,
      193,  563,  147,  193,  562,  147,  970,  193,  561,  147,
      974,  193,  972,  147,  975,  193,  548,  147,  193,  557,
      147,  976,  193,  193,  147,  147,  193,   96,  147,  989,
      892,  892,  892,  981,  519,  893,  980,  977,  518,  193,
       96,  147,  512,  978,  983,  108,  979,  998,  998,  998,
      109,  464,  999,  109,  462,  109,  109, 1044, 1000,  109,
     1001, 1001, 1001,  463,  462, 1002,  908,  908,  908,  462,
      193,  909,  911,  911,  911, 1033, 1033, 1033,  912, 1007,

      461,  108,  913,  913,  913,  194,  460,  459,  912,  109,
      109,  109,  109,  458, 1006,  109,  109, 1008, 1009,  193,
      109,  109,  109,  109,  457,  456,  109,  109,  109,  109,
      109,  109, 1011, 1010,  109,  109,  109, 1069,  109, 1015,
      194,  109,  109, 1012,  109,  109,  109,  883, 1014, 1013,
      109,  109,  109,  109, 1016,  455, 1018,  109,  109,  109,
      711,  109,  109,  452,  109,  109, 1017,  109,  109,  109,
      109,  502,  109,  109, 1021, 1019,  109,  109,  109,  109,
      109,  502, 1022, 1020,  109,  109,  451,  109,  109,  447,
      109,  109, 1023, 1027,  109,  109, 1035, 1024,  109,  109,

     1025,  446,  109,  109, 1030,  109,  936,  936,  936, 1026,
      445,  937, 1028, 1028, 1028,  109,  193,  109,  147, 1031,
      935,  109,  109,  193,  109,  147,  935,  444,  109,  941,
      941,  941, 1034,  194, 1045,  942,  109,  109,  109,  109,
      222,  443,  109,  502, 1029, 1036, 1036, 1036,  109, 1042,
      109,  947,  442,  441,  109, 1037,  950,  950,  950, 1039,
      193,  109,  147,  439,  193,  109,  147,  193,  193,  147,
      147,  193,  400,  147, 1043,  399,  351,  193,  193,  147,
      147,  350,  349, 1041,  193,  193,  147,  147,  193,  193,
      147,  147, 1047, 1046,  222,  193, 1050,  147,  193, 1048,

      147,  348,  250, 1049, 1054, 1051,  250,  250, 1052,  757,
      193,  193,  147,  147, 1059,  193, 1053,  147,  193, 1060,
      147,  193, 1061,  147, 1055,  548,  346,  332, 1057,  548,
      193, 1062,  147,  193,  331,  147, 1058, 1056,  325,  193,
     1064,  147, 1063,  193,  193,  147,  147,  193,  193,  147,
      147, 1065,  998,  998,  998,  109, 1066,  109,  324, 1081,
      222,  109,  293,  292, 1082, 1067, 1083, 1083, 1083, 1070,
      548, 1084, 1001, 1001, 1001, 1068,  193, 1002, 1087, 1088,
     1087, 1325,  253,  109, 1004,  109, 1090,  108,  109,  109,
      109,  252, 1094, 1091,  109,  109,  109, 1092, 1093, 1095,

      251,  109,  109,  109,  250,  109, 1033, 1033, 1033,  109,
      109,  247,  109,  614,  614,  614,  109, 1096,  615,  109,
      109, 1097,  109,  193,  246,  109,  109,  109,  181,  109,
     1098,  245,  109,  109,  109,  240,  239,  194,  109, 1012,
      194,  109,  238,  109, 1101,  237, 1099,  109,  109,  166,
      109,  711,  217, 1100,  109,  109,  109,  109,  109,  216,
     1325,  109,  109,  109,  109,  109,  502,  177,   96,  109,
      109,  109,  172,  109,  502,  171, 1102,  109, 1103,  109,
      109, 1104,  170, 1106,  109,  109,  109,  711,  109, 1028,
     1028, 1028,  109, 1105,  109,  109,  109,  109,  169,  168,

      109,  109,  109,  935,  109, 1109, 1109, 1109,  109, 1108,
      167, 1110,  614,  614,  614, 1111,  166,  615, 1036, 1036,
     1036, 1029,  193, 1034,  947,  164,  109,  109,  109,  109,
     1112,  163,  109,  109,  193,  130,  147,  109,  125,  109,
      256,  124,  193,  109,  147,  193,  193,  147,  147,  193,
      193,  147,  147,  193,  121,  147,  193,  193,  147,  147,
     1119,  120,  119, 1120, 1114,  193, 1115,  147,  193, 1117,
      147, 1116, 1118,  193, 1121,  147,  193,  193,  147,  147,
     1122,  193,  193,  147,  147,  118,  193, 1126,  147, 1123,
      222,  193,  193,  147,  147,  112, 1048,  757,  193, 1124,

      147,  193, 1125,  147,   93,  193,  193,  147,  147,  548,
      193,   92,  147, 1128,  548, 1131,  193, 1127,  147,  757,
      193, 1129,  147,   91,   90,  193, 1133,  147, 1325, 1130,
     1144, 1144, 1144, 1088, 1088, 1088, 1145, 1066, 1132, 1134,
      109, 1325,  109, 1083, 1083, 1083,  109, 1325, 1084, 1146,
     1149, 1150, 1149, 1087, 1088, 1087, 1086, 1325,  108, 1004,
      502,  109,  109,  109, 1153,  711,  109,  109, 1325,  109,
      109,  109,  109, 1152, 1325,  109,  109,  109,  109,  109,
      109, 1325, 1155,  109,  109, 1012,  109, 1156, 1154,  711,
     1325, 1325,  109,  109,  193,  109,  147, 1158,  109,  109,

      109,  193, 1157,  147,  109,  109, 1325,  109,  109, 1325,
      109,  109, 1175, 1325,  109,  109, 1159,  109,  109, 1325,
      109,  109,  548, 1160,  109,  109, 1325,  109, 1161,  194,
      109,  109,  109,  109, 1325,  109,  109, 1012, 1162,  109,
      109,  711,  109,  193,  194,  147,  109, 1325,  109,  193,
      109,  147,  502, 1325,  109, 1109, 1109, 1109, 1164, 1164,
     1164, 1110, 1325,  109,  732,  109, 1325, 1325, 1165,  109,
      193, 1166,  147, 1169,  109,  502,  109,  193, 1325,  147,
     1167,  193, 1170,  147, 1325,  193, 1171,  147,  193,  193,
      147,  147,  193,  757,  147,  193,  193,  147,  147, 1173,

     1325,  193, 1174,  147,  193, 1176,  147,  193,  193,  147,
      147, 1172, 1325, 1048,  757,  193, 1325,  147, 1177,  193,
      193,  147,  147, 1325,  147,  222, 1325, 1178, 1179, 1181,
     1325, 1325, 1182,  757, 1180, 1048,  222, 1186, 1325, 1073,
      193, 1183,  147, 1144, 1144, 1144, 1195, 1325,  548, 1145,
     1193, 1193, 1193,  548, 1196, 1196, 1196,  109, 1325,  109,
     1148, 1198, 1216,  109, 1149, 1150, 1149, 1150, 1150, 1150,
     1086,  109, 1325,  109,  614,  614,  614,  109,  711,  615,
      109, 1325,  109,  109,  193,  109,  109, 1012, 1194,  109,
      109,  109,  109, 1201,  711, 1200,  109,  109,  109, 1202,

      109,  109, 1203,  109,  109, 1204, 1325,  109, 1164, 1164,
     1164, 1199, 1325,  109,  732,  109,  109, 1325,  109,  109,
     1205, 1325,  109,  109, 1207,  109,  109, 1325, 1325,  109,
      109,  109,  109, 1208,  109, 1325, 1325,  109,  109, 1209,
      193,  193,  147,  147,  193,  193,  147,  147, 1325,  193,
     1211,  147, 1212,  193,  193,  147,  147,  193, 1325,  147,
      757,  193,  193,  147,  147, 1325, 1325, 1217,  757, 1325,
     1325, 1214, 1218,  193, 1325,  147, 1215, 1048,  193, 1219,
      147,  193, 1325,  147, 1193, 1193, 1193,  109,  193,  109,
      147, 1325,  502,  109, 1220, 1325, 1196, 1196, 1196, 1325,

     1325, 1221, 1148, 1230,  998, 1230, 1231, 1325,  109, 1222,
     1325,  109,  109,  109,  548, 1325,  474,  109, 1325,  109,
      711,  109, 1194,  711,  711,  109, 1325,  109,  109,  109,
      109, 1232, 1325,  109,  109,  109,  109,  109,  109, 1325,
     1325,  109,  109, 1012,  109, 1325, 1233,  711, 1325,  109,
      109,  109, 1235,  194,  109,  109,  109,  109, 1325,  109,
      109, 1012, 1236,  109,  193,  193,  147,  147,  193, 1325,
      147,  193,  193,  147,  147,  193,  193,  147,  147,  193,
     1325,  147,  193, 1325,  147, 1238,  757,  757,  193, 1243,
      147, 1185,  193,  193,  147,  147, 1325, 1325, 1325,  757,

     1325, 1239, 1240, 1257, 1048,  193, 1241,  147,  757,  222,
     1230,  998, 1230, 1325, 1250, 1325, 1048, 1248, 1242,  109,
     1252,  109, 1249,  474,  109,  109,  109,  711, 1325, 1255,
      109,  109,  109,  109,  109, 1325, 1253,  109,  109,  109,
     1325,  109, 1254, 1254, 1254,  109,  193,  193,  147,  147,
      193, 1325,  147, 1263, 1144, 1263,  748, 1256, 1265, 1264,
     1325, 1325,  193,  757,  147, 1325,  474,  109, 1258,  109,
     1266, 1325,  109,  109, 1270,  109,  109,  109,  109, 1325,
     1268,  109, 1012, 1325,  109, 1254, 1254, 1254,  193,  193,
      147,  147, 1269,  193, 1325,  147, 1276, 1276, 1276,  748,

     1263, 1144, 1263, 1325,  711,  109, 1264,  109, 1325, 1271,
     1277,  109, 1325,  474, 1325, 1325, 1272, 1048, 1278, 1193,
     1278,  109, 1325,  109, 1280, 1325, 1325,  109, 1281, 1281,
     1281,  474,  711, 1325, 1282, 1282, 1282,  109, 1325,  109,
     1283, 1325,  935,  109,  193,  193,  147,  147,  748,  193,
     1325,  147, 1276, 1276, 1276, 1325, 1279, 1278, 1193, 1278,
      711,  109, 1289,  109,  757,  757, 1277,  109, 1325, 1284,
      474,  109, 1325,  109, 1281, 1281, 1281,  109, 1282, 1282,
     1282, 1290, 1325, 1325, 1283, 1291, 1291, 1291,  935,  193,
     1325,  147,  748, 1325, 1325, 1279, 1298, 1298, 1298,  748,

     1325, 1293, 1299, 1291, 1291, 1291,  193, 1325,  147, 1325,
      935, 1325, 1325, 1298, 1298, 1298, 1325,  748, 1325, 1299,
     1305, 1305, 1305, 1292, 1325, 1325,  757,  935, 1325, 1311,
     1276, 1311, 1325, 1325,  935, 1305, 1305, 1305, 1311, 1276,
     1311, 1292,  474, 1312, 1325, 1319, 1319, 1319, 1325,  935,
     1325,  474, 1312, 1319, 1319, 1319, 1325, 1325, 1306, 1320,
     1323, 1323, 1323, 1323, 1323, 1323, 1325, 1320, 1325, 1325,
     1325, 1325, 1325, 1306, 1324, 1325, 1325, 1324,   26,   26,
       26,   26,   26,   26,   26,   26,   26,   26,   26,   26,
       26,   26,   61,   61,   61,   61,   61,   61,   61,   61,

       61,   61,   61,   61,   61,   61,   65,   65,   65,   65,
       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
       85,   85,   85,   85,   96, 1325,   96, 1325, 1325, 1325,
     1325,   96, 1325,   96,   96,  109,  109,  109, 1325, 1325,
      109, 1325, 1325,  109,  109, 1325,  109,  147,  147,  147,
     1325, 1325, 1325, 1325, 1325,  147,  147,  165,  165,  165,
      165,  165,  165,  165,  165,  165,  165, 1325,  165,  165,
      178,  178, 1325,  178,  178,  178,  178,  178,  178,  178,
      178,  178,  178,  178,  221,  221, 1325,  221,  221,  221,

      221,  221,  221,  221,  221,  221,  221,  221,  347,  347,
      347,  347,  347,  347,  347,  347,  347,  347, 1325,  347,
      347,  347,  395,  395,  395, 1325, 1325,  395, 1325, 1325,
      395,  395, 1325,  395,  465,  465,  465, 1325, 1325,  465,
     1325, 1325,  465,  465, 1325,  465,  471,  471,  471,  471,
      471,  471,  471,  471,  471,  471,  471,  471,  471,  471,
      558,  558,  558,  558,  558,  558,  558,  558,  558,  558,
      558,  558,  558,  558,  640,  640,  640,  640,  640,  640,
      640,  640,  640,  640, 1325,  640,  640,  725,  725, 1325,
      725, 1325,  725,  725,  725,  725, 1325,  725,  731,  731,

      731,  731,  731,  731,  731,  731,  731,  731, 1325,  731,
      731,  783,  783, 1325,  783,  783,  783,  783,  783,  783,
      783,  783,  783,  783,  783,  794,  794, 1325,  794,  794,
      794,  794,  794,  794,  794,  794,  794,  794,  794,  808,
      808,  808, 1325, 1325, 1325, 1325, 1325, 1325,  808, 1325,
     1325,  808,  832,  832,  832,  832,  832,  832,  832,  832,
      832,  832, 1325,  832,  832,  847,  847,  847, 1325, 1325,
      847, 1325, 1325,  847,  847, 1325,  847,  946,  946,  946,
      946,  946,  946,  946,  946,  946,  946, 1325,  946,  946,
     1003, 1003, 1325, 1003, 1003, 1003, 1003, 1003, 1003, 1003,

     1003, 1003, 1003, 1003, 1072, 1072, 1325, 1072, 1072, 1072,
     1072, 1072, 1072, 1072, 1072, 1072, 1072, 1072, 1085, 1085,
     1325, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085,
     1085, 1085, 1147, 1147, 1147, 1147, 1147, 1147, 1147, 1147,
     1147, 1147, 1325, 1147, 1147, 1184, 1184, 1325, 1184, 1184,
     1184, 1184, 1184, 1184, 1184, 1184, 1184, 1184, 1184,   25,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,

     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325
    } ;

static yyconst short int yy_chk[4709] =
    {   0,
        0,    3,   13,    3,    9,    3,   15,   10,   13,   15,
        3,   17,    3,   14,    9,    3,    0,   10,   19,   14,
       21,   20,   16,   15,   19,   16,   17,   20,   22,   42,
       17,   23,   42,    3,   21,    3,    4,   42,    4,   16,
        4,   23,   22,   24,   41,    4,   41,    4,    9,   50,
        4,   10,   36,   24,   47,   51,   36,   17,   47, 1066,
     1066,   57,   63,   50,   51,   57,   63,  147,    4,  147,
        4,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,

        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,

       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   18, 1317,   35,   38,   35,
       38,   55,   55,   55,   68, 1315,   35,   38,   68,   60,
       18,   35,   38,   60,   18,   55,   39,   39,   39,   35,
       38,   39,   60,   54,   54,   54,   39,   93,   93,   93,
       38,   39,   54,   55,   56,  855,   56,   54,   95,   55,
       95,   18,   32,   56,   32,  855,   98,   95,   56,   96,
       98,   32,   95, 1310,   39,   54,   32,   58,   58,   58,
       95,   54,   96,   98,   32,  154,   58,  154,   69,   69,
       69,   58,   58,   81,   32,   97,   81,   97,   69,   32,

       69,   81,  100,   32,   37,   37,   37, 1029, 1309,   37,
       70,   70,   70,  154,   37,  100,   37, 1029,  784,   37,
       70,   71,   71,   71,  784,  458,   69,   72,   72,   72,
       75,   71,   97,   75,  795,   75,   97,   72,   75,  458,
      795,   71,   37,   59,   59,   59,   80,   80,   70,   74,
       80,  101,   59,   74, 1308,   80,   74,   59,   59,   71,
       72,   74,   76,  101,  101,   72,   76,   59,   77,   76,
      184,   77,  140,  184,   76,   77,   77,  471, 1303,   77,
       59,   73,   73,   73,   78,  140,   79,   78,  113,  471,
       79,   73,   78,   79,  148,   78,  148,  113,   79,  113,

      104,  104,  104,  113, 1171,  104,  107,  107,  107,   73,
      104,  148,   73,  141, 1171,  104,  107,   73,  107,   73,
       94,  322,   94,  108,  108,  108,  141,  141,  108,   94,
      109,  109,  109,  115,   94,  115,  112,  112,  112,  115,
      109,  116,   94,  110,  110,  110,  112,  135,  116,  322,
      116,  135,   94,  110,  116,  114,  338,   94,  174,  338,
      135,   94,  106,  106,  106,  953,  114,  112,  114,  112,
      110,  174,  114,  112,  106,  117,  156,  117,  156, 1302,
      118,  117,  118,  106,  106,  106,  118,  118,  953,  120,
      106,  120,  119,  106,  119,  120,  119,  106,  119,  142,

      121,  120,  121,  106,  122, 1301,  121,  142,  123,  156,
      123,  122,  142,  122,  123,  123,  124,  122,  124,  125,
      218,  125,  124,  124,  126,  125,  126,  149,  127,  149,
      126,  126,  127,  218,  127,  127,  128,  129,  127,  128,
      129,  128,  129,  473,  130,  128,  129,  130,  149,  130,
      132,  132,  132,  130,  133,  473,  133,  139,  139,  139,
      145,  145,  145,  133,  132,  146,  146,  146,  133,  150,
      145,  150,  139, 1296,  151,  146,  151,  146,  152,  150,
      152,  153,  132,  153,  155,  157,  155,  157,  132,  158,
      404,  158,  152,  176,  159,  151,  159,  176,  160,  157,

      160,  175,  161,  146,  161,  162,  176,  162,  153,  155,
      173,  173,  173,  733,  175,  175,  194,  158,  404,  194,
      161,  194,  159,  162, 1295,  194,  160,  180,  180,  180,
      189,  189,  189, 1210,  733,  189,  191,  191,  191,  940,
      219,  191,  173, 1210,  219,  189,  192,  192,  192,  195,
     1294,  195,  196,  219,  198,  195,  198,  198,  220,  197,
      198,  196,  180,  196,  196,  199,  197,  196,  197, 1251,
      940,  220,  197,  200,  223,  199,  223,  199,  192, 1251,
      200,  199,  200,  201,  202,  201,  200, 1287,  242,  201,
      206,  202,  206,  202,  201,  223,  206,  202,  203,  203,

      205,  242,  205,  203,  205,  203,  205,  203,  225,  203,
      225,  203,  204,  203,  204,  204,  203,  207,  204,  207,
      208,  209,  225,  207,  208,  209,  208,  209,  208,  210,
      208,  209, 1286,  212,  209,  212,  210,  212,  210,  212,
     1285,  295,  210,  211,  211,  211,  213,  211,  213,  295,
     1275,  211,  213,  222,  295,  222,  211,  211, 1073,  211,
      211,  214,  211,  211, 1073, 1274,  214,  215,  214,  215,
      243,  222,  214,  215,  215,  224,  226,  224,  226,  227,
      229,  227,  229,  243,  243,  230,  224,  230,  232,  231,
      232,  231,  235,  227,  235,  838,  236,  233,  236,  233,

     1113,  256,  244,  256,  229,  232, 1113,  256,  226,  228,
      230,  228,  231,  232,  233,  244,  244,  838,  257,  235,
     1273,  228,  228,  298,  236,  298,  228,  233,  228,  257,
      239,  257,  239,  298,  228,  257,  228, 1261,  239,  228,
      234,  234,  234,  239,  234,  239, 1260,  297,  234,  297,
      254,  254,  254,  234,  234,  299,  234,  299,  258,  234,
      234,  245,  245, 1259,  245,  258,  301,  258,  301,  294,
      245,  258,  245,  294,  297,  245,  299,  245,  245,  259,
      245,  245,  254, 1247,  335,  259,  294,  259,  260,  260,
      260,  259,  301,  261,  262,  261,  262,  335,  260,  261,

      262,  261,  263,  264,  952,  264,  263,  952,  264,  264,
      474,  263,  265,  263,  265,  263,  263,  263,  265,  265,
      266,  263,  474,  267,  275,  267,  402,  266,  267,  267,
      275,  266,  275,  266, 1246,  268,  275,  266,  268,  402,
      268,  269,  283,  269,  268,  271,  269,  269,  270, 1344,
      270,  283, 1344,  283,  270,  270,  271,  283,  271,  272,
     1245,  272,  271,  274,  272,  272,  273,  276,  273,  276,
      276,  273,  273,  276,  274,  276,  274,  277, 1244,  278,
      274,  278,  288,  288,  288,  278,  278,  288,  277,  279,
      277,  279,  288, 1243,  277,  279,  279,  280,  305,  280,

      305,  281,  280,  280,  281,  304,  281,  304,  282, 1229,
      281,  282,  284,  282,  284,  284,  305,  282,  284,  285,
      312,  285,  312,  286,  286,  285,  285,  286,  296,  286,
      287,  304,  287,  286, 1040,  287,  287,  289,  289,  289,
      296,  296,  289,  290,  312,  436,  291,  289,  290,  291,
      290, 1228,  289,  291,  290,  291,  302, 1040,  302,  291,
      303,  306,  303,  306,  308,  307,  308,  307, 1227,  309,
      303,  309,  520,  436,  308,  289,  300,  303,  300,  302,
      310,  311,  310,  311,  302,  520, 1226,  306,  300,  314,
     1300,  314,  300,  307, 1225,  309,  311, 1224,  313,  300,

      313,  300,  300,  315, 1300,  315,  310,  300,  313,  316,
      317,  316,  317,  318,  319,  318,  319,  314,  320,  321,
      320,  321,  323, 1194,  323,  318,  437,  316,  317,  315,
      325,  325,  325,  333,  333,  333,  323,  334,  319,  323,
     1107,  334,  353,  437,  353,  321,  320,  405,  353,  405,
      334,  352,  352,  352,  437,  523,  352,  333,  354,  355,
      354,  352, 1192, 1107,  354,  355,  352,  355,  405,  569,
      333,  355,  356, 1292,  356,  357,  357,  357,  356,  358,
      357,  358,  569,  523,  359,  358, 1292, 1306,  357,  352,
      357,  359,  360,  359,  360,  361,  362,  359,  360,  372,

     1306,  372,  361,  558,  361,  372,  372,  362,  361,  362,
      363,  449,  363,  362,  364,  558,  363,  366,  363,  449,
      365,  364,  365,  364,  449,  365,  365,  364,  366,  367,
      366,  406,  368,  406,  366,  560,  368,  367,  368,  367,
     1338, 1338,  368,  367,  369,  406,  369,  560,  370,  369,
      369,  370,  412,  370,  412,  371,  374,  370,  371,  373,
      371,  373,  373,  374,  371,  373,  375,  374,  375,  374,
      377, 1191,  375,  374,  376, 1190,  376,  377,  412,  377,
      376,  376,  378,  377,  410,  379,  410,  378,  379,  378,
      379, 1341, 1341,  378,  379,  380,  381,  380,  381,  555,

      380,  380,  381,  381,  382,  384,  382,  383, 1189,  384,
      382,  384,  383,  410,  384,  384,  383,  555,  383,  401,
      385,  401,  383,  385,  386,  385,  386,  555, 1188,  385,
      386,  387,  401,  387,  388,  572,  388,  387,  387,  388,
      388,  389,  390,  389, 1313,  572,  389,  389,  572,  390,
      391,  391,  391,  390,  685,  390,  391,  392, 1313,  390,
      392,  685,  392,  393,  393,  393,  392,  685,  393,  394,
      394,  394,  395,  395,  395,  394,  397,  395,  393,  403,
      403,  403,  395,  397,  407,  397,  407,  395,  789,  397,
      398,  398,  398, 1187,  408,  398,  408,  409,  789,  409,

      398,  789, 1186,  403,  411,  407,  411,  409,  408,  413,
      395,  413,  415,  414,  415,  414,  403, 1184,  411,  413,
      416,  420,  416,  420, 1163,  398,  414, 1147,  398,  415,
      417,  418,  417,  418,  419,  422,  419,  422, 1185,  415,
      421,  423,  421,  423, 1185,  420,  416, 1163,  417,  418,
      421,  424,  425,  424,  425,  521,  422,  421,  426,  427,
      426,  427,  419, 1143,  428,  424,  428,  521,  521,  423,
      425,  429,  430,  429,  430,  431,  432,  431,  432,  684,
      427,  428, 1142,  433,  426,  433,  440,  440,  440,  429,
      428,  684,  684,  430,  434,  435,  434,  435,  438,  440,

      438, 1141,  432,  431,  434,  448,  448,  448, 1140,  433,
      526,  434,  526,  435,  450,  450,  450, 1139,  448,  450,
      448, 1168,  526,  438,  462,  462,  462, 1307, 1138,  462,
      465,  465,  465, 1168,  527,  465,  527,  467,  450,  467,
      465,  828,  468,  467,  468,  465,  828,  828,  468,  468,
     1307,  450,  450,  469,  532,  469,  532,  470,  527,  469,
      470,  478,  470,  478,  478, 1137,  470,  478,  465,  472,
      472,  472,  532, 1135,  472,  475,  475,  475,  477,  476,
      475,  476,  472,  674,  472,  476,  476,  477,  475,  477,
      479, 1085,  479,  477,  704, 1084,  479,  479,  480,  480,

      480,  481,  482,  481,  480, 1080,  704,  481,  481,  483,
      674,  674,  483,  482,  483,  482, 1079,  704,  483,  482,
      484,  485,  484,  482, 1078, 1206,  484,  485,  485,  485,
      486, 1206,  484,  485,  487,  793,  533,  486,  533,  486,
      793, 1077,  487,  486,  487,  488,  489,  488,  487,  488,
      793,  488,  489,  490,  489, 1352, 1352,  490,  489,  490,
      491,  524, 1076,  490,  490,  492,  491,  492,  491,  533,
      492,  492,  491,  493,  495,  493,  495, 1075,  524,  493,
      495,  493,  494,  494,  494, 1005,  496,  494,  497,  524,
      497, 1074,  494,  496,  497,  496,  498, 1005,  498,  496,

      751,  501,  498,  498, 1005,  499,  499,  499, 1072,  494,
      499,  500,  501,  500,  501,  499, 1071,  500,  501,  500,
      502,  502,  502,  503,  529,  502,  529,  504,  751,  503,
      502,  503,  499,  505,  504,  503,  504,  505, 1318,  505,
      504, 1003, 1002,  505,  505,  506,  529,  506,  507,  508,
      507,  506,  506,  507,  507,  778,  508,  509,  508,  509,
      997, 1318,  508,  509,  509,  510,  510,  510,  511,  511,
      511,  510,  513,  528,  513,  528,  806,  513,  513,  514,
      514,  514,  996,  778,  514,  515,  515,  515,  806,  525,
      516,  525,  516,  517,  514,  516,  516,  517,  995,  517,

      517,  528,  994,  517,  519,  519,  519,  522,  522,  522,
      525,  530,  806,  530,  531,  534,  531,  534,  535,  993,
      535,  536,  522,  536,  531,  537,  538,  537,  538,  539,
      534,  539,  535,  540,  536,  540,  541,  534,  541,  530,
      542,  538,  542, 1234,  882,  531,  539,  544,  540,  544,
      537,  543,  543,  543,  992, 1234,  543,  539,  545,  991,
      545,  543,  541,  543,  546,  547,  546,  547,  549,  542,
      549,  550,  882,  550,  544,  552,  990,  552,  543,  545,
      551,  989,  551,  549,  553,  550,  553,  554,  556,  554,
      556,  763,  546,  763,  547,  883,  988,  551,  559,  559,

      559,  763,  987,  552,  566,  566,  566,  591,  551,  591,
      553,  559,  883,  591,  556,  554,  568,  568,  568,  570,
      570,  570,  986,  883,  570,  571,  571,  571,  645,  568,
      645,  568,  985, 1069,  570,  584,  584,  584,  910,  588,
      584,  588,  588,  589,  589,  588,  596,  589,  596,  589,
      910,  590,  596,  589,  590,  645,  590,  592,  592,  592,
      590, 1069,  592,  593,  593,  593,  984,  594,  594,  594,
      592,  949,  594,  597,  910, 1089,  593,  594,  595,  597,
      595,  595,  599,  597,  595,  597,  599, 1089,  599,  597,
      598,  650,  599,  650,  594,  593,  600,  598,  642,  598,

     1089, 1312,  601,  598,  600,  601,  600,  601,  946,  650,
      600,  601,  602, 1312,  602,  603,  642,  603,  602,  602,
      603,  603,  604,  605,  604,  605,  642,  604,  604,  605,
      606,  607,  606,  607,  909,  903,  606,  607,  607,  608,
      901,  608,  609,  900,  609,  608,  608,  610,  609,  609,
      610,  643,  611,  643,  610,  611,  610,  611,  613,  898,
      610,  611,  612,  897,  612,  613,  896,  613,  612,  612,
      895,  613,  614,  614,  614,  643,  616,  614,  616,  617,
      617,  617,  616,  618,  630,  630,  630,  614,  893,  617,
      618,  890,  618,  619,  619,  619,  618,  621,  619,  620,

      620,  620,  889, 1288,  621,  620,  621,  622,  619,  622,
      621,  626,  623,  622,  623, 1288,  887,  626,  623,  623,
      624,  626,  624,  626,  624,  625,  624,  626,  625,  627,
     1288,  627,  625,  886,  625,  627,  627,  620,  625,  628,
      629,  628,  848,  629,  628,  628,  888,  629,  888,  629,
      632,  632,  632,  629,  845,  632,  633,  633,  633,  634,
      632,  634,  634,  833,  635,  634,  635,  637,  637,  637,
      635,  638,  638,  638,  639,  639,  639,  641,  641,  641,
      832,  644,  641,  644,  647,  646,  647,  646,  639,  639,
      648,  641,  648,  829,  801,  638,  646,  649,  647,  649,

      799,  651,  646,  651,  652,  644,  652,  648,  638,  653,
      649,  653,  646,  654,  655,  654,  655,  648,  656,  657,
      656,  657,  658,  798,  658,  659,  660,  659,  660,  651,
      652,  661,  797,  661,  662,  653,  662,  655,  796,  659,
      654,  665,  659,  665,  660,  794,  656,  657,  662,  792,
      658,  663,  663,  663, 1151,  666,  663,  666,  667,  661,
      667,  668,  669,  668,  669,  670, 1151,  670,  665,  666,
      791,  790,  667,  671,  672,  671,  672, 1151,  673,  670,
      673,  675,  670,  675,  671,  787,  754,  669,  754,  668,
      671,  899,  673,  899,  786,  673,  682,  682,  682,  785,

      754,  699,  672,  699,  762,  675,  762,  699,  700,  700,
      700,  701,  702,  701,  700,  783,  762,  701,  868,  702,
      868,  702,  703,  703,  703,  702,  705,  705,  705,  782,
      708,  705,  706,  706,  706,  703,  707,  708,  707,  708,
      868,  705,  707,  708,  709,  781,  752,  709,  752,  709,
      710,  780,  710,  709,  703,  757,  710,  710,  711,  711,
      711,  731,  725,  711,  712,  697,  712,  713,  711,  752,
      712,  712,  713,  696,  765,  713,  765,  714,  713,  714,
      713,  716,  715,  714,  713,  715,  717,  765,  695,  715,
      716,  715,  716,  718,  694,  715,  716,  717,  718,  717,

      718,  719,  720,  717,  718,  764,  720,  764,  720,  719,
      721,  719,  720,  693,  721,  719,  721,  722,  720,  722,
      721,  764,  722,  722,  724,  723,  721,  723,  724,  692,
      735,  723,  724,  727,  724,  726,  726,  726,  724,  691,
      727,  735,  727,  735,  726,  690,  727,  735,  689,  726,
      726,  728,  728,  728,  688,  729,  728,  729,  687,  686,
      729,  729,  730,  730,  730,  729,  728,  683,  730,  732,
      732,  732,  734,  734,  734,  732,  737,  734,  736,  737,
      736,  737,  734,  736,  736,  737,  681,  738,  739,  739,
      739,  738,  680,  739,  755,  738,  755,  738,  739,  679,

      730,  738,  740,  773,  740,  773,  740,  678,  740,  741,
      741,  741,  755,  773,  741,  742,  742,  742,  677,  741,
      742,  743,  743,  743,  741,  744,  745,  743,  745,  745,
      742,  744,  745,  744,  746,  746,  746,  744,  747,  747,
      747,  749,  749,  749,  676,  664,  749,  741,  746,  750,
      750,  750,  753,  747,  753,  749,  756,  758,  756,  758,
      640,  636,  759,  750,  759,  760,  769,  760,  769,  761,
     1279,  761,  759,  631,  766,  753,  766,  759,  615,  587,
      759,  750, 1279,  761,  756,  758,  761,  769,  760,  759,
      586,  766,  767,  768,  767,  768, 1279,  770,  771,  770,

      771,  772,  774,  772,  774,  583,  775,  766,  775,  767,
      770,  582,  771,  776,  770,  776,  777,  581,  777,  768,
      779,  865,  779,  865,  775,  767,  776,  772,  774,  580,
      776,  857,  772,  857,  865,  779,  802,  788,  788,  788,
      579,  777,  788,  802,  803,  802,  810,  804,  810,  802,
      578,  803,  810,  803,  804,  577,  804,  803,  576,  857,
      804,  805,  805,  805,  575,  574,  805,  807,  807,  807,
      856,  805,  856,  807,  573,  788,  808,  808,  808,  809,
      567,  809,  808,  811,  856,  809,  809,  811,  565,  811,
      812,  564,  811,  811,  812,  870,  812,  870,  563,  812,

      812,  813,  814,  813,  814,  562,  813,  813,  814,  815,
      816,  815,  816,  817,  561,  815,  816,  816,  818,  557,
      870,  817,  818,  817,  872,  818,  872,  817,  818,  819,
      818,  819,  548,  518,  818,  819,  821,  512,  819,  820,
      820,  820,  821,  821,  821,  820,  872,  822,  821,  822,
      823,  822,  823,  822,  823,  825,  823,  824,  824,  824,
      826,  466,  825,  824,  825,  464,  830,  826,  825,  826,
      827,  827,  827,  826,  830,  858,  830,  858,  461,  827,
      830,  831,  831,  831,  827,  827,  831,  834,  834,  834,
      835,  863,  834,  863,  460,  831,  831,  835,  858,  835,

      836,  834,  836,  835,  459,  836,  836,  837,  837,  837,
      839,  839,  839,  837,  863,  839,  840,  840,  840,  457,
      456,  841,  840,  841,  842,  839,  842,  841,  841,  843,
      842,  842,  844,  844,  844,  846,  843,  844,  843,  847,
      847,  847,  843,  861,  847,  861,  846,  844,  846,  847,
      455,  862,  846,  862,  847,  849,  849,  849,  850,  850,
      850,  849,  851,  852,  867,  851,  867,  851,  852,  861,
      852,  851,  862,  859,  852,  859, 1297,  847,  853,  853,
      853,  854,  854,  854,  860,  454,  860,  864, 1297,  864,
      859,  453,  853,  853,  867,  854,  452,  866,  866,  859,

      451,  860,  866,  447,  869,  866,  869,  871,  446,  871,
      860,  445, 1297,  854,  866,  864,  873,  444,  873,  869,
      874,  443,  874,  875,  442,  875,  869,  876,  441,  876,
      873,  877,  871,  877,  874,  878,  875,  878,  879,  439,
      879,  876,  880,  881,  880,  881,  884,  894,  884,  894,
      892,  892,  892,  881,  400,  892,  880,  877,  399,  957,
      894,  957,  396,  878,  884,  892,  879,  904,  904,  904,
      905,  351,  905,  906,  350,  906,  905,  957,  906,  906,
      907,  907,  907,  349,  348,  907,  908,  908,  908,  346,
      907,  908,  911,  911,  911,  942,  942,  942,  911,  915,

      345,  908,  913,  913,  913,  914,  344,  343,  913,  914,
      915,  914,  915,  342,  914,  914,  915,  916,  917,  982,
      916,  917,  916,  917,  341,  340,  916,  917,  918,  919,
      918,  919,  919,  918,  918,  919,  920,  982,  920,  923,
      921,  923,  920,  920,  921,  923,  921,  982,  922,  921,
      921,  922,  924,  922,  924,  339,  926,  922,  924,  925,
      927,  925,  926,  337,  926,  925,  925,  927,  926,  927,
      928,  930,  928,  927,  932,  928,  928,  929,  930,  929,
      930,  931,  932,  929,  930,  932,  336,  932,  931,  332,
      931,  932,  933,  934,  931,  934,  945,  933,  945,  934,

      933,  331,  945,  933,  938,  933,  936,  936,  936,  933,
      330,  936,  937,  937,  937,  938,  958,  938,  958,  939,
      936,  938,  939,  955,  939,  955,  937,  329,  939,  941,
      941,  941,  943,  944,  958,  941,  943,  944,  943,  944,
      955,  328,  943,  944,  937,  947,  947,  947,  948,  955,
      948,  947,  327,  326,  948,  948,  950,  950,  950,  951,
      954,  951,  954,  324,  956,  951,  956,  959,  960,  959,
      960,  961,  293,  961,  956,  292,  255,  962,  963,  962,
      963,  253,  252,  954,  964,  965,  964,  965,  966,  967,
      966,  967,  960,  959,  962,  968,  963,  968,  969,  961,

      969,  251,  249,  962,  967,  964,  248,  247,  965,  968,
      970,  971,  970,  971,  974,  972,  966,  972,  973,  974,
      973,  975,  974,  975,  969,  971,  246,  241,  973,  972,
      976,  974,  976,  977,  240,  977,  973,  970,  238,  978,
      976,  978,  975,  979,  980,  979,  980,  981,  983,  981,
      983,  977,  998,  998,  998,  999,  978,  999,  237,  998,
      979,  999,  217,  216,  999,  980, 1000, 1000, 1000,  983,
      979, 1000, 1001, 1001, 1001,  981, 1000, 1001, 1004, 1004,
     1004,  193,  188, 1006, 1004, 1006, 1006, 1001, 1007, 1006,
     1007,  187, 1010, 1007, 1007, 1008, 1009, 1008, 1009, 1011,

      186, 1008, 1009, 1010,  185, 1010, 1033, 1033, 1033, 1010,
     1011,  183, 1011, 1012, 1012, 1012, 1011, 1013, 1012, 1014,
     1013, 1014, 1013, 1012,  182, 1014, 1013, 1015,  181, 1015,
     1015,  177, 1016, 1015, 1016,  172,  171, 1017, 1016, 1016,
     1012, 1017,  170, 1017, 1019,  169, 1017, 1017, 1018,  165,
     1018, 1020,  137, 1018, 1018, 1019, 1020, 1019, 1020,  136,
      111, 1019, 1020, 1021, 1022, 1021, 1022,  102,   99, 1021,
     1022, 1023,   92, 1023, 1021,   91, 1023, 1023, 1024, 1025,
     1024, 1025,   90, 1027, 1024, 1025, 1026, 1030, 1026, 1028,
     1028, 1028, 1026, 1026, 1027, 1030, 1027, 1030,   89,   88,

     1027, 1030, 1031, 1028, 1031, 1032, 1032, 1032, 1031, 1031,
       86, 1032, 1034, 1034, 1034, 1035,   85, 1034, 1036, 1036,
     1036, 1028, 1034, 1037, 1036,   84, 1035, 1037, 1035, 1037,
     1039,   82, 1035, 1037, 1041,   52, 1041, 1039,   49, 1039,
     1034,   48, 1042, 1039, 1042, 1043, 1044, 1043, 1044, 1045,
     1046, 1045, 1046, 1047,   46, 1047, 1049, 1050, 1049, 1050,
     1046,   45,   44, 1047, 1041, 1051, 1042, 1051, 1052, 1044,
     1052, 1043, 1045, 1053, 1049, 1053, 1054, 1055, 1054, 1055,
     1050, 1056, 1057, 1056, 1057,   43, 1058, 1055, 1058, 1051,
     1053, 1059, 1060, 1059, 1060,   40, 1052, 1056, 1061, 1053,

     1061, 1062, 1054, 1062,   31, 1063, 1064, 1063, 1064, 1058,
     1065,   30, 1065, 1060, 1057, 1063, 1067, 1059, 1067, 1064,
     1068, 1061, 1068,   29,   27, 1070, 1067, 1070,   25, 1062,
     1081, 1081, 1081, 1088, 1088, 1088, 1081, 1068, 1065, 1070,
     1082,    0, 1082, 1083, 1083, 1083, 1082,    0, 1083, 1082,
     1086, 1086, 1086, 1087, 1087, 1087, 1086,    0, 1083, 1087,
     1090, 1091, 1090, 1091, 1092, 1093, 1090, 1091,    0, 1092,
     1093, 1092, 1093, 1091,    0, 1092, 1093, 1094, 1095, 1094,
     1095,    0, 1097, 1094, 1095, 1095, 1096, 1098, 1096, 1094,
        0,    0, 1096, 1097, 1124, 1097, 1124, 1100, 1098, 1097,

     1098, 1115, 1099, 1115, 1098, 1099,    0, 1099, 1100,    0,
     1100, 1099, 1124,    0, 1100, 1101, 1101, 1101, 1102,    0,
     1102, 1101, 1115, 1102, 1102, 1103,    0, 1103, 1103, 1105,
     1104, 1103, 1104, 1105,    0, 1105, 1104, 1104, 1105, 1105,
     1106, 1108, 1106, 1114, 1108, 1114, 1106,    0, 1108, 1116,
     1108, 1116, 1106,    0, 1108, 1109, 1109, 1109, 1110, 1110,
     1110, 1109,    0, 1111, 1110, 1111,    0,    0, 1112, 1111,
     1117, 1112, 1117, 1114, 1112, 1111, 1112, 1118,    0, 1118,
     1112, 1119, 1116, 1119,    0, 1120, 1117, 1120, 1121, 1122,
     1121, 1122, 1123, 1118, 1123, 1125, 1126, 1125, 1126, 1122,

        0, 1127, 1123, 1127, 1128, 1125, 1128, 1129, 1130, 1129,
     1130, 1121,    0, 1120, 1119, 1131,    0, 1131, 1126, 1132,
     1133, 1132, 1133,    0, 1134, 1130,    0, 1127, 1128, 1134,
        0,    0, 1134, 1132, 1130, 1129, 1132, 1136,    0, 1136,
     1176, 1134, 1176, 1144, 1144, 1144, 1146,    0, 1131, 1144,
     1145, 1145, 1145, 1133, 1148, 1148, 1148, 1146,    0, 1146,
     1148, 1152, 1176, 1146, 1149, 1149, 1149, 1150, 1150, 1150,
     1149, 1152,    0, 1152, 1153, 1153, 1153, 1152, 1154, 1153,
     1156,    0, 1156, 1154, 1153, 1154, 1156, 1156, 1145, 1154,
     1155, 1157, 1155, 1157, 1159, 1155, 1155, 1157, 1158, 1158,

     1158, 1159, 1160, 1159, 1158, 1161,    0, 1159, 1164, 1164,
     1164, 1153,    0, 1160, 1164, 1160, 1161,    0, 1161, 1160,
     1162,    0, 1161, 1162, 1165, 1162, 1165,    0,    0, 1162,
     1165, 1166, 1167, 1166, 1167,    0,    0, 1166, 1167, 1167,
     1169, 1170, 1169, 1170, 1172, 1173, 1172, 1173,    0, 1174,
     1169, 1174, 1170, 1175, 1177, 1175, 1177, 1178,    0, 1178,
     1172, 1180, 1179, 1180, 1179,    0,    0, 1178, 1177,    0,
        0, 1173, 1179, 1181,    0, 1181, 1175, 1174, 1182, 1180,
     1182, 1183,    0, 1183, 1193, 1193, 1193, 1195, 1211, 1195,
     1211,    0, 1195, 1195, 1181,    0, 1196, 1196, 1196,    0,

        0, 1182, 1196, 1197, 1197, 1197, 1198,    0, 1198, 1183,
        0, 1199, 1198, 1199, 1211,    0, 1197, 1199,    0, 1200,
     1202, 1200, 1193, 1201, 1199, 1200,    0, 1202, 1201, 1202,
     1201, 1200,    0, 1202, 1201, 1203, 1204, 1203, 1204,    0,
        0, 1203, 1204, 1204, 1205,    0, 1205, 1203,    0, 1207,
     1205, 1207, 1207, 1209, 1208, 1207, 1208, 1209,    0, 1209,
     1208, 1208, 1209, 1209, 1212, 1213, 1212, 1213, 1214,    0,
     1214, 1215, 1216, 1215, 1216, 1217, 1218, 1217, 1218, 1219,
        0, 1219, 1220,    0, 1220, 1212, 1216, 1215, 1221, 1223,
     1221, 1223, 1222, 1241, 1222, 1241,    0,    0,    0, 1213,

        0, 1214, 1219, 1241, 1218, 1238, 1220, 1238, 1217, 1222,
     1230, 1230, 1230,    0, 1232,    0, 1221, 1230, 1222, 1231,
     1235, 1231, 1231, 1230, 1232, 1231, 1232, 1233,    0, 1238,
     1232, 1235, 1233, 1235, 1233,    0, 1236, 1235, 1233, 1236,
        0, 1236, 1237, 1237, 1237, 1236, 1239, 1240, 1239, 1240,
     1242,    0, 1242, 1248, 1248, 1248, 1237, 1239, 1249, 1248,
        0,    0, 1255, 1240, 1255,    0, 1248, 1249, 1242, 1249,
     1250,    0, 1250, 1249, 1255, 1252, 1250, 1252, 1253,    0,
     1253, 1252, 1252,    0, 1253, 1254, 1254, 1254, 1256, 1257,
     1256, 1257, 1254, 1258,    0, 1258, 1262, 1262, 1262, 1254,

     1263, 1263, 1263,    0, 1265, 1265, 1263, 1265,    0, 1256,
     1262, 1265,    0, 1263,    0,    0, 1258, 1257, 1264, 1264,
     1264, 1266,    0, 1266, 1266,    0,    0, 1266, 1267, 1267,
     1267, 1264, 1268,    0, 1269, 1269, 1269, 1268,    0, 1268,
     1269,    0, 1267, 1268, 1270, 1271, 1270, 1271, 1269, 1272,
        0, 1272, 1276, 1276, 1276,    0, 1264, 1278, 1278, 1278,
     1289, 1289, 1280, 1289, 1270, 1272, 1276, 1289,    0, 1271,
     1278, 1280,    0, 1280, 1281, 1281, 1281, 1280, 1282, 1282,
     1282, 1281,    0,    0, 1282, 1283, 1283, 1283, 1281, 1284,
        0, 1284, 1282,    0,    0, 1278, 1290, 1290, 1290, 1283,

        0, 1284, 1290, 1291, 1291, 1291, 1293,    0, 1293,    0,
     1290,    0,    0, 1298, 1298, 1298,    0, 1291,    0, 1298,
     1299, 1299, 1299, 1283,    0,    0, 1293, 1298,    0, 1304,
     1304, 1304,    0,    0, 1299, 1305, 1305, 1305, 1311, 1311,
     1311, 1291, 1304, 1304,    0, 1314, 1314, 1314,    0, 1305,
        0, 1311, 1311, 1319, 1319, 1319,    0,    0, 1299, 1314,
     1322, 1322, 1322, 1323, 1323, 1323,    0, 1319,    0,    0,
        0,    0,    0, 1305, 1322,    0,    0, 1323, 1326, 1326,
     1326, 1326, 1326, 1326, 1326, 1326, 1326, 1326, 1326, 1326,
     1326, 1326, 1327, 1327, 1327, 1327, 1327, 1327, 1327, 1327,

     1327, 1327, 1327, 1327, 1327, 1327, 1328, 1328, 1328, 1328,
     1328, 1328, 1328, 1328, 1328, 1328, 1328, 1328, 1328, 1328,
     1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329,
     1329, 1329, 1329, 1329, 1330,    0, 1330,    0,    0,    0,
        0, 1330,    0, 1330, 1330, 1331, 1331, 1331,    0,    0,
     1331,    0,    0, 1331, 1331,    0, 1331, 1332, 1332, 1332,
        0,    0,    0,    0,    0, 1332, 1332, 1333, 1333, 1333,
     1333, 1333, 1333, 1333, 1333, 1333, 1333,    0, 1333, 1333,
     1334, 1334,    0, 1334, 1334, 1334, 1334, 1334, 1334, 1334,
     1334, 1334, 1334, 1334, 1335, 1335,    0, 1335, 1335, 1335,

     1335, 1335, 1335, 1335, 1335, 1335, 1335, 1335, 1336, 1336,
     1336, 1336, 1336, 1336, 1336, 1336, 1336, 1336,    0, 1336,
     1336, 1336, 1337, 1337, 1337,    0,    0, 1337,    0,    0,
     1337, 1337,    0, 1337, 1339, 1339, 1339,    0,    0, 1339,
        0,    0, 1339, 1339,    0, 1339, 1340, 1340, 1340, 1340,
     1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340,
     1342, 1342, 1342, 1342, 1342, 1342, 1342, 1342, 1342, 1342,
     1342, 1342, 1342, 1342, 1343, 1343, 1343, 1343, 1343, 1343,
     1343, 1343, 1343, 1343,    0, 1343, 1343, 1345, 1345,    0,
     1345,    0, 1345, 1345, 1345, 1345,    0, 1345, 1346, 1346,

     1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346,    0, 1346,
     1346, 1347, 1347,    0, 1347, 1347, 1347, 1347, 1347, 1347,
     1347, 1347, 1347, 1347, 1347, 1348, 1348,    0, 1348, 1348,
     1348, 1348, 1348, 1348, 1348, 1348, 1348, 1348, 1348, 1349,
     1349, 1349,    0,    0,    0,    0,    0,    0, 1349,    0,
        0, 1349, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350,
     1350, 1350,    0, 1350, 1350, 1351, 1351, 1351,    0,    0,
     1351,    0,    0, 1351, 1351,    0, 1351, 1353, 1353, 1353,
     1353, 1353, 1353, 1353, 1353, 1353, 1353,    0, 1353, 1353,
     1354, 1354,    0, 1354, 1354, 1354, 1354, 1354, 1354, 1354,

     1354, 1354, 1354, 1354, 1355, 1355,    0, 1355, 1355, 1355,
     1355, 1355, 1355, 1355, 1355, 1355, 1355, 1355, 1356, 1356,
        0, 1356, 1356, 1356, 1356, 1356, 1356, 1356, 1356, 1356,
     1356, 1356, 1357, 1357, 1357, 1357, 1357, 1357, 1357, 1357,
     1357, 1357,    0, 1357, 1357, 1358, 1358,    0, 1358, 1358,
     1358, 1358, 1358, 1358, 1358, 1358, 1358, 1358, 1358, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,
     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,

     1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0
#include "functions.h"
#define FirstParse 1

#define SecondParse 2

#define VarDecl 3

#define Delete 4

#define Write 5

#define Comment 6

#define NoChange 7

#define CaplFunc 8

#define DelCommentML 9

#define NoChangeFirstParse 10

#define FooterState 11

#define YY_STACK_USED 1
#define YY_NEVER_INTERACTIVE 1

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;



	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1326 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 4660 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
yy_push_state(NoChangeFirstParse);
	YY_BREAK
case 2:
YY_RULE_SETUP

	YY_BREAK
case 3:
YY_RULE_SETUP
yy_pop_state();
	YY_BREAK
case 4:
YY_RULE_SETUP
vKeyStoreCase();
	YY_BREAK
case 5:
YY_RULE_SETUP
vKeyStoreHeader();
	YY_BREAK
case 6:
YY_RULE_SETUP
vEnvVar();
	YY_BREAK
case 7:
YY_RULE_SETUP
vCaplFunc();
	YY_BREAK
case 8:
YY_RULE_SETUP

	YY_BREAK
case 9:
YY_RULE_SETUP
counter = 2;
	YY_BREAK
case 10:
YY_RULE_SETUP
fprestart = 1;
	YY_BREAK
case 11:
YY_RULE_SETUP
fstart = 1;
	YY_BREAK
case 12:
YY_RULE_SETUP
vHeader();  
	YY_BREAK
case 13:
YY_RULE_SETUP
vMsgCpy();
	YY_BREAK
case 14:
YY_RULE_SETUP
vMsgDecl();
	YY_BREAK
case 15:
YY_RULE_SETUP
vDelete(); 
	YY_BREAK
case 16:
YY_RULE_SETUP

	YY_BREAK
case 17:
YY_RULE_SETUP
yy_push_state(DelCommentML);
	YY_BREAK
case 18:
YY_RULE_SETUP
yy_pop_state();
	YY_BREAK
case 19:
YY_RULE_SETUP
vUtilFunc();
	YY_BREAK
case 20:
YY_RULE_SETUP
vEndBody();                          
	YY_BREAK
case 21:
YY_RULE_SETUP
vTimerFunc();  
	YY_BREAK
case 22:
YY_RULE_SETUP
vCnvrtByte();  
	YY_BREAK
case 23:
YY_RULE_SETUP
vPutKeyCase(); 
	YY_BREAK
case 24:
YY_RULE_SETUP
vWrite();  
	YY_BREAK
case 25:
YY_RULE_SETUP
vMsgID(); 
	YY_BREAK
case 26:
YY_RULE_SETUP
vUnSptdFunc();
	YY_BREAK
case 27:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case 28:
YY_RULE_SETUP
vRemovePhys();
	YY_BREAK
case 29:
YY_RULE_SETUP
vWriteDot();
	YY_BREAK
case 30:
YY_RULE_SETUP
ECHO;  
	YY_BREAK
case 31:
YY_RULE_SETUP
vCnvrtThis();  
	YY_BREAK
case 32:
YY_RULE_SETUP
vWriteTerminator(); 
	YY_BREAK
case 33:
YY_RULE_SETUP
ECHO ,   yy_push_state(NoChange);
	YY_BREAK
case 34:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case 35:
YY_RULE_SETUP
ECHO;   yy_pop_state();
	YY_BREAK
case 36:
YY_RULE_SETUP
velCount(); 
	YY_BREAK
case 37:
YY_RULE_SETUP
vSetTimer();   
	YY_BREAK
case 38:
YY_RULE_SETUP
fprintf(yyout,"SendMsg(RxMsg)");
	YY_BREAK
case 39:
YY_RULE_SETUP
vOutput();
	YY_BREAK
case 40:
YY_RULE_SETUP
vCancelTimer();
	YY_BREAK
case 41:
YY_RULE_SETUP
vOnLine();
	YY_BREAK
case 42:
YY_RULE_SETUP
vOffLine();
	YY_BREAK
case 43:
YY_RULE_SETUP
vTrigger();
	YY_BREAK
case 44:
YY_RULE_SETUP
vResetCan();
	YY_BREAK
case 45:
YY_RULE_SETUP
vDisconnect();
	YY_BREAK
case 46:
YY_RULE_SETUP
vFuncCall();  
	YY_BREAK
case 47:
YY_RULE_SETUP
ECHO,   yy_push_state(Comment);
	YY_BREAK
case 48:
YY_RULE_SETUP
vAddLine();
	YY_BREAK
case 49:
YY_RULE_SETUP
vFooter();	
	YY_BREAK
case 50:
YY_RULE_SETUP

	YY_BREAK
case 51:
YY_RULE_SETUP
ECHO,  yy_pop_state(); 
	YY_BREAK
case 52:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case 53:
YY_RULE_SETUP

	YY_BREAK
case 54:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case 55:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(FirstParse):
case YY_STATE_EOF(SecondParse):
case YY_STATE_EOF(VarDecl):
case YY_STATE_EOF(Delete):
case YY_STATE_EOF(Write):
case YY_STATE_EOF(Comment):
case YY_STATE_EOF(NoChange):
case YY_STATE_EOF(CaplFunc):
case YY_STATE_EOF(DelCommentML):
case YY_STATE_EOF(NoChangeFirstParse):
case YY_STATE_EOF(FooterState):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a singled characater, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1326 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1326 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 1325);

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yytext_ptr = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext_ptr + YY_MORE_ADJ;
						return EOF;
						}

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
					break;

				case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
					YY_FATAL_ERROR(
					"unexpected last match in yyinput()" );
#else
					YY_FATAL_ERROR(
					"unexpected last match in input()" );
#endif
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *str )
#else
YY_BUFFER_STATE yy_scan_string( str )
yyconst char *str;
#endif
	{
	int len;
	for ( len = 0; str[len]; ++len )
		;

	return yy_scan_bytes( str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif

int yywrap()
{
return 1;
}






































CConverter::CConverter()
{
    m_uiResultCode = CON_RC_NOERROR;
}




CConverter::~CConverter()
{
    m_listMessages.RemoveAll();
}

const char CConverter::m_accHeader[] =
    "//******************************BUSMASTER Messages and signals Database ******************************//\n";

unsigned int CConverter::Convert(CString sCanoeFile)
{
    fstream fileInput,fileOutput;
    char acLine[1024]; 
    fileInput.open(sCanoeFile, fstream::in);

    if(!fileInput.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);
    }

    
    if(fileInput.getline(acLine, 1024) == 0)
    {
        
        fileInput.close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
    }
    else 
    {
        
        if(strncmp(acLine, "VERSION ",8) != 0)
        {
            fileInput.close();
            return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
        }
    }

    
    GenerateMessageList(fileInput);
    
    
    ValidateMessageList();
    
    
    fileInput.close();
    
    BOOL bRes = 0;

    if(!bRes)
    {
        CString sLogFile = sCanoeFile.Left(sCanoeFile.GetLength()-4);
        sLogFile += ".log";
        fstream fileLog;
        fileLog.open(sLogFile, fstream::out);

        if(!fileLog.is_open())
        {
            
            return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);
        }
        else
        {
            CreateLogFile(fileLog);
            fileLog.close();
            return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
        }
    }

    return 1;
}

void CConverter::GetResultString(string& str)
{
    switch(m_uiResultCode)
    {
        case 0:
            str = "Conversion completed.";
            break;

        case 1:
            str = "Conversion completed with warnings. See log file.";
            break;

        case 2:
            str = "Conversion aborted. Error opening input file.";
            break;

        case 3:
            str = "Conversion aborted. Error creating output file.";
            break;

        case 4:
            str = "Conversion aborted. Error with input file format.";
            break;

        case 5:
            str = "Conversion aborted. Error creating log file.";
            break;

        default:
            str = "Unknown";
            break;
    }
}

unsigned int CConverter::SetResultCode(unsigned int uiCode)
{
    return (m_uiResultCode = uiCode);
}





bool CConverter::WriteToOutputFile(CString sCanMonFile)
{
    bool bResult = true;
    fstream fileOutput;
    
    
    
    fileOutput.open(sCanMonFile, fstream::out);

    if(!fileOutput.is_open())
    {
        
        
        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);
    }

    fileOutput << CConverter::m_accHeader;
    fileOutput << endl;
    
    fileOutput << "[""DATABASE_VERSION""]" " " "1.1";
    fileOutput << endl;
    fileOutput << endl;
    
    fileOutput << "[NUMBER_OF_MESSAGES] " << m_listMessages.GetCount() << endl;
    fileOutput << endl;
    
    POSITION pos = m_listMessages.GetHeadPosition();

    while(pos != 0)
    {
        CMessage& msg = m_listMessages.GetNext(pos);
        
        fileOutput << "[START_MSG] " << msg.m_acName;
        fileOutput << "," << dec << msg.m_uiMsgID;
        fileOutput << "," << dec << msg.m_ucLength;
        fileOutput << "," << dec << msg.m_ucNumOfSignals;
        fileOutput << "," << msg.m_cDataFormat;
        fileOutput << "," << msg.m_cFrameFormat << endl;
        
        POSITION posSig = msg.m_listSignals.GetHeadPosition();

        while(posSig != 0)
        {
            
            CSignal& sig = msg.m_listSignals.GetNext(posSig);

            
            if(sig.m_uiError == CSignal::SIG_EC_NO_ERR)
            {
                
                
                
                if(msg.m_cDataFormat == '0')
                {
                    sig.m_ucWhichByte = sig.m_ucWhichByte - (8 - msg.m_ucLength);
                }

                switch(sig.m_ucType)
                {
                    case CSignal::SIG_TYPE_BOOL:
                    case CSignal::SIG_TYPE_UINT:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << sig.m_ucType;
                        fileOutput << "," << dec << sig.m_MaxValue.uiValue;
                        fileOutput << "," << dec << sig.m_MinValue.uiValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                    case CSignal::SIG_TYPE_INT:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << sig.m_ucType;
                        fileOutput << "," << dec << sig.m_MaxValue.iValue;
                        fileOutput << "," << dec << sig.m_MinValue.iValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                        
                        

















                    case CSignal::SIG_TYPE_INT64:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << 'I'; 
                        fileOutput << "," << dec << sig.m_MaxValue.dValue;
                        fileOutput << "," << dec << sig.m_MinValue.dValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                    case CSignal::SIG_TYPE_UINT64:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << 'U'; 
                        fileOutput << "," << dec << sig.m_MaxValue.dValue;
                        fileOutput << "," << dec << sig.m_MinValue.dValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                    default:
                        break;
                }

                
                POSITION posValDesc = sig.m_listValueDescriptor.GetHeadPosition();

                while(posValDesc != 0)
                {
                    CValueDescriptor& rValDesc = sig.m_listValueDescriptor.GetNext(posValDesc);

                    switch(sig.m_ucType)
                    {
                        case CSignal::SIG_TYPE_BOOL:
                        case CSignal::SIG_TYPE_UINT:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.uiValue << endl;
                            break;

                        case CSignal::SIG_TYPE_INT:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.iValue << endl;
                            break;

                            
                            









                        case CSignal::SIG_TYPE_INT64:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.i64Value << endl;
                            break;

                        case CSignal::SIG_TYPE_UINT64:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.ui64Value << endl;
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                bResult = false;
            }
        }

        
        fileOutput << "[END_MSG]" << endl << endl;
    }

    fileOutput.close();
    return bResult;
}



void CConverter::ValidateMessageList()
{
    POSITION pos = m_listMessages.GetHeadPosition();

    while(pos != 0)
    {
        CMessage& rMsg = m_listMessages.GetNext(pos);
        unsigned char ucDataFormat = 0;
        unsigned int uiResult;

        
        
        if(rMsg.m_uiMsgID < 0x80000000UL)
        {
            rMsg.m_cFrameFormat = CMessage::MSG_FF_STANDARD;
        }
        else
        {
            rMsg.m_cFrameFormat = CMessage::MSG_FF_EXTENDED;
            rMsg.m_uiMsgID &= 0x7FFFFFFF;
        }

        rMsg.m_ucNumOfSignals = 0; 
        
        
        
        
        
        POSITION posSigx = rMsg.m_listSignals.GetHeadPosition();
        int iCntMotorolaSignals = 0;
        int iCntIntelSignals = 0;

        while(posSigx != 0)
        {
            CSignal& rSig = rMsg.m_listSignals.GetNext(posSigx);

            if(rSig.m_ucDataFormat == CSignal::SIG_DF_INTEL)
            {
                iCntIntelSignals++;
            }
            else if(rSig.m_ucDataFormat == CSignal::SIG_DF_MOTOROLA)
            {
                iCntMotorolaSignals++;
            }
        }

        
        if(iCntIntelSignals >= iCntMotorolaSignals)
        {
            ucDataFormat = CSignal::SIG_DF_INTEL;
            rMsg.m_cDataFormat = ucDataFormat; 
        }
        else
        {
            ucDataFormat = CSignal::SIG_DF_MOTOROLA;
            rMsg.m_cDataFormat = ucDataFormat;
        }

        
        POSITION posSig = rMsg.m_listSignals.GetHeadPosition();

        while(posSig != 0)
        {
            CSignal& rSig = rMsg.m_listSignals.GetNext(posSig);
            uiResult = rSig.Validate(ucDataFormat);

            
            if(uiResult == CSignal::SIG_EC_NO_ERR)
            {
                






                rMsg.m_ucNumOfSignals++; 
            }
        }

        posSig = rMsg.m_listSignals.GetHeadPosition();
        __int64 n64Matrix = 0;

        while(posSig != 0)
        {
            CSignal& rSig = rMsg.m_listSignals.GetNext(posSig);
            __int64 n64Mask = ( 1 << rSig.m_ucLength ) - 1;
            n64Mask <<=
                ( rSig.m_ucWhichByte - 1 ) * 8 + rSig.m_ucStartBit;

            if( n64Matrix & n64Mask )
            {
                rSig.m_uiError = CSignal::SIG_EC_OVERLAP;
                rMsg.m_ucNumOfSignals--;
            }
            else
            {
                n64Matrix |= n64Mask;
            }
        }
    }
}


void CConverter::GenerateMessageList(fstream& fileInput)
{
    char acLine[1024]; 
    
    BOOL bSkipSignalParsing = 0;

    
    while(fileInput.getline(acLine, 1024))
    {
        char* pcToken;
        char* pcNextToken;
        char* pcLine;
        
        
        
        pcLine = acLine;

        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        pcToken = strtok_s(pcLine, " :", &pcNextToken);

        if(pcToken)
        {
            

            
            if(strcmp(pcToken,"\n") == 0)
            {
                continue;
            }
            
            else if(strcmp(pcToken,"BO_") == 0)
            {
                CMessage msg;
                msg.Format(pcLine + strlen(pcToken)+1);

                if( msg.m_uiMsgID != 0xc0000000 ) 
                {
                    bSkipSignalParsing = 0;
                    
                    m_listMessages.AddTail(msg);
                }
                else
                {
                    bSkipSignalParsing = 1;
                }
            }
            
            else if(strcmp(pcToken,"SG_") == 0)
            {
                if( bSkipSignalParsing == 0 )
                {
                    CSignal sig;
                    sig.Format(pcLine + strlen(pcToken)+1);
                    POSITION pos = m_listMessages.GetTailPosition();
                    CMessage& msg = m_listMessages.GetAt(pos);
                    msg.m_listSignals.AddTail(sig);
                    
                    msg.m_ucNumOfSignals++; 
                }
            }
            
            else if(strcmp(pcToken,"VAL_") == 0)
            {
                
                
                
                
                pcLine = pcLine + strlen(pcToken) + 1; 
                pcToken = strtok_s(pcLine, " ", &pcNextToken); 
                unsigned int id = (unsigned int)atoi(pcToken);
                POSITION posMsg = m_listMessages.GetHeadPosition();

                while(posMsg != 0)
                {
                    CMessage& rMsg = m_listMessages.GetNext(posMsg);

                    
                    if(rMsg.m_uiMsgID == id)
                    {
                        pcLine = pcLine + strlen(pcToken) + 1; 
                        pcToken = strtok_s(pcLine, " ", &pcNextToken); 
                        POSITION posSig = rMsg.m_listSignals.GetHeadPosition();

                        
                        while(posSig != 0)
                        {
                            
                            CSignal& rSig =  rMsg.m_listSignals.GetNext(posSig);

                            if(strcmp(rSig.m_acName.c_str(),pcToken) == 0)
                            {
                                rSig.AddValueDescriptors(pcLine + strlen(pcToken) + 1);
                                break; 
                            }
                        }

                        break; 
                    }
                }
            }
            
            else if(strcmp(pcToken,"SIG_VALTYPE_") == 0)
            {
                
                
                
                
                
                pcToken = strtok_s(0, " :;", &pcNextToken); 
                unsigned int id = (unsigned int)atoi(pcToken);
                POSITION posMsg = m_listMessages.GetHeadPosition();

                while(posMsg != 0)
                {
                    CMessage& rMsg = m_listMessages.GetNext(posMsg);

                    
                    if(rMsg.m_uiMsgID == id)
                    {
                        pcToken = strtok_s(0, " :;", &pcNextToken); 
                        POSITION posSig = rMsg.m_listSignals.GetHeadPosition();

                        
                        while(posSig != 0)
                        {
                            CSignal& rSig =  rMsg.m_listSignals.GetNext(posSig);

                            if(strcmp(rSig.m_acName.c_str(),pcToken) == 0)
                            {
                                if(pcToken = strtok_s(0, " :;", &pcNextToken)) 
                                {
                                    
                                    switch(*pcToken)
                                    {
                                        case '1':
                                            rSig.m_ucType = CSignal::SIG_TYPE_FLOAT;
                                            break;

                                        case '2':
                                            rSig.m_ucType = CSignal::SIG_TYPE_DOUBLE;
                                            break;

                                        default:
                                            break;
                                    }
                                }

                                break; 
                            }
                        }

                        break; 
                    }
                }
            }
            
            else
            {
                continue;
            }
        }
    }
}




void CConverter::CreateLogFile(fstream& fileLog)
{
    
    char acMsgLine[200];
    fileLog << "Conversion Error Log" << endl;
    fileLog << endl;
    
    
    POSITION pos = m_listMessages.GetHeadPosition();

    while(pos != 0)
    {
        acMsgLine[0] = '\0';
        CMessage& msg = m_listMessages.GetNext(pos);
        POSITION posSig = msg.m_listSignals.GetHeadPosition();

        while(posSig != 0)
        {
            CSignal& sig = msg.m_listSignals.GetNext(posSig);

            
            if(sig.m_uiError != CSignal::SIG_EC_NO_ERR)
            {
                string str;

                
                if(acMsgLine[0] == '\0')
                {
                    fileLog << endl;
                    fileLog << "MSG_ID: " << dec << msg.m_uiMsgID;
                    fileLog << "\tMSG_NAME: " << msg.m_acName << endl;
                }

                sig.GetErrorString(str);
                fileLog << "\tDiscarded SIG_NAME: " << sig.m_acName;
                fileLog << ", Reason: " << str.c_str() << endl;
            }
        }
    }
}

CMessage CConverter::ouFindMessage(CString omStrMsgName)
{
    CMessage omTemp;
    POSITION pos = m_listMessages.GetHeadPosition();

    
    for (int index = 0; index < m_listMessages.GetCount(); index++)
    {
        
        omTemp = m_listMessages.GetNext(pos);

        
        if(omStrMsgName == omTemp.m_acName.c_str())
        {
            
            return omTemp;
        }
    }

    
    omTemp.m_uiMsgID = 0xffffffff;
    return omTemp;
}


CMessage CConverter::ouFindMessage(UINT nMsgID)
{
    POSITION pos = m_listMessages.GetHeadPosition();
    CMessage omTemp;

    
    for (int index = 0; index < m_listMessages.GetCount(); index++)
    {
        
        omTemp = m_listMessages.GetNext(pos);

        
        if( nMsgID == omTemp.m_uiMsgID)
        {
            
            return omTemp;
        }
    }

    
    omTemp.m_uiMsgID = 0xffffffff;
    return omTemp;
}
         ì     ì     êÿÿÿÿ  êÿÿÿÿ    MJ˜      expression was true       *pcLine   ìÿÿÿÿ  ê     ìÿÿÿÿ  ê      expression was false       *pcLine   ìÿÿÿÿ  ê     ìÿÿÿÿ  ê                   Î     Î   :  Ìÿÿÿÿ  Ìÿÿÿÿ    SÅ      expression was false       index < m_listMessages.GetCount()   Îÿÿÿÿ  Ì     Îÿÿÿÿ  Ì   :                µ     µ   :  ³ÿÿÿÿ  ³ÿÿÿÿ    S¹8      expression was false       index < m_listMessages.GetCount()   µÿÿÿÿ  ³     µÿÿÿÿ  ³   :                –     –     ”ÿÿÿÿ  ”ÿÿÿÿ    S¬X      expression was false       posSig != 0   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”                  SÈ                  ÿÿÿÿ  ÿÿÿÿ    S®      expression was false       pos != 0   ÿÿÿÿ       ÿÿÿÿ                    S˜¨        Z     Z   *  Xÿÿÿÿ  Xÿÿÿÿ     ò      expression was false       posSig != 0   Zÿÿÿÿ  X     Zÿÿÿÿ  X   *                ñ÷        O     O   "  Mÿÿÿÿ  Mÿÿÿÿ     ò	      expression was false       posMsg != 0   Oÿÿÿÿ  M     Oÿÿÿÿ  M   "                ñğH        3     3   *  1ÿÿÿÿ  1ÿÿÿÿ     ñä8      expression was false       posSig != 0   3ÿÿÿÿ  1     3ÿÿÿÿ  1   *                ñİX   	     '     '   "  %ÿÿÿÿ  %ÿÿÿÿ     ñç¸      expression was false       posMsg != 0   'ÿÿÿÿ  %     'ÿÿÿÿ  %   "                ñÒ¨   
     ì     ì   (  êÿÿÿÿ  êÿÿÿÿ    MKp      expression was true       *pcLine == ' '   ìÿÿÿÿ  ê     ìÿÿÿÿ  ê   (   expression was false       *pcLine == ' '   ìÿÿÿÿ  ê     ìÿÿÿÿ  ê   (               MIÀ        â     â   *  àÿÿÿÿ  àÿÿÿÿ    S’      expression was false       fileInput.getline(acLine, 1024)   âÿÿÿÿ  à     âÿÿÿÿ  à   *                Æ     Æ     Äÿÿÿÿ  Äÿÿÿÿ    M@P      expression was false       posSig != 0   Æÿÿÿÿ  Ä     Æÿÿÿÿ  Ä                   5ŞÀ        °     °     ®ÿÿÿÿ  ®ÿÿÿÿ     ,e      expression was false       posSig != 0   °ÿÿÿÿ  ®     °ÿÿÿÿ  ®                  $ë        “     “     ‘ÿÿÿÿ  ‘ÿÿÿÿ    `à      expression was false       posSigx != 0   “ÿÿÿÿ  ‘     “ÿÿÿÿ  ‘                   .
À        w     w     uÿÿÿÿ  uÿÿÿÿ    MB      expression was false       pos != 0   wÿÿÿÿ  u     wÿÿÿÿ  u                   .         8     8   &  6ÿÿÿÿ  6ÿÿÿÿ    Oè      expression was false       posValDesc != 0   8ÿÿÿÿ  6     8ÿÿÿÿ  6   &               S`         Ë      Ë      Éÿÿÿÿ   Éÿÿÿÿ     .€      expression was false       posSig != 0    Ëÿÿÿÿ   É      Ëÿÿÿÿ   É                   )«          ¾      ¾      ¼ÿÿÿÿ   ¼ÿÿÿÿ     .À      expression was false       pos != 0    ¾ÿÿÿÿ   ¼      ¾ÿÿÿÿ   ¼                   )­P        Ô     Ô   '  Òÿÿÿÿ  Òÿÿÿÿ    SÃĞ      expression was false       nMsgID == omTemp.m_uiMsgID   Ôÿÿÿÿ  Ò     Ôÿÿÿÿ  Ò   '               SÂ        »     »   3  ¹ÿÿÿÿ  ¹ÿÿÿÿ    S·x      expression was false       omStrMsgName == omTemp.m_acName.c_str()   »ÿÿÿÿ  ¹     »ÿÿÿÿ  ¹   3               Sµ°                  (  ÿÿÿÿ  ÿÿÿÿ    S¦à      expression was false       acMsgLine[0] == '\0'    ÿÿÿÿ        ÿÿÿÿ     (               S¢ˆ        ›     ›   7  ™ÿÿÿÿ  ™ÿÿÿÿ    Sª˜      expression was false       sig.m_uiError != CSignal::SIG_EC_NO_ERR   ›ÿÿÿÿ  ™     ›ÿÿÿÿ  ™   7               S Ğ        `   $  `   N  ^ÿÿÿÿ  ^ÿÿÿÿ     ò       expression was false       pcToken = strtok_s(0, " :;", &pcNextToken)   `ÿÿÿÿ  ^   $  `ÿÿÿÿ  ^   N                ^      ^   J  \ÿÿÿÿ  \ÿÿÿÿ     òP      expression was false       strcmp(rSig.m_acName.c_str(),pcToken) == 0   ^ÿÿÿÿ  \      ^ÿÿÿÿ  \   J                ñúX        T     T   ,  Rÿÿÿÿ  Rÿÿÿÿ     òĞ      expression was false       rMsg.m_uiMsgID == id   Tÿÿÿÿ  R     Tÿÿÿÿ  R   ,                ñó`        8      8   J  6ÿÿÿÿ  6ÿÿÿÿ     ñâx      expression was false       strcmp(rSig.m_acName.c_str(),pcToken) == 0   8ÿÿÿÿ  6      8ÿÿÿÿ  6   J                ñà         ,     ,   ,  *ÿÿÿÿ  *ÿÿÿÿ     ñåø      expression was false       rMsg.m_uiMsgID == id   ,ÿÿÿÿ  *     ,ÿÿÿÿ  *   ,                ñÕÀ                ,  ÿÿÿÿ  ÿÿÿÿ    Md€      expression was false       bSkipSignalParsing == 0   ÿÿÿÿ       ÿÿÿÿ     ,               M](        ó     ó     ñÿÿÿÿ  ñÿÿÿÿ    Sà      expression was false       pcToken   óÿÿÿÿ  ñ     óÿÿÿÿ  ñ                   ¶     ¶   2  ´ÿÿÿÿ  ´ÿÿÿÿ    ](      expression was false       uiResult == CSignal::SIG_EC_NO_ERR   ¶ÿÿÿÿ  ´     ¶ÿÿÿÿ  ´   2               Sˆx         ›     ›   D  ™ÿÿÿÿ  ™ÿÿÿÿ    sĞ      expression was false       rSig.m_ucDataFormat == CSignal::SIG_DF_MOTOROLA   ›ÿÿÿÿ  ™     ›ÿÿÿÿ  ™   D                ¸P   !      Ö      Ö   ,   Ôÿÿÿÿ   Ôÿÿÿÿ     )‘¸      expression was false       msg.m_cDataFormat == '0'    Öÿÿÿÿ   Ô      Öÿÿÿÿ   Ô   ,                )¢x   "      «      «      ©ÿÿÿÿ   ©ÿÿÿÿ    ÄĞ      expression was false       !fileOutput.is_open()    «ÿÿÿÿ   ©      «ÿÿÿÿ   ©                  ¯8   #      `      `      ^ÿÿÿÿ   ^ÿÿÿÿ    Œ@8      expression was false       !bRes    `ÿÿÿÿ   ^      `ÿÿÿÿ   ^                  $éh   $      N      N   .   Lÿÿÿÿ   Lÿÿÿÿ     Óx      expression was false       strncmp(acLine, "VERSION ",8) != 0    Nÿÿÿÿ   L      Nÿÿÿÿ   L   .                Ø(   %      ?      ?      =ÿÿÿÿ   =ÿÿÿÿ    $ÏÈ      expression was false       !fileInput.is_open()    ?ÿÿÿÿ   =      ?ÿÿÿÿ   =                   ,E@   &     İ     İ     Ûÿÿÿÿ  Ûÿÿÿÿ    SÇ°       statement executed        return omTemp;   İÿÿÿÿ  Û     İÿÿÿÿ  Û              '     Ù     Ù     ×ÿÿÿÿ  ×ÿÿÿÿ    SÄ¸       statement executed        }   Ùÿÿÿÿ  ×     Ùÿÿÿÿ  ×              (     ×     ×     Õÿÿÿÿ  Õÿÿÿÿ    SÂø       statement executed        return omTemp;   ×ÿÿÿÿ  Õ     ×ÿÿÿÿ  Õ              )     Ä     Ä     Âÿÿÿÿ  Âÿÿÿÿ    S»X       statement executed        return omTemp;   Äÿÿÿÿ  Â     Äÿÿÿÿ  Â              *     À     À     ¾ÿÿÿÿ  ¾ÿÿÿÿ    S¸`       statement executed        }   Àÿÿÿÿ  ¾     Àÿÿÿÿ  ¾              +     ¾     ¾     ¼ÿÿÿÿ  ¼ÿÿÿÿ    S¶        statement executed        return omTemp;   ¾ÿÿÿÿ  ¼     ¾ÿÿÿÿ  ¼              ,     ­     ­     «ÿÿÿÿ  «ÿÿÿÿ    S¯        statement executed        }   ­ÿÿÿÿ  «     ­ÿÿÿÿ  «              -     ¬     ¬     ªÿÿÿÿ  ªÿÿÿÿ    S­@       statement executed        }   ¬ÿÿÿÿ  ª     ¬ÿÿÿÿ  ª              .     «   	  «   
  ©ÿÿÿÿ  ©ÿÿÿÿ    S«€       statement executed        }   «ÿÿÿÿ  ©   	  «ÿÿÿÿ  ©   
           /     ª     ª     ¨ÿÿÿÿ  ¨ÿÿÿÿ    S©À       statement executed        }   ªÿÿÿÿ  ¨     ªÿÿÿÿ  ¨              0     ¥     ¥     £ÿÿÿÿ  £ÿÿÿÿ    S¦       statement executed        }   ¥ÿÿÿÿ  £     ¥ÿÿÿÿ  £              1               ÿÿÿÿ  ÿÿÿÿ    S“h       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                2     €     €     ~ÿÿÿÿ  ~ÿÿÿÿ    S‘¸       statement executed        }   €ÿÿÿÿ  ~     €ÿÿÿÿ  ~              3     }     }     {ÿÿÿÿ  {ÿÿÿÿ     òP       statement executed        continue;   }ÿÿÿÿ  {     }ÿÿÿÿ  {              4     y     y     wÿÿÿÿ  wÿÿÿÿ     ò
x       statement executed        }   yÿÿÿÿ  w     yÿÿÿÿ  w              5     x     x     vÿÿÿÿ  vÿÿÿÿ     ò¸       statement executed        }   xÿÿÿÿ  v     xÿÿÿÿ  v              6     v     v     tÿÿÿÿ  tÿÿÿÿ     òø       statement executed        break;   vÿÿÿÿ  t     vÿÿÿÿ  t              7     t     t     rÿÿÿÿ  rÿÿÿÿ     ò8       statement executed        }   tÿÿÿÿ  r     tÿÿÿÿ  r              8     r   !  r   '  pÿÿÿÿ  pÿÿÿÿ     òx       statement executed        break;   rÿÿÿÿ  p   !  rÿÿÿÿ  p   '           9     p   !  p   "  nÿÿÿÿ  nÿÿÿÿ     òÈ       statement executed        }   pÿÿÿÿ  n   !  pÿÿÿÿ  n   "           :     n   -  n   3  lÿÿÿÿ  lÿÿÿÿ     ò ğ       statement executed        break;   nÿÿÿÿ  l   -  nÿÿÿÿ  l   3           ;     k   -  k   3  iÿÿÿÿ  iÿÿÿÿ     ò        statement executed        break;   kÿÿÿÿ  i   -  kÿÿÿÿ  i   3           <     g   -  g   3  eÿÿÿÿ  eÿÿÿÿ     ñı        statement executed        break;   gÿÿÿÿ  e   -  gÿÿÿÿ  e   3           =     B     B     @ÿÿÿÿ  @ÿÿÿÿ     ñè        statement executed        }   Bÿÿÿÿ  @     Bÿÿÿÿ  @              >     A     A     ?ÿÿÿÿ  ?ÿÿÿÿ     ñæà       statement executed        }   Aÿÿÿÿ  ?     Aÿÿÿÿ  ?              ?     ?     ?     =ÿÿÿÿ  =ÿÿÿÿ     ñå        statement executed        break;   ?ÿÿÿÿ  =     ?ÿÿÿÿ  =              @     =     =     ;ÿÿÿÿ  ;ÿÿÿÿ     ñã`       statement executed        }   =ÿÿÿÿ  ;     =ÿÿÿÿ  ;              A     ;   !  ;   '  9ÿÿÿÿ  9ÿÿÿÿ     ñá        statement executed        break;   ;ÿÿÿÿ  9   !  ;ÿÿÿÿ  9   '           B               ÿÿÿÿ  ÿÿÿÿ    Meh       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                C               ÿÿÿÿ  ÿÿÿÿ    Mc¨       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                D               	ÿÿÿÿ  	ÿÿÿÿ    MZ        statement executed        }   ÿÿÿÿ  	     ÿÿÿÿ  	              E               ÿÿÿÿ  ÿÿÿÿ    MX        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                F     ú     ú     øÿÿÿÿ  øÿÿÿÿ    MR(       statement executed        continue;   úÿÿÿÿ  ø     úÿÿÿÿ  ø              G     ï   	  ï   
  íÿÿÿÿ  íÿÿÿÿ    MM˜       statement executed        }   ïÿÿÿÿ  í   	  ïÿÿÿÿ  í   
           H     Ø     Ø     Öÿÿÿÿ  Öÿÿÿÿ    MBø       statement executed        }   Øÿÿÿÿ  Ö     Øÿÿÿÿ  Ö              I     ×     ×     Õÿÿÿÿ  Õÿÿÿÿ    MA8       statement executed        }   ×ÿÿÿÿ  Õ     ×ÿÿÿÿ  Õ              J     Õ     Õ     Óÿÿÿÿ  Óÿÿÿÿ    M>è       statement executed        }   Õÿÿÿÿ  Ó     Õÿÿÿÿ  Ó              K     Ñ     Ñ     Ïÿÿÿÿ  Ïÿÿÿÿ    ?İˆ       statement executed        }   Ñÿÿÿÿ  Ï     Ñÿÿÿÿ  Ï              L     Á   	  Á   
  ¿ÿÿÿÿ  ¿ÿÿÿÿ    VĞ       statement executed        }   Áÿÿÿÿ  ¿   	  Áÿÿÿÿ  ¿   
           M     À     À     ¾ÿÿÿÿ  ¾ÿÿÿÿ    S|ğ       statement executed        }   Àÿÿÿÿ  ¾     Àÿÿÿÿ  ¾              N     «   	  «   
  ©ÿÿÿÿ  ©ÿÿÿÿ    ŒGP       statement executed        }   «ÿÿÿÿ  ©   	  «ÿÿÿÿ  ©   
           O     ¦   	  ¦   
  ¤ÿÿÿÿ  ¤ÿÿÿÿ    Œ^       statement executed        }   ¦ÿÿÿÿ  ¤   	  ¦ÿÿÿÿ  ¤   
           P               œÿÿÿÿ  œÿÿÿÿ     ó€       statement executed        }   ÿÿÿÿ  œ     ÿÿÿÿ  œ              Q     š     š     ˜ÿÿÿÿ  ˜ÿÿÿÿ     ,°X       statement executed        }   šÿÿÿÿ  ˜     šÿÿÿÿ  ˜              R     ‡   	  ‡   
  …ÿÿÿÿ  …ÿÿÿÿ     ºp       statement executed        }   ‡ÿÿÿÿ  …   	  ‡ÿÿÿÿ  …   
           S      ,      ,      *ÿÿÿÿ   *ÿÿÿÿ     à€       statement executed        }    ,ÿÿÿÿ   *      ,ÿÿÿÿ   *              T      4      4      2ÿÿÿÿ   2ÿÿÿÿ     ,SĞ       statement executed        }    4ÿÿÿÿ   2      4ÿÿÿÿ   2              U      A   	   A   <   ?ÿÿÿÿ   ?ÿÿÿÿ    $ãP       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);    Aÿÿÿÿ   ?   	   Aÿÿÿÿ   ?   <           V      I   	   I   :   Gÿÿÿÿ   Gÿÿÿÿ     ,x        statement executed        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);    Iÿÿÿÿ   G   	   Iÿÿÿÿ   G   :           W      Q      Q   >   Oÿÿÿÿ   Oÿÿÿÿ     ã˜       statement executed        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);    Qÿÿÿÿ   O      Qÿÿÿÿ   O   >           X      S      S      Qÿÿÿÿ   Qÿÿÿÿ     Ò        statement executed        }    Sÿÿÿÿ   Q      Sÿÿÿÿ   Q              Y      j      j   A   hÿÿÿÿ   hÿÿÿÿ    $Ø       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);    jÿÿÿÿ   h      jÿÿÿÿ   h   A           Z      p      p   ?   nÿÿÿÿ   nÿÿÿÿ    $Õ       statement executed        return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);    pÿÿÿÿ   n      pÿÿÿÿ   n   ?           [      t      t      rÿÿÿÿ   rÿÿÿÿ    À¸       statement executed        return 1;    tÿÿÿÿ   r      tÿÿÿÿ   r              \      }      }      {ÿÿÿÿ   {ÿÿÿÿ     è0       statement executed        break;    }ÿÿÿÿ   {      }ÿÿÿÿ   {              ]                  ÿÿÿÿ   ÿÿÿÿ     ,ƒè       statement executed        break;    ÿÿÿÿ         ÿÿÿÿ                 ^      …      …      ƒÿÿÿÿ   ƒÿÿÿÿ     ,{À       statement executed        break;    …ÿÿÿÿ   ƒ      …ÿÿÿÿ   ƒ              _      ‰      ‰      ‡ÿÿÿÿ   ‡ÿÿÿÿ    ±¨       statement executed        break;    ‰ÿÿÿÿ   ‡      ‰ÿÿÿÿ   ‡              `                  ‹ÿÿÿÿ   ‹ÿÿÿÿ     Ğ       statement executed        break;    ÿÿÿÿ   ‹      ÿÿÿÿ   ‹              a      ‘      ‘      ÿÿÿÿ   ÿÿÿÿ     Ş        statement executed        break;    ‘ÿÿÿÿ         ‘ÿÿÿÿ                 b      •      •      “ÿÿÿÿ   “ÿÿÿÿ     â0       statement executed        break;    •ÿÿÿÿ   “      •ÿÿÿÿ   “              c      —      —      •ÿÿÿÿ   •ÿÿÿÿ    ¸`       statement executed        }    —ÿÿÿÿ   •      —ÿÿÿÿ   •              d      ›      ›   &   ™ÿÿÿÿ   ™ÿÿÿÿ    “       statement executed        return (m_uiResultCode = uiCode);    ›ÿÿÿÿ   ™      ›ÿÿÿÿ   ™   &           e      ¯   	   ¯   =   ­ÿÿÿÿ   ­ÿÿÿÿ    ¥˜       statement executed        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);    ¯ÿÿÿÿ   ­   	   ¯ÿÿÿÿ   ­   =           f      Ù      Ù      ×ÿÿÿÿ   ×ÿÿÿÿ     )”       statement executed        }    Ùÿÿÿÿ   ×      Ùÿÿÿÿ   ×              g      ì      ì      êÿÿÿÿ   êÿÿÿÿ    S       statement executed        break;    ìÿÿÿÿ   ê      ìÿÿÿÿ   ê              h      ü      ü      úÿÿÿÿ   úÿÿÿÿ    S‹°       statement executed        break;    üÿÿÿÿ   ú      üÿÿÿÿ   ú              i               ÿÿÿÿ  ÿÿÿÿ    S‰        statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                j     /     /     -ÿÿÿÿ  -ÿÿÿÿ    S†È       statement executed        break;   /ÿÿÿÿ  -     /ÿÿÿÿ  -              k     2     2     0ÿÿÿÿ  0ÿÿÿÿ    S‚       statement executed        break;   2ÿÿÿÿ  0     2ÿÿÿÿ  0              l     B     B   #  @ÿÿÿÿ  @ÿÿÿÿ    S{@       statement executed        break;   Bÿÿÿÿ  @     Bÿÿÿÿ  @   #           m     G     G   #  Eÿÿÿÿ  Eÿÿÿÿ    SvP       statement executed        break;   Gÿÿÿÿ  E     Gÿÿÿÿ  E   #           n     W     W   #  Uÿÿÿÿ  Uÿÿÿÿ    Stø       statement executed        break;   Wÿÿÿÿ  U     Wÿÿÿÿ  U   #           o     \     \   #  Zÿÿÿÿ  Zÿÿÿÿ    St(       statement executed        break;   \ÿÿÿÿ  Z     \ÿÿÿÿ  Z   #           p     _     _   #  ]ÿÿÿÿ  ]ÿÿÿÿ    [x       statement executed        break;   _ÿÿÿÿ  ]     _ÿÿÿÿ  ]   #           q     a     a     _ÿÿÿÿ  _ÿÿÿÿ    QH       statement executed        }   aÿÿÿÿ  _     aÿÿÿÿ  _              r     b     b     `ÿÿÿÿ  `ÿÿÿÿ     .#        statement executed        }   bÿÿÿÿ  `     bÿÿÿÿ  `              s     f     f     dÿÿÿÿ  dÿÿÿÿ     . @       statement executed        }   fÿÿÿÿ  d     fÿÿÿÿ  d              t     k     k     iÿÿÿÿ  iÿÿÿÿ     .        statement executed        }   kÿÿÿÿ  i     kÿÿÿÿ  i              u     n     n     lÿÿÿÿ  lÿÿÿÿ     .`       statement executed        return bResult;   nÿÿÿÿ  l     nÿÿÿÿ  l              v     ‚   	  ‚   
  €ÿÿÿÿ  €ÿÿÿÿ     É       statement executed        }   ‚ÿÿÿÿ  €   	  ‚ÿÿÿÿ  €   
        CConverter::CConverter CConverter::CConverter()    *      ,      (ÿÿÿÿ   *ÿÿÿÿCConverter::~CConverter CConverter::~CConverter()    2      4      0ÿÿÿÿ   2ÿÿÿÿCConverter::Convert unsigned int CConverter::Convert(CString sCanoeFile)    :      u      8ÿÿÿÿ   sÿÿÿÿCConverter::GetResultString void CConverter::GetResultString(string& str)    x      —      vÿÿÿÿ   •ÿÿÿÿCConverter::SetResultCode unsigned int CConverter::SetResultCode(unsigned int uiCode)    š      œ      ˜ÿÿÿÿ   šÿÿÿÿCConverter::WriteToOutputFile bool CConverter::WriteToOutputFile(CString sCanMonFile)    £     o      ¡ÿÿÿÿ  mÿÿÿÿCConverter::ValidateMessageList void CConverter::ValidateMessageList()   t     Ø     rÿÿÿÿ  ÖÿÿÿÿCConverter::GenerateMessageList void CConverter::GenerateMessageList(fstream& fileInput)   Ü          Úÿÿÿÿ  ÿÿÿÿCConverter::CreateLogFile void CConverter::CreateLogFile(fstream& fileLog)   ‡     ­     …ÿÿÿÿ  «ÿÿÿÿCConverter::ouFindMessage CMessage CConverter::ouFindMessage(CString omStrMsgName)   °     Å     ®ÿÿÿÿ  ÃÿÿÿÿCConverter::ouFindMessage CMessage CConverter::ouFindMessage(UINT nMsgID)   É     Ş     Çÿÿÿÿ  Üÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Converter.cpp
 * \brief     Implementation file for CConverter class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CConverter class
 */

/* Project includes */
#include "ConstString.h"
#include "Converter.h"
#include "Signal.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define defCON_MAX_LINE_LEN 1024

/**
 * Construction
 */
CConverter::CConverter()
{
    m_uiResultCode = CON_RC_NOERROR;
}

/**
 * Destruction
 */
CConverter::~CConverter()
{
    m_listMessages.RemoveAll();
}

const char CConverter::m_accHeader[] =
    "//******************************BUSMASTER Messages and signals Database ******************************//\n";

unsigned int CConverter::Convert(CString sCanoeFile)
{
    fstream fileInput,fileOutput;
    char acLine[defCON_MAX_LINE_LEN]; // I don't expect one line to be more than this
    fileInput.open(sCanoeFile, fstream::in);

    if(!fileInput.is_open())
    {
        return SetResultCode(CON_RC_FILEOPEN_ERROR_INFILE);
    }

    // first line of input file starts with keyword "VERSION", else file format error
    if(fileInput.getline(acLine, defCON_MAX_LINE_LEN) == NULL)
    {
        // eof file reached without reading anything
        fileInput.close();
        return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
    }
    else // if something was read
    {
        // verify the format
        if(strncmp(acLine, "VERSION ",8) != 0)
        {
            fileInput.close();
            return SetResultCode(CON_RC_FORMAT_ERROR_INFILE);
        }
    }

    // Generate the list of messages
    GenerateMessageList(fileInput);
    // All information gathered, validate and update if necessary
    // Make appropriate changes in the contents of the list
    ValidateMessageList();
    // the format is OK then open the output file
    //  bool bRes = WriteToOutputFile(fileOutput);
    fileInput.close();
    //  fileOutput.close();
    BOOL bRes = FALSE;

    if(!bRes)
    {
        CString sLogFile = sCanoeFile.Left(sCanoeFile.GetLength()-4);
        sLogFile += ".log";
        fstream fileLog;
        fileLog.open(sLogFile, fstream::out);

        if(!fileLog.is_open())
        {
            // if log file cannot be opened return the error code
            return SetResultCode(CON_RC_FILEOPEN_ERROR_LOGFILE);
        }
        else
        {
            CreateLogFile(fileLog);
            fileLog.close();
            return SetResultCode(CON_RC_COMPLETED_WITH_ERROR);
        }
    }

    return 1;
}

void CConverter::GetResultString(string& str)
{
    switch(m_uiResultCode)
    {
        case 0:
            str = "Conversion completed.";
            break;

        case 1:
            str = "Conversion completed with warnings. See log file.";
            break;

        case 2:
            str = "Conversion aborted. Error opening input file.";
            break;

        case 3:
            str = "Conversion aborted. Error creating output file.";
            break;

        case 4:
            str = "Conversion aborted. Error with input file format.";
            break;

        case 5:
            str = "Conversion aborted. Error creating log file.";
            break;

        default:
            str = "Unknown";
            break;
    }
}

unsigned int CConverter::SetResultCode(unsigned int uiCode)
{
    return (m_uiResultCode = uiCode);
}

// parses the full message list and makes any changes required for
// BUSMASTER format
// Message Data format = DF of first signal, discard all signals of other type

bool CConverter::WriteToOutputFile(CString sCanMonFile)
{
    bool bResult = true;
    fstream fileOutput;
    // write to the output file
    // write header
    //  FILE *message = fopen("d:\\message.txt","w");
    fileOutput.open(sCanMonFile, fstream::out);

    if(!fileOutput.is_open())
    {
        // if output file cannot be opened the close the input file
        // and return the error code
        return SetResultCode(CON_RC_FILEOPEN_ERROR_OUTFILE);
    }

    fileOutput << CConverter::m_accHeader;
    fileOutput << endl;
    //Version no.
    fileOutput << defSTR_DB_VER " " defSTR_VER_NO;
    fileOutput << endl;
    fileOutput << endl;
    // number of messages
    fileOutput << "[NUMBER_OF_MESSAGES] " << m_listMessages.GetCount() << endl;
    fileOutput << endl;
    // write all messages, signals and value descriptors
    POSITION pos = m_listMessages.GetHeadPosition();

    while(pos != NULL)
    {
        CMessage& msg = m_listMessages.GetNext(pos);
        // MSG,MSGID,MSG_LENGTH,NO_OF_SIGNALS,DATA_FORMAT,FRAME_FORMAT
        fileOutput << "[START_MSG] " << msg.m_acName;
        fileOutput << "," << dec << msg.m_uiMsgID;
        fileOutput << "," << dec << msg.m_ucLength;
        fileOutput << "," << dec << msg.m_ucNumOfSignals;
        fileOutput << "," << msg.m_cDataFormat;
        fileOutput << "," << msg.m_cFrameFormat << endl;
        //      fprintf(message,"%s,%u,%u\n",msg.m_acName,msg.m_uiMsgID,msg.m_ucLength);
        POSITION posSig = msg.m_listSignals.GetHeadPosition();

        while(posSig != NULL)
        {
            // SIG_NAME,SIG_LENGTH,WHICH_BYTE_IN_MSG,START_BIT,SIG_TYPE,MAX_VAL,MIN_VAL,SIG_DATA_FORMAT,SIG_OFFSET,SIG_FACTOR,SIG_UNIT
            CSignal& sig = msg.m_listSignals.GetNext(posSig);

            // write signal only if it is valid
            if(sig.m_uiError == CSignal::SIG_EC_NO_ERR)
            {
                // For signal having motoroal format, the message length could be less
                // then eight byte. so in that case the whichByte needs to be shifted
                // accordingly.
                if(msg.m_cDataFormat == '0')
                {
                    sig.m_ucWhichByte = sig.m_ucWhichByte - (8 - msg.m_ucLength);
                }

                switch(sig.m_ucType)
                {
                    case CSignal::SIG_TYPE_BOOL:
                    case CSignal::SIG_TYPE_UINT:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << sig.m_ucType;
                        fileOutput << "," << dec << sig.m_MaxValue.uiValue;
                        fileOutput << "," << dec << sig.m_MinValue.uiValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                    case CSignal::SIG_TYPE_INT:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << sig.m_ucType;
                        fileOutput << "," << dec << sig.m_MaxValue.iValue;
                        fileOutput << "," << dec << sig.m_MinValue.iValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                        // Enable these when FLOAT and DOUBLE are supported
                        /*
                        case CSignal::SIG_TYPE_FLOAT:
                            sprintf(acLine,"[START_SIGNALS] %s,%u,%u,%u,%c,%f,%f,%c,%f,%f,%s\n",
                            sig.m_acName,sig.m_ucLength,sig.m_ucWhichByte,sig.m_ucStartBit,sig.m_ucType,
                            sig.m_MaxValue.fValue,sig.m_MinValue.fValue,sig.m_ucDataFormat,
                            sig.m_fOffset,sig.m_fScaleFactor,sig.m_acUnit);

                            break;

                        case CSignal::SIG_TYPE_DOUBLE:
                            sprintf(acLine,"[START_SIGNALS] %s,%u,%u,%u,%c,%f,%f,%c,%f,%f,%s\n",
                            sig.m_acName,sig.m_ucLength,sig.m_ucWhichByte,sig.m_ucStartBit,sig.m_ucType,
                            sig.m_MaxValue.dValue,sig.m_MinValue.dValue,sig.m_ucDataFormat,
                            sig.m_fOffset,sig.m_fScaleFactor,sig.m_acUnit);

                            break;
                        */

                    case CSignal::SIG_TYPE_INT64:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << 'I'; /* sig.m_ucType */
                        fileOutput << "," << dec << sig.m_MaxValue.dValue;
                        fileOutput << "," << dec << sig.m_MinValue.dValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                    case CSignal::SIG_TYPE_UINT64:
                        fileOutput << "[START_SIGNALS] " << sig.m_acName;
                        fileOutput << "," << dec << sig.m_ucLength;
                        fileOutput << "," << dec << sig.m_ucWhichByte;
                        fileOutput << "," << dec << sig.m_ucStartBit;
                        fileOutput << "," << 'U'; /* sig.m_ucType */
                        fileOutput << "," << dec << sig.m_MaxValue.dValue;
                        fileOutput << "," << dec << sig.m_MinValue.dValue;
                        fileOutput << "," << sig.m_ucDataFormat;
                        fileOutput << "," << sig.m_fOffset;
                        fileOutput << "," << sig.m_fScaleFactor;
                        fileOutput << "," << sig.m_acUnit;
                        fileOutput << "," << sig.m_acMultiplex;
                        fileOutput << "," << sig.m_rxNode << endl;
                        break;

                    default:
                        break;
                }

                // now write value descriptors for this signal
                POSITION posValDesc = sig.m_listValueDescriptor.GetHeadPosition();

                while(posValDesc != NULL)
                {
                    CValueDescriptor& rValDesc = sig.m_listValueDescriptor.GetNext(posValDesc);

                    switch(sig.m_ucType)
                    {
                        case CSignal::SIG_TYPE_BOOL:
                        case CSignal::SIG_TYPE_UINT:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.uiValue << endl;
                            break;

                        case CSignal::SIG_TYPE_INT:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.iValue << endl;
                            break;

                            // when FLOAT and DOUBLE are supported enable this
                            /*
                            case CSignal::SIG_TYPE_FLOAT:
                                sprintf(acLine,"[VALUE_DESCRIPTION] %s,%f\n",rValDesc.m_acDescriptor,rValDesc.m_value.fValue);
                                break;

                            case CSignal::SIG_TYPE_DOUBLE:
                                sprintf(acLine,"[VALUE_DESCRIPTION] %s,%f\n",rValDesc.m_acDescriptor,rValDesc.m_value.dValue);
                                break;
                            */

                        case CSignal::SIG_TYPE_INT64:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.i64Value << endl;
                            break;

                        case CSignal::SIG_TYPE_UINT64:
                            fileOutput << "[VALUE_DESCRIPTION] " << rValDesc.m_acDescriptor;
                            fileOutput << "," << dec << rValDesc.m_value.ui64Value << endl;
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                bResult = false;
            }
        }

        //      fclose(message);
        fileOutput << "[END_MSG]" << endl << endl;
    }

    fileOutput.close();
    return bResult;
}



void CConverter::ValidateMessageList()
{
    POSITION pos = m_listMessages.GetHeadPosition();

    while(pos != NULL)
    {
        CMessage& rMsg = m_listMessages.GetNext(pos);
        unsigned char ucDataFormat = 0;
        unsigned int uiResult;

        // set the id and frame format
        // canoe puts MSbit = 1 for extended ID
        if(rMsg.m_uiMsgID < 0x80000000UL)
        {
            rMsg.m_cFrameFormat = CMessage::MSG_FF_STANDARD;
        }
        else
        {
            rMsg.m_cFrameFormat = CMessage::MSG_FF_EXTENDED;
            rMsg.m_uiMsgID &= 0x7FFFFFFF;
        }

        rMsg.m_ucNumOfSignals = 0; // reset number of signals to 0
        // this should be updated to number of
        // valid signals as we parse the Signal list
        //pems - Start
        //Scan the message list and make the message format same as the
        //one that has maximum number of signals.
        POSITION posSigx = rMsg.m_listSignals.GetHeadPosition();
        int iCntMotorolaSignals = 0;
        int iCntIntelSignals = 0;

        while(posSigx != NULL)
        {
            CSignal& rSig = rMsg.m_listSignals.GetNext(posSigx);

            if(rSig.m_ucDataFormat == CSignal::SIG_DF_INTEL)
            {
                iCntIntelSignals++;
            }
            else if(rSig.m_ucDataFormat == CSignal::SIG_DF_MOTOROLA)
            {
                iCntMotorolaSignals++;
            }
        }

        // Update the message data format
        if(iCntIntelSignals >= iCntMotorolaSignals)
        {
            ucDataFormat = CSignal::SIG_DF_INTEL;
            rMsg.m_cDataFormat = ucDataFormat; // set message data format to this i.e format of first valid signal
        }
        else
        {
            ucDataFormat = CSignal::SIG_DF_MOTOROLA;
            rMsg.m_cDataFormat = ucDataFormat;
        }

        //pems - end
        POSITION posSig = rMsg.m_listSignals.GetHeadPosition();

        while(posSig != NULL)
        {
            CSignal& rSig = rMsg.m_listSignals.GetNext(posSig);
            uiResult = rSig.Validate(ucDataFormat);

            // if the signal is valid
            if(uiResult == CSignal::SIG_EC_NO_ERR)
            {
                /*Pems Start
                    if(ucDataFormat == 0)
                    {
                        ucDataFormat = rSig.m_ucDataFormat; // now this is updated to the first valid signal's format
                        rMsg.m_cDataFormat = ucDataFormat; // set message data format to this i.e format of first valid signal
                    }
                Pems End*/
                rMsg.m_ucNumOfSignals++; // increment the signal count for this message
            }
        }

        posSig = rMsg.m_listSignals.GetHeadPosition();
        __int64 n64Matrix = 0;

        while(posSig != NULL)
        {
            CSignal& rSig = rMsg.m_listSignals.GetNext(posSig);
            __int64 n64Mask = ( 1 << rSig.m_ucLength ) - 1;
            n64Mask <<=
                ( rSig.m_ucWhichByte - 1 ) * 8 + rSig.m_ucStartBit;

            if( n64Matrix & n64Mask )
            {
                rSig.m_uiError = CSignal::SIG_EC_OVERLAP;
                rMsg.m_ucNumOfSignals--;
            }
            else
            {
                n64Matrix |= n64Mask;
            }
        }
    }
}

// generates the message list with signals and value descriptors
void CConverter::GenerateMessageList(fstream& fileInput)
{
    char acLine[defCON_MAX_LINE_LEN]; // I don't expect one line to be more than this
    // Flag to skip signal parsing of independent messages
    BOOL bSkipSignalParsing = FALSE;

    // parsing the input file
    while(fileInput.getline(acLine, defCON_MAX_LINE_LEN))
    {
        char* pcToken;
        char* pcNextToken;
        char* pcLine;
        // avoid leading <spaces> before tokenising, so passing the
        // starting point will be correct in each case, when calling
        // msg.Format, sig.Format etc.
        pcLine = acLine;

        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        pcToken = strtok_s(pcLine, " :", &pcNextToken);

        if(pcToken)
        {
            //compare token to known types to interpret the line further

            // new line - skip
            if(strcmp(pcToken,"\n") == 0)
            {
                continue;
            }
            // message
            else if(strcmp(pcToken,"BO_") == 0)
            {
                CMessage msg;
                msg.Format(pcLine + strlen(pcToken)+1);

                if( msg.m_uiMsgID != 0xc0000000 ) // Vector independent message
                {
                    bSkipSignalParsing = FALSE;
                    // add the new message to the list
                    m_listMessages.AddTail(msg);
                }
                else
                {
                    bSkipSignalParsing = TRUE;
                }
            }
            // signal
            else if(strcmp(pcToken,"SG_") == 0)
            {
                if( bSkipSignalParsing == FALSE )
                {
                    CSignal sig;
                    sig.Format(pcLine + strlen(pcToken)+1);
                    POSITION pos = m_listMessages.GetTailPosition();
                    CMessage& msg = m_listMessages.GetAt(pos);
                    msg.m_listSignals.AddTail(sig);
                    // this signal should belong to the last message
                    msg.m_ucNumOfSignals++; // increment the signal count
                }
            }
            // value descriptor
            else if(strcmp(pcToken,"VAL_") == 0)
            {
                // <msgid><sp><signalName><sp><value1><sp><"desc1"><sp><value2><sp><"desc2"> ...;
                // get MsgId, find the message from the messagelist.
                // find the signal from the message, then add the value descritors
                // to the respective signals
                pcLine = pcLine + strlen(pcToken) + 1; // to get next token
                pcToken = strtok_s(pcLine, " ", &pcNextToken); // msgid
                unsigned int id = (unsigned int)atoi(pcToken);
                POSITION posMsg = m_listMessages.GetHeadPosition();

                while(posMsg != NULL)
                {
                    CMessage& rMsg = m_listMessages.GetNext(posMsg);

                    // find matching message from list
                    if(rMsg.m_uiMsgID == id)
                    {
                        pcLine = pcLine + strlen(pcToken) + 1; // to get next token
                        pcToken = strtok_s(pcLine, " ", &pcNextToken); // Signal name
                        POSITION posSig = rMsg.m_listSignals.GetHeadPosition();

                        // find matching signal
                        while(posSig != NULL)
                        {
                            //  char *pcToken1;
                            CSignal& rSig =  rMsg.m_listSignals.GetNext(posSig);

                            if(strcmp(rSig.m_acName.c_str(),pcToken) == 0)
                            {
                                rSig.AddValueDescriptors(pcLine + strlen(pcToken) + 1);
                                break; // if we got the signal we wanted
                            }
                        }

                        break; // we got the message we wanted
                    }
                }
            }
            // signal value qualifier
            else if(strcmp(pcToken,"SIG_VALTYPE_") == 0)
            {
                // <msgID> <signal name> : 1 -- float
                // <msgID> <signal name> : 2 -- double
                // get MsgId, find the message from the messagelist.
                // find the signal from the message, then update the
                // signal type appropriately of the respective signal
                pcToken = strtok_s(NULL, " :;", &pcNextToken); // msgid
                unsigned int id = (unsigned int)atoi(pcToken);
                POSITION posMsg = m_listMessages.GetHeadPosition();

                while(posMsg != NULL)
                {
                    CMessage& rMsg = m_listMessages.GetNext(posMsg);

                    // find matching message from list
                    if(rMsg.m_uiMsgID == id)
                    {
                        pcToken = strtok_s(NULL, " :;", &pcNextToken); // Signal name
                        POSITION posSig = rMsg.m_listSignals.GetHeadPosition();

                        // find matching signal
                        while(posSig != NULL)
                        {
                            CSignal& rSig =  rMsg.m_listSignals.GetNext(posSig);

                            if(strcmp(rSig.m_acName.c_str(),pcToken) == 0)
                            {
                                if(pcToken = strtok_s(NULL, " :;", &pcNextToken)) // qualifier (1 or 2)
                                {
                                    // update signal type based on qualifier
                                    switch(*pcToken)
                                    {
                                        case '1':
                                            rSig.m_ucType = CSignal::SIG_TYPE_FLOAT;
                                            break;

                                        case '2':
                                            rSig.m_ucType = CSignal::SIG_TYPE_DOUBLE;
                                            break;

                                        default:
                                            break;
                                    }
                                }

                                break; // we got the signal we wanted
                            }
                        }

                        break; // we got the message we wanted
                    }
                }
            }
            // anything else skip
            else
            {
                continue;
            }
        }
    }
}


// Create a log file of errors encountered
// file name  = Inputfile with extension changed to ".log"
void CConverter::CreateLogFile(fstream& fileLog)
{
    // write to the output file
    char acMsgLine[200];
    fileLog << "Conversion Error Log" << endl;
    fileLog << endl;
    // write all signals & messages which encountered errors
    // MSG_ID ,MAG_NAME,SIG_NAME:
    POSITION pos = m_listMessages.GetHeadPosition();

    while(pos != NULL)
    {
        acMsgLine[0] = '\0';
        CMessage& msg = m_listMessages.GetNext(pos);
        POSITION posSig = msg.m_listSignals.GetHeadPosition();

        while(posSig != NULL)
        {
            CSignal& sig = msg.m_listSignals.GetNext(posSig);

            // write signal only if it is valid
            if(sig.m_uiError != CSignal::SIG_EC_NO_ERR)
            {
                string str;

                // for the first wrong signal, log the message details also
                if(acMsgLine[0] == '\0')
                {
                    fileLog << endl;
                    fileLog << "MSG_ID: " << dec << msg.m_uiMsgID;
                    fileLog << "\tMSG_NAME: " << msg.m_acName << endl;
                }

                sig.GetErrorString(str);
                fileLog << "\tDiscarded SIG_NAME: " << sig.m_acName;
                fileLog << ", Reason: " << str.c_str() << endl;
            }
        }
    }
}

CMessage CConverter::ouFindMessage(CString omStrMsgName)
{
    CMessage omTemp;
    POSITION pos = m_listMessages.GetHeadPosition();

    // iterate through the list
    for (int index = 0; index < m_listMessages.GetCount(); index++)
    {
        // store the data
        omTemp = m_listMessages.GetNext(pos);

        // compare with message name
        if(omStrMsgName == omTemp.m_acName.c_str())
        {
            // send the result
            return omTemp;
        }
    }

    // if not found then
    omTemp.m_uiMsgID = 0xffffffff;
    return omTemp;
}


CMessage CConverter::ouFindMessage(UINT nMsgID)
{
    POSITION pos = m_listMessages.GetHeadPosition();
    CMessage omTemp;

    // iterate through the list
    for (int index = 0; index < m_listMessages.GetCount(); index++)
    {
        // store the data
        omTemp = m_listMessages.GetNext(pos);

        // compare with message name
        if( nMsgID == omTemp.m_uiMsgID)
        {
            // send the result
            return omTemp;
        }
    }

    // if not found
    omTemp.m_uiMsgID = 0xffffffff;
    return omTemp;
}




































List::List(CWnd* pParent )
    : CDialog(List::IDD, pParent)
{
    
    
    
    
}


void List::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    
    DDX_Control(pDX, 1000, m_UnSupKeys);
    DDX_Control(pDX, 1002, m_AltKeys);
    DDX_Control(pDX, 1003, m_EquiKeys);
    
}


const AFX_MSGMAP* __stdcall List::_GetBaseMessageMap() { return &CDialog::messageMap; } const AFX_MSGMAP* List::GetMessageMap() const { return &List::messageMap; }   const AFX_MSGMAP List::messageMap = { &List::_GetBaseMessageMap, &List::_messageEntries[0] };  const AFX_MSGMAP_ENTRY List::_messageEntries[] = {
    
    { 0x0111, (WORD)0, (WORD)1004, (WORD)1004, AfxSig_vv, (AFX_PMSG)&OnAdd },
    { 0x0111, (WORD)0, (WORD)1005, (WORD)1005, AfxSig_vv, (AFX_PMSG)&OnTerminate },
    { 0x0111, (WORD)0, (WORD)1016, (WORD)1016, AfxSig_vv, (AFX_PMSG)&OnRemove },
    { 0x0010, 0, 0, 0, AfxSig_vv, (AFX_PMSG)(AFX_PMSGW)(void ( CWnd::*)(void))&OnClose },
    
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };










          -      -      ,ÿÿÿÿ   ,ÿÿÿÿ     ,E@       statement executed        }    -ÿÿÿÿ   ,      -ÿÿÿÿ   ,                    8      8      7ÿÿÿÿ   7ÿÿÿÿ     ,SĞ       statement executed        }    8ÿÿÿÿ   7      8ÿÿÿÿ   7                    ;   :   ;   V   :ÿÿÿÿ   :ÿÿÿÿ     à€       statement executed        return &CDialog::messageMap;    ;ÿÿÿÿ   :   :   ;ÿÿÿÿ   :   V                 ;   ‰   ;   ¢   :ÿÿÿÿ   :ÿÿÿÿ     Û        statement executed        return &List::messageMap;    ;ÿÿÿÿ   :   ‰   ;ÿÿÿÿ   :   ¢        List::List List::List(CWnd* pParent )    (      -      'ÿÿÿÿ   ,ÿÿÿÿList::DoDataExchange void List::DoDataExchange(CDataExchange* pDX)    1      8      0ÿÿÿÿ   7ÿÿÿÿList::_GetBaseMessageMap const AFX_MSGMAP* __stdcall List::_GetBaseMessageMap()    ;   8   ;   X   :ÿÿÿÿ   :ÿÿÿÿList::GetMessageMap const AFX_MSGMAP* List::GetMessageMap()    ;   ‡   ;   ¤   :ÿÿÿÿ   :ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      List.cpp
 * \brief     Implementation file for CList class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CList class
 */

/* Project includes */
#include "List.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// List dialog


List::List(CWnd* pParent /*=NULL*/)
    : CDialog(List::IDD, pParent)
{
    //{{AFX_DATA_INIT(List)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    //  m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}


void List::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(List)
    DDX_Control(pDX, IDC_LSTB_UNSK, m_UnSupKeys);
    DDX_Control(pDX, IDC_LSTB_AVLK, m_AltKeys);
    DDX_Control(pDX, IDC_LSTB_ALTK, m_EquiKeys);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(List, CDialog)
    //{{AFX_MSG_MAP(List)
    ON_BN_CLICKED(IDC_CBTN_ADD, OnAdd)
    ON_BN_CLICKED(IDC_CBTN_OK, OnTerminate)
    ON_BN_CLICKED(IDC_CBTN_RMV, OnRemove)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// List message handlers











































CMessage::CMessage()
{
    m_acName[0] = '\0';
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    m_cFrameFormat = MSG_FF_STANDARD;
    m_ucLength = 8;
    m_ucNumOfSignals = 1;
    m_uiMsgID = 0;
    m_listSignals.RemoveAll();
}

CMessage::~CMessage()
{
    if(!m_listSignals.IsEmpty())
    {
        m_listSignals.RemoveAll();
    }
}

CMessage& CMessage::operator=(CMessage& message)
{
    
    if(!m_listSignals.IsEmpty())
    {
        m_listSignals.RemoveAll();
    }

    
    m_acName = message.m_acName;
    m_cDataFormat = message.m_cDataFormat;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_ucNumOfSignals = message.m_ucNumOfSignals;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals.AddTail(&message.m_listSignals);
    return (*this);
}

CMessage::CMessage(CMessage& message)
{
    
    if(!m_listSignals.IsEmpty())
    {
        m_listSignals.RemoveAll();
    }

    
    m_acName = message.m_acName;
    m_cDataFormat = message.m_cDataFormat;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_ucNumOfSignals = message.m_ucNumOfSignals;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals.AddTail(&message.m_listSignals);
}




int CMessage::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    
    pcToken = strtok_s(pcLine, " :", &pcNextToken);
    m_uiMsgID = (unsigned int)atoi(pcToken);
    












    
    pcToken = strtok_s(0, " :", &pcNextToken);
    m_acName = pcToken;
    
    pcToken = strtok_s(0, " :", &pcNextToken);
    m_ucLength = (unsigned char)atoi(pcToken);
    
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    
    m_ucNumOfSignals = 0;
    return 1;
}
          O      O       Nÿÿÿÿ   Nÿÿÿÿ     Ø(      expression was false       !m_listSignals.IsEmpty()    Oÿÿÿÿ   N      Oÿÿÿÿ   N                    Ş          <      <       ;ÿÿÿÿ   ;ÿÿÿÿ     ,x       expression was false       !m_listSignals.IsEmpty()    <ÿÿÿÿ   ;      <ÿÿÿÿ   ;                    ,GØ         3      3       2ÿÿÿÿ   2ÿÿÿÿ    Ç       expression was false       !m_listSignals.IsEmpty()    3ÿÿÿÿ   2      3ÿÿÿÿ   2                    Ğ                     ~ÿÿÿÿ   ~ÿÿÿÿ    $ÏÈ       statement executed        return 1;    ÿÿÿÿ   ~      ÿÿÿÿ   ~                    \      \      [ÿÿÿÿ   [ÿÿÿÿ    $ãP       statement executed        }    \ÿÿÿÿ   [      \ÿÿÿÿ   [                    R      R      Qÿÿÿÿ   Qÿÿÿÿ     Û        statement executed        }    Rÿÿÿÿ   Q      Rÿÿÿÿ   Q                    I      I      Hÿÿÿÿ   Hÿÿÿÿ     à€       statement executed        return (*this);    Iÿÿÿÿ   H      Iÿÿÿÿ   H                    ?      ?      >ÿÿÿÿ   >ÿÿÿÿ     ,SĞ       statement executed        }    ?ÿÿÿÿ   >      ?ÿÿÿÿ   >                    7      7      6ÿÿÿÿ   6ÿÿÿÿ     ,E@       statement executed        }    7ÿÿÿÿ   6      7ÿÿÿÿ   6              	      6      6      5ÿÿÿÿ   5ÿÿÿÿ    ºø       statement executed        }    6ÿÿÿÿ   5      6ÿÿÿÿ   5              
      /      /      .ÿÿÿÿ   .ÿÿÿÿ    •x       statement executed        }    /ÿÿÿÿ   .      /ÿÿÿÿ   .           CMessage::CMessage CMessage::CMessage()    '      /      &ÿÿÿÿ   .ÿÿÿÿCMessage::~CMessage CMessage::~CMessage()    2      7      1ÿÿÿÿ   6ÿÿÿÿCMessage::operator= CMessage& CMessage::operator=(CMessage& message)    :      J      9ÿÿÿÿ   IÿÿÿÿCMessage::CMessage CMessage::CMessage(CMessage& message)    M      \      Lÿÿÿÿ   [ÿÿÿÿCMessage::Format int CMessage::Format(char* pcLine)    b      €      aÿÿÿÿ   ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Message.cpp
 * \brief     Implementation file for CMessage class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CMessage class
 */

/* Project includes */
#include "Message.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMessage::CMessage()
{
    m_acName[0] = '\0';
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    m_cFrameFormat = MSG_FF_STANDARD;
    m_ucLength = 8;
    m_ucNumOfSignals = 1;
    m_uiMsgID = 0;
    m_listSignals.RemoveAll();
}

CMessage::~CMessage()
{
    if(!m_listSignals.IsEmpty())
    {
        m_listSignals.RemoveAll();
    }
}

CMessage& CMessage::operator=(CMessage& message)
{
    // if there are some elements in the signal list clear them first
    if(!m_listSignals.IsEmpty())
    {
        m_listSignals.RemoveAll();
    }

    // now copy the other elements of the new message to this
    m_acName = message.m_acName;
    m_cDataFormat = message.m_cDataFormat;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_ucNumOfSignals = message.m_ucNumOfSignals;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals.AddTail(&message.m_listSignals);
    return (*this);
}

CMessage::CMessage(CMessage& message)
{
    // if there are some elements in the signal list clear them first
    if(!m_listSignals.IsEmpty())
    {
        m_listSignals.RemoveAll();
    }

    // now copy the other elements of the new message to this
    m_acName = message.m_acName;
    m_cDataFormat = message.m_cDataFormat;
    m_cFrameFormat = message.m_cFrameFormat;
    m_ucLength = message.m_ucLength;
    m_ucNumOfSignals = message.m_ucNumOfSignals;
    m_uiMsgID = message.m_uiMsgID;
    m_listSignals.AddTail(&message.m_listSignals);
}


// extract the message info from the line and store it in the Message object
// return an appropriate error code if something wrong with messageline
int CMessage::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    // get the MSG ID
    pcToken = strtok_s(pcLine, " :", &pcNextToken);
    m_uiMsgID = (unsigned int)atoi(pcToken);
    /*
    // set the id and frame format
    // canoe puts MSbit = 1 for extended ID
    if(msg.m_uiMsgID < 0x80000000UL)
    {
        msg.m_cFrameFormat = CMessage::MSG_FF_STANDARD;
    }
    else
    {
        msg.m_cFrameFormat = CMessage::MSG_FF_EXTENDED;
        msg.m_uiMsgID &= 0x7FFFFFFF;
    }
    */
    // get the message name
    pcToken = strtok_s(NULL, " :", &pcNextToken);
    m_acName = pcToken;
    // set the message length
    pcToken = strtok_s(NULL, " :", &pcNextToken);
    m_ucLength = (unsigned char)atoi(pcToken);
    // set the Data format
    m_cDataFormat = CSignal::SIG_DF_INTEL;
    // set the number of signals
    m_ucNumOfSignals = 0;
    return 1;
}




































CSelectdb::CSelectdb(CWnd* pParent )
    : CDialog(CSelectdb::IDD, pParent)
{
    
    m_option = 0;
    
    
}


void CSelectdb::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    
    DDX_Check(pDX, 1044, m_option);
    
}


const AFX_MSGMAP* __stdcall CSelectdb::_GetBaseMessageMap() { return &CDialog::messageMap; } const AFX_MSGMAP* CSelectdb::GetMessageMap() const { return &CSelectdb::messageMap; }   const AFX_MSGMAP CSelectdb::messageMap = { &CSelectdb::_GetBaseMessageMap, &CSelectdb::_messageEntries[0] };  const AFX_MSGMAP_ENTRY CSelectdb::_messageEntries[] = {
    
    { 0x0111, (WORD)0, (WORD)1004, (WORD)1004, AfxSig_vv, (AFX_PMSG)&OnBrowseCANoeDb },
    { 0x0111, (WORD)0, (WORD)1005, (WORD)1005, AfxSig_vv, (AFX_PMSG)&OnBrowseBUSMASTERDb },
    { 0x0111, (WORD)0, (WORD)1044, (WORD)1044, AfxSig_vv, (AFX_PMSG)&OnChkbOption },
    { 0x0111, (WORD)0x0300, (WORD)1006, (WORD)1006, AfxSig_vv, (AFX_PMSG)&OnChangeEditAdcanoe },
    { 0x0010, 0, 0, 0, AfxSig_vv, (AFX_PMSG)(AFX_PMSGW)(void ( CWnd::*)(void))&OnClose },
    
{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } };




void CSelectdb::SaveSettings()
{
    
    CString strSection       = "Files";
    CString strStringItem    = "Database File";
    CWinApp* pApp = AfxGetApp();
    CString omStrDatabaseName;
    CWnd* pCAPL = GetDlgItem(1006);
    pCAPL->GetWindowTextA(omStrDatabaseName);
    pApp->WriteProfileStringA(strSection, strStringItem,omStrDatabaseName);
}





          P      P      Oÿÿÿÿ   Oÿÿÿÿ    ¸`       statement executed        }    Pÿÿÿÿ   O      Pÿÿÿÿ   O                    9   “   9   ±   8ÿÿÿÿ   8ÿÿÿÿ    “       statement executed        return &CSelectdb::messageMap;    9ÿÿÿÿ   8   “   9ÿÿÿÿ   8   ±                 9   ?   9   [   8ÿÿÿÿ   8ÿÿÿÿ     5ê`       statement executed        return &CDialog::messageMap;    9ÿÿÿÿ   8   ?   9ÿÿÿÿ   8   [                 6      6      5ÿÿÿÿ   5ÿÿÿÿ     5çˆ       statement executed        }    6ÿÿÿÿ   5      6ÿÿÿÿ   5                    -      -      ,ÿÿÿÿ   ,ÿÿÿÿ     5äø       statement executed        }    -ÿÿÿÿ   ,      -ÿÿÿÿ   ,           CSelectdb::CSelectdb CSelectdb::CSelectdb(CWnd* pParent )    (      -      'ÿÿÿÿ   ,ÿÿÿÿCSelectdb::DoDataExchange void CSelectdb::DoDataExchange(CDataExchange* pDX)    1      6      0ÿÿÿÿ   5ÿÿÿÿCSelectdb::_GetBaseMessageMap const AFX_MSGMAP* __stdcall CSelectdb::_GetBaseMessageMap()    9   =   9   ]   8ÿÿÿÿ   8ÿÿÿÿCSelectdb::GetMessageMap const AFX_MSGMAP* CSelectdb::GetMessageMap()    9   ‘   9   ³   8ÿÿÿÿ   8ÿÿÿÿCSelectdb::SaveSettings void CSelectdb::SaveSettings()    G      P      Fÿÿÿÿ   Oÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Selectdb.cpp
 * \brief     Implementation file for CSelectdb class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CSelectdb class
 */

/* Project includes */
#include "Selectdb.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectdb dialog


CSelectdb::CSelectdb(CWnd* pParent /*=NULL*/)
    : CDialog(CSelectdb::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSelectdb)
    m_option = FALSE;
    //}}AFX_DATA_INIT
    //  m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}


void CSelectdb::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelectdb)
    DDX_Check(pDX, IDC_CHKB_OPTION, m_option);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectdb, CDialog)
    //{{AFX_MSG_MAP(CSelectdb)
    ON_BN_CLICKED(IDC_CBTN_CANOEDB, OnBrowseCANoeDb)
    ON_BN_CLICKED(IDC_CBTN_BUSMASTERDB, OnBrowseBUSMASTERDb)
    ON_BN_CLICKED(IDC_CHKB_OPTION, OnChkbOption)
    ON_EN_CHANGE(IDC_EDIT_ADCANOE, OnChangeEditAdcanoe)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectdb message handlers

void CSelectdb::SaveSettings()
{
    //this fuction will save the settings of last selected file in the registry.
    CString strSection       = "Files";
    CString strStringItem    = "Database File";
    CWinApp* pApp = AfxGetApp();
    CString omStrDatabaseName;
    CWnd* pCAPL = GetDlgItem(IDC_EDIT_ADCANOE);
    pCAPL->GetWindowText(omStrDatabaseName);
    pApp->WriteProfileString(strSection, strStringItem,omStrDatabaseName);
}


































CSignal::CSignal()
{
    m_acMultiplex = "";
    m_acName = "";
    m_ucLength = 1; 
    m_ucWhichByte = 1; 
    m_ucStartBit = 0; 
    m_ucType = SIG_TYPE_BOOL; 
    m_MaxValue.uiValue = 1; 
    m_MinValue.uiValue = 0; 
    m_ucDataFormat = SIG_DF_INTEL;
    m_fOffset = 0.0f;
    m_fScaleFactor = 1.0f;
    m_acUnit = "";
    m_uiError = SIG_EC_NO_ERR;
    m_rxNode = "";
    m_listValueDescriptor.RemoveAll();
}




CSignal::~CSignal()
{
    
    if(!m_listValueDescriptor.IsEmpty())
    {
        m_listValueDescriptor.RemoveAll();
    }
}






CSignal& CSignal::operator=(CSignal& signal)
{
    if(!m_listValueDescriptor.IsEmpty())
    {
        m_listValueDescriptor.RemoveAll(); 
    }

    
    m_acMultiplex = signal.m_acMultiplex;
    m_acName = signal.m_acName;
    m_ucLength = signal.m_ucLength;
    m_ucWhichByte = signal.m_ucWhichByte;
    m_ucStartBit = signal.m_ucStartBit;
    m_ucType = signal.m_ucType;
    m_MaxValue = signal.m_MaxValue;
    m_MinValue = signal.m_MinValue;
    m_ucDataFormat = signal.m_ucDataFormat;
    m_fOffset = signal.m_fOffset;
    m_fScaleFactor = signal.m_fScaleFactor;
    m_acUnit = signal.m_acUnit;
    m_uiError = signal.m_uiError;
    m_rxNode = signal.m_rxNode;
    
    m_listValueDescriptor.AddTail(&signal.m_listValueDescriptor);
    return (*this);
}





int CSignal::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    char acTemp[1026],*pcTemp;
    pcTemp = acTemp;
    
    
    
    
    
    pcToken = strtok_s(pcLine, ":", &pcNextToken); 

    
    
    while(*pcToken && *pcToken == ' ')
    {
        pcToken++;
    }

    
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_acName = acTemp; 
    pcTemp = acTemp; 
    
    *pcToken++;

    
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; 
    }

    *pcTemp = '\0'; 
    m_acMultiplex = acTemp; 
    pcTemp = acTemp; 
    
    pcToken = strtok_s(0, " :", &pcNextToken);

    
    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    
    unsigned int uiStartBit = atoi(acTemp);
    
    
    
    
    
    
    



    
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '@')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    m_ucLength = atoi(acTemp); 
    
    m_ucDataFormat = *pcToken;

    
    if(SIG_DF_MOTOROLA == m_ucDataFormat)
    {
        







        INT nTemp = 0;
        
        
        
        
        
        nTemp =  8 * ( ( m_ucLength - 1 ) / 8 ) - ( ( m_ucLength - 1) % 8 );
        uiStartBit = uiStartBit + nTemp;
        
        nTemp = 8 * ( 8 - ( 2 * ( uiStartBit/8 ) + 1 ) );
        uiStartBit = uiStartBit + nTemp ;
    }

    m_ucWhichByte = uiStartBit / 8 + 1;
    m_ucStartBit = uiStartBit % 8;
    

    
    
    

    if(m_ucLength >32)
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT64 : SIG_TYPE_UINT64;
    }
    else
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT : SIG_TYPE_UINT;
    }

    
    pcToken = strtok_s(0, " (", &pcNextToken);
    pcTemp = acTemp;

    
    while(*pcToken && *pcToken != ',')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 
    m_fScaleFactor = (float)atof(acTemp); 
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ')')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    m_fOffset = (float)atof(acTemp); 
    
    pcToken = strtok_s(0, " [", &pcNextToken);
    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 

    
    if(m_ucLength <= 32)
    {
        m_MinValue.dValue = atof(acTemp);    
    }
    else
    {
        m_MinValue.i64Value = _atoi64(acTemp);
    }

    
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ']')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; 

    if(m_ucLength <= 32)
    {
        m_MaxValue.dValue = atof(acTemp);    
    }
    else
    {
        m_MaxValue.i64Value = _atoi64(acTemp);
    }

    
    pcTemp = acTemp;
    pcToken++;

    
    while(*pcToken && *pcToken != '\"')
    {
        pcToken++;
    }

    pcToken++;

    
    while(*pcToken && *pcToken != '\"')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    m_acUnit = acTemp; 
    pcToken++;

    while(*pcToken && *pcToken != ' ')
    {
        pcToken++;
    }

    pcToken++;
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '\n')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';

    if(strcmp(acTemp,"Vector__XXX") != 0)
    {
        m_rxNode = acTemp;
    }
    else
    {
        m_rxNode = "";
    }

    return 1;
}





int CSignal::AddValueDescriptors(char* pcLine)
{
    char acValue[100];
    char acDesc[100];
    char* pcValue = acValue;
    char* pcDesc = acDesc;

    
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    while(*pcLine && *pcLine != ';')
    {
        pcValue = acValue;
        pcDesc = acDesc;
        *pcValue = *pcDesc = '\0';

        while(*pcLine && *pcLine != ' ')
        {
            *pcValue++ = *pcLine++; 
        }

        *pcValue = '\0'; 

        
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        
        while(*pcLine && *pcLine == '\"')
        {
            *pcLine++;
        }

        while(*pcLine && *pcLine != '\"')
        {
            *pcDesc++ = *pcLine;
            pcLine++;
        }

        *pcDesc = '\0';
        
        pcLine++;

        
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        
        if(acDesc[0] != '\0')
        {
            CValueDescriptor valDesc;
            valDesc.m_value.dValue = atof(acValue);
            valDesc.m_acDescriptor = acDesc;
            m_listValueDescriptor.AddTail(valDesc);
        }
    }

    return 1;
}
















unsigned int CSignal::Validate(unsigned char ucFormat)
{
    
    if(ucFormat != 0 && ucFormat != m_ucDataFormat)
    {
        return (m_uiError = SIG_EC_DATA_FORMAT_ERR);
    }

    
    if(m_ucLength > 64)
    {
        return (m_uiError = SIG_EC_LENGTH_ERR);
    }

    
    if(m_ucWhichByte < 1 || m_ucWhichByte > 8)
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }

    if(m_ucWhichByte == 8 && m_ucStartBit > 7)
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }

    
    if(m_ucType == SIG_TYPE_DOUBLE || m_ucType == SIG_TYPE_FLOAT)
    {
        return (m_uiError = SIG_EC_TYPE_ERR);
    }

    
    if(m_ucLength == 1) 
    {
        m_ucType = SIG_TYPE_BOOL;
    }

    
    switch(m_ucType)
    {
        case SIG_TYPE_BOOL:
        case SIG_TYPE_UINT:
            m_MaxValue.uiValue = (unsigned int)m_MaxValue.dValue;
            m_MinValue.uiValue = (unsigned int)m_MinValue.dValue;
            unsigned int uiDefault;
            uiDefault = (1 << m_ucLength) - 1;

            if(m_MaxValue.uiValue == m_MinValue.uiValue)
            {
                if(m_MaxValue.uiValue <= uiDefault && m_MaxValue.uiValue >0)
                {
                    m_MinValue.uiValue = 0;
                }
                else
                {
                    m_MaxValue.uiValue = uiDefault;
                    m_MinValue.uiValue = 0;
                }
            }
            else
            {
                if(m_MaxValue.uiValue > uiDefault)
                {
                    m_MaxValue.uiValue = uiDefault;
                }

                if(m_MinValue.uiValue >m_MaxValue.uiValue )
                {
                    m_MinValue.uiValue = 0;
                }
            }

            break;

        case SIG_TYPE_INT:
            m_MaxValue.iValue = (int)m_MaxValue.dValue;
            m_MinValue.iValue = (int)m_MinValue.dValue;
            int iDefault;
            iDefault = (1 << (m_ucLength - 1)) - 1;

            if(m_MaxValue.iValue == m_MinValue.iValue)
            {
                if(m_MaxValue.iValue <= iDefault)
                {
                    m_MinValue.iValue = -1*iDefault - 1;
                }
                else
                {
                    m_MaxValue.iValue = iDefault;
                    m_MinValue.iValue = -1*iDefault - 1;
                }
            }
            else
            {
                if(m_MaxValue.iValue > iDefault)
                {
                    m_MaxValue.iValue = iDefault;
                }

                if(m_MinValue.iValue >m_MaxValue.iValue )
                {
                    m_MinValue.iValue = -1*iDefault - 1;
                }
            }

            break;

            
        case SIG_TYPE_FLOAT:
            m_MaxValue.fValue = (float)m_MaxValue.dValue;
            m_MinValue.fValue = (float)m_MinValue.dValue;
            break;

            
        case SIG_TYPE_DOUBLE:
            
            break;

        case SIG_TYPE_INT64:
            m_MaxValue.i64Value = (LONGLONG)m_MaxValue.dValue;
            m_MinValue.i64Value = (LONGLONG)m_MinValue.dValue;
            UINT unPower;
            __int64 i64Default;
            UINT i;

            if(m_ucLength == 64 )
            {
                unPower = m_ucLength - 1;
            }
            else
            {
                unPower = m_ucLength;
            }

            i64Default = 1;

            for(i = 0; i<unPower; i++)
            {
                i64Default = (__int64)( 2*i64Default);
            }

            if(m_MaxValue.ui64Value == m_MinValue.ui64Value)
            {
                if(m_MaxValue.i64Value <= i64Default && m_MaxValue.i64Value >0)
                {
                    m_MinValue.i64Value =  -(i64Default+1);
                }
                else
                {
                    m_MaxValue.i64Value = i64Default-1;
                    m_MinValue.i64Value =  -(i64Default+1);
                }
            }
            else
            {
                if(m_MaxValue.i64Value > i64Default - 1)
                {
                    m_MaxValue.i64Value = i64Default - 1;
                }

                if(m_MinValue.i64Value > m_MaxValue.i64Value )
                {
                    m_MinValue.i64Value = -(i64Default + 1);
                }
            }

            break;

        case SIG_TYPE_UINT64:
            m_MaxValue.ui64Value = (ULONGLONG)m_MaxValue.dValue;
            m_MinValue.ui64Value = (ULONGLONG)m_MinValue.dValue;
            unsigned __int64 ui64Default;

            if(m_ucLength == 64 )
            {
                unPower = m_ucLength - 1;
            }
            else
            {
                unPower = m_ucLength;
            }

            ui64Default = 1;

            for(i = 0; i<unPower; i++)
            {
                ui64Default = (unsigned __int64)( 2*ui64Default);
            }

            if(m_MaxValue.ui64Value == m_MinValue.ui64Value)
            {
                if(m_MaxValue.ui64Value <= ui64Default - 1 && m_MaxValue.ui64Value > 0)
                {
                    m_MinValue.ui64Value = 0;
                }
                else
                {
                    m_MaxValue.ui64Value = ui64Default - 1;
                    m_MinValue.ui64Value = 0;
                }
            }
            else
            {
                if(m_MaxValue.ui64Value > ui64Default - 1)
                {
                    m_MaxValue.ui64Value = ui64Default-1;
                }

                if(m_MinValue.ui64Value >m_MaxValue.ui64Value )
                {
                    m_MinValue.ui64Value = 0;
                }
            }

            break;

        default:
            break;
    }

    
    POSITION posValDesc = m_listValueDescriptor.GetHeadPosition();

    while(posValDesc != 0)
    {
        CValueDescriptor& rValDesc = m_listValueDescriptor.GetNext(posValDesc);

        switch(m_ucType)
        {
            case SIG_TYPE_BOOL:
            case SIG_TYPE_UINT:
                rValDesc.m_value.uiValue = (unsigned int)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_INT:
                rValDesc.m_value.iValue = (int)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_FLOAT:
                rValDesc.m_value.fValue = (float)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_DOUBLE:
                break;

            case SIG_TYPE_INT64:
                rValDesc.m_value.i64Value = (LONGLONG)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_UINT64:
                rValDesc.m_value.ui64Value = (ULONGLONG)rValDesc.m_value.dValue;
                break;

            default:
                break;
        }
    }

    return (m_uiError = SIG_EC_NO_ERR);
}

void CSignal::GetErrorString(string& str)
{
    switch(m_uiError)
    {
        case SIG_EC_NO_ERR:
            str = "No error";
            break;

        case SIG_EC_DATA_FORMAT_ERR:
            str = "Data format mismatch";
            break;

        case SIG_EC_LENGTH_ERR:
            str = "Invalid signal length";
            break;

        case SIG_EC_STARTBIT_ERR:
            str = "Invalid start bit";
            break;

        case SIG_EC_TYPE_ERR:
            str = "Invalid signal type";
            break;

        case SIG_EC_OVERLAP:
            str = "Overlapping signal";
            break;

        default:
            str = "Unknown";
            break;
    }
}
         Y     Y     Xÿÿÿÿ  Xÿÿÿÿ    Èè      expression was true       *pcLine   Yÿÿÿÿ  X     Yÿÿÿÿ  X      expression was false       *pcLine   Yÿÿÿÿ  X     Yÿÿÿÿ  X                   :     :   '  9ÿÿÿÿ  9ÿÿÿÿ    ŒZP      expression was true       *pcToken != '\n'   :ÿÿÿÿ  9     :ÿÿÿÿ  9   '   expression was false       *pcToken != '\n'   :ÿÿÿÿ  9     :ÿÿÿÿ  9   '               ŒX         :     :     9ÿÿÿÿ  9ÿÿÿÿ    ŒYx      expression was true       *pcToken   :ÿÿÿÿ  9     :ÿÿÿÿ  9      expression was false       *pcToken   :ÿÿÿÿ  9     :ÿÿÿÿ  9                   2     2   &  1ÿÿÿÿ  1ÿÿÿÿ    ŒS       expression was true       *pcToken != ' '   2ÿÿÿÿ  1     2ÿÿÿÿ  1   &   expression was false       *pcToken != ' '   2ÿÿÿÿ  1     2ÿÿÿÿ  1   &               ŒQp        2     2     1ÿÿÿÿ  1ÿÿÿÿ    ŒRH      expression was true       *pcToken   2ÿÿÿÿ  1     2ÿÿÿÿ  1      expression was false       *pcToken   2ÿÿÿÿ  1     2ÿÿÿÿ  1              
     )     )   '  (ÿÿÿÿ  (ÿÿÿÿ    ŒJ(      expression was true       *pcToken != '\"'   )ÿÿÿÿ  (     )ÿÿÿÿ  (   '   expression was false       *pcToken != '\"'   )ÿÿÿÿ  (     )ÿÿÿÿ  (   '               ŒHx        )     )     (ÿÿÿÿ  (ÿÿÿÿ    ŒIP      expression was true       *pcToken   )ÿÿÿÿ  (     )ÿÿÿÿ  (      expression was false       *pcToken   )ÿÿÿÿ  (     )ÿÿÿÿ  (                   !     !   '   ÿÿÿÿ   ÿÿÿÿ    ŒDh      expression was true       *pcToken != '\"'   !ÿÿÿÿ        !ÿÿÿÿ      '   expression was false       *pcToken != '\"'   !ÿÿÿÿ        !ÿÿÿÿ      '               ŒB¸        !     !      ÿÿÿÿ   ÿÿÿÿ    ŒC      expression was true       *pcToken   !ÿÿÿÿ        !ÿÿÿÿ         expression was false       *pcToken   !ÿÿÿÿ        !ÿÿÿÿ                              &  
ÿÿÿÿ  
ÿÿÿÿ     æ       expression was true       *pcToken != ']'   ÿÿÿÿ  
     ÿÿÿÿ  
   &   expression was false       *pcToken != ']'   ÿÿÿÿ  
     ÿÿÿÿ  
   &                äp                  
ÿÿÿÿ  
ÿÿÿÿ     åH      expression was true       *pcToken   ÿÿÿÿ  
     ÿÿÿÿ  
      expression was false       *pcToken   ÿÿÿÿ  
     ÿÿÿÿ  
                    ö      ö   &   õÿÿÿÿ   õÿÿÿÿ     Ö       expression was true       *pcToken != '|'    öÿÿÿÿ   õ      öÿÿÿÿ   õ   &   expression was false       *pcToken != '|'    öÿÿÿÿ   õ      öÿÿÿÿ   õ   &                ÔP         ö      ö      õÿÿÿÿ   õÿÿÿÿ     Õ(      expression was true       *pcToken    öÿÿÿÿ   õ      öÿÿÿÿ   õ      expression was false       *pcToken    öÿÿÿÿ   õ      öÿÿÿÿ   õ                    ê      ê   &   éÿÿÿÿ   éÿÿÿÿ    $ç@      expression was true       *pcToken != ')'    êÿÿÿÿ   é      êÿÿÿÿ   é   &   expression was false       *pcToken != ')'    êÿÿÿÿ   é      êÿÿÿÿ   é   &               $å         ê      ê      éÿÿÿÿ   éÿÿÿÿ    $æh      expression was true       *pcToken    êÿÿÿÿ   é      êÿÿÿÿ   é      expression was false       *pcToken    êÿÿÿÿ   é      êÿÿÿÿ   é                    ß      ß   &   Şÿÿÿÿ   Şÿÿÿÿ    $Ûğ      expression was true       *pcToken != ','    ßÿÿÿÿ   Ş      ßÿÿÿÿ   Ş   &   expression was false       *pcToken != ','    ßÿÿÿÿ   Ş      ßÿÿÿÿ   Ş   &               $Ú@          ß      ß      Şÿÿÿÿ   Şÿÿÿÿ    $Û      expression was true       *pcToken    ßÿÿÿÿ   Ş      ßÿÿÿÿ   Ş      expression was false       *pcToken    ßÿÿÿÿ   Ş      ßÿÿÿÿ   Ş              "      ×      ×   )   Öÿÿÿÿ   Öÿÿÿÿ    $Ô       expression was true       (*(++pcToken) == '-')    ×ÿÿÿÿ   Ö      ×ÿÿÿÿ   Ö   )   expression was false       (*(++pcToken) == '-')    ×ÿÿÿÿ   Ö      ×ÿÿÿÿ   Ö   )               $Ò¨   $      Ó      Ó   )   Òÿÿÿÿ   Òÿÿÿÿ    $Îà      expression was true       (*(++pcToken) == '-')    Óÿÿÿÿ   Ò      Óÿÿÿÿ   Ò   )   expression was false       (*(++pcToken) == '-')    Óÿÿÿÿ   Ò      Óÿÿÿÿ   Ò   )               $Í°   &      ¦      ¦   &   ¥ÿÿÿÿ   ¥ÿÿÿÿ     )      expression was true       *pcToken != '@'    ¦ÿÿÿÿ   ¥      ¦ÿÿÿÿ   ¥   &   expression was false       *pcToken != '@'    ¦ÿÿÿÿ   ¥      ¦ÿÿÿÿ   ¥   &               Sà   (      ¦      ¦      ¥ÿÿÿÿ   ¥ÿÿÿÿ    S¸      expression was true       *pcToken    ¦ÿÿÿÿ   ¥      ¦ÿÿÿÿ   ¥      expression was false       *pcToken    ¦ÿÿÿÿ   ¥      ¦ÿÿÿÿ   ¥              *               &   ÿÿÿÿ   ÿÿÿÿ    S„       expression was true       *pcToken != '|'    ÿÿÿÿ         ÿÿÿÿ      &   expression was false       *pcToken != '|'    ÿÿÿÿ         ÿÿÿÿ      &               S‚ğ   ,                  ÿÿÿÿ   ÿÿÿÿ    SƒÈ      expression was true       *pcToken    ÿÿÿÿ         ÿÿÿÿ         expression was false       *pcToken    ÿÿÿÿ         ÿÿÿÿ                 .      ƒ      ƒ   &   ‚ÿÿÿÿ   ‚ÿÿÿÿ    Sy      expression was true       *pcToken != ' '    ƒÿÿÿÿ   ‚      ƒÿÿÿÿ   ‚   &   expression was false       *pcToken != ' '    ƒÿÿÿÿ   ‚      ƒÿÿÿÿ   ‚   &               Swh   0      ƒ      ƒ      ‚ÿÿÿÿ   ‚ÿÿÿÿ    Sx@      expression was true       *pcToken    ƒÿÿÿÿ   ‚      ƒÿÿÿÿ   ‚      expression was false       *pcToken    ƒÿÿÿÿ   ‚      ƒÿÿÿÿ   ‚              2      w      w   &   vÿÿÿÿ   vÿÿÿÿ    Yh      expression was true       *pcToken != ' '    wÿÿÿÿ   v      wÿÿÿÿ   v   &   expression was false       *pcToken != ' '    wÿÿÿÿ   v      wÿÿÿÿ   v   &               W¸   4      w      w      vÿÿÿÿ   vÿÿÿÿ    X      expression was true       *pcToken    wÿÿÿÿ   v      wÿÿÿÿ   v      expression was false       *pcToken    wÿÿÿÿ   v      wÿÿÿÿ   v              6      q      q   &   pÿÿÿÿ   pÿÿÿÿ    SĞ      expression was true       *pcToken == ' '    qÿÿÿÿ   p      qÿÿÿÿ   p   &   expression was false       *pcToken == ' '    qÿÿÿÿ   p      qÿÿÿÿ   p   &               R    8      q      q      pÿÿÿÿ   pÿÿÿÿ    Rø      expression was true       *pcToken    qÿÿÿÿ   p      qÿÿÿÿ   p      expression was false       *pcToken    qÿÿÿÿ   p      qÿÿÿÿ   p              :     [     [   !  Zÿÿÿÿ  Zÿÿÿÿ     ,Vh      expression was false       i<unPower   [ÿÿÿÿ  Z     [ÿÿÿÿ  Z   !           ;     +     +   !  *ÿÿÿÿ  *ÿÿÿÿ    Ê8      expression was false       i<unPower   +ÿÿÿÿ  *     +ÿÿÿÿ  *   !           <     ‚     ‚     ÿÿÿÿ  ÿÿÿÿ     ,‹à      expression was false       posValDesc != 0   ‚ÿÿÿÿ       ‚ÿÿÿÿ                     ,t    =     Y     Y   $  Xÿÿÿÿ  Xÿÿÿÿ    ÉÀ      expression was true       *pcLine == ' '   Yÿÿÿÿ  X     Yÿÿÿÿ  X   $   expression was false       *pcLine == ' '   Yÿÿÿÿ  X     Yÿÿÿÿ  X   $               È   ?     ^     ^     ]ÿÿÿÿ  ]ÿÿÿÿ    Îh      expression was true       *pcLine   ^ÿÿÿÿ  ]     ^ÿÿÿÿ  ]      expression was false       *pcLine   ^ÿÿÿÿ  ]     ^ÿÿÿÿ  ]              A     ^     ^   $  ]ÿÿÿÿ  ]ÿÿÿÿ    Ï@      expression was true       *pcLine != ';'   ^ÿÿÿÿ  ]     ^ÿÿÿÿ  ]   $   expression was false       *pcLine != ';'   ^ÿÿÿÿ  ]     ^ÿÿÿÿ  ]   $               Í   C     d     d     cÿÿÿÿ  cÿÿÿÿ    Õ°      expression was true       *pcLine   dÿÿÿÿ  c     dÿÿÿÿ  c      expression was false       *pcLine   dÿÿÿÿ  c     dÿÿÿÿ  c              E     d     d   (  cÿÿÿÿ  cÿÿÿÿ    Öˆ      expression was true       *pcLine != ' '   dÿÿÿÿ  c     dÿÿÿÿ  c   (   expression was false       *pcLine != ' '   dÿÿÿÿ  c     dÿÿÿÿ  c   (               ÔØ   G     l     l     kÿÿÿÿ  kÿÿÿÿ    İ       expression was true       *pcLine   lÿÿÿÿ  k     lÿÿÿÿ  k      expression was false       *pcLine   lÿÿÿÿ  k     lÿÿÿÿ  k              I     l     l   (  kÿÿÿÿ  kÿÿÿÿ    İø      expression was true       *pcLine == ' '   lÿÿÿÿ  k     lÿÿÿÿ  k   (   expression was false       *pcLine == ' '   lÿÿÿÿ  k     lÿÿÿÿ  k   (               ÜH   K     r     r     qÿÿÿÿ  qÿÿÿÿ    b       expression was true       *pcLine   rÿÿÿÿ  q     rÿÿÿÿ  q      expression was false       *pcLine   rÿÿÿÿ  q     rÿÿÿÿ  q              M     r     r   )  qÿÿÿÿ  qÿÿÿÿ    cx      expression was true       *pcLine == '\"'   rÿÿÿÿ  q     rÿÿÿÿ  q   )   expression was false       *pcLine == '\"'   rÿÿÿÿ  q     rÿÿÿÿ  q   )               aÈ   O     w     w     vÿÿÿÿ  vÿÿÿÿ    h       expression was true       *pcLine   wÿÿÿÿ  v     wÿÿÿÿ  v      expression was false       *pcLine   wÿÿÿÿ  v     wÿÿÿÿ  v              Q     w     w   )  vÿÿÿÿ  vÿÿÿÿ    hø      expression was true       *pcLine != '\"'   wÿÿÿÿ  v     wÿÿÿÿ  v   )   expression was false       *pcLine != '\"'   wÿÿÿÿ  v     wÿÿÿÿ  v   )               gH   S     ‚     ‚     ÿÿÿÿ  ÿÿÿÿ    p      expression was true       *pcLine   ‚ÿÿÿÿ       ‚ÿÿÿÿ        expression was false       *pcLine   ‚ÿÿÿÿ       ‚ÿÿÿÿ                U     ‚     ‚   (  ÿÿÿÿ  ÿÿÿÿ    pè      expression was true       *pcLine == ' '   ‚ÿÿÿÿ       ‚ÿÿÿÿ     (   expression was false       *pcLine == ' '   ‚ÿÿÿÿ       ‚ÿÿÿÿ     (               o8   W     ¦     ¦     ¥ÿÿÿÿ  ¥ÿÿÿÿ    ‚°      expression was true       ucFormat != 0   ¦ÿÿÿÿ  ¥     ¦ÿÿÿÿ  ¥      expression was false       ucFormat != 0   ¦ÿÿÿÿ  ¥     ¦ÿÿÿÿ  ¥                  €€   Y     ¦     ¦   3  ¥ÿÿÿÿ  ¥ÿÿÿÿ    ƒ˜      expression was true       ucFormat != m_ucDataFormat   ¦ÿÿÿÿ  ¥     ¦ÿÿÿÿ  ¥   3   expression was false       ucFormat != m_ucDataFormat   ¦ÿÿÿÿ  ¥     ¦ÿÿÿÿ  ¥   3               Ø   [     ²     ²     ±ÿÿÿÿ  ±ÿÿÿÿ    ‰°      expression was true       m_ucWhichByte < 1   ²ÿÿÿÿ  ±     ²ÿÿÿÿ  ±      expression was false       m_ucWhichByte < 1   ²ÿÿÿÿ  ±     ²ÿÿÿÿ  ±              ]     ²     ²   .  ±ÿÿÿÿ  ±ÿÿÿÿ    Šˆ      expression was true       m_ucWhichByte > 8   ²ÿÿÿÿ  ±     ²ÿÿÿÿ  ±   .   expression was false       m_ucWhichByte > 8   ²ÿÿÿÿ  ±     ²ÿÿÿÿ  ±   .           _     ·     ·     ¶ÿÿÿÿ  ¶ÿÿÿÿ     5ÓĞ      expression was true       m_ucWhichByte == 8   ·ÿÿÿÿ  ¶     ·ÿÿÿÿ  ¶      expression was false       m_ucWhichByte == 8   ·ÿÿÿÿ  ¶     ·ÿÿÿÿ  ¶                   5Ò°   a     ·     ·   .  ¶ÿÿÿÿ  ¶ÿÿÿÿ     5Ô¸      expression was true       m_ucStartBit > 7   ·ÿÿÿÿ  ¶     ·ÿÿÿÿ  ¶   .   expression was false       m_ucStartBit > 7   ·ÿÿÿÿ  ¶     ·ÿÿÿÿ  ¶   .           c     ½     ½   #  ¼ÿÿÿÿ  ¼ÿÿÿÿ     5Û      expression was true       m_ucType == SIG_TYPE_DOUBLE   ½ÿÿÿÿ  ¼     ½ÿÿÿÿ  ¼   #   expression was false       m_ucType == SIG_TYPE_DOUBLE   ½ÿÿÿÿ  ¼     ½ÿÿÿÿ  ¼   #                5ØÈ   e     ½   '  ½   A  ¼ÿÿÿÿ  ¼ÿÿÿÿ     5Ûğ      expression was true       m_ucType == SIG_TYPE_FLOAT   ½ÿÿÿÿ  ¼   '  ½ÿÿÿÿ  ¼   A   expression was false       m_ucType == SIG_TYPE_FLOAT   ½ÿÿÿÿ  ¼   '  ½ÿÿÿÿ  ¼   A                5Ú0   g     Ô     Ô   3  Óÿÿÿÿ  Óÿÿÿÿ     5ğ8      expression was true       m_MaxValue.uiValue <= uiDefault   Ôÿÿÿÿ  Ó     Ôÿÿÿÿ  Ó   3   expression was false       m_MaxValue.uiValue <= uiDefault   Ôÿÿÿÿ  Ó     Ôÿÿÿÿ  Ó   3                5ï   i     Ô   7  Ô   L  Óÿÿÿÿ  Óÿÿÿÿ     5ñ       expression was true       m_MaxValue.uiValue >0   Ôÿÿÿÿ  Ó   7  Ôÿÿÿÿ  Ó   L   expression was false       m_MaxValue.uiValue >0   Ôÿÿÿÿ  Ó   7  Ôÿÿÿÿ  Ó   L           k     s     s   >  rÿÿÿÿ  rÿÿÿÿ     ,n       expression was false       m_MinValue.ui64Value >m_MaxValue.ui64Value   sÿÿÿÿ  r     sÿÿÿÿ  r   >           l     n     n   :  mÿÿÿÿ  mÿÿÿÿ     ,j      expression was false       m_MaxValue.ui64Value > ui64Default - 1   nÿÿÿÿ  m     nÿÿÿÿ  m   :                ,f0   m     C     C   =  Bÿÿÿÿ  Bÿÿÿÿ     ,A(      expression was false       m_MinValue.i64Value > m_MaxValue.i64Value   Cÿÿÿÿ  B     Cÿÿÿÿ  B   =           n     >     >   8  =ÿÿÿÿ  =ÿÿÿÿ    İx      expression was false       m_MaxValue.i64Value > i64Default - 1   >ÿÿÿÿ  =     >ÿÿÿÿ  =   8               Ù   o             8  ÿÿÿÿ  ÿÿÿÿ    ­ˆ      expression was false       m_MinValue.iValue >m_MaxValue.iValue   ÿÿÿÿ       ÿÿÿÿ     8           p             0   ÿÿÿÿ   ÿÿÿÿ    ©H      expression was false       m_MaxValue.iValue > iDefault   ÿÿÿÿ        ÿÿÿÿ      0           q     å     å   :  äÿÿÿÿ  äÿÿÿÿ          expression was false       m_MinValue.uiValue >m_MaxValue.uiValue   åÿÿÿÿ  ä     åÿÿÿÿ  ä   :           r     à     à   2  ßÿÿÿÿ  ßÿÿÿÿ     5üÀ      expression was false       m_MaxValue.uiValue > uiDefault   àÿÿÿÿ  ß     àÿÿÿÿ  ß   2           s     Ã     Ã     Âÿÿÿÿ  Âÿÿÿÿ     5âø      expression was false       m_ucLength == 1   Ãÿÿÿÿ  Â     Ãÿÿÿÿ  Â                   5ßÈ   t     2     2   5  1ÿÿÿÿ  1ÿÿÿÿ    Î(      expression was true       m_MaxValue.i64Value <= i64Default   2ÿÿÿÿ  1     2ÿÿÿÿ  1   5   expression was false       m_MaxValue.i64Value <= i64Default   2ÿÿÿÿ  1     2ÿÿÿÿ  1   5               Í   v     2   9  2   O  1ÿÿÿÿ  1ÿÿÿÿ    Ï      expression was true       m_MaxValue.i64Value >0   2ÿÿÿÿ  1   9  2ÿÿÿÿ  1   O   expression was false       m_MaxValue.i64Value >0   2ÿÿÿÿ  1   9  2ÿÿÿÿ  1   O           x     b     b   ;  aÿÿÿÿ  aÿÿÿÿ     ,[@      expression was true       m_MaxValue.ui64Value <= ui64Default - 1   bÿÿÿÿ  a     bÿÿÿÿ  a   ;   expression was false       m_MaxValue.ui64Value <= ui64Default - 1   bÿÿÿÿ  a     bÿÿÿÿ  a   ;                ,Z   z     ¬     ¬     «ÿÿÿÿ  «ÿÿÿÿ    ˆ`      expression was false       m_ucLength > 64   ¬ÿÿÿÿ  «     ¬ÿÿÿÿ  «              {     b   ?  b   W  aÿÿÿÿ  aÿÿÿÿ     ,\(      expression was true       m_MaxValue.ui64Value > 0   bÿÿÿÿ  a   ?  bÿÿÿÿ  a   W   expression was false       m_MaxValue.ui64Value > 0   bÿÿÿÿ  a   ?  bÿÿÿÿ  a   W           }     ˆ     ˆ     ‡ÿÿÿÿ  ‡ÿÿÿÿ    {@      expression was false       acDesc[0] != '\0'   ˆÿÿÿÿ  ‡     ˆÿÿÿÿ  ‡                  tø   ~      ²      ²   )   ±ÿÿÿÿ   ±ÿÿÿÿ     )§à      expression was false       SIG_DF_MOTOROLA == m_ucDataFormat    ²ÿÿÿÿ   ±      ²ÿÿÿÿ   ±   )                )˜          E      E   (   Dÿÿÿÿ   Dÿÿÿÿ     Ç°      expression was false       !m_listValueDescriptor.IsEmpty()    Eÿÿÿÿ   D      Eÿÿÿÿ   D   (                Å`   €      8      8   (   7ÿÿÿÿ   7ÿÿÿÿ     Â`      expression was false       !m_listValueDescriptor.IsEmpty()    8ÿÿÿÿ   7      8ÿÿÿÿ   7   (                À        È     È     Çÿÿÿÿ  Çÿÿÿÿ     î½(       statement executed        }   Èÿÿÿÿ  Ç     Èÿÿÿÿ  Ç              ‚     Æ     Æ     Åÿÿÿÿ  Åÿÿÿÿ     ,›ø       statement executed        break;   Æÿÿÿÿ  Å     Æÿÿÿÿ  Å              ƒ     Â     Â     Áÿÿÿÿ  Áÿÿÿÿ     ,š       statement executed        break;   Âÿÿÿÿ  Á     Âÿÿÿÿ  Á              „     ¾     ¾     ½ÿÿÿÿ  ½ÿÿÿÿ     ,˜       statement executed        break;   ¾ÿÿÿÿ  ½     ¾ÿÿÿÿ  ½              …     º     º     ¹ÿÿÿÿ  ¹ÿÿÿÿ     ,–(       statement executed        break;   ºÿÿÿÿ  ¹     ºÿÿÿÿ  ¹              †     ¶     ¶     µÿÿÿÿ  µÿÿÿÿ     ,”8       statement executed        break;   ¶ÿÿÿÿ  µ     ¶ÿÿÿÿ  µ              ‡     ²     ²     ±ÿÿÿÿ  ±ÿÿÿÿ     ,’H       statement executed        break;   ²ÿÿÿÿ  ±     ²ÿÿÿÿ  ±              ˆ     ®     ®     ­ÿÿÿÿ  ­ÿÿÿÿ     ,X       statement executed        break;   ®ÿÿÿÿ  ­     ®ÿÿÿÿ  ­              ‰     ¥     ¥   (  ¤ÿÿÿÿ  ¤ÿÿÿÿ     ,ŒÈ       statement executed        return (m_uiError = SIG_EC_NO_ERR);   ¥ÿÿÿÿ  ¤     ¥ÿÿÿÿ  ¤   (           Š     £     £     ¢ÿÿÿÿ  ¢ÿÿÿÿ     ,‹       statement executed        }   £ÿÿÿÿ  ¢     £ÿÿÿÿ  ¢              ‹     ¡     ¡      ÿÿÿÿ   ÿÿÿÿ     ,Š0       statement executed        break;   ¡ÿÿÿÿ        ¡ÿÿÿÿ                 Œ               ÿÿÿÿ  ÿÿÿÿ     ,‰X       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                     š     š     ™ÿÿÿÿ  ™ÿÿÿÿ     ,…¨       statement executed        break;   šÿÿÿÿ  ™     šÿÿÿÿ  ™                   –     –     •ÿÿÿÿ  •ÿÿÿÿ     ,ø       statement executed        break;   –ÿÿÿÿ  •     –ÿÿÿÿ  •                   “     “     ’ÿÿÿÿ  ’ÿÿÿÿ     ,        statement executed        break;   “ÿÿÿÿ  ’     “ÿÿÿÿ  ’                             ÿÿÿÿ  ÿÿÿÿ     ,}€       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                ‘     ‹     ‹     Šÿÿÿÿ  Šÿÿÿÿ     ,yà       statement executed        break;   ‹ÿÿÿÿ  Š     ‹ÿÿÿÿ  Š              ’     |     |     {ÿÿÿÿ  {ÿÿÿÿ     ,qp       statement executed        break;   |ÿÿÿÿ  {     |ÿÿÿÿ  {              “     y     y     xÿÿÿÿ  xÿÿÿÿ     ,p˜       statement executed        break;   yÿÿÿÿ  x     yÿÿÿÿ  x              ”     w     w     vÿÿÿÿ  vÿÿÿÿ     ,nØ       statement executed        }   wÿÿÿÿ  v     wÿÿÿÿ  v              •     v     v     uÿÿÿÿ  uÿÿÿÿ     ,m(       statement executed        }   vÿÿÿÿ  u     vÿÿÿÿ  u              –     q     q     pÿÿÿÿ  pÿÿÿÿ     ,i¸       statement executed        }   qÿÿÿÿ  p     qÿÿÿÿ  p              —     j     j     iÿÿÿÿ  iÿÿÿÿ     ,d@       statement executed        }   jÿÿÿÿ  i     jÿÿÿÿ  i              ˜     e     e     dÿÿÿÿ  dÿÿÿÿ     ,_h       statement executed        }   eÿÿÿÿ  d     eÿÿÿÿ  d              ™     ^     ^     ]ÿÿÿÿ  ]ÿÿÿÿ     ,U       statement executed        }   ^ÿÿÿÿ  ]     ^ÿÿÿÿ  ]              š     W     W     Vÿÿÿÿ  Vÿÿÿÿ     ,P        statement executed        }   Wÿÿÿÿ  V     Wÿÿÿÿ  V              ›     S     S     Rÿÿÿÿ  Rÿÿÿÿ     ,Mè       statement executed        }   Sÿÿÿÿ  R     Sÿÿÿÿ  R              œ     I     I     Hÿÿÿÿ  Hÿÿÿÿ     ,CÀ       statement executed        break;   Iÿÿÿÿ  H     Iÿÿÿÿ  H                   G     G     Fÿÿÿÿ  Fÿÿÿÿ     ,B        statement executed        }   Gÿÿÿÿ  F     Gÿÿÿÿ  F                   F     F     Eÿÿÿÿ  Eÿÿÿÿ     ,@P       statement executed        }   Fÿÿÿÿ  E     Fÿÿÿÿ  E              Ÿ     A     A     @ÿÿÿÿ  @ÿÿÿÿ    Ü        statement executed        }   Aÿÿÿÿ  @     Aÿÿÿÿ  @                    :     :     9ÿÿÿÿ  9ÿÿÿÿ    ×(       statement executed        }   :ÿÿÿÿ  9     :ÿÿÿÿ  9              ¡     5     5     4ÿÿÿÿ  4ÿÿÿÿ    ÒP       statement executed        }   5ÿÿÿÿ  4     5ÿÿÿÿ  4              ¢     .     .     -ÿÿÿÿ  -ÿÿÿÿ    É`       statement executed        }   .ÿÿÿÿ  -     .ÿÿÿÿ  -              £     '     '     &ÿÿÿÿ  &ÿÿÿÿ    Ãø       statement executed        }   'ÿÿÿÿ  &     'ÿÿÿÿ  &              ¤     #     #     "ÿÿÿÿ  "ÿÿÿÿ    ÁÀ       statement executed        }   #ÿÿÿÿ  "     #ÿÿÿÿ  "              ¥               ÿÿÿÿ  ÿÿÿÿ    ¶°       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                ¦               ÿÿÿÿ  ÿÿÿÿ    µØ       statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                §               ÿÿÿÿ  ÿÿÿÿ    °        statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                ¨     
     
     	ÿÿÿÿ  	ÿÿÿÿ    ®`       statement executed        }   
ÿÿÿÿ  	     
ÿÿÿÿ  	              ©     	     	     ÿÿÿÿ  ÿÿÿÿ    ¬°       statement executed        }   	ÿÿÿÿ       	ÿÿÿÿ                ª               ÿÿÿÿ  ÿÿÿÿ    ¨p       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                «     ı     ı     üÿÿÿÿ  üÿÿÿÿ    ¤À       statement executed        }   ıÿÿÿÿ  ü     ıÿÿÿÿ  ü              ¬     ø     ø     ÷ÿÿÿÿ  ÷ÿÿÿÿ    Ÿø       statement executed        }   øÿÿÿÿ  ÷     øÿÿÿÿ  ÷              ­     ë     ë     êÿÿÿÿ  êÿÿÿÿ    ‘        statement executed        break;   ëÿÿÿÿ  ê     ëÿÿÿÿ  ê              ®     é     é     èÿÿÿÿ  èÿÿÿÿ    ğ       statement executed        }   éÿÿÿÿ  è     éÿÿÿÿ  è              ¯     è     è     çÿÿÿÿ  çÿÿÿÿ     5ÿ@       statement executed        }   èÿÿÿÿ  ç     èÿÿÿÿ  ç              °     ã     ã     âÿÿÿÿ  âÿÿÿÿ     5ûè       statement executed        }   ãÿÿÿÿ  â     ãÿÿÿÿ  â              ±     Ü     Ü     Ûÿÿÿÿ  Ûÿÿÿÿ     5ø8       statement executed        }   Üÿÿÿÿ  Û     Üÿÿÿÿ  Û              ²     ×     ×     Öÿÿÿÿ  Öÿÿÿÿ     5ôX       statement executed        }   ×ÿÿÿÿ  Ö     ×ÿÿÿÿ  Ö              ³     Æ     Æ     Åÿÿÿÿ  Åÿÿÿÿ     5â        statement executed        }   Æÿÿÿÿ  Å     Æÿÿÿÿ  Å              ´     ¿   	  ¿   .  ¾ÿÿÿÿ  ¾ÿÿÿÿ     5İè       statement executed        return (m_uiError = SIG_EC_TYPE_ERR);   ¿ÿÿÿÿ  ¾   	  ¿ÿÿÿÿ  ¾   .           µ     ¹   	  ¹   2  ¸ÿÿÿÿ  ¸ÿÿÿÿ     5Ö        statement executed        return (m_uiError = SIG_EC_STARTBIT_ERR);   ¹ÿÿÿÿ  ¸   	  ¹ÿÿÿÿ  ¸   2           ¶     ´   	  ´   2  ³ÿÿÿÿ  ³ÿÿÿÿ     5Ğà       statement executed        return (m_uiError = SIG_EC_STARTBIT_ERR);   ´ÿÿÿÿ  ³   	  ´ÿÿÿÿ  ³   2           ·     ®   	  ®   0  ­ÿÿÿÿ  ­ÿÿÿÿ    ‡ˆ       statement executed        return (m_uiError = SIG_EC_LENGTH_ERR);   ®ÿÿÿÿ  ­   	  ®ÿÿÿÿ  ­   0           ¸     ¨   	  ¨   5  §ÿÿÿÿ  §ÿÿÿÿ    …       statement executed        return (m_uiError = SIG_EC_DATA_FORMAT_ERR);   ¨ÿÿÿÿ  §   	  ¨ÿÿÿÿ  §   5           ¹     ‘     ‘     ÿÿÿÿ  ÿÿÿÿ    }è       statement executed        return 1;   ‘ÿÿÿÿ       ‘ÿÿÿÿ                º               ÿÿÿÿ  ÿÿÿÿ    |(       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                »        	     
  ÿÿÿÿ  ÿÿÿÿ    zh       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           ¼     …   	  …   
  „ÿÿÿÿ  „ÿÿÿÿ    rø       statement executed        }   …ÿÿÿÿ  „   	  …ÿÿÿÿ  „   
           ½     {   	  {   
  zÿÿÿÿ  zÿÿÿÿ    l        statement executed        }   {ÿÿÿÿ  z   	  {ÿÿÿÿ  z   
           ¾     u   	  u   
  tÿÿÿÿ  tÿÿÿÿ    eˆ       statement executed        }   uÿÿÿÿ  t   	  uÿÿÿÿ  t   
           ¿     o   	  o   
  nÿÿÿÿ  nÿÿÿÿ    `       statement executed        }   oÿÿÿÿ  n   	  oÿÿÿÿ  n   
           À     g   	  g   
  fÿÿÿÿ  fÿÿÿÿ    Ùp       statement executed        }   gÿÿÿÿ  f   	  gÿÿÿÿ  f   
           Á     \     \     [ÿÿÿÿ  [ÿÿÿÿ    ËĞ       statement executed        }   \ÿÿÿÿ  [     \ÿÿÿÿ  [              Â     J     J     Iÿÿÿÿ  Iÿÿÿÿ    Á        statement executed        return 1;   Jÿÿÿÿ  I     Jÿÿÿÿ  I              Ã     H     H     Gÿÿÿÿ  Gÿÿÿÿ    ¿à       statement executed        }   Hÿÿÿÿ  G     Hÿÿÿÿ  G              Ä     D     D     Cÿÿÿÿ  Cÿÿÿÿ    ½è       statement executed        }   Dÿÿÿÿ  C     Dÿÿÿÿ  C              Å     =     =     <ÿÿÿÿ  <ÿÿÿÿ    Œ]8       statement executed        }   =ÿÿÿÿ  <     =ÿÿÿÿ  <              Æ     5     5     4ÿÿÿÿ  4ÿÿÿÿ    ŒUH       statement executed        }   5ÿÿÿÿ  4     5ÿÿÿÿ  4              Ç     ,     ,     +ÿÿÿÿ  +ÿÿÿÿ    ŒM       statement executed        }   ,ÿÿÿÿ  +     ,ÿÿÿÿ  +              È     $     $     #ÿÿÿÿ  #ÿÿÿÿ    ŒFx       statement executed        }   $ÿÿÿÿ  #     $ÿÿÿÿ  #              É               ÿÿÿÿ  ÿÿÿÿ    Œ?`       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Ê               ÿÿÿÿ  ÿÿÿÿ     îà       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Ë               ÿÿÿÿ  ÿÿÿÿ     é       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Ì               ÿÿÿÿ  ÿÿÿÿ     áX       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Í               ÿÿÿÿ  ÿÿÿÿ     ŞØ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                Î      ù      ù      øÿÿÿÿ   øÿÿÿÿ     Ù        statement executed        }    ùÿÿÿÿ   ø      ùÿÿÿÿ   ø              Ï      0      0      /ÿÿÿÿ   /ÿÿÿÿ     ¾        statement executed        }    0ÿÿÿÿ   /      0ÿÿÿÿ   /              Ğ      ;      ;      :ÿÿÿÿ   :ÿÿÿÿ     Áˆ       statement executed        }    ;ÿÿÿÿ   :      ;ÿÿÿÿ   :              Ñ      <      <      ;ÿÿÿÿ   ;ÿÿÿÿ     ÃH       statement executed        }    <ÿÿÿÿ   ;      <ÿÿÿÿ   ;              Ò      H      H      Gÿÿÿÿ   Gÿÿÿÿ     ÆØ       statement executed        }    Hÿÿÿÿ   G      Hÿÿÿÿ   G              Ó      [      [      Zÿÿÿÿ   Zÿÿÿÿ    Kh       statement executed        return (*this);    [ÿÿÿÿ   Z      [ÿÿÿÿ   Z              Ô      t      t      sÿÿÿÿ   sÿÿÿÿ    Uø       statement executed        }    tÿÿÿÿ   s      tÿÿÿÿ   s              Õ      z      z      yÿÿÿÿ   yÿÿÿÿ    \P       statement executed        }    zÿÿÿÿ   y      zÿÿÿÿ   y              Ö      †      †      …ÿÿÿÿ   …ÿÿÿÿ    S|       statement executed        }    †ÿÿÿÿ   …      †ÿÿÿÿ   …              ×      ’      ’      ‘ÿÿÿÿ   ‘ÿÿÿÿ    S‡        statement executed        }    ’ÿÿÿÿ   ‘      ’ÿÿÿÿ   ‘              Ø      ©      ©      ¨ÿÿÿÿ   ¨ÿÿÿÿ     )’       statement executed        }    ©ÿÿÿÿ   ¨      ©ÿÿÿÿ   ¨              Ù      Ç      Ç      Æÿÿÿÿ   Æÿÿÿÿ     )§       statement executed        }    Çÿÿÿÿ   Æ      Çÿÿÿÿ   Æ              Ú      Ô      Ô      Óÿÿÿÿ   Óÿÿÿÿ    $Ğ°       statement executed        }    Ôÿÿÿÿ   Ó      Ôÿÿÿÿ   Ó              Û      Ø      Ø      ×ÿÿÿÿ   ×ÿÿÿÿ    $Õğ       statement executed        }    Øÿÿÿÿ   ×      Øÿÿÿÿ   ×              Ü      â      â      áÿÿÿÿ   áÿÿÿÿ    $Şğ       statement executed        }    âÿÿÿÿ   á      âÿÿÿÿ   á              İ      í      í      ìÿÿÿÿ   ìÿÿÿÿ    $ê@       statement executed        }    íÿÿÿÿ   ì      íÿÿÿÿ   ì           CSignal::CSignal CSignal::CSignal()           0      ÿÿÿÿ   /ÿÿÿÿCSignal::~CSignal CSignal::~CSignal()    6      <      5ÿÿÿÿ   ;ÿÿÿÿCSignal::operator= CSignal& CSignal::operator=(CSignal& signal)    D      \      Cÿÿÿÿ   [ÿÿÿÿCSignal::Format int CSignal::Format(char* pcLine)    c     K      bÿÿÿÿ  JÿÿÿÿCSignal::AddValueDescriptors int CSignal::AddValueDescriptors(char* pcLine)   R     ’     Qÿÿÿÿ  ‘ÿÿÿÿCSignal::Validate unsigned int CSignal::Validate(unsigned char ucFormat)   ¤     ¦     £ÿÿÿÿ  ¥ÿÿÿÿCSignal::GetErrorString void CSignal::GetErrorString(string& str)   ©     È     ¨ÿÿÿÿ  Çÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Signal.cpp
 * \brief     Implementation file for CSignal class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CSignal class
 */

/* Project includes */
#include "Signal.h"

/**
 * Construction
 */
CSignal::CSignal()
{
    m_acMultiplex = "";
    m_acName = "";
    m_ucLength = 1; // minimum signal length should be 1 bit
    m_ucWhichByte = 1; // ONE based index
    m_ucStartBit = 0; // ZERO based index
    m_ucType = SIG_TYPE_BOOL; // let default be bool type -- match with default length
    m_MaxValue.uiValue = 1; // use unsigned int field for bool also
    m_MinValue.uiValue = 0; //
    m_ucDataFormat = SIG_DF_INTEL;
    m_fOffset = 0.0f;
    m_fScaleFactor = 1.0f;
    m_acUnit = "";
    m_uiError = SIG_EC_NO_ERR;
    m_rxNode = "";
    m_listValueDescriptor.RemoveAll();
}

/**
 * Destruction
 */
CSignal::~CSignal()
{
    // clear the embedded value descriptor list before destroying the signal
    if(!m_listValueDescriptor.IsEmpty())
    {
        m_listValueDescriptor.RemoveAll();
    }
}

/**
 * Overload assignment operator. We should clear the existing value descriptor
 * list and copy contents of the argument's list to this signal.
 * The rest of the members are copied by value.
 */
CSignal& CSignal::operator=(CSignal& signal)
{
    if(!m_listValueDescriptor.IsEmpty())
    {
        m_listValueDescriptor.RemoveAll(); // clear the list first
    }

    // copy all the data members except the list
    m_acMultiplex = signal.m_acMultiplex;
    m_acName = signal.m_acName;
    m_ucLength = signal.m_ucLength;
    m_ucWhichByte = signal.m_ucWhichByte;
    m_ucStartBit = signal.m_ucStartBit;
    m_ucType = signal.m_ucType;
    m_MaxValue = signal.m_MaxValue;
    m_MinValue = signal.m_MinValue;
    m_ucDataFormat = signal.m_ucDataFormat;
    m_fOffset = signal.m_fOffset;
    m_fScaleFactor = signal.m_fScaleFactor;
    m_acUnit = signal.m_acUnit;
    m_uiError = signal.m_uiError;
    m_rxNode = signal.m_rxNode;
    // now copy the list
    m_listValueDescriptor.AddTail(&signal.m_listValueDescriptor);
    return (*this);
}

/**
 * Extract the signal info from the line and store it in the signal object
 * return an appropriate error code if something wrong with signalline
 */
int CSignal::Format(char* pcLine)
{
    char* pcToken;
    char* pcNextToken;
    char acTemp[defVTAB_MAX_LINE_LEN],*pcTemp;
    pcTemp = acTemp;
    // get signal name
    // in older versions of CANoe it can be in any of this format
    // <SIG_NAME :> -- standard signal
    // <SIG_NAME M :> -- mode signal
    // <SIG_NAME mk :> -- mode dependent signal
    pcToken = strtok_s(pcLine, ":", &pcNextToken); // get upto colon

    // copy only signal name because we BUSMASTER does not support modes
    // skip leading spaces first
    while(*pcToken && *pcToken == ' ')
    {
        pcToken++;
    }

    // now get the signal name
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; // copy SIG_NAME only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_acName = acTemp; // copy the name to the signal's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer
    //leave blank space
    *pcToken++;

    //Find the signal's multiplexing details
    while(*pcToken && *pcToken != ' ')
    {
        *pcTemp++ = *pcToken++; // copy SIG_NAME only, i.e. till first 'space'
    }

    *pcTemp = '\0'; // terminate it
    m_acMultiplex = acTemp; // copy the name to the signal's data member
    pcTemp = acTemp; // reset pcTemp to start of buffer
    // next token (START_BIT|LENGTH@DATA_FORMAT(+/-))
    pcToken = strtok_s(NULL, " :", &pcNextToken);

    // get start bit
    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip '|'
    // store the start byte and start bit information
    unsigned int uiStartBit = atoi(acTemp);
    // rajesh: 21-03-2003: begin:
    // based on INTEL/MOTOROLA - the start bit is represnted differently by CANoe.
    // With motorola format, bits are stored in reverse order. BUSMASTER
    // does not differentiate between INTEL and MOTOROLA at this stage and START_BYTE
    // and START_BIT are not depending on this. So process this after identifying the
    // format. Original code commented - moved down.
    /*
    m_ucWhichByte = uiStartBit / 8 + 1;
    m_ucStartBit = uiStartBit % 8;
    */
    // rajesh: 21-03-2003: end_1: continued below
    // get signal length
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '@')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip '@'
    m_ucLength = atoi(acTemp); // store signal length
    // get DATA_FORMAT (intel or motorola)
    m_ucDataFormat = *pcToken;

    // rajesh: 21-03-2003: begin_1: modification continued
    if(SIG_DF_MOTOROLA == m_ucDataFormat)
    {
        /*  if(m_ucLength>=8)
            {
                uiStartBit = ( 65 - ( (uiStartBit/8*8) + (8-uiStartBit%8) + m_ucLength));
            }
            else if(m_ucLength!=1)
            {
                uiStartBit = 63 - (uiStartBit + m_ucLength )+(uiStartBit+1)/8*8 ;
            }*/
        INT nTemp = 0;
        // If the signal is of type Motorola, its length and
        // endbit is indicated in the file. The end bit is represented in Intel format
        // itself.
        // Get the start bit w.r.t to bit numbering in Intel format but bits are in
        // Motorola format.
        nTemp =  8 * ( ( m_ucLength - 1 ) / 8 ) - ( ( m_ucLength - 1) % 8 );
        uiStartBit = uiStartBit + nTemp;
        // Swap the byte position to get it is intel format.
        nTemp = 8 * ( 8 - ( 2 * ( uiStartBit/8 ) + 1 ) );
        uiStartBit = uiStartBit + nTemp ;
    }

    m_ucWhichByte = uiStartBit / 8 + 1;
    m_ucStartBit = uiStartBit % 8;
    // rajesh: 21-03-2003:end:

    // get sign of signal. At this point we know only whether the
    // signal is signed or unsigned. Whether it is float or double
    // will be known later only when we process "SIG_VALTYPE_"

    if(m_ucLength >32)
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT64 : SIG_TYPE_UINT64;
    }
    else
    {
        m_ucType = (*(++pcToken) == '-') ? SIG_TYPE_INT : SIG_TYPE_UINT;
    }

    // next token - (SCALE_FACTOR,OFFSET)
    pcToken = strtok_s(NULL, " (", &pcNextToken);
    pcTemp = acTemp;

    // get scale factor
    while(*pcToken && *pcToken != ',')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip ','
    m_fScaleFactor = (float)atof(acTemp); // store scale factor
    // Get offset
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ')')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    m_fOffset = (float)atof(acTemp); // store Offset
    // next token [MIN|MAX]
    pcToken = strtok_s(NULL, " [", &pcNextToken);
    // get MIN
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '|')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip '|'

    // now store as double until we parse till SIG_VALTYPE_
    if(m_ucLength <= 32)
    {
        m_MinValue.dValue = atof(acTemp);    // store MIN value
    }
    else
    {
        m_MinValue.i64Value = _atoi64(acTemp);
    }

    // get MAX value
    pcTemp = acTemp;

    while(*pcToken && *pcToken != ']')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    pcToken++; // skip ']'

    if(m_ucLength <= 32)
    {
        m_MaxValue.dValue = atof(acTemp);    // store MAX value
    }
    else
    {
        m_MaxValue.i64Value = _atoi64(acTemp);
    }

    // next token -- "UNIT", ""
    pcTemp = acTemp;
    pcToken++;

    // skip first <">
    while(*pcToken && *pcToken != '\"')
    {
        pcToken++;
    }

    pcToken++;

    // copy everything, but not including the last <">
    while(*pcToken && *pcToken != '\"')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';
    m_acUnit = acTemp; // copy UNIT to corresponding data member.
    pcToken++;

    while(*pcToken && *pcToken != ' ')
    {
        pcToken++;
    }

    pcToken++;
    pcTemp = acTemp;

    while(*pcToken && *pcToken != '\n')
    {
        *pcTemp++ = *pcToken++;
    }

    *pcTemp='\0';

    if(strcmp(acTemp,"Vector__XXX") != 0)
    {
        m_rxNode = acTemp;
    }
    else
    {
        m_rxNode = "";
    }

    return 1;
}

/**
 * Extracts Values and value descriptors from the line and
 * stores them to the Signal
 */
int CSignal::AddValueDescriptors(char* pcLine)
{
    char acValue[100];
    char acDesc[100];
    char* pcValue = acValue;
    char* pcDesc = acDesc;

    // skip leading spaces
    while(*pcLine && *pcLine == ' ')
    {
        *pcLine++;
    }

    while(*pcLine && *pcLine != ';')
    {
        pcValue = acValue;
        pcDesc = acDesc;
        *pcValue = *pcDesc = '\0';

        while(*pcLine && *pcLine != ' ')
        {
            *pcValue++ = *pcLine++; // copy all but terminating space
        }

        *pcValue = '\0'; // terminate the string

        // skip leading spaces
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        // skip leading '"'
        while(*pcLine && *pcLine == '\"')
        {
            *pcLine++;
        }

        while(*pcLine && *pcLine != '\"')
        {
            *pcDesc++ = *pcLine;
            pcLine++;
        }

        *pcDesc = '\0';
        // skip trailing '"'.
        pcLine++;

        // skip spaces if any before next iteration.
        while(*pcLine && *pcLine == ' ')
        {
            *pcLine++;
        }

        // if any value read then add it to list
        if(acDesc[0] != '\0')
        {
            CValueDescriptor valDesc;
            valDesc.m_value.dValue = atof(acValue);
            valDesc.m_acDescriptor = acDesc;
            m_listValueDescriptor.AddTail(valDesc);
        }
    }

    return 1;
}

/**
 * \brief validate for conformance to BUSMASTER DB format
 * \param[in] ucFormat Data format of previous signal
 *
 * Convert single bit INT and UINT to BOOL
 * if MAX_value == MIN_value update MAX_value to MAX_default
 * else if MAX_value == MIN_value == MAX_default, update MIN_value to MIN_default
 * signals with length more than 32 bits shall be discarded
 *
 * The data format of previous signal is passed as a parameter
 * For the first one it will be zero, for then on either INTEL or MOTOROLA
 * If this signals format is not matching with previous signal then this signal to be
 * discarded.
 * SIG_EC_NO_ERR, SIG_EC_DATA_FORMAT_ERR,SIG_EC_LENGTH_ERR,SIG_EC_STARTBIT_ERR,SIG_EC_TYPE_ERR
 */
unsigned int CSignal::Validate(unsigned char ucFormat)
{
    // data format mismatch with previous signal
    if(ucFormat != 0 && ucFormat != m_ucDataFormat)
    {
        return (m_uiError = SIG_EC_DATA_FORMAT_ERR);
    }

    // if more than 64 bits should be discarded
    if(m_ucLength > 64)
    {
        return (m_uiError = SIG_EC_LENGTH_ERR);
    }

    // validate start bit and byte
    if(m_ucWhichByte < 1 || m_ucWhichByte > 8)
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }

    if(m_ucWhichByte == 8 && m_ucStartBit > 7)
    {
        return (m_uiError = SIG_EC_STARTBIT_ERR);
    }

    // DOUBLE & FLOAT are not supported right now
    if(m_ucType == SIG_TYPE_DOUBLE || m_ucType == SIG_TYPE_FLOAT)
    {
        return (m_uiError = SIG_EC_TYPE_ERR);
    }

    // errors eliminated now do necessary conversions
    if(m_ucLength == 1) // single bit - change type to bool
    {
        m_ucType = SIG_TYPE_BOOL;
    }

    // update MAX value and MIN value based on type
    switch(m_ucType)
    {
        case SIG_TYPE_BOOL:
        case SIG_TYPE_UINT:
            m_MaxValue.uiValue = (unsigned int)m_MaxValue.dValue;
            m_MinValue.uiValue = (unsigned int)m_MinValue.dValue;
            unsigned int uiDefault;
            uiDefault = (1 << m_ucLength) - 1;

            if(m_MaxValue.uiValue == m_MinValue.uiValue)
            {
                if(m_MaxValue.uiValue <= uiDefault && m_MaxValue.uiValue >0)
                {
                    m_MinValue.uiValue = 0;
                }
                else
                {
                    m_MaxValue.uiValue = uiDefault;
                    m_MinValue.uiValue = 0;
                }
            }
            else
            {
                if(m_MaxValue.uiValue > uiDefault)
                {
                    m_MaxValue.uiValue = uiDefault;
                }

                if(m_MinValue.uiValue >m_MaxValue.uiValue )
                {
                    m_MinValue.uiValue = 0;
                }
            }

            break;

        case SIG_TYPE_INT:
            m_MaxValue.iValue = (int)m_MaxValue.dValue;
            m_MinValue.iValue = (int)m_MinValue.dValue;
            int iDefault;
            iDefault = (1 << (m_ucLength - 1)) - 1;

            if(m_MaxValue.iValue == m_MinValue.iValue)
            {
                if(m_MaxValue.iValue <= iDefault)
                {
                    m_MinValue.iValue = -1*iDefault - 1;
                }
                else
                {
                    m_MaxValue.iValue = iDefault;
                    m_MinValue.iValue = -1*iDefault - 1;
                }
            }
            else
            {
                if(m_MaxValue.iValue > iDefault)
                {
                    m_MaxValue.iValue = iDefault;
                }

                if(m_MinValue.iValue >m_MaxValue.iValue )
                {
                    m_MinValue.iValue = -1*iDefault - 1;
                }
            }

            break;

            // float is not supported right now, so no validation
        case SIG_TYPE_FLOAT:
            m_MaxValue.fValue = (float)m_MaxValue.dValue;
            m_MinValue.fValue = (float)m_MinValue.dValue;
            break;

            // double is not supported right now, so no validation
        case SIG_TYPE_DOUBLE:
            // no need to update MAX and MIN values, already stored as double
            break;

        case SIG_TYPE_INT64:
            m_MaxValue.i64Value = (LONGLONG)m_MaxValue.dValue;
            m_MinValue.i64Value = (LONGLONG)m_MinValue.dValue;
            UINT unPower;
            __int64 i64Default;
            UINT i;

            if(m_ucLength == 64 )
            {
                unPower = m_ucLength - 1;
            }
            else
            {
                unPower = m_ucLength;
            }

            i64Default = 1;

            for(i = 0; i<unPower; i++)
            {
                i64Default = (__int64)( 2*i64Default);
            }

            if(m_MaxValue.ui64Value == m_MinValue.ui64Value)
            {
                if(m_MaxValue.i64Value <= i64Default && m_MaxValue.i64Value >0)
                {
                    m_MinValue.i64Value =  -(i64Default+1);
                }
                else
                {
                    m_MaxValue.i64Value = i64Default-1;
                    m_MinValue.i64Value =  -(i64Default+1);
                }
            }
            else
            {
                if(m_MaxValue.i64Value > i64Default - 1)
                {
                    m_MaxValue.i64Value = i64Default - 1;
                }

                if(m_MinValue.i64Value > m_MaxValue.i64Value )
                {
                    m_MinValue.i64Value = -(i64Default + 1);
                }
            }

            break;

        case SIG_TYPE_UINT64:
            m_MaxValue.ui64Value = (ULONGLONG)m_MaxValue.dValue;
            m_MinValue.ui64Value = (ULONGLONG)m_MinValue.dValue;
            unsigned __int64 ui64Default;

            if(m_ucLength == 64 )
            {
                unPower = m_ucLength - 1;
            }
            else
            {
                unPower = m_ucLength;
            }

            ui64Default = 1;

            for(i = 0; i<unPower; i++)
            {
                ui64Default = (unsigned __int64)( 2*ui64Default);
            }

            if(m_MaxValue.ui64Value == m_MinValue.ui64Value)
            {
                if(m_MaxValue.ui64Value <= ui64Default - 1 && m_MaxValue.ui64Value > 0)
                {
                    m_MinValue.ui64Value = 0;
                }
                else
                {
                    m_MaxValue.ui64Value = ui64Default - 1;
                    m_MinValue.ui64Value = 0;
                }
            }
            else
            {
                if(m_MaxValue.ui64Value > ui64Default - 1)
                {
                    m_MaxValue.ui64Value = ui64Default-1;
                }

                if(m_MinValue.ui64Value >m_MaxValue.ui64Value )
                {
                    m_MinValue.ui64Value = 0;
                }
            }

            break;

        default:
            break;
    }

    // correct value descriptors according to type of signal
    POSITION posValDesc = m_listValueDescriptor.GetHeadPosition();

    while(posValDesc != NULL)
    {
        CValueDescriptor& rValDesc = m_listValueDescriptor.GetNext(posValDesc);

        switch(m_ucType)
        {
            case SIG_TYPE_BOOL:
            case SIG_TYPE_UINT:
                rValDesc.m_value.uiValue = (unsigned int)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_INT:
                rValDesc.m_value.iValue = (int)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_FLOAT:
                rValDesc.m_value.fValue = (float)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_DOUBLE:
                break;

            case SIG_TYPE_INT64:
                rValDesc.m_value.i64Value = (LONGLONG)rValDesc.m_value.dValue;
                break;

            case SIG_TYPE_UINT64:
                rValDesc.m_value.ui64Value = (ULONGLONG)rValDesc.m_value.dValue;
                break;

            default:
                break;
        }
    }

    return (m_uiError = SIG_EC_NO_ERR);
}

void CSignal::GetErrorString(string& str)
{
    switch(m_uiError)
    {
        case SIG_EC_NO_ERR:
            str = "No error";
            break;

        case SIG_EC_DATA_FORMAT_ERR:
            str = "Data format mismatch";
            break;

        case SIG_EC_LENGTH_ERR:
            str = "Invalid signal length";
            break;

        case SIG_EC_STARTBIT_ERR:
            str = "Invalid start bit";
            break;

        case SIG_EC_TYPE_ERR:
            str = "Invalid signal type";
            break;

        case SIG_EC_OVERLAP:
            str = "Overlapping signal";
            break;

        default:
            str = "Unknown";
            break;
    }
}





































BOOL CSymbolTable::bAdd(const CString& omValue)
{
    
    
    BOOL bSuccess = 0;

    if( CSymbolTable::nFind( omValue) == -1)
    {
        m_omData.Add(omValue);
        bSuccess = 1;
    }

    return bSuccess;
}


int CSymbolTable::nFind(CString omValue) const
{
    
    
    
    omValue.MakeLower();
    int nPos = -1;
    int size = m_omData.GetSize();

    for( int nIndex = 0; nIndex< size ; nIndex++)
    {
        CString omElement = m_omData.GetAt(nIndex);
        omElement.MakeLower();

        if ( omValue == omElement )
        {
            nPos = nIndex;
            nIndex = size;
        }
    }

    return nPos;
}

void CSymbolTable::vClearArray()
{
    
    m_omData.RemoveAll();
}

const CString CSymbolTable::omGetAt(int nIndex)
{
    
    ((void)0);
    return m_omData.GetAt( nIndex);
}

int CSymbolTable::nGetSize()
{
    
    return m_omData.GetSize();
}
          @      @   &   ?ÿÿÿÿ   ?ÿÿÿÿ     ù¸      expression was false       nIndex< size    @ÿÿÿÿ   ?      @ÿÿÿÿ   ?   &                 E      E   "   Dÿÿÿÿ   Dÿÿÿÿ     ÷ø      expression was false       omValue == omElement    Eÿÿÿÿ   D      Eÿÿÿÿ   D   "                ó€         -   	   -   ,   ,ÿÿÿÿ   ,ÿÿÿÿ     ´°      expression was false       CSymbolTable::nFind( omValue) == -1    -ÿÿÿÿ   ,   	   -ÿÿÿÿ   ,   ,                ,²˜         _      _      ^ÿÿÿÿ   ^ÿÿÿÿ    Fø       statement executed        return m_omData.GetSize();    _ÿÿÿÿ   ^      _ÿÿÿÿ   ^                    Y      Y   $   Xÿÿÿÿ   Xÿÿÿÿ    D¨       statement executed        return m_omData.GetAt( nIndex);    Yÿÿÿÿ   X      Yÿÿÿÿ   X   $                 S      S      Rÿÿÿÿ   Rÿÿÿÿ    BH       statement executed        }    Sÿÿÿÿ   R      Sÿÿÿÿ   R                    L      L      Kÿÿÿÿ   Kÿÿÿÿ    @       statement executed        return nPos;    Lÿÿÿÿ   K      Lÿÿÿÿ   K                    1      1      0ÿÿÿÿ   0ÿÿÿÿ     'Là       statement executed        }    1ÿÿÿÿ   0      1ÿÿÿÿ   0                    3      3      2ÿÿÿÿ   2ÿÿÿÿ     µ˜       statement executed        return bSuccess;    3ÿÿÿÿ   2      3ÿÿÿÿ   2              	      I   	   I   
   Hÿÿÿÿ   Hÿÿÿÿ     ÷        statement executed        }    Iÿÿÿÿ   H   	   Iÿÿÿÿ   H   
           
      J      J      Iÿÿÿÿ   Iÿÿÿÿ     øà       statement executed        }    Jÿÿÿÿ   I      Jÿÿÿÿ   I           CSymbolTable::bAdd BOOL CSymbolTable::bAdd(const CString& omValue)    (      4      'ÿÿÿÿ   3ÿÿÿÿCSymbolTable::nFind int CSymbolTable::nFind(CString omValue)    8      M      7ÿÿÿÿ   LÿÿÿÿCSymbolTable::vClearArray void CSymbolTable::vClearArray()    P      S      Oÿÿÿÿ   RÿÿÿÿCSymbolTable::omGetAt const CString CSymbolTable::omGetAt(int nIndex)    V      Z      Uÿÿÿÿ   YÿÿÿÿCSymbolTable::nGetSize int CSymbolTable::nGetSize()    ]      `      \ÿÿÿÿ   _ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      SymbolTable.cpp
 * \brief     Implementation file for CSymbolTable class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CSymbolTable class
 */

/* Project includes */
#include "SymbolTable.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


BOOL CSymbolTable::bAdd(const CString& omValue)
{
    //this funtion will add a data to the array if it is not in that array.
    //If that element is already in the arry it will not add that.
    BOOL bSuccess = FALSE;

    if( CSymbolTable::nFind( omValue) == -1)
    {
        m_omData.Add(omValue);
        bSuccess = TRUE;
    }

    return bSuccess;
}


int CSymbolTable::nFind(CString omValue) const
{
    //this will find an element in the array and will retrun the position
    //of the element the the array. If it will not found in the array the
    //function will return -1.
    omValue.MakeLower();
    int nPos = -1;
    int size = m_omData.GetSize();

    for( int nIndex = 0; nIndex< size ; nIndex++)
    {
        CString omElement = m_omData.GetAt(nIndex);
        omElement.MakeLower();

        if ( omValue == omElement )
        {
            nPos = nIndex;
            nIndex = size;
        }
    }

    return nPos;
}

void CSymbolTable::vClearArray()
{
    //this will clear the contents of array.
    m_omData.RemoveAll();
}

const CString CSymbolTable::omGetAt(int nIndex)
{
    //this will return the data at a particular index in the array.
    ASSERT( nIndex < m_omData.GetSize());
    return m_omData.GetAt( nIndex);
}

int CSymbolTable::nGetSize()
{
    //this will return the size of an array.
    return m_omData.GetSize();
}




































CValueDescriptor::CValueDescriptor()
{
    m_value.dValue = 0; 
    m_acDescriptor[0] = '\0';
}

CValueDescriptor::~CValueDescriptor()
{
    
}

          /      /      .ÿÿÿÿ   .ÿÿÿÿ     ,²˜       statement executed        }    /ÿÿÿÿ   .      /ÿÿÿÿ   .                    *      *      )ÿÿÿÿ   )ÿÿÿÿ     ,°è       statement executed        }    *ÿÿÿÿ   )      *ÿÿÿÿ   )           CValueDescriptor::CValueDescriptor CValueDescriptor::CValueDescriptor()    '      *      &ÿÿÿÿ   )ÿÿÿÿCValueDescriptor::~CValueDescriptor CValueDescriptor::~CValueDescriptor()    -      /      ,ÿÿÿÿ   .ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ValueDescriptor.cpp
 * \brief     Implementation file for CValueDescriptor class
 * \authors   Amit Ranjan
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for CValueDescriptor class
 */

/* Project includes */
#include "ValueDescriptor.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CValueDescriptor::CValueDescriptor()
{
    m_value.dValue = 0; // assume double type for default constructor
    m_acDescriptor[0] = '\0';
}

CValueDescriptor::~CValueDescriptor()
{
    // nothing special to do here
}

  d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp                   (ÿ ×0šŸ0    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           (ÿ       ×0®Şë¼    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           ,      ñ ×0(å    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp           /      "º ×0Yğ{ï    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           QÇ       } ×0ŒhN    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           RD       } ×0&§    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp           RÁ       ×0°Úê    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           ZÑ       x ×0îÅ<½    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           [I       t ×0 W:¼    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp           [½      *O ×0ÕÎä    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           †      Ø ×0‡>C    d:\busmaster oss\sources\format converter\formatconverterapp\defconverterpage.cpp .\DefConverterPage.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           Œä      o ×0¢²<    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp           “S      ç +ÂÙ&¥C    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           (ÿ       +ÂÙ®Şë¼    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           ,      ñ +ÂÙ(å    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp           ™:      Ğ +ÂÙ”)á_    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           
       } +ÂÙûj–    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           ‡       } +ÂÙrÊ&    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp                 	 +ÂÙ ËÆt    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           ZÑ       x +ÂÙîÅ<½    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           [I       t +ÂÙ W:¼    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp                  Ñ +ÂÙ{×.û    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           †      Ø +ÂÙ‡>C    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterapp.cpp .\FormatConverterApp.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           Œä      o +ÂÙ¢²<    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp           ¬Ş       èSø;    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           (ÿ       è®Şë¼    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           ,      ñ è(å    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp           ¼ß      
 è6M¨˜    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           Ëé       } è	e»    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           Ìf       } è<¬    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp           Ìã      [ è_œC£    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           ZÑ       x èîÅ<½    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           [I       t è W:¼    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp           Ó>      — èÛ³«    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           †      Ø è‡>C    d:\busmaster oss\sources\format converter\formatconverterapp\formatconverterwnd.cpp .\FormatConverterWnd.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           Œä      o è¢²<    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp           äÕ       ¥ ª?¿6R&9    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           (ÿ       ª?¿®Şë¼    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           ,      ñ ª?¿(å    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp           åz       ú ª?¿"Ñ5á    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           æt       } ª?¿XµÉ    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           æñ       } ª?¿e'ù    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp           çn       ª?¿c›nı    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           ZÑ       x ª?¿îÅ<½    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           [I       t ª?¿ W:¼    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp           èz      œ ª?¿æı†	    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           †      Ø ª?¿‡>C    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.cpp .\PluginManagerBase.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           Œä      o ª?¿¢²<    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp           í      
û I;…”k    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           (ÿ       I;…®Şë¼    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           ,      ñ I;…(å    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp           ø      1 I;… UP    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h          B       } I;…ŒOd    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h          ¿       } I;…F(’    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp          <      Œ I;…LîîÙ    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           ZÑ       x I;…îÅ<½    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           [I       t I;… W:¼    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp          
È      « I;…şKr    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerbase.h d:\busmaster oss\sources\format converter\formatconverterapp\PluginManagerBase.h           †      Ø I;…‡>C    d:\busmaster oss\sources\format converter\formatconverterapp\pluginmanagerdll.cpp .\PluginManagerDLL.cpp d:\busmaster oss\sources\format converter\formatconverterapp\baseconverter.h d:\busmaster oss\sources\format converter\formatconverterapp\BaseConverter.h           Œä      o I;…¢²<    d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp          s      3e š }öšó    d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp          LØ      -× š }ÑØeÏ    d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp          z¯      	è š }‡r†J    d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\exportlogfiledlg.cpp .\ExportLogFileDlg.cpp          „—      = š }—‰ëÙ    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp          Á¨      Ó ‘ã š9~Ú    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp          Ú{      * ‘ã âkş    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp          š       ‘ã tÙDx    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcel.cpp .\LogToExcel.cpp          )      #Ğ ‘ã ãø—¦    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp          +ù      $ ‹€gBYQ    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp          4      	÷ ‹€gÃ–RV    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp          >      X ‹€g è¥    d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp d:\busmaster oss\sources\format converter\logtoexcelconverter\logtoexcelconverter.cpp .\LogToExcelConverter.cpp          El      Ù ‹€gÆÏw’    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp          VE       ”l¢—    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          a^      Œ ”lè*\    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp          dê      m ”läûò    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          mW       ‘ ”l>!y    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp          mè      ~ ”l¥ÿ    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          sf       “ ”l¨E‚    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp          sù       ”la^m    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.cpp .\AscLogConverter.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          ‹      ß ”lä•á    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp          ’ï      æ •%Ìªîª    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          a^      Œ •%è*\    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp          –Õ      ì •%¨ï    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          šÁ       ‘ •%íƒ ®    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp          ›R      . •%j‹xR    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          sf       “ •%¨E‚    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp          œ€      X •%CM¢    d:\busmaster oss\sources\format converter\asclogconverter\asclogconverterdll.cpp .\AscLogConverterDLL.cpp d:\busmaster oss\sources\format converter\asclogconverter\asclogconverter.h d:\busmaster oss\sources\format converter\asclogconverter\AscLogConverter.h          ‹      ß •%ä•á    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c          ªØ      bc .NÛ5øÿ    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c          ;      jÖ .N+m      d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c          x      ‚ .N]—M˜    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_lexer.c .\Asc_Log_Lexer.c          ~“      ¤ .Naìt¥    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c          "±      7› ñÆÀß5<    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c          ZL      >® ñÆÀz²*»    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c          ˜ú      Ã ñÆÀÈIÿî    d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c d:\busmaster oss\sources\format converter\asclogconverter\asc_log_parser.c .\Asc_Log_Parser.c          ›½      u ñÆÀƒçgË    d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp          >      ¬ }şß’f1    d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp           ê      V }şß"D*    d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp          5@      X }şß<(    d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\comment.cpp .\Comment.cpp          8˜      X }şß@öİ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp          Rğ      W vÃºˆ~Ê    d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp          ª€      |ñ vÃå?U    d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp          'q      Å vÃ¿ıÂÛ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\converter.cpp .\Converter.cpp          ,6      eõ vÃM…Em    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp          ’+      	‘ |~ ¼b°=    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp          ›¼      š |~ e¨	â    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp          ¤V       |~ nI     d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverter.cpp .\DBF2DBCConverter.cpp          ªr      ş |~ 7Ë‚    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp          ¾p      º øêWLİb    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp          Â*      í øê»Óëú    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp          Æ      . øêg¿xJ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\dbf2dbcconverterdll.cpp .\DBF2DBCConverterDLL.cpp          ÇE      § øêîNÔ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp          Ôì      	| }í—b    d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp          Şh      á }í„ãã     d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp          æI      ³ }í+ÃúŞ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\message.cpp .\Message.cpp          èü      Ì }íMŒÎ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp          úÈ      =© ğÕQ°8Z    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp          8q      Zø ğÕQM†ûR    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp          “i      ı ğÕQ]vŞå    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameter.cpp .\Parameter.cpp          ›f      U+ ğÕQ­Ib    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp          ğ‘      5 v»Z¡O    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp          Æ      ), v»ÀUÛ¢    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp          /ò      € v»ùNÍ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\parameterval.cpp .\ParameterVal.cpp          5r      %½ v»Ñ™&    d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp          [/      b uİÑÅæÍ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp          w‘      Å uİÑÊÓì    d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp          “V      æ uİÑ÷å
²    d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\signal.cpp .\Signal.cpp          –<      )" uİÑkF¦    d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp          ¿^      ” ¶%n}˜M    d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp          Çò      ³ ¶%nÁ‘Ú¨    d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp          Ë¥        ¶%n]œ}B    d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\utility.cpp .\Utility.cpp          Ï¥       ¶%näşµ~    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          ã§      	‹ ‡´ıãhO    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          í2      a ‡´ï¼ğ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          ş“       ‡´‘Ñ³    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          	 ¯      - ‡´våÙ    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp          	Ü      œ ¯Ã{˜nşß    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp          	x      Ã ¯Ã{¢¡ò    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp          	%;      R ¯Ã{XÛ“    d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbf2dbcconverter\valuetable.cpp .\ValueTable.cpp          	'      Ì ¯Ã{øÕùá    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp          	7Y      1 Øâ½z¦;    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	DŠ      p ØârÚg    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp          	Gú      ± Øâ%ÂY    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	U«       ‘ ØâoÒ!ë    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp          	V<      ~ Øâ"< –    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	[º       “ Øâ¤Ep    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp          	\M      Ñ Øâ­˜"    d:\busmaster oss\sources\format converter\logascconverter\logascconverter.cpp .\LogAscConverter.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	t      “ ØâBá}­    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp          	{±      Ÿ »Q¤Ï/×ì    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	DŠ      p »Q¤rÚg    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp          	P      ì »Q¤R8ì(    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	ƒ<       ‘ »Q¤'T!9    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp          	ƒÍ      . »Q¤eÿxF    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	[º       “ »Q¤¤Ep    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp          	„û      î »Q¤ëijÔ    d:\busmaster oss\sources\format converter\logascconverter\logascconverterdll.cpp .\LogAscConverterDLL.cpp d:\busmaster oss\sources\format converter\logascconverter\logascconverter.h d:\busmaster oss\sources\format converter\logascconverter\LogAscConverter.h          	t      “ »Q¤Bá}­    d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp          	’é      s @ş“sTôp    d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp          	›\      ` @ş“_z¤    d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp          	¨¼       ¡ @ş“pIv    d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\logascconverter\utility.cpp .\Utility.cpp          	©]      W @ş“$êe    d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c          	µ´      f *2ÕJIlò    d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c          
µ      jJ *2Õoz÷n    d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c          
…ÿ      ‚ *2ÕxXOS    d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_lexer.c .\Log_Asc_Lexer.c          
Œ      § *2ÕoŞQ    d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c          4      4Ù ,’ğ÷×
    d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c          hè      =[ ,’µ‡åç    d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c          ¦C      r ,’I-7r    d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c d:\busmaster oss\sources\format converter\logascconverter\log_asc_parser.c .\Log_Asc_Parser.c          ©µ      s ,’œ„     d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp          Â       ï ÷øø1d    d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp          ±       ú ÷ømG3/    d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp          «       ´ ÷øå¢MQ    d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\comment.cpp .\Comment.cpp          _      ì ÷øø¬–.    d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp          $K      { >q"“Ä    d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp          ³Æ      ¡| >qkÓ¾í    d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp          UB      Ã >qÊàÀK    d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\converter.cpp .\Converter.cpp          Z      §‹ >q[[‡ö    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp                	 iPÇ¹m    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          
§      ¹ iP°z(    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp          `      	 iPj•æß    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          i       ‘ iP‹y¡    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp          ú      – iP^Íô…    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h                 ” iPeçDş    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp          $      Š iPÙZ`Ä    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.cpp .\DBC2DBFConverter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          0®      t iP)cy+    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp          8"      º Ç¹W@İb    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          ;Ü      · Ç¹S7'ê    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp          ?“      í Ç¹Ïé˜    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          C€       ‘ Ç¹7Z!b    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp          D      . Ç¹g¿xJ    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          E?       ” Ç¹e‘Dü    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp          EÓ      ¨ Ç¹óO¥    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverterdll.cpp .\DBC2DBFConverterDLL.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc2dbfconverter.h d:\busmaster oss\sources\format converter\dbc2dbfconverter\DBC2DBFConverter.h          0®      t Ç¹)cy+    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c          S{      Pà Ì,âÊy    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c          ¤[      `¾ Ì,±c+    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c                  Ì,2PŒ    d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c d:\busmaster oss\sources\format converter\dbc2dbfconverter\dbc_dbf_lexer.c .\dbc_dbf_Lexer.c                ‘{ Ì,™t[    d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp          ”      à äçhäM     d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp          ©t      @ äçhÁ2}©    d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp          ¯´       äçh5«É    d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\message.cpp .\Message.cpp          ±Ò      n äçh¶m6<    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp          Æ@      -¿ ‘ÒÚnÜ    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp          óÿ      >› ‘Ò^H“Û    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp          2š      æ ‘Ò!|Â    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameter.cpp .\Parameter.cpp          5€      >½ ‘Ò5úV    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp          t=      h ­A 1    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp          ’¥      4´ ­Aá«È    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp          ÇY      æ ­A‘˜„e    d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\parameterval.cpp .\ParameterVal.cpp          Î?      0| ­A¶¦Õ+    d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp          ş»      N ÄG+g5    d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp          LÁ      wä ÄGÃ«ü    d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp          Ä¥      Ë ÄGìÖ[    d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\signal.cpp .\Signal.cpp          Èp      n@ ÄG‹˜ÿ°    d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp          6°      Œ h|NC—ñ    d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp          ?<      ³ h|óÜ¢    d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp          Bï        h|ˆ}
    d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\utility.cpp .\Utility.cpp          Fï      E h|&c²    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          Z4      
 £Ú)ÄVÕD    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          a>      3 £Ú)ÎGqÆ    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          gq      º £Ú)(C¯A    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          i+      T £Ú)­¤Ç    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp          u      – Šşr]ºúv    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp          ‚       ŠşrÑŸ˜    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp          ¡-      < Šşrã¬ÔT    d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp d:\busmaster oss\sources\format converter\dbc2dbfconverter\valuetable.cpp .\ValueTable.cpp          £i      ¬ Šşr–ö[    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp          ¸      _ .Ÿ³•Šçs    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp          ¾t       .Ÿ³,¬    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp          Æ       .Ÿ³ìÛ    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverter.cpp .\CAPL2CConverter.cpp          Ì      I .Ÿ³¢ü¡    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp          ÒK      { âk¬	"Ó    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp          ÕÆ      ì âk¬òzå@    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp          Ù²      . âk¬"—wº    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cconverterdll.cpp .\CAPL2CConverterDLL.cpp          Úà       âk¬˜p”    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp          åö      8 *x}Tt£¿    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\functions.hpp d:\busmaster oss\sources\format converter\capl2cconverter\Functions.hpp          	      Õ *x}®GRÖ    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h          ó%     ²~ *x}jr#    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp          ¥£      1ê *x}n1î    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\functions.hpp d:\busmaster oss\sources\format converter\capl2cconverter\Functions.hpp          ×      Ç *x}œõõ    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h          ¬      Ô *x}Hé½    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp          €      j *x}>¸Ø†    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\functions.hpp d:\busmaster oss\sources\format converter\capl2cconverter\Functions.hpp          )ê      
² *x}I•ŸA    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h          4œ      ~ *x}kíÿ‰    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp          =      Q¿ *x}ö+×    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\functions.hpp d:\busmaster oss\sources\format converter\capl2cconverter\Functions.hpp          Ù      ôÂ *x}Éëæª    d:\busmaster oss\sources\format converter\capl2cconverter\capl2cpropertypage.cpp .\CAPL2CPropertyPage.cpp d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h d:\busmaster oss\sources\format converter\capl2cconverter\lexer.h          ƒ›     ê” *x}É2k    d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp          n/      Ny ©–Ã -    d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp          ¼¨      @Y ©–ã­µ    d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp          ı      « ©–sF¶0    d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp d:\busmaster oss\sources\format converter\capl2cconverter\converter.cpp .\Converter.cpp          ¬      gº ©–µd‘…    d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp          if      a ³}”ªó'h    d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp          mÇ      ' ³}”èÑã    d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp          oî      — ³}” ¨—Ï    d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp d:\busmaster oss\sources\format converter\capl2cconverter\list.cpp .\List.cpp          q…      ú ³}”3fL    d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp          y      = )B1
«    d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp          €¼      ä )Bs÷Qî    d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp          †       Æ )BÓá¦y    d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp d:\busmaster oss\sources\format converter\capl2cconverter\message.cpp .\Message.cpp          ˆf      ¢ )B)©“W    d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp          —      .  şwù™¶ì    d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp          6      ©  şwÇ&è    d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp          Ÿß         şw=˜Æ¤    d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp d:\busmaster oss\sources\format converter\capl2cconverter\selectdb.cpp .\Selectdb.cpp          ¡ÿ      	¾  şwr€ùâ    d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp          «½      7Æ A®Û©Ñyè    d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp          ãƒ      k A®Û«½B    d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp          Nˆ      • A®Ûb¡ïı    d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp d:\busmaster oss\sources\format converter\capl2cconverter\signal.cpp .\Signal.cpp          Q      Ká A®Ûüÿ    d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp          œş      ü ßròL$    d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp           ú       ßr^¥ek    d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp          §      ÷ ßrÇ‡¹à    d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp d:\busmaster oss\sources\format converter\capl2cconverter\symboltable.cpp .\SymbolTable.cpp          ¨ÿ      
D ßrÔG.Z    d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          ³C       ä 5d¥[1×    d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          ´'       ú 5d¯å5€    d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          µ!       ô 5dƒÃg“    d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp d:\busmaster oss\sources\format converter\capl2cconverter\valuedescriptor.cpp .\ValueDescriptor.cpp          ¶      Ü 5dÑ–ÛH      ü31
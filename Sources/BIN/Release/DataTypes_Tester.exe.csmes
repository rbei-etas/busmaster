
























const int SIZE_CHAR = sizeof(char);















tagFilterName::tagFilterName()
{
    m_acFilterName[LENGTH_FILTERNAME - 1] = L'\0';
    vClear();
}













void tagFilterName::vClear(void)
{
    _tcsset(m_acFilterName, L'\0');
    m_bFilterType = 0;
}













tagFilterName& tagFilterName::operator=(const tagFilterName& RefObj)
{
    strcpy(m_acFilterName, RefObj.m_acFilterName);
    m_bFilterType = RefObj.m_bFilterType;

    return *this;
}

















BYTE* tagFilterName::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    {memcpy(pbTStream, m_acFilterName, LENGTH_FILTERNAME * SIZE_CHAR); pbTStream += LENGTH_FILTERNAME * SIZE_CHAR;};
    {memcpy(pbTStream, &m_bFilterType, sizeof(m_bFilterType)); pbTStream += sizeof(m_bFilterType);};

    return pbTStream;
}

















BYTE* tagFilterName::pbSetConfigData(BYTE* pbTarget)
{
    BYTE* pbTStream = pbTarget;

    {memcpy(m_acFilterName, pbTStream, LENGTH_FILTERNAME * SIZE_CHAR); pbTStream += LENGTH_FILTERNAME * SIZE_CHAR;};
    {memcpy(&m_bFilterType, pbTStream, sizeof(m_bFilterType)); pbTStream += sizeof(m_bFilterType);};

    return pbTStream;
}

















tagSFILTER::tagSFILTER()
{
    vClear();
}













void tagSFILTER::vClear(void)
{
    m_ucFilterType  = 0;
    m_dwMsgIDFrom   = 0;
    m_dwMsgIDTo     = 0;
    m_eDrctn        = DIR_ALL;
}













tagSFILTER& tagSFILTER::operator=(const tagSFILTER& RefObj)
{
    m_ucFilterType  = RefObj.m_ucFilterType;
    m_dwMsgIDFrom   = RefObj.m_dwMsgIDFrom; 
    m_dwMsgIDTo     = RefObj.m_dwMsgIDTo;
    m_eDrctn        = RefObj.m_eDrctn;

    return *this;
}













UINT tagSFILTER::unGetSize(void) const
{
    return (sizeof(m_ucFilterType) + sizeof(m_dwMsgIDFrom) + 
            sizeof(m_dwMsgIDTo) + sizeof(m_eDrctn));
}

















BYTE* tagSFILTER::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    {memcpy(pbTStream, &m_ucFilterType, sizeof(m_ucFilterType)); pbTStream += sizeof(m_ucFilterType);};
    {memcpy(pbTStream, &m_dwMsgIDFrom, sizeof(m_dwMsgIDFrom)); pbTStream += sizeof(m_dwMsgIDFrom);};
    {memcpy(pbTStream, &m_dwMsgIDTo, sizeof(m_dwMsgIDTo)); pbTStream += sizeof(m_dwMsgIDTo);};
    {memcpy(pbTStream, &m_eDrctn, sizeof(m_eDrctn)); pbTStream += sizeof(m_eDrctn);};

    return pbTStream;
}

















BYTE* tagSFILTER::pbSetConfigData(BYTE* pbTarget)
{
    vClear();

    BYTE* pbTStream = pbTarget;

    {memcpy(&m_ucFilterType, pbTStream, sizeof(m_ucFilterType)); pbTStream += sizeof(m_ucFilterType);};
    {memcpy(&m_dwMsgIDFrom, pbTStream, sizeof(m_dwMsgIDFrom)); pbTStream += sizeof(m_dwMsgIDFrom);};
    {memcpy(&m_dwMsgIDTo, pbTStream, sizeof(m_dwMsgIDTo)); pbTStream += sizeof(m_dwMsgIDTo);};
    {memcpy(&m_eDrctn, pbTStream, sizeof(m_eDrctn)); pbTStream += sizeof(m_eDrctn);};

    return pbTStream;
}

















SFILTER_CAN::SFILTER_CAN()
{
    vClear();
}













SFILTER_CAN::~SFILTER_CAN()
{
    vClear();
}













SFILTER_CAN& SFILTER_CAN::operator=(const SFILTER_CAN& RefObj)
{
    this->SFILTER::operator = (RefObj);

    m_byMsgType = RefObj.m_byMsgType;
    m_byIDType  = RefObj.m_byIDType;
    m_eChannel = RefObj.m_eChannel;

    return *this;
}













void SFILTER_CAN::vClear(void)
{
    m_byIDType = TYPE_ID_CAN_NONE;
    m_byMsgType = TYPE_MSG_CAN_NONE;
    m_eChannel = CAN_CHANNEL_ALL;
    this->SFILTER::vClear();
}














BOOL SFILTER_CAN::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = 0;

    SFRAMEINFO_BASIC_CAN& sCurrFrame = *((SFRAMEINFO_BASIC_CAN *) psCurrFrame);

    
    if (m_ucFilterType == 0)
    {
        
        if (m_dwMsgIDFrom == sCurrFrame.m_dwFrameID)
        {
            
            if ( (CAN_CHANNEL_ALL == m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
                
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
                    
                    if ((TYPE_ID_CAN_ALL == m_byIDType) ||
                        (m_byIDType == sCurrFrame.m_byIDType))
                    {
                        
                        if ((TYPE_MSG_CAN_ALL == m_byMsgType) ||
                            (m_byMsgType == sCurrFrame.m_byMsgType))
                        {
					        bResult = 1;
                        }
                    }
				}
			}
        }
    }
    
    else if (m_ucFilterType == 1)
    {
        
        if ( (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo) )
        {
            
            if ( (CAN_CHANNEL_ALL == m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
               
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
					
                    if ((TYPE_ID_CAN_ALL == m_byIDType) ||
                        (m_byIDType == sCurrFrame.m_byIDType))
                    {
                        
                        if ((TYPE_MSG_CAN_ALL == m_byMsgType) ||
                            (m_byMsgType == sCurrFrame.m_byMsgType))
                        {
					        bResult = 1;
                        }
                    }
				}
            }
		}
    }
    else
    {
        ((void)0);
    }

    return bResult;
}













UINT SFILTER_CAN::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    Result += sizeof(m_byIDType);
    Result += sizeof(m_byMsgType);
    Result += sizeof(m_eChannel);

    return Result;
}

















BYTE* SFILTER_CAN::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    {memcpy(pbTStream, &m_byIDType, sizeof(m_byIDType)); pbTStream += sizeof(m_byIDType);};
    {memcpy(pbTStream, &m_byMsgType, sizeof(m_byMsgType)); pbTStream += sizeof(m_byMsgType);};
    {memcpy(pbTStream, &m_eChannel, sizeof(m_eChannel)); pbTStream += sizeof(m_eChannel);};

    return pbTStream;
}

















BYTE* SFILTER_CAN::pbSetConfigData(BYTE* pbTarget)
{
    vClear();

    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    {memcpy(&m_byIDType, pbTStream, sizeof(m_byIDType)); pbTStream += sizeof(m_byIDType);};
    {memcpy(&m_byMsgType, pbTStream, sizeof(m_byMsgType)); pbTStream += sizeof(m_byMsgType);};
    {memcpy(&m_eChannel, pbTStream, sizeof(m_eChannel)); pbTStream += sizeof(m_eChannel);};

    return pbTStream;
}

















SFILTER_FLEXRAY::SFILTER_FLEXRAY()
{
    vClear();
}













SFILTER_FLEXRAY::~SFILTER_FLEXRAY()
{
    vClear();
}













SFILTER_FLEXRAY& SFILTER_FLEXRAY::operator=(const SFILTER_FLEXRAY& RefObj)
{
    this->SFILTER::operator = (RefObj);

    m_eChannel = RefObj.m_eChannel;

    return *this;
}













void SFILTER_FLEXRAY::vClear(void)
{
    m_eChannel = FLEXRAY_CHANNEL_AB;
    this->SFILTER::vClear();
}














BOOL SFILTER_FLEXRAY::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = 0;

    SFRAMEINFO_BASIC_FLEXRAY& sCurrFrame = *((SFRAMEINFO_BASIC_FLEXRAY *) psCurrFrame);
    
    if (m_ucFilterType == 0)
    {
        
        if (m_dwMsgIDFrom == sCurrFrame.m_dwFrameID)
        {
            
            if ( (FLEXRAY_CHANNEL_AB == m_eChannel) ||
                 (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
                
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
					bResult = 1;
				}
			}
        }
    }
    
    else if (m_ucFilterType == 1)
    {
        
        if ( (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo) )
        {
            
            if ( (FLEXRAY_CHANNEL_AB == m_eChannel) ||
                 (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
               
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
					bResult = 1;
				}
            }
		}
    }
    else
    {
        ((void)0);
    }

    return bResult;
}













UINT SFILTER_FLEXRAY::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    Result += sizeof(m_eChannel);

    return Result;
}

















BYTE* SFILTER_FLEXRAY::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    {memcpy(pbTStream, &m_eChannel, sizeof(m_eChannel)); pbTStream += sizeof(m_eChannel);};

    return pbTStream;
}

















BYTE* SFILTER_FLEXRAY::pbSetConfigData(BYTE* pbTarget)
{
    vClear();

    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    {memcpy(&m_eChannel, pbTStream, sizeof(m_eChannel)); pbTStream += sizeof(m_eChannel);};

    return pbTStream;
}


















SFILTER_MCNET::SFILTER_MCNET()
{
    vClear();
}













SFILTER_MCNET::~SFILTER_MCNET()
{
    vClear();
}













SFILTER_MCNET& SFILTER_MCNET::operator=(const SFILTER_MCNET& RefObj)
{
    this->SFILTER::operator = (RefObj);
    return *this;
}













void SFILTER_MCNET::vClear(void)
{
    this->SFILTER::vClear();
}














BOOL SFILTER_MCNET::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = 0;

    SFRAMEINFO_BASIC_MCNET& sCurrFrame = *((SFRAMEINFO_BASIC_MCNET *) psCurrFrame);
    
    if (m_ucFilterType == 0)
    {
        
        if (m_dwMsgIDFrom == sCurrFrame.m_dwFrameID)
        {
            bResult = 1;
        }
    }
    
    else if (m_ucFilterType == 1)
    {
        
        if ( (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo) )
        {
            bResult = 1;
		}
    }
    else
    {
        ((void)0);
    }

    return bResult;
}













UINT SFILTER_MCNET::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    return Result;
}

















BYTE* SFILTER_MCNET::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    return pbTStream;
}

















BYTE* SFILTER_MCNET::pbSetConfigData(BYTE* pbTarget)
{
    vClear();
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    return pbTStream;
}

















SFILTER_J1939::SFILTER_J1939()
{
    vClear();
}













SFILTER_J1939::~SFILTER_J1939()
{
    vClear();
}













SFILTER_J1939& SFILTER_J1939::operator=(const SFILTER_J1939& RefObj)
{
    this->SFILTER::operator = (RefObj);
    return *this;
}













void SFILTER_J1939::vClear(void)
{
    this->SFILTER::vClear();
}














BOOL SFILTER_J1939::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = 0;

    SFRAMEINFO_BASIC_J1939& sCurrFrame = *((SFRAMEINFO_BASIC_J1939 *) psCurrFrame);
    
    if (m_ucFilterType == 0)
    {
        
        if (m_dwMsgIDFrom == sCurrFrame.m_dwPGN)
        {
            bResult = 1;
        }
    }
    
    else if (m_ucFilterType == 1)
    {
        
        if ( (sCurrFrame.m_dwPGN >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwPGN <= m_dwMsgIDTo) )
        {
            bResult = 1;
		}
    }
    else
    {
        ((void)0);
    }

    return bResult;
}













UINT SFILTER_J1939::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    return Result;
}

















BYTE* SFILTER_J1939::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    return pbTStream;
}

















BYTE* SFILTER_J1939::pbSetConfigData(BYTE* pbTarget)
{
    vClear();
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    return pbTStream;
}















tagFilterSet::tagFilterSet()
{
    m_sFilterName.vClear();
    m_bEnabled = 1;
    m_eCurrBus = BUS_INVALID;
    m_ushFilters = 0;
    m_psFilterInfo = 0;
}













tagFilterSet::~tagFilterSet()
{
    vClear();
}











void tagFilterSet::vClear(void)
{
    m_sFilterName.vClear();
    m_ushFilters = 0;
    if (0 != m_psFilterInfo)
    {
        switch (m_eCurrBus)
        {
            case CAN:
            {
                PSFILTER_CAN psFilterCAN 
                                   = static_cast<PSFILTER_CAN>(m_psFilterInfo);
                delete[] psFilterCAN;
            }
            break;
            case FLEXRAY:
            {
                PSFILTER_FLEXRAY psFilterFlex 
                               = static_cast<PSFILTER_FLEXRAY>(m_psFilterInfo);
                delete[] psFilterFlex;
            }
            break;
            case MCNET:
            {
                PSFILTER_MCNET psFilterMCNet 
                                   = static_cast<PSFILTER_MCNET>(m_psFilterInfo);
                delete[] psFilterMCNet;
            }
            break;
            case J1939:
            {
                PSFILTER_J1939 psFilterJ1939 
                                   = static_cast<PSFILTER_J1939>(m_psFilterInfo);
                delete[] psFilterJ1939;
            }
            break;
            default: ((void)0);
        }
        m_psFilterInfo = 0;
    }
    m_eCurrBus = BUS_INVALID;
}











bool tagFilterSet::bClone(const tagFilterSet& RefObj)
{
    vClear(); 

    bool bResult = false;

    m_sFilterName = RefObj.m_sFilterName;
    m_bEnabled = RefObj.m_bEnabled;
    m_eCurrBus = RefObj.m_eCurrBus;
    m_ushFilters = RefObj.m_ushFilters;

    if (m_ushFilters > 0)
    {
        switch (m_eCurrBus)
        {
            case CAN:
            {
                m_psFilterInfo = new SFILTER_CAN[m_ushFilters];
                if (0 != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_CAN* pDestObj = ((SFILTER_CAN *)m_psFilterInfo) + i;
                        SFILTER_CAN* pSrcObj = ((SFILTER_CAN *)RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            case FLEXRAY:
            {
                m_psFilterInfo = new SFILTER_FLEXRAY[m_ushFilters];
                if (0 != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_FLEXRAY* pDestObj = ((SFILTER_FLEXRAY *) m_psFilterInfo) + i;
                        SFILTER_FLEXRAY* pSrcObj = ((SFILTER_FLEXRAY *) RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            case MCNET:
            {
                m_psFilterInfo = new SFILTER_MCNET[m_ushFilters];
                if (0 != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_MCNET* pDestObj = ((SFILTER_MCNET *)m_psFilterInfo) + i;
                        SFILTER_MCNET* pSrcObj = ((SFILTER_MCNET *)RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            case J1939:
            {
                m_psFilterInfo = new SFILTER_J1939[m_ushFilters];
                if (0 != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_J1939* pDestObj = ((SFILTER_J1939 *)m_psFilterInfo) + i;
                        SFILTER_J1939* pSrcObj = ((SFILTER_J1939 *)RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            default: ((void)0);
        }
    }
    else
    {
        m_psFilterInfo = 0;
        bResult = true;
    }

    return bResult;
}











UINT tagFilterSet::unGetSize(void) const
{
    UINT Result = sizeof(m_sFilterName) + sizeof(m_bEnabled) + 
                  sizeof(m_eCurrBus) + sizeof(m_ushFilters);

    switch (m_eCurrBus)
    {
        case CAN:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_CAN*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        case FLEXRAY:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_FLEXRAY*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        case MCNET:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_MCNET*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        case J1939:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_J1939*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        default:
        {
            ((void)0);            
        }
        break;
    }

    return Result;
}















BYTE* tagFilterSet::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    pbTStream = m_sFilterName.pbGetConfigData(pbTStream);
    {memcpy(pbTStream, &m_bEnabled, sizeof(m_bEnabled)); pbTStream += sizeof(m_bEnabled);};
    {memcpy(pbTStream, &m_eCurrBus, sizeof(m_eCurrBus)); pbTStream += sizeof(m_eCurrBus);};
    {memcpy(pbTStream, &m_ushFilters, sizeof(m_ushFilters)); pbTStream += sizeof(m_ushFilters);};

    for (USHORT i = 0; i < m_ushFilters; i++)
    {
        switch (m_eCurrBus)
        {
            case CAN:
            {
                pbTStream = (((SFILTER_CAN*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            case FLEXRAY:
            {
                pbTStream = (((SFILTER_FLEXRAY*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            case MCNET:
            {
                pbTStream = (((SFILTER_MCNET*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            case J1939:
            {
                pbTStream = (((SFILTER_J1939*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            default:
            {
                ((void)0);
            }
            break;
        }
    }

    return pbTStream;
}















BYTE* tagFilterSet::pbSetConfigData(BYTE* pbTarget, bool& Result)
{
    vClear(); 

    BYTE* pbTStream = pbTarget;
    Result = true;

    pbTStream = m_sFilterName.pbSetConfigData(pbTStream);
    {memcpy(&m_bEnabled, pbTStream, sizeof(m_bEnabled)); pbTStream += sizeof(m_bEnabled);};
    {memcpy(&m_eCurrBus, pbTStream, sizeof(m_eCurrBus)); pbTStream += sizeof(m_eCurrBus);};
    {memcpy(&m_ushFilters, pbTStream, sizeof(m_ushFilters)); pbTStream += sizeof(m_ushFilters);};

    if (m_ushFilters > 0)
    {
        switch (m_eCurrBus)
        {
            case CAN: m_psFilterInfo = new SFILTER_CAN[m_ushFilters]; break;
            case FLEXRAY: m_psFilterInfo = new SFILTER_FLEXRAY[m_ushFilters]; break;
            case MCNET: m_psFilterInfo = new SFILTER_MCNET[m_ushFilters]; break;
            case J1939: m_psFilterInfo = new SFILTER_J1939[m_ushFilters]; break;
            default: ((void)0);
        }

        if (0 != m_psFilterInfo)
        {
            switch (m_eCurrBus)
            {
                case CAN:
                {

                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_CAN*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                case FLEXRAY:
                {

                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_FLEXRAY*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                case MCNET:
                {
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_MCNET*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                case J1939:
                {
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_J1939*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                default:
                {
                    ((void)0);
                }
                break;
            }
        }
        else
        {
            UINT unFilterSize = 0;
            switch (m_eCurrBus)
            {
                case CAN: unFilterSize = sizeof(SFILTER_CAN); break;
                case FLEXRAY: unFilterSize = sizeof(SFILTER_FLEXRAY); break;
                case MCNET: unFilterSize = sizeof(SFILTER_MCNET); break;
                case J1939: unFilterSize = sizeof(SFILTER_J1939); break;
                default: ((void)0);
            }
            pbTStream += m_ushFilters * unFilterSize;
            m_ushFilters = 0;
            Result = false;
        }
    }

    return pbTStream;
}

tagFilterSet* tagFilterSet::psGetFilterSetPointer(tagFilterSet* psSet, UINT Count, char* acFilterName)
{    
    for (UINT i = 0; i < Count; i++)
    {
        tagFilterSet* psTemp = psSet + i;
        if ((psTemp != 0) &&(_tcscmp(psTemp->m_sFilterName.m_acFilterName, acFilterName) == 0))
        {
            return psTemp;
        }
    }
    return 0;
}



         v     v   4  tÿÿÿÿ  tÿÿÿÿ    VÃğ      expression was true       (FLEXRAY_CHANNEL_AB == m_eChannel)   vÿÿÿÿ  t     vÿÿÿÿ  t   4   expression was false       (FLEXRAY_CHANNEL_AB == m_eChannel)   vÿÿÿÿ  t     vÿÿÿÿ  t   4               d-        ¯     ¯   D  ­ÿÿÿÿ  ­ÿÿÿÿ    Eˆ      expression was true       (m_byMsgType == sCurrFrame.m_byMsgType)   ¯ÿÿÿÿ  ­     ¯ÿÿÿÿ  ­   D   expression was false       (m_byMsgType == sCurrFrame.m_byMsgType)   ¯ÿÿÿÿ  ­     ¯ÿÿÿÿ  ­   D               C¸        ®     ®   >  ¬ÿÿÿÿ  ¬ÿÿÿÿ    D       expression was true       (TYPE_MSG_CAN_ALL == m_byMsgType)   ®ÿÿÿÿ  ¬     ®ÿÿÿÿ  ¬   >   expression was false       (TYPE_MSG_CAN_ALL == m_byMsgType)   ®ÿÿÿÿ  ¬     ®ÿÿÿÿ  ¬   >               B        «     «   >  ©ÿÿÿÿ  ©ÿÿÿÿ    /!H      expression was true       (m_byIDType == sCurrFrame.m_byIDType)   «ÿÿÿÿ  ©     «ÿÿÿÿ  ©   >   expression was false       (m_byIDType == sCurrFrame.m_byIDType)   «ÿÿÿÿ  ©     «ÿÿÿÿ  ©   >               >È        ª     ª   8  ¨ÿÿÿÿ  ¨ÿÿÿÿ     6Eø      expression was true       (TYPE_ID_CAN_ALL == m_byIDType)   ªÿÿÿÿ  ¨     ªÿÿÿÿ  ¨   8   expression was false       (TYPE_ID_CAN_ALL == m_byIDType)   ªÿÿÿÿ  ¨     ªÿÿÿÿ  ¨   8               h¦À   
     §     §   7  ¥ÿÿÿÿ  ¥ÿÿÿÿ    '
ˆ      expression was true       (m_eDrctn == sCurrFrame.m_eDrctn)   §ÿÿÿÿ  ¥     §ÿÿÿÿ  ¥   7   expression was false       (m_eDrctn == sCurrFrame.m_eDrctn)   §ÿÿÿÿ  ¥     §ÿÿÿÿ  ¥   7                .Ø        ¦     ¦   6  ¤ÿÿÿÿ  ¤ÿÿÿÿ    ­ÃØ      expression was true       (DIR_ALL == sCurrFrame.m_eDrctn)   ¦ÿÿÿÿ  ¤     ¦ÿÿÿÿ  ¤   6   expression was false       (DIR_ALL == sCurrFrame.m_eDrctn)   ¦ÿÿÿÿ  ¤     ¦ÿÿÿÿ  ¤   6               f Ø        ¥     ¥   +  £ÿÿÿÿ  £ÿÿÿÿ    5Y(      expression was true       (DIR_ALL == m_eDrctn)   ¥ÿÿÿÿ  £     ¥ÿÿÿÿ  £   +   expression was false       (DIR_ALL == m_eDrctn)   ¥ÿÿÿÿ  £     ¥ÿÿÿÿ  £   +                .¸        w     w   ?  uÿÿÿÿ  uÿÿÿÿ    VÄÈ      expression was true       (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel)   wÿÿÿÿ  u     wÿÿÿÿ  u   ?   expression was false       (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel)   wÿÿÿÿ  u     wÿÿÿÿ  u   ?               d/X        ¢     ¢   7   ÿÿÿÿ   ÿÿÿÿ    2=¸      expression was true       (m_eChannel == sCurrFrame.m_eChannel)   ¢ÿÿÿÿ        ¢ÿÿÿÿ      7   expression was false       (m_eChannel == sCurrFrame.m_eChannel)   ¢ÿÿÿÿ        ¢ÿÿÿÿ      7               /"È        ¡     ¡   1  Ÿÿÿÿÿ  Ÿÿÿÿÿ     ıMp      expression was true       (CAN_CHANNEL_ALL == m_eChannel)   ¡ÿÿÿÿ  Ÿ     ¡ÿÿÿÿ  Ÿ   1   expression was false       (CAN_CHANNEL_ALL == m_eChannel)   ¡ÿÿÿÿ  Ÿ     ¡ÿÿÿÿ  Ÿ   1               ¶ˆ                5  œÿÿÿÿ  œÿÿÿÿ    &¨      expression was true       (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo)   ÿÿÿÿ  œ     ÿÿÿÿ  œ   5   expression was false       (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo)   ÿÿÿÿ  œ     ÿÿÿÿ  œ   5               h                 7  ›ÿÿÿÿ  ›ÿÿÿÿ    €      expression was true       (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom)   ÿÿÿÿ  ›     ÿÿÿÿ  ›   7   expression was false       (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom)   ÿÿÿÿ  ›     ÿÿÿÿ  ›   7               ”|x                D  ÿÿÿÿ  ÿÿÿÿ    H˜ğ      expression was true       (m_byMsgType == sCurrFrame.m_byMsgType)   ÿÿÿÿ       ÿÿÿÿ     D   expression was false       (m_byMsgType == sCurrFrame.m_byMsgType)   ÿÿÿÿ       ÿÿÿÿ     D               ;±x                >  ÿÿÿÿ  ÿÿÿÿ    ;µx      expression was true       (TYPE_MSG_CAN_ALL == m_byMsgType)   ÿÿÿÿ       ÿÿÿÿ     >   expression was false       (TYPE_MSG_CAN_ALL == m_byMsgType)   ÿÿÿÿ       ÿÿÿÿ     >               ˆî8        Œ     Œ   >  Šÿÿÿÿ  Šÿÿÿÿ     6A       expression was true       (m_byIDType == sCurrFrame.m_byIDType)   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š   >   expression was false       (m_byIDType == sCurrFrame.m_byIDType)   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š   >               =ğ         ‹     ‹   8  ‰ÿÿÿÿ  ‰ÿÿÿÿ    ‰÷0      expression was true       (TYPE_ID_CAN_ALL == m_byIDType)   ‹ÿÿÿÿ  ‰     ‹ÿÿÿÿ  ‰   8   expression was false       (TYPE_ID_CAN_ALL == m_byIDType)   ‹ÿÿÿÿ  ‰     ‹ÿÿÿÿ  ‰   8               VMH   "     ˆ     ˆ   7  †ÿÿÿÿ  †ÿÿÿÿ     ó±è      expression was true       (m_eDrctn == sCurrFrame.m_eDrctn)   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †   7   expression was false       (m_eDrctn == sCurrFrame.m_eDrctn)   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †   7               ˜h   $     ‡     ‡   6  …ÿÿÿÿ  …ÿÿÿÿ    p      expression was true       (DIR_ALL == sCurrFrame.m_eDrctn)   ‡ÿÿÿÿ  …     ‡ÿÿÿÿ  …   6   expression was false       (DIR_ALL == sCurrFrame.m_eDrctn)   ‡ÿÿÿÿ  …     ‡ÿÿÿÿ  …   6               f    &     †     †   +  „ÿÿÿÿ  „ÿÿÿÿ           expression was true       (DIR_ALL == m_eDrctn)   †ÿÿÿÿ  „     †ÿÿÿÿ  „   +   expression was false       (DIR_ALL == m_eDrctn)   †ÿÿÿÿ  „     †ÿÿÿÿ  „   +               Eöp   (     x     x   7  vÿÿÿÿ  vÿÿÿÿ    VÉ       expression was true       (m_eChannel == sCurrFrame.m_eChannel)   xÿÿÿÿ  v     xÿÿÿÿ  v   7   expression was false       (m_eChannel == sCurrFrame.m_eChannel)   xÿÿÿÿ  v     xÿÿÿÿ  v   7               VÇĞ   *     ƒ     ƒ   7  ÿÿÿÿ  ÿÿÿÿ    c      expression was true       (m_eChannel == sCurrFrame.m_eChannel)   ƒÿÿÿÿ       ƒÿÿÿÿ     7   expression was false       (m_eChannel == sCurrFrame.m_eChannel)   ƒÿÿÿÿ       ƒÿÿÿÿ     7               fà   ,     ‚     ‚   1  €ÿÿÿÿ  €ÿÿÿÿ    fp      expression was true       (CAN_CHANNEL_ALL == m_eChannel)   ‚ÿÿÿÿ  €     ‚ÿÿÿÿ  €   1   expression was false       (CAN_CHANNEL_ALL == m_eChannel)   ‚ÿÿÿÿ  €     ‚ÿÿÿÿ  €   1               OşX   .     
     
     ÿÿÿÿ  ÿÿÿÿ    …ç       expression was false       i < Count   
ÿÿÿÿ       
ÿÿÿÿ                /     ç   (  ç   8  åÿÿÿÿ  åÿÿÿÿ    v³Ø      expression was false       i < m_ushFilters   çÿÿÿÿ  å   (  çÿÿÿÿ  å   8           0     ß   (  ß   8  İÿÿÿÿ  İÿÿÿÿ    fz       expression was false       i < m_ushFilters   ßÿÿÿÿ  İ   (  ßÿÿÿÿ  İ   8           1     ×   (  ×   8  Õÿÿÿÿ  Õÿÿÿÿ    fr      expression was false       i < m_ushFilters   ×ÿÿÿÿ  Õ   (  ×ÿÿÿÿ  Õ   8           2     Î   (  Î   8  Ìÿÿÿÿ  Ìÿÿÿÿ    ¹¸      expression was false       i < m_ushFilters   Îÿÿÿÿ  Ì   (  Îÿÿÿÿ  Ì   8           3             (  }ÿÿÿÿ  }ÿÿÿÿ     îIˆ      expression was false       i < m_ushFilters   ÿÿÿÿ  }     ÿÿÿÿ  }   (           4     W     W   .  Uÿÿÿÿ  Uÿÿÿÿ    Ì      expression was false       i < m_ushFilters   Wÿÿÿÿ  U     Wÿÿÿÿ  U   .           5     N     N   .  Lÿÿÿÿ  Lÿÿÿÿ    ogĞ      expression was false       i < m_ushFilters   Nÿÿÿÿ  L     Nÿÿÿÿ  L   .           6     E     E   .  Cÿÿÿÿ  Cÿÿÿÿ    ˜®ˆ      expression was false       i < m_ushFilters   Eÿÿÿÿ  C     Eÿÿÿÿ  C   .           7     <     <   .  :ÿÿÿÿ  :ÿÿÿÿ    ˜¦€      expression was false       i < m_ushFilters   <ÿÿÿÿ  :     <ÿÿÿÿ  :   .           8        (     8  ÿÿÿÿ  ÿÿÿÿ    wê(      expression was false       i < m_ushFilters   ÿÿÿÿ     (  ÿÿÿÿ     8           9     ı   (  ı   8  ûÿÿÿÿ  ûÿÿÿÿ    ¬3Ğ      expression was false       i < m_ushFilters   ıÿÿÿÿ  û   (  ıÿÿÿÿ  û   8           :     ê   (  ê   8  èÿÿÿÿ  èÿÿÿÿ     kÈ      expression was false       i < m_ushFilters   êÿÿÿÿ  è   (  êÿÿÿÿ  è   8           ;     ×   (  ×   8  Õÿÿÿÿ  Õÿÿÿÿ    .ÅH      expression was false       i < m_ushFilters   ×ÿÿÿÿ  Õ   (  ×ÿÿÿÿ  Õ   8           <     {     {   +  yÿÿÿÿ  yÿÿÿÿ     ú0      expression was true       (DIR_ALL == m_eDrctn)   {ÿÿÿÿ  y     {ÿÿÿÿ  y   +   expression was false       (DIR_ALL == m_eDrctn)   {ÿÿÿÿ  y     {ÿÿÿÿ  y   +               VÌ¸   >     ¼   	  ¼     ºÿÿÿÿ  ºÿÿÿÿ    ñGˆ      expression was false       m_ushFilters > 0   ¼ÿÿÿÿ  º   	  ¼ÿÿÿÿ  º              ?     ‘   	  ‘     ÿÿÿÿ  ÿÿÿÿ    U…ˆ      expression was false       0 != m_psFilterInfo   ‘ÿÿÿÿ     	  ‘ÿÿÿÿ                    O%ğ   @     |     |   6  zÿÿÿÿ  zÿÿÿÿ     ú0à      expression was true       (DIR_ALL == sCurrFrame.m_eDrctn)   |ÿÿÿÿ  z     |ÿÿÿÿ  z   6   expression was false       (DIR_ALL == sCurrFrame.m_eDrctn)   |ÿÿÿÿ  z     |ÿÿÿÿ  z   6               VÎè   B             0  ÿÿÿÿ  ÿÿÿÿ    +°˜      expression was false       m_dwMsgIDFrom == sCurrFrame.m_dwPGN   ÿÿÿÿ       ÿÿÿÿ     0               ê›x   C     }     }   7  {ÿÿÿÿ  {ÿÿÿÿ     ú5¨      expression was true       (m_eDrctn == sCurrFrame.m_eDrctn)   }ÿÿÿÿ  {     }ÿÿÿÿ  {   7   expression was false       (m_eDrctn == sCurrFrame.m_eDrctn)   }ÿÿÿÿ  {     }ÿÿÿÿ  {   7                ú3Ø   E     L     L   4  Jÿÿÿÿ  Jÿÿÿÿ    ¾3      expression was false       m_dwMsgIDFrom == sCurrFrame.m_dwFrameID   Lÿÿÿÿ  J     Lÿÿÿÿ  J   4               ¾08   F     ˆ     ˆ   7  †ÿÿÿÿ  †ÿÿÿÿ    Äw€      expression was true       (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom)   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †   7   expression was false       (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom)   ˆÿÿÿÿ  †     ˆÿÿÿÿ  †   7               Ätx   H     ‰     ‰   5  ‡ÿÿÿÿ  ‡ÿÿÿÿ    Äxh      expression was true       (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo)   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡   5   expression was false       (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo)   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡   5               Äv˜   J     Œ     Œ   4  Šÿÿÿÿ  Šÿÿÿÿ    “áØ      expression was true       (FLEXRAY_CHANNEL_AB == m_eChannel)   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š   4   expression was false       (FLEXRAY_CHANNEL_AB == m_eChannel)   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š   4               Ä{   L             ?  ‹ÿÿÿÿ  ‹ÿÿÿÿ    “âÀ      expression was true       (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel)   ÿÿÿÿ  ‹     ÿÿÿÿ  ‹   ?   expression was false       (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel)   ÿÿÿÿ  ‹     ÿÿÿÿ  ‹   ?               “àğ   N             7  Œÿÿÿÿ  Œÿÿÿÿ    “ç˜      expression was true       (m_eChannel == sCurrFrame.m_eChannel)   ÿÿÿÿ  Œ     ÿÿÿÿ  Œ   7   expression was false       (m_eChannel == sCurrFrame.m_eChannel)   ÿÿÿÿ  Œ     ÿÿÿÿ  Œ   7               “åÈ   P     s     s   4  qÿÿÿÿ  qÿÿÿÿ    Äp˜      expression was false       m_dwMsgIDFrom == sCurrFrame.m_dwFrameID   sÿÿÿÿ  q     sÿÿÿÿ  q   4               d*è   Q     ‘     ‘   +  ÿÿÿÿ  ÿÿÿÿ    sÓh      expression was true       (DIR_ALL == m_eDrctn)   ‘ÿÿÿÿ       ‘ÿÿÿÿ     +   expression was false       (DIR_ALL == m_eDrctn)   ‘ÿÿÿÿ       ‘ÿÿÿÿ     +               “ê°   S     ’     ’   6  ÿÿÿÿ  ÿÿÿÿ    sÔP      expression was true       (DIR_ALL == sCurrFrame.m_eDrctn)   ’ÿÿÿÿ       ’ÿÿÿÿ     6   expression was false       (DIR_ALL == sCurrFrame.m_eDrctn)   ’ÿÿÿÿ       ’ÿÿÿÿ     6               sÒÈ   U     “     “   7  ‘ÿÿÿÿ  ‘ÿÿÿÿ    sÙ(      expression was true       (m_eDrctn == sCurrFrame.m_eDrctn)   “ÿÿÿÿ  ‘     “ÿÿÿÿ  ‘   7   expression was false       (m_eDrctn == sCurrFrame.m_eDrctn)   “ÿÿÿÿ  ‘     “ÿÿÿÿ  ‘   7               s×X   W     U     U   7  Sÿÿÿÿ  Sÿÿÿÿ    ¾:€      expression was true       (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom)   Uÿÿÿÿ  S     Uÿÿÿÿ  S   7   expression was false       (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom)   Uÿÿÿÿ  S     Uÿÿÿÿ  S   7               ¾7H   Y     V     V   5  Tÿÿÿÿ  Tÿÿÿÿ    ¾;h      expression was true       (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo)   Vÿÿÿÿ  T     Vÿÿÿÿ  T   5   expression was false       (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo)   Vÿÿÿÿ  T     Vÿÿÿÿ  T   5               ¾9˜   [             3  
ÿÿÿÿ  
ÿÿÿÿ    +·ğ      expression was true       (sCurrFrame.m_dwPGN >= m_dwMsgIDFrom)   ÿÿÿÿ  
     ÿÿÿÿ  
   3   expression was false       (sCurrFrame.m_dwPGN >= m_dwMsgIDFrom)   ÿÿÿÿ  
     ÿÿÿÿ  
   3               +´¸   ]             1  ÿÿÿÿ  ÿÿÿÿ    +¸Ø      expression was true       (sCurrFrame.m_dwPGN <= m_dwMsgIDTo)   ÿÿÿÿ       ÿÿÿÿ     1   expression was false       (sCurrFrame.m_dwPGN <= m_dwMsgIDTo)   ÿÿÿÿ       ÿÿÿÿ     1               +·   _               ÿÿÿÿ  ÿÿÿÿ    …á¸      expression was true       (psTemp != 0)   ÿÿÿÿ       ÿÿÿÿ        expression was false       (psTemp != 0)   ÿÿÿÿ       ÿÿÿÿ                    ñNĞ   a             _  ÿÿÿÿ  ÿÿÿÿ    …â       expression was true       (_tcscmp(psTemp->m_sFilterName.m_acFilterName, acFilterName) == 0)   ÿÿÿÿ       ÿÿÿÿ     _   expression was false       (_tcscmp(psTemp->m_sFilterName.m_acFilterName, acFilterName) == 0)   ÿÿÿÿ       ÿÿÿÿ     _               …àà   c             4  }ÿÿÿÿ  }ÿÿÿÿ     ìÍx      expression was false       m_dwMsgIDFrom == sCurrFrame.m_dwFrameID   ÿÿÿÿ  }     ÿÿÿÿ  }   4                ìÇÀ   d               ÿÿÿÿ  ÿÿÿÿ    …çø       statement executed        return 0;   ÿÿÿÿ       ÿÿÿÿ                e               ÿÿÿÿ  ÿÿÿÿ    …æH       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                f               ÿÿÿÿ  ÿÿÿÿ    …ä˜       statement executed        return psTemp;   ÿÿÿÿ       ÿÿÿÿ                g               ÿÿÿÿ  ÿÿÿÿ    ñH`       statement executed        return pbTStream;   ÿÿÿÿ       ÿÿÿÿ                h        	     
   ÿÿÿÿ   ÿÿÿÿ    ñEÈ       statement executed        }   ÿÿÿÿ      	  ÿÿÿÿ      
           i     ü   C  ü   I  úÿÿÿÿ  úÿÿÿÿ    ñAH       statement executed        break;   üÿÿÿÿ  ú   C  üÿÿÿÿ  ú   I           j     û   C  û   I  ùÿÿÿÿ  ùÿÿÿÿ    v¾€       statement executed        break;   ûÿÿÿÿ  ù   C  ûÿÿÿÿ  ù   I           k     ú   G  ú   M  øÿÿÿÿ  øÿÿÿÿ    v¼H       statement executed        break;   úÿÿÿÿ  ø   G  úÿÿÿÿ  ø   M           l     ù   ?  ù   E  ÷ÿÿÿÿ  ÷ÿÿÿÿ    vº       statement executed        break;   ùÿÿÿÿ  ÷   ?  ùÿÿÿÿ  ÷   E           m     ó   	  ó   
  ñÿÿÿÿ  ñÿÿÿÿ    v¶`       statement executed        }   óÿÿÿÿ  ñ   	  óÿÿÿÿ  ñ   
           n     ñ     ñ     ïÿÿÿÿ  ïÿÿÿÿ    vµˆ       statement executed        break;   ñÿÿÿÿ  ï     ñÿÿÿÿ  ï              o     ì     ì     êÿÿÿÿ  êÿÿÿÿ    v´°       statement executed        break;   ìÿÿÿÿ  ê     ìÿÿÿÿ  ê              p     ê     ê     èÿÿÿÿ  èÿÿÿÿ    v³        statement executed        }   êÿÿÿÿ  è     êÿÿÿÿ  è              q     ä     ä     âÿÿÿÿ  âÿÿÿÿ    f{x       statement executed        break;   äÿÿÿÿ  â     äÿÿÿÿ  â              r     â     â     àÿÿÿÿ  àÿÿÿÿ    fyÈ       statement executed        }   âÿÿÿÿ  à     âÿÿÿÿ  à              s     Ü     Ü     Úÿÿÿÿ  Úÿÿÿÿ    fsh       statement executed        break;   Üÿÿÿÿ  Ú     Üÿÿÿÿ  Ú              t     Ú     Ú     Øÿÿÿÿ  Øÿÿÿÿ    fq¸       statement executed        }   Úÿÿÿÿ  Ø     Úÿÿÿÿ  Ø              u     Ó     Ó     Ñÿÿÿÿ  Ñÿÿÿÿ    º       statement executed        break;   Óÿÿÿÿ  Ñ     Óÿÿÿÿ  Ñ              v     Ñ     Ñ     Ïÿÿÿÿ  Ïÿÿÿÿ    ¸à       statement executed        }   Ñÿÿÿÿ  Ï     Ñÿÿÿÿ  Ï              w     Ã   K  Ã   Q  Áÿÿÿÿ  Áÿÿÿÿ    °à       statement executed        break;   Ãÿÿÿÿ  Á   K  Ãÿÿÿÿ  Á   Q           x     Â   K  Â   Q  Àÿÿÿÿ  Àÿÿÿÿ    œŞ       statement executed        break;   Âÿÿÿÿ  À   K  Âÿÿÿÿ  À   Q           y     Á   O  Á   U  ¿ÿÿÿÿ  ¿ÿÿÿÿ    œÜX       statement executed        break;   Áÿÿÿÿ  ¿   O  Áÿÿÿÿ  ¿   U           z     À   G  À   M  ¾ÿÿÿÿ  ¾ÿÿÿÿ    œÚ        statement executed        break;   Àÿÿÿÿ  ¾   G  Àÿÿÿÿ  ¾   M           {     Ÿ     Ÿ     ÿÿÿÿ  ÿÿÿÿ     îJ`       statement executed        return pbTStream;   Ÿÿÿÿÿ       Ÿÿÿÿÿ                |               ›ÿÿÿÿ  ›ÿÿÿÿ     îH°       statement executed        }   ÿÿÿÿ  ›     ÿÿÿÿ  ›              }     ›     ›     ™ÿÿÿÿ  ™ÿÿÿÿ     îGØ       statement executed        break;   ›ÿÿÿÿ  ™     ›ÿÿÿÿ  ™              ~     –     –     ”ÿÿÿÿ  ”ÿÿÿÿ     îG        statement executed        break;   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”                   ‘     ‘     ÿÿÿÿ  ÿÿÿÿ     î@à       statement executed        break;   ‘ÿÿÿÿ       ‘ÿÿÿÿ                €     Œ     Œ     Šÿÿÿÿ  Šÿÿÿÿ    e        statement executed        break;   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š                   ‡     ‡     …ÿÿÿÿ  …ÿÿÿÿ    e€       statement executed        break;   ‡ÿÿÿÿ  …     ‡ÿÿÿÿ  …              ‚     e     e     cÿÿÿÿ  cÿÿÿÿ    Ì       statement executed        return Result;   eÿÿÿÿ  c     eÿÿÿÿ  c              ƒ     b   	  b     `ÿÿÿÿ  `ÿÿÿÿ    Ì¸       statement executed        break;   bÿÿÿÿ  `   	  bÿÿÿÿ  `              „     ]   	  ]     [ÿÿÿÿ  [ÿÿÿÿ    Ìà       statement executed        break;   ]ÿÿÿÿ  [   	  ]ÿÿÿÿ  [              …     [     [     Yÿÿÿÿ  Yÿÿÿÿ    oo        statement executed        }   [ÿÿÿÿ  Y     [ÿÿÿÿ  Y              †     T   	  T     Rÿÿÿÿ  Rÿÿÿÿ    oh¨       statement executed        break;   Tÿÿÿÿ  R   	  Tÿÿÿÿ  R              ‡     R     R     Pÿÿÿÿ  Pÿÿÿÿ    ofø       statement executed        }   Rÿÿÿÿ  P     Rÿÿÿÿ  P              ˆ     K   	  K     Iÿÿÿÿ  Iÿÿÿÿ    ˜¯`       statement executed        break;   Kÿÿÿÿ  I   	  Kÿÿÿÿ  I              ‰     I     I     Gÿÿÿÿ  Gÿÿÿÿ    ˜­°       statement executed        }   Iÿÿÿÿ  G     Iÿÿÿÿ  G              Š     B   	  B     @ÿÿÿÿ  @ÿÿÿÿ    ˜§X       statement executed        break;   Bÿÿÿÿ  @   	  Bÿÿÿÿ  @              ‹     @     @     >ÿÿÿÿ  >ÿÿÿÿ    ˜¥¨       statement executed        }   @ÿÿÿÿ  >     @ÿÿÿÿ  >              Œ     &     &     $ÿÿÿÿ  $ÿÿÿÿ    v¥Ø       statement executed        return bResult;   &ÿÿÿÿ  $     &ÿÿÿÿ  $                   $     $     "ÿÿÿÿ  "ÿÿÿÿ    v¤(       statement executed        }   $ÿÿÿÿ  "     $ÿÿÿÿ  "                             ÿÿÿÿ  ÿÿÿÿ    v ğ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                               ÿÿÿÿ  ÿÿÿÿ    v        statement executed        break;   ÿÿÿÿ       ÿÿÿÿ                               ÿÿÿÿ  ÿÿÿÿ    wìà       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ‘               ÿÿÿÿ  ÿÿÿÿ    wë        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ’               ÿÿÿÿ  ÿÿÿÿ    wéP       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                “     	     	     ÿÿÿÿ  ÿÿÿÿ    ¬8H       statement executed        break;   	ÿÿÿÿ       	ÿÿÿÿ                ”               ÿÿÿÿ  ÿÿÿÿ    ¬6ˆ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                •               ÿÿÿÿ  ÿÿÿÿ    ¬4¨       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                –                ÿÿÿÿ   ÿÿÿÿ    ¬2ø       statement executed        }   ÿÿÿÿ        ÿÿÿÿ                 —     ö     ö     ôÿÿÿÿ  ôÿÿÿÿ    \Ò        statement executed        break;   öÿÿÿÿ  ô     öÿÿÿÿ  ô              ˜     ô     ô     òÿÿÿÿ  òÿÿÿÿ    \ĞP       statement executed        }   ôÿÿÿÿ  ò     ôÿÿÿÿ  ò              ™     ğ     ğ     îÿÿÿÿ  îÿÿÿÿ     l        statement executed        }   ğÿÿÿÿ  î     ğÿÿÿÿ  î              š     ï     ï     íÿÿÿÿ  íÿÿÿÿ     jğ       statement executed        }   ïÿÿÿÿ  í     ïÿÿÿÿ  í              ›     ã     ã     áÿÿÿÿ  áÿÿÿÿ    .ÉÀ       statement executed        break;   ãÿÿÿÿ  á     ãÿÿÿÿ  á              œ     á     á     ßÿÿÿÿ  ßÿÿÿÿ    .È        statement executed        }   áÿÿÿÿ  ß     áÿÿÿÿ  ß                   İ     İ     Ûÿÿÿÿ  Ûÿÿÿÿ    .Æ        statement executed        }   İÿÿÿÿ  Û     İÿÿÿÿ  Û                   Ü     Ü     Úÿÿÿÿ  Úÿÿÿÿ    .Äp       statement executed        }   Üÿÿÿÿ  Ú     Üÿÿÿÿ  Ú              Ÿ     ¶     ¶     ´ÿÿÿÿ  ´ÿÿÿÿ    U‡¨       statement executed        }   ¶ÿÿÿÿ  ´     ¶ÿÿÿÿ  ´                    ´     ´     ²ÿÿÿÿ  ²ÿÿÿÿ    U„°       statement executed        }   ´ÿÿÿÿ  ²     ´ÿÿÿÿ  ²              ¡     °     °     ®ÿÿÿÿ  ®ÿÿÿÿ    U‚Ğ       statement executed        break;   °ÿÿÿÿ  ®     °ÿÿÿÿ  ®              ¢     ©     ©     §ÿÿÿÿ  §ÿÿÿÿ    U€       statement executed        break;   ©ÿÿÿÿ  §     ©ÿÿÿÿ  §              £     ¢     ¢      ÿÿÿÿ   ÿÿÿÿ    O,¨       statement executed        break;   ¢ÿÿÿÿ        ¢ÿÿÿÿ                 ¤     ›     ›     ™ÿÿÿÿ  ™ÿÿÿÿ    O)       statement executed        break;   ›ÿÿÿÿ  ™     ›ÿÿÿÿ  ™              ¥               ÿÿÿÿ  ÿÿÿÿ    O!ğ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ¦     p     p     nÿÿÿÿ  nÿÿÿÿ    ËP       statement executed        }   pÿÿÿÿ  n     pÿÿÿÿ  n              §     X     X     Vÿÿÿÿ  Vÿÿÿÿ    Ãè       statement executed        return pbTStream;   Xÿÿÿÿ  V     Xÿÿÿÿ  V              ¨     @     @     >ÿÿÿÿ  >ÿÿÿÿ    Q|@       statement executed        return pbTStream;   @ÿÿÿÿ  >     @ÿÿÿÿ  >              ©     )     )     'ÿÿÿÿ  'ÿÿÿÿ    Qvø       statement executed        return Result;   )ÿÿÿÿ  '     )ÿÿÿÿ  '              ª               ÿÿÿÿ  ÿÿÿÿ    Qs        statement executed        return bResult;   ÿÿÿÿ       ÿÿÿÿ                «               ÿÿÿÿ  ÿÿÿÿ    Qp˜       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ¬               ÿÿÿÿ  ÿÿÿÿ    Qp       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ­               ÿÿÿÿ  ÿÿÿÿ    +»Ø       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ®               ÿÿÿÿ  ÿÿÿÿ    +±p       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ¯        	     
  ÿÿÿÿ  ÿÿÿÿ    +°       statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
           °     ë     ë     éÿÿÿÿ  éÿÿÿÿ    ê”À       statement executed        }   ëÿÿÿÿ  é     ëÿÿÿÿ  é              ±     Ù     Ù     ×ÿÿÿÿ  ×ÿÿÿÿ    ê‘       statement executed        return *this;   Ùÿÿÿÿ  ×     Ùÿÿÿÿ  ×              ²     È     È     Æÿÿÿÿ  Æÿÿÿÿ    Şîx       statement executed        }   Èÿÿÿÿ  Æ     Èÿÿÿÿ  Æ              ³     ·     ·     µÿÿÿÿ  µÿÿÿÿ    Şì        statement executed        }   ·ÿÿÿÿ  µ     ·ÿÿÿÿ  µ              ´     ¡     ¡     Ÿÿÿÿÿ  Ÿÿÿÿÿ    Şé°       statement executed        return pbTStream;   ¡ÿÿÿÿ  Ÿ     ¡ÿÿÿÿ  Ÿ              µ     ‰     ‰     ‡ÿÿÿÿ  ‡ÿÿÿÿ    Şä       statement executed        return pbTStream;   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡              ¶     r     r     pÿÿÿÿ  pÿÿÿÿ    I	ø       statement executed        return Result;   rÿÿÿÿ  p     rÿÿÿÿ  p              ·     `     `     ^ÿÿÿÿ  ^ÿÿÿÿ    I        statement executed        return bResult;   `ÿÿÿÿ  ^     `ÿÿÿÿ  ^              ¸     ^     ^     \ÿÿÿÿ  \ÿÿÿÿ    Ix       statement executed        }   ^ÿÿÿÿ  \     ^ÿÿÿÿ  \              ¹     Z     Z     Xÿÿÿÿ  Xÿÿÿÿ    I        statement executed        }   Zÿÿÿÿ  X     Zÿÿÿÿ  X              º     Y     Y     Wÿÿÿÿ  Wÿÿÿÿ    I à       statement executed        }   Yÿÿÿÿ  W     Yÿÿÿÿ  W              »     P     P     Nÿÿÿÿ  Nÿÿÿÿ    ¾4        statement executed        }   Pÿÿÿÿ  N     Pÿÿÿÿ  N              ¼     O   	  O   
  Mÿÿÿÿ  Mÿÿÿÿ    ¾2@       statement executed        }   Oÿÿÿÿ  M   	  Oÿÿÿÿ  M   
           ½     4     4     2ÿÿÿÿ  2ÿÿÿÿ    |§        statement executed        }   4ÿÿÿÿ  2     4ÿÿÿÿ  2              ¾     "     "      ÿÿÿÿ   ÿÿÿÿ    |£Ğ       statement executed        return *this;   "ÿÿÿÿ        "ÿÿÿÿ                 ¿               ÿÿÿÿ  ÿÿÿÿ    | À       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                À                 şÿÿÿÿ  şÿÿÿÿ    2;è       statement executed        }    ÿÿÿÿ  ş      ÿÿÿÿ  ş              Á     é     é     çÿÿÿÿ  çÿÿÿÿ    29à       statement executed        return pbTStream;   éÿÿÿÿ  ç     éÿÿÿÿ  ç              Â     Í     Í     Ëÿÿÿÿ  Ëÿÿÿÿ    22ğ       statement executed        return pbTStream;   Íÿÿÿÿ  Ë     Íÿÿÿÿ  Ë              Ã     ³     ³     ±ÿÿÿÿ  ±ÿÿÿÿ     ıI°       statement executed        return Result;   ³ÿÿÿÿ  ±     ³ÿÿÿÿ  ±              Ä     Ÿ     Ÿ     ÿÿÿÿ  ÿÿÿÿ     ıDĞ       statement executed        return bResult;   Ÿÿÿÿÿ       Ÿÿÿÿÿ                Å               ›ÿÿÿÿ  ›ÿÿÿÿ     ıBH       statement executed        }   ÿÿÿÿ  ›     ÿÿÿÿ  ›              Æ     ™     ™     —ÿÿÿÿ  —ÿÿÿÿ     ıAp       statement executed        }   ™ÿÿÿÿ  —     ™ÿÿÿÿ  —              Ç     ˜     ˜     –ÿÿÿÿ  –ÿÿÿÿ     ı@       statement executed        }   ˜ÿÿÿÿ  –     ˜ÿÿÿÿ  –              È     —     —     •ÿÿÿÿ  •ÿÿÿÿ    sİĞ       statement executed        }   —ÿÿÿÿ  •     —ÿÿÿÿ  •              É     –     –     ”ÿÿÿÿ  ”ÿÿÿÿ    sÜ       statement executed        }   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”              Ê      0      0      .ÿÿÿÿ   .ÿÿÿÿ    úğ       statement executed        }    0ÿÿÿÿ   .      0ÿÿÿÿ   .              Ë      B      B      @ÿÿÿÿ   @ÿÿÿÿ    ı        statement executed        }    Bÿÿÿÿ   @      Bÿÿÿÿ   @              Ì      U      U      Sÿÿÿÿ   Sÿÿÿÿ    ÿP       statement executed        return *this;    Uÿÿÿÿ   S      Uÿÿÿÿ   S              Í      o      o      mÿÿÿÿ   mÿÿÿÿ    U£¸       statement executed        return pbTStream;    oÿÿÿÿ   m      oÿÿÿÿ   m              Î      ‰      ‰      ‡ÿÿÿÿ   ‡ÿÿÿÿ    U¨       statement executed        return pbTStream;    ‰ÿÿÿÿ   ‡      ‰ÿÿÿÿ   ‡              Ï      Ÿ      Ÿ      ÿÿÿÿ   ÿÿÿÿ    U¨ğ       statement executed        }    Ÿÿÿÿÿ         Ÿÿÿÿÿ                 Ğ      ³      ³      ±ÿÿÿÿ   ±ÿÿÿÿ    /*       statement executed        }    ³ÿÿÿÿ   ±      ³ÿÿÿÿ   ±              Ñ      È      È      Æÿÿÿÿ   Æÿÿÿÿ            statement executed        return *this;    Èÿÿÿÿ   Æ      Èÿÿÿÿ   Æ              Ò      Ù      Ú   5   ×ÿÿÿÿ   Øÿÿÿÿ    /$8       statement executed        return (sizeof(m_ucFilterType) + sizeof(m_dwMsgIDFrom) + 
            sizeof(m_dwMsgIDTo) + sizeof(m_eDrctn));    Ùÿÿÿÿ   ×      Úÿÿÿÿ   Ø   5           Ó      ö      ö      ôÿÿÿÿ   ôÿÿÿÿ    ;·8       statement executed        return pbTStream;    öÿÿÿÿ   ô      öÿÿÿÿ   ô              Ô               ÿÿÿÿ  ÿÿÿÿ    ~:@       statement executed        return pbTStream;   ÿÿÿÿ       ÿÿÿÿ                Õ     *     *     (ÿÿÿÿ  (ÿÿÿÿ    ~;       statement executed        }   *ÿÿÿÿ  (     *ÿÿÿÿ  (              Ö     ;     ;     9ÿÿÿÿ  9ÿÿÿÿ     6C¨       statement executed        }   ;ÿÿÿÿ  9     ;ÿÿÿÿ  9              ×     Q     Q     Oÿÿÿÿ  Oÿÿÿÿ    4Ê       statement executed        return *this;   Qÿÿÿÿ  O     Qÿÿÿÿ  O              Ø     f     f     dÿÿÿÿ  dÿÿÿÿ    ™ˆ       statement executed        }   fÿÿÿÿ  d     fÿÿÿÿ  d              Ù     “     “     ‘ÿÿÿÿ  ‘ÿÿÿÿ    VAÀ       statement executed        }   “ÿÿÿÿ  ‘     “ÿÿÿÿ  ‘              Ú     ”     ”     ’ÿÿÿÿ  ’ÿÿÿÿ    5Â8       statement executed        }   ”ÿÿÿÿ  ’     ”ÿÿÿÿ  ’              Û     •     •     “ÿÿÿÿ  “ÿÿÿÿ     é       statement executed        }   •ÿÿÿÿ  “     •ÿÿÿÿ  “              Ü     –     –     ”ÿÿÿÿ  ”ÿÿÿÿ     ìÎØ       statement executed        }   –ÿÿÿÿ  ”     –ÿÿÿÿ  ”              İ     —   	  —   
  •ÿÿÿÿ  •ÿÿÿÿ    V       statement executed        }   —ÿÿÿÿ  •   	  —ÿÿÿÿ  •   
           Ş     ˜     ˜     –ÿÿÿÿ  –ÿÿÿÿ    '	°       statement executed        }   ˜ÿÿÿÿ  –     ˜ÿÿÿÿ  –              ß     ²     ²     °ÿÿÿÿ  °ÿÿÿÿ    Hp       statement executed        }   ²ÿÿÿÿ  °     ²ÿÿÿÿ  °              à     ³     ³     ±ÿÿÿÿ  ±ÿÿÿÿ    J0       statement executed        }   ³ÿÿÿÿ  ±     ³ÿÿÿÿ  ±              á     ´     ´     ²ÿÿÿÿ  ²ÿÿÿÿ    ø        statement executed        }   ´ÿÿÿÿ  ²     ´ÿÿÿÿ  ²              â     µ     µ     ³ÿÿÿÿ  ³ÿÿÿÿ    ø!p       statement executed        }   µÿÿÿÿ  ³     µÿÿÿÿ  ³              ã     ¶     ¶     ´ÿÿÿÿ  ´ÿÿÿÿ    ø#0       statement executed        }   ¶ÿÿÿÿ  ´     ¶ÿÿÿÿ  ´              ä     ·     ·     µÿÿÿÿ  µÿÿÿÿ    ø$ğ       statement executed        }   ·ÿÿÿÿ  µ     ·ÿÿÿÿ  µ              å     »     »     ¹ÿÿÿÿ  ¹ÿÿÿÿ    ø%È       statement executed        }   »ÿÿÿÿ  ¹     »ÿÿÿÿ  ¹              æ     ½     ½     »ÿÿÿÿ  »ÿÿÿÿ    ø(p       statement executed        return bResult;   ½ÿÿÿÿ  »     ½ÿÿÿÿ  »              ç     Ó     Ó     Ñÿÿÿÿ  Ñÿÿÿÿ    8P       statement executed        return Result;   Óÿÿÿÿ  Ñ     Óÿÿÿÿ  Ñ              è     ï     ï     íÿÿÿÿ  íÿÿÿÿ    ¿Âø       statement executed        return pbTStream;   ïÿÿÿÿ  í     ïÿÿÿÿ  í              é               ÿÿÿÿ  ÿÿÿÿ    ¦%       statement executed        return pbTStream;   ÿÿÿÿ       ÿÿÿÿ                ê     #     #     !ÿÿÿÿ  !ÿÿÿÿ    ¦'        statement executed        }   #ÿÿÿÿ  !     #ÿÿÿÿ  !              ë     4     4     2ÿÿÿÿ  2ÿÿÿÿ    ¦)0       statement executed        }   4ÿÿÿÿ  2     4ÿÿÿÿ  2              ì     H     H     Fÿÿÿÿ  Fÿÿÿÿ    ¦,è       statement executed        return *this;   Hÿÿÿÿ  F     Hÿÿÿÿ  F              í     [     [     Yÿÿÿÿ  Yÿÿÿÿ    d$à       statement executed        }   [ÿÿÿÿ  Y     [ÿÿÿÿ  Y              î     €     €     ~ÿÿÿÿ  ~ÿÿÿÿ     ú8       statement executed        }   €ÿÿÿÿ  ~     €ÿÿÿÿ  ~              ï               ÿÿÿÿ  ÿÿÿÿ     ú:P       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ğ     ‚   	  ‚   
  €ÿÿÿÿ  €ÿÿÿÿ    Äp       statement executed        }   ‚ÿÿÿÿ  €   	  ‚ÿÿÿÿ  €   
           ñ     ƒ     ƒ     ÿÿÿÿ  ÿÿÿÿ    Äqp       statement executed        }   ƒÿÿÿÿ       ƒÿÿÿÿ             tagFilterName::tagFilterName tagFilterName::tagFilterName()    -      0      +ÿÿÿÿ   .ÿÿÿÿtagFilterName::vClear void tagFilterName::vClear(void)    ?      B      =ÿÿÿÿ   @ÿÿÿÿtagFilterName::operator= tagFilterName& tagFilterName::operator=(const tagFilterName& RefObj)    Q      V      Oÿÿÿÿ   TÿÿÿÿtagFilterName::pbGetConfigData BYTE* tagFilterName::pbGetConfigData(BYTE* pbTarget)    i      p      gÿÿÿÿ   nÿÿÿÿtagFilterName::pbSetConfigData BYTE* tagFilterName::pbSetConfigData(BYTE* pbTarget)    ƒ      Š      ÿÿÿÿ   ˆÿÿÿÿtagSFILTER::tagSFILTER tagSFILTER::tagSFILTER()          Ÿ      ›ÿÿÿÿ   ÿÿÿÿtagSFILTER::vClear void tagSFILTER::vClear(void)    ®      ³      ¬ÿÿÿÿ   ±ÿÿÿÿtagSFILTER::operator= tagSFILTER& tagSFILTER::operator=(const tagSFILTER& RefObj)    Â      É      Àÿÿÿÿ   ÇÿÿÿÿtagSFILTER::unGetSize UINT tagSFILTER::unGetSize(void)    Ø      Û      Öÿÿÿÿ   ÙÿÿÿÿtagSFILTER::pbGetConfigData BYTE* tagSFILTER::pbGetConfigData(BYTE* pbTarget)    î      ÷      ìÿÿÿÿ   õÿÿÿÿtagSFILTER::pbSetConfigData BYTE* tagSFILTER::pbSetConfigData(BYTE* pbTarget)   
          ÿÿÿÿ  ÿÿÿÿSFILTER_CAN::SFILTER_CAN SFILTER_CAN::SFILTER_CAN()   (     *     &ÿÿÿÿ  (ÿÿÿÿSFILTER_CAN::~SFILTER_CAN SFILTER_CAN::~SFILTER_CAN()   9     ;     7ÿÿÿÿ  9ÿÿÿÿSFILTER_CAN::operator= SFILTER_CAN& SFILTER_CAN::operator=(const SFILTER_CAN& RefObj)   J     R     Hÿÿÿÿ  PÿÿÿÿSFILTER_CAN::vClear void SFILTER_CAN::vClear(void)   a     f     _ÿÿÿÿ  dÿÿÿÿSFILTER_CAN::bDoesFrameOccur BOOL SFILTER_CAN::bDoesFrameOccur(const void* psCurrFrame)   v     ¾     tÿÿÿÿ  ¼ÿÿÿÿSFILTER_CAN::unGetSize UINT SFILTER_CAN::unGetSize(void)   Í     Ô     Ëÿÿÿÿ  ÒÿÿÿÿSFILTER_CAN::pbGetConfigData BYTE* SFILTER_CAN::pbGetConfigData(BYTE* pbTarget)   ç     ğ     åÿÿÿÿ  îÿÿÿÿSFILTER_CAN::pbSetConfigData BYTE* SFILTER_CAN::pbSetConfigData(BYTE* pbTarget)             ÿÿÿÿ  ÿÿÿÿSFILTER_FLEXRAY::SFILTER_FLEXRAY SFILTER_FLEXRAY::SFILTER_FLEXRAY()   !     #     ÿÿÿÿ  !ÿÿÿÿSFILTER_FLEXRAY::~SFILTER_FLEXRAY SFILTER_FLEXRAY::~SFILTER_FLEXRAY()   2     4     0ÿÿÿÿ  2ÿÿÿÿSFILTER_FLEXRAY::operator= SFILTER_FLEXRAY& SFILTER_FLEXRAY::operator=(const SFILTER_FLEXRAY& RefObj)   C     I     Aÿÿÿÿ  GÿÿÿÿSFILTER_FLEXRAY::vClear void SFILTER_FLEXRAY::vClear(void)   X     [     Vÿÿÿÿ  YÿÿÿÿSFILTER_FLEXRAY::bDoesFrameOccur BOOL SFILTER_FLEXRAY::bDoesFrameOccur(const void* psCurrFrame)   k           iÿÿÿÿ  ÿÿÿÿSFILTER_FLEXRAY::unGetSize UINT SFILTER_FLEXRAY::unGetSize(void)   ¯     ´     ­ÿÿÿÿ  ²ÿÿÿÿSFILTER_FLEXRAY::pbGetConfigData BYTE* SFILTER_FLEXRAY::pbGetConfigData(BYTE* pbTarget)   Ç     Î     Åÿÿÿÿ  ÌÿÿÿÿSFILTER_FLEXRAY::pbSetConfigData BYTE* SFILTER_FLEXRAY::pbSetConfigData(BYTE* pbTarget)   á     ê     ßÿÿÿÿ  èÿÿÿÿSFILTER_MCNET::SFILTER_MCNET SFILTER_MCNET::SFILTER_MCNET()   ş           üÿÿÿÿ  şÿÿÿÿSFILTER_MCNET::~SFILTER_MCNET SFILTER_MCNET::~SFILTER_MCNET()             ÿÿÿÿ  ÿÿÿÿSFILTER_MCNET::operator= SFILTER_MCNET& SFILTER_MCNET::operator=(const SFILTER_MCNET& RefObj)         #     ÿÿÿÿ  !ÿÿÿÿSFILTER_MCNET::vClear void SFILTER_MCNET::vClear(void)   2     4     0ÿÿÿÿ  2ÿÿÿÿSFILTER_MCNET::bDoesFrameOccur BOOL SFILTER_MCNET::bDoesFrameOccur(const void* psCurrFrame)   D     a     Bÿÿÿÿ  _ÿÿÿÿSFILTER_MCNET::unGetSize UINT SFILTER_MCNET::unGetSize(void)   p     s     nÿÿÿÿ  qÿÿÿÿSFILTER_MCNET::pbGetConfigData BYTE* SFILTER_MCNET::pbGetConfigData(BYTE* pbTarget)   †     Š     „ÿÿÿÿ  ˆÿÿÿÿSFILTER_MCNET::pbSetConfigData BYTE* SFILTER_MCNET::pbSetConfigData(BYTE* pbTarget)        ¢     ›ÿÿÿÿ   ÿÿÿÿSFILTER_J1939::SFILTER_J1939 SFILTER_J1939::SFILTER_J1939()   µ     ·     ³ÿÿÿÿ  µÿÿÿÿSFILTER_J1939::~SFILTER_J1939 SFILTER_J1939::~SFILTER_J1939()   Æ     È     Äÿÿÿÿ  ÆÿÿÿÿSFILTER_J1939::operator= SFILTER_J1939& SFILTER_J1939::operator=(const SFILTER_J1939& RefObj)   ×     Ú     Õÿÿÿÿ  ØÿÿÿÿSFILTER_J1939::vClear void SFILTER_J1939::vClear(void)   é     ë     çÿÿÿÿ  éÿÿÿÿSFILTER_J1939::bDoesFrameOccur BOOL SFILTER_J1939::bDoesFrameOccur(const void* psCurrFrame)   û          ùÿÿÿÿ  ÿÿÿÿSFILTER_J1939::unGetSize UINT SFILTER_J1939::unGetSize(void)   '     *     %ÿÿÿÿ  (ÿÿÿÿSFILTER_J1939::pbGetConfigData BYTE* SFILTER_J1939::pbGetConfigData(BYTE* pbTarget)   =     A     ;ÿÿÿÿ  ?ÿÿÿÿSFILTER_J1939::pbSetConfigData BYTE* SFILTER_J1939::pbSetConfigData(BYTE* pbTarget)   T     Y     Rÿÿÿÿ  WÿÿÿÿtagFilterSet::tagFilterSet tagFilterSet::tagFilterSet()   j     p     hÿÿÿÿ  nÿÿÿÿtagFilterSet::~tagFilterSet tagFilterSet::~tagFilterSet()             }ÿÿÿÿ  ÿÿÿÿtagFilterSet::vClear void tagFilterSet::vClear(void)        ¶     Œÿÿÿÿ  ´ÿÿÿÿtagFilterSet::bClone bool tagFilterSet::bClone(const tagFilterSet& RefObj)   Ã     '     Áÿÿÿÿ  %ÿÿÿÿtagFilterSet::unGetSize UINT tagFilterSet::unGetSize(void)   4     f     2ÿÿÿÿ  dÿÿÿÿtagFilterSet::pbGetConfigData BYTE* tagFilterSet::pbGetConfigData(BYTE* pbTarget)   w           uÿÿÿÿ  ÿÿÿÿtagFilterSet::pbSetConfigData BYTE* tagFilterSet::pbSetConfigData(BYTE* pbTarget, bool& Result)   ±          ¯ÿÿÿÿ  ÿÿÿÿtagFilterSet::psGetFilterSetPointer tagFilterSet* tagFilterSet::psGetFilterSetPointer(tagFilterSet* psSet, UINT Count, char* acFilterName)   	          ÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Filter_Datatypes.cpp
 * \brief     Source file for filter data types.
 * \author    Ratnadip Choudhury
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file for filter data types.
 */

#include "DataTypes_StdAfx.h"
#include "Filter_Datatypes.h"

const int SIZE_CHAR = sizeof(char);

/* Starts SFILTERNAME / tagFilterName */

/******************************************************************************
  Function Name    :  tagFilterName
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  tagFilterName
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagFilterName::tagFilterName()
{
    m_acFilterName[LENGTH_FILTERNAME - 1] = L'\0';
    vClear();
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  tagFilterName
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void tagFilterName::vClear(void)
{
    _tcsset(m_acFilterName, L'\0');
    m_bFilterType = FALSE;
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  const tagFilterName& RefObj - The source object
  Output           :  tagFilterName& - The current object reference.
  Functionality    :  Copies a source object by '=' operator overloading.
  Member of        :  tagFilterName
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagFilterName& tagFilterName::operator=(const tagFilterName& RefObj)
{
    _tcscpy(m_acFilterName, RefObj.m_acFilterName);
    m_bFilterType = RefObj.m_bFilterType;

    return *this;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  tagFilterName
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* tagFilterName::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    COPY_DATA(pbTStream, m_acFilterName, LENGTH_FILTERNAME * SIZE_CHAR);
    COPY_DATA(pbTStream, &m_bFilterType, sizeof(m_bFilterType));

    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them
                      into the current object. Advances the reading pointer to
                      the next byte occurring after the block.
  Member of        :  tagFilterName
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* tagFilterName::pbSetConfigData(BYTE* pbTarget)
{
    BYTE* pbTStream = pbTarget;

    COPY_DATA_2(m_acFilterName, pbTStream, LENGTH_FILTERNAME * SIZE_CHAR);
    COPY_DATA_2(&m_bFilterType, pbTStream, sizeof(m_bFilterType));

    return pbTStream;
}

/* Ends SFILTERNAME / tagFilterName */

/* Starts SFILTER / tagSFILTER */

/******************************************************************************
  Function Name    :  tagSFILTER
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  tagSFILTER
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagSFILTER::tagSFILTER()
{
    vClear();
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  tagSFILTER
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void tagSFILTER::vClear(void)
{
    m_ucFilterType  = 0;
    m_dwMsgIDFrom   = 0;
    m_dwMsgIDTo     = 0;
    m_eDrctn        = DIR_ALL;
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  const tagSFILTER& RefObj - The source object
  Output           :  tagSFILTER& - The current object reference.
  Functionality    :  Copies a source object by '=' operator overloading.
  Member of        :  tagSFILTER
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagSFILTER& tagSFILTER::operator=(const tagSFILTER& RefObj)
{
    m_ucFilterType  = RefObj.m_ucFilterType;
    m_dwMsgIDFrom   = RefObj.m_dwMsgIDFrom; 
    m_dwMsgIDTo     = RefObj.m_dwMsgIDTo;
    m_eDrctn        = RefObj.m_eDrctn;

    return *this;
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current filtering block
  Functionality    :  Returns in bytes size of the current filtering block.
  Member of        :  tagSFILTER
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
UINT tagSFILTER::unGetSize(void) const
{
    return (sizeof(m_ucFilterType) + sizeof(m_dwMsgIDFrom) + 
            sizeof(m_dwMsgIDTo) + sizeof(m_eDrctn));
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  tagSFILTER
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* tagSFILTER::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    COPY_DATA(pbTStream, &m_ucFilterType, sizeof(m_ucFilterType));
    COPY_DATA(pbTStream, &m_dwMsgIDFrom, sizeof(m_dwMsgIDFrom));
    COPY_DATA(pbTStream, &m_dwMsgIDTo, sizeof(m_dwMsgIDTo));
    COPY_DATA(pbTStream, &m_eDrctn, sizeof(m_eDrctn));

    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them
                      into the current object. Advances the reading pointer to
                      the next byte occurring after the block.
  Member of        :  tagSFILTER
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* tagSFILTER::pbSetConfigData(BYTE* pbTarget)
{
    vClear();

    BYTE* pbTStream = pbTarget;

    COPY_DATA_2(&m_ucFilterType, pbTStream, sizeof(m_ucFilterType));
    COPY_DATA_2(&m_dwMsgIDFrom, pbTStream, sizeof(m_dwMsgIDFrom));
    COPY_DATA_2(&m_dwMsgIDTo, pbTStream, sizeof(m_dwMsgIDTo));
    COPY_DATA_2(&m_eDrctn, pbTStream, sizeof(m_eDrctn));

    return pbTStream;
}
/* Ends SFILTER / tagSFILTER */


/* Starts SFILTER_CAN */

/******************************************************************************
  Function Name    :  SFILTER_CAN
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_CAN::SFILTER_CAN()
{
    vClear();
}

/******************************************************************************
  Function Name    :  ~SFILTER_CAN
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_CAN::~SFILTER_CAN()
{
    vClear();
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  const SFILTER_CAN& RefObj - The source object
  Output           :  SFILTER_CAN& - The current object reference.
  Functionality    :  Copies a source object by '=' operator overloading.
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_CAN& SFILTER_CAN::operator=(const SFILTER_CAN& RefObj)
{
    this->SFILTER::operator = (RefObj);

    m_byMsgType = RefObj.m_byMsgType;
    m_byIDType  = RefObj.m_byIDType;
    m_eChannel = RefObj.m_eChannel;

    return *this;
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void SFILTER_CAN::vClear(void)
{
    m_byIDType = TYPE_ID_CAN_NONE;
    m_byMsgType = TYPE_MSG_CAN_NONE;
    m_eChannel = CAN_CHANNEL_ALL;
    this->SFILTER::vClear();
}

/******************************************************************************
  Function Name    :  bDoesFrameOccur
  Input(s)         :  psCurrFrame - The frame in question.
  Output           :  TRUE if the frame occurs in the filtering block.
  Functionality    :  Query function to know if this filtering block is 
                      configured for the message entry passed.
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BOOL SFILTER_CAN::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = FALSE;

    SFRAMEINFO_BASIC_CAN& sCurrFrame = *((SFRAMEINFO_BASIC_CAN *) psCurrFrame);

    // For Signle Id Filtering
    if (m_ucFilterType == defFILTER_TYPE_SINGLE_ID)
    {
        // Check for Message ID
        if (m_dwMsgIDFrom == sCurrFrame.m_dwFrameID)
        {
            // Check for message Channel
            if ( (CAN_CHANNEL_ALL == m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
                // Check for message direction
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
                    // Check for extended Id
                    if ((TYPE_ID_CAN_ALL == m_byIDType) ||
                        (m_byIDType == sCurrFrame.m_byIDType))
                    {
                        //Check for RTR
                        if ((TYPE_MSG_CAN_ALL == m_byMsgType) ||
                            (m_byMsgType == sCurrFrame.m_byMsgType))
                        {
					        bResult = TRUE;
                        }
                    }
				}
			}
        }
    }
    // For Range Filter
    else if (m_ucFilterType == defFILTER_TYPE_ID_RANGE)
    {
        // Check for message falling in the Range
        if ( (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo) )
        {
            // Check for message Channel
            if ( (CAN_CHANNEL_ALL == m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
               // Check for message Direction
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
					// Check for extended Id
                    if ((TYPE_ID_CAN_ALL == m_byIDType) ||
                        (m_byIDType == sCurrFrame.m_byIDType))
                    {
                        //Check for RTR
                        if ((TYPE_MSG_CAN_ALL == m_byMsgType) ||
                            (m_byMsgType == sCurrFrame.m_byMsgType))
                        {
					        bResult = TRUE;
                        }
                    }
				}
            }
		}
    }
    else
    {
        ASSERT(FALSE);
    }

    return bResult;
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current filtering block
  Functionality    :  Returns in bytes size of the current filtering block.
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
UINT SFILTER_CAN::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    Result += sizeof(m_byIDType);
    Result += sizeof(m_byMsgType);
    Result += sizeof(m_eChannel);

    return Result;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_CAN::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    COPY_DATA(pbTStream, &m_byIDType, sizeof(m_byIDType));
    COPY_DATA(pbTStream, &m_byMsgType, sizeof(m_byMsgType));
    COPY_DATA(pbTStream, &m_eChannel, sizeof(m_eChannel));

    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them
                      into the current object. Advances the reading pointer to
                      the next byte occurring after the block.
  Member of        :  SFILTER_CAN
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_CAN::pbSetConfigData(BYTE* pbTarget)
{
    vClear();

    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    COPY_DATA_2(&m_byIDType, pbTStream, sizeof(m_byIDType));
    COPY_DATA_2(&m_byMsgType, pbTStream, sizeof(m_byMsgType));
    COPY_DATA_2(&m_eChannel, pbTStream, sizeof(m_eChannel));

    return pbTStream;
}

/* Ends SFILTER_CAN */

/* Starts SFILTER_FLEXRAY */

/******************************************************************************
  Function Name    :  SFILTER_FLEXRAY
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_FLEXRAY::SFILTER_FLEXRAY()
{
    vClear();
}

/******************************************************************************
  Function Name    :  ~SFILTER_FLEXRAY
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_FLEXRAY::~SFILTER_FLEXRAY()
{
    vClear();
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  const SFILTER_FLEXRAY& RefObj - The source object
  Output           :  SFILTER_FLEXRAY& - The current object reference.
  Functionality    :  Copies a source object by '=' operator overloading.
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_FLEXRAY& SFILTER_FLEXRAY::operator=(const SFILTER_FLEXRAY& RefObj)
{
    this->SFILTER::operator = (RefObj);

    m_eChannel = RefObj.m_eChannel;

    return *this;
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void SFILTER_FLEXRAY::vClear(void)
{
    m_eChannel = FLEXRAY_CHANNEL_AB;
    this->SFILTER::vClear();
}

/******************************************************************************
  Function Name    :  bDoesFrameOccur
  Input(s)         :  psCurrFrame - The frame in question.
  Output           :  TRUE if the frame occurs in the filtering block.
  Functionality    :  Query function to know if this filtering block is 
                      configured for the message entry passed.
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BOOL SFILTER_FLEXRAY::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = FALSE;

    SFRAMEINFO_BASIC_FLEXRAY& sCurrFrame = *((SFRAMEINFO_BASIC_FLEXRAY *) psCurrFrame);
    // For Signle Id Filtering
    if (m_ucFilterType == defFILTER_TYPE_SINGLE_ID)
    {
        // Check for Message ID
        if (m_dwMsgIDFrom == sCurrFrame.m_dwFrameID)
        {
            // Check for message Channel
            if ( (FLEXRAY_CHANNEL_AB == m_eChannel) ||
                 (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
                // Check for message direction
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
					bResult = TRUE;
				}
			}
        }
    }
    // For Range Filter
    else if (m_ucFilterType == defFILTER_TYPE_ID_RANGE)
    {
        // Check for message falling in the Range
        if ( (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo) )
        {
            // Check for message Channel
            if ( (FLEXRAY_CHANNEL_AB == m_eChannel) ||
                 (FLEXRAY_CHANNEL_AB == sCurrFrame.m_eChannel) ||
                 (m_eChannel == sCurrFrame.m_eChannel) )
            {
               // Check for message Direction
                if ( (DIR_ALL == m_eDrctn) ||
                     (DIR_ALL == sCurrFrame.m_eDrctn) ||
                     (m_eDrctn == sCurrFrame.m_eDrctn) )
				{
					bResult = TRUE;
				}
            }
		}
    }
    else
    {
        ASSERT(FALSE);
    }

    return bResult;
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current filtering block
  Functionality    :  Returns in bytes size of the current filtering block.
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
UINT SFILTER_FLEXRAY::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    Result += sizeof(m_eChannel);

    return Result;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_FLEXRAY::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    COPY_DATA(pbTStream, &m_eChannel, sizeof(m_eChannel));

    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them
                      into the current object. Advances the reading pointer to
                      the next byte occurring after the block.
  Member of        :  SFILTER_FLEXRAY
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_FLEXRAY::pbSetConfigData(BYTE* pbTarget)
{
    vClear();

    BYTE* pbTStream = pbTarget;

    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    COPY_DATA_2(&m_eChannel, pbTStream, sizeof(m_eChannel));

    return pbTStream;
}

/* Ends SFILTER_FLEXRAY */


/* Starts SFILTER_MCNET */

/******************************************************************************
  Function Name    :  SFILTER_MCNET
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_MCNET::SFILTER_MCNET()
{
    vClear();
}

/******************************************************************************
  Function Name    :  ~SFILTER_MCNET
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_MCNET::~SFILTER_MCNET()
{
    vClear();
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  const SFILTER_MCNET& RefObj - The source object
  Output           :  SFILTER_MCNET& - The current object reference.
  Functionality    :  Copies a source object by '=' operator overloading.
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_MCNET& SFILTER_MCNET::operator=(const SFILTER_MCNET& RefObj)
{
    this->SFILTER::operator = (RefObj);
    return *this;
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void SFILTER_MCNET::vClear(void)
{
    this->SFILTER::vClear();
}

/******************************************************************************
  Function Name    :  bDoesFrameOccur
  Input(s)         :  psCurrFrame - The frame in question.
  Output           :  TRUE if the frame occurs in the filtering block.
  Functionality    :  Query function to know if this filtering block is 
                      configured for the message entry passed.
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BOOL SFILTER_MCNET::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = FALSE;

    SFRAMEINFO_BASIC_MCNET& sCurrFrame = *((SFRAMEINFO_BASIC_MCNET *) psCurrFrame);
    // For Signle Id Filtering
    if (m_ucFilterType == defFILTER_TYPE_SINGLE_ID)
    {
        // Check for Message ID
        if (m_dwMsgIDFrom == sCurrFrame.m_dwFrameID)
        {
            bResult = TRUE;
        }
    }
    // For Range Filter
    else if (m_ucFilterType == defFILTER_TYPE_ID_RANGE)
    {
        // Check for message falling in the Range
        if ( (sCurrFrame.m_dwFrameID >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwFrameID <= m_dwMsgIDTo) )
        {
            bResult = TRUE;
		}
    }
    else
    {
        ASSERT(FALSE);
    }

    return bResult;
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current filtering block
  Functionality    :  Returns in bytes size of the current filtering block.
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
UINT SFILTER_MCNET::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    return Result;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_MCNET::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them
                      into the current object. Advances the reading pointer to
                      the next byte occurring after the block.
  Member of        :  SFILTER_MCNET
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_MCNET::pbSetConfigData(BYTE* pbTarget)
{
    vClear();
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    return pbTStream;
}
/* Ends SFILTER_MCNET */


/* Starts SFILTER_J1939 */

/******************************************************************************
  Function Name    :  SFILTER_J1939
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_J1939::SFILTER_J1939()
{
    vClear();
}

/******************************************************************************
  Function Name    :  ~SFILTER_J1939
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_J1939::~SFILTER_J1939()
{
    vClear();
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  const SFILTER_J1939& RefObj - The source object
  Output           :  SFILTER_J1939& - The current object reference.
  Functionality    :  Copies a source object by '=' operator overloading.
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
SFILTER_J1939& SFILTER_J1939::operator=(const SFILTER_J1939& RefObj)
{
    this->SFILTER::operator = (RefObj);
    return *this;
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
void SFILTER_J1939::vClear(void)
{
    this->SFILTER::vClear();
}

/******************************************************************************
  Function Name    :  bDoesFrameOccur
  Input(s)         :  psCurrFrame - The frame in question.
  Output           :  TRUE if the frame occurs in the filtering block.
  Functionality    :  Query function to know if this filtering block is 
                      configured for the message entry passed.
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
BOOL SFILTER_J1939::bDoesFrameOccur(const void* psCurrFrame) const
{
    BOOL bResult = FALSE;

    SFRAMEINFO_BASIC_J1939& sCurrFrame = *((SFRAMEINFO_BASIC_J1939 *) psCurrFrame);
    // For Signle Id Filtering
    if (m_ucFilterType == defFILTER_TYPE_SINGLE_ID)
    {
        // Check for Message ID
        if (m_dwMsgIDFrom == sCurrFrame.m_dwPGN)
        {
            bResult = TRUE;
        }
    }
    // For Range Filter
    else if (m_ucFilterType == defFILTER_TYPE_ID_RANGE)
    {
        // Check for message falling in the Range
        if ( (sCurrFrame.m_dwPGN >= m_dwMsgIDFrom) &&
             (sCurrFrame.m_dwPGN <= m_dwMsgIDTo) )
        {
            bResult = TRUE;
		}
    }
    else
    {
        ASSERT(FALSE);
    }

    return bResult;
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current filtering block
  Functionality    :  Returns in bytes size of the current filtering block.
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
UINT SFILTER_J1939::unGetSize(void) const
{
    UINT Result = this->SFILTER::unGetSize();
    return Result;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_J1939::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbGetConfigData(pbTStream);
    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them
                      into the current object. Advances the reading pointer to
                      the next byte occurring after the block.
  Member of        :  SFILTER_J1939
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  30.11.2010
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* SFILTER_J1939::pbSetConfigData(BYTE* pbTarget)
{
    vClear();
    BYTE* pbTStream = pbTarget;
    pbTStream = this->SFILTER::pbSetConfigData(pbTStream);
    return pbTStream;
}
/* Ends SFILTER_J1939 */

/* Starts SFILTERSET / tagFilterSet */
/******************************************************************************
  Function Name    :  tagFilterSet
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagFilterSet::tagFilterSet()
{
    m_sFilterName.vClear();
    m_bEnabled = TRUE;
    m_eCurrBus = BUS_INVALID;
    m_ushFilters = 0;
    m_psFilterInfo = NULL;
}

/******************************************************************************
  Function Name    :  ~tagFilterSet
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagFilterSet::~tagFilterSet()
{
    vClear();
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current filtering block
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  ****************************************************************************/
void tagFilterSet::vClear(void)
{
    m_sFilterName.vClear();
    m_ushFilters = 0;
    if (NULL != m_psFilterInfo)
    {
        switch (m_eCurrBus)
        {
            case CAN:
            {
                PSFILTER_CAN psFilterCAN 
                                   = static_cast<PSFILTER_CAN>(m_psFilterInfo);
                delete[] psFilterCAN;
            }
            break;
            case FLEXRAY:
            {
                PSFILTER_FLEXRAY psFilterFlex 
                               = static_cast<PSFILTER_FLEXRAY>(m_psFilterInfo);
                delete[] psFilterFlex;
            }
            break;
            case MCNET:
            {
                PSFILTER_MCNET psFilterMCNet 
                                   = static_cast<PSFILTER_MCNET>(m_psFilterInfo);
                delete[] psFilterMCNet;
            }
            break;
            case J1939:
            {
                PSFILTER_J1939 psFilterJ1939 
                                   = static_cast<PSFILTER_J1939>(m_psFilterInfo);
                delete[] psFilterJ1939;
            }
            break;
            default: ASSERT(FALSE);
        }
        m_psFilterInfo = NULL;
    }
    m_eCurrBus = BUS_INVALID;
}

/******************************************************************************
  Function Name    :  bClone
  Input(s)         :  RefObj - The source object.
  Output           :  true if cloning operation is successful, else false.
  Functionality    :  Clones a filtering object to initialise the current one.
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
******************************************************************************/
bool tagFilterSet::bClone(const tagFilterSet& RefObj)
{
    vClear(); // First clear everything

    bool bResult = false;

    m_sFilterName = RefObj.m_sFilterName;
    m_bEnabled = RefObj.m_bEnabled;
    m_eCurrBus = RefObj.m_eCurrBus;
    m_ushFilters = RefObj.m_ushFilters;

    if (m_ushFilters > 0)
    {
        switch (m_eCurrBus)
        {
            case CAN:
            {
                m_psFilterInfo = new SFILTER_CAN[m_ushFilters];
                if (NULL != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_CAN* pDestObj = ((SFILTER_CAN *)m_psFilterInfo) + i;
                        SFILTER_CAN* pSrcObj = ((SFILTER_CAN *)RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            case FLEXRAY:
            {
                m_psFilterInfo = new SFILTER_FLEXRAY[m_ushFilters];
                if (NULL != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_FLEXRAY* pDestObj = ((SFILTER_FLEXRAY *) m_psFilterInfo) + i;
                        SFILTER_FLEXRAY* pSrcObj = ((SFILTER_FLEXRAY *) RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            case MCNET:
            {
                m_psFilterInfo = new SFILTER_MCNET[m_ushFilters];
                if (NULL != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_MCNET* pDestObj = ((SFILTER_MCNET *)m_psFilterInfo) + i;
                        SFILTER_MCNET* pSrcObj = ((SFILTER_MCNET *)RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            case J1939:
            {
                m_psFilterInfo = new SFILTER_J1939[m_ushFilters];
                if (NULL != m_psFilterInfo)
                {
                    bResult = true;
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        SFILTER_J1939* pDestObj = ((SFILTER_J1939 *)m_psFilterInfo) + i;
                        SFILTER_J1939* pSrcObj = ((SFILTER_J1939 *)RefObj.m_psFilterInfo) + i;
                        *pDestObj = *pSrcObj;
                    }
                }
                else
                {
                    m_ushFilters = 0;
                }
            }
            break;
            default: ASSERT(FALSE);
        }
    }
    else
    {
        m_psFilterInfo = NULL;
        bResult = true;
    }

    return bResult;
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current filtering block
  Functionality    :  Returns in bytes size of the current filtering block.
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
******************************************************************************/
UINT tagFilterSet::unGetSize(void) const
{
    UINT Result = sizeof(m_sFilterName) + sizeof(m_bEnabled) + 
                  sizeof(m_eCurrBus) + sizeof(m_ushFilters);

    switch (m_eCurrBus)
    {
        case CAN:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_CAN*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        case FLEXRAY:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_FLEXRAY*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        case MCNET:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_MCNET*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        case J1939:
        {
            for (UINT i = 0; i < m_ushFilters; i++)
            {

                Result += (((SFILTER_J1939*) m_psFilterInfo) + i)->unGetSize();
            }
        }
        break;
        default:
        {
            ASSERT(FALSE);            
        }
        break;
    }

    return Result;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save filtering data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves filtering block information of the current object
                      into the target buffer. Advances the writing pointer to
                      the next byte occurring after the written block.
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
******************************************************************************/
BYTE* tagFilterSet::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    pbTStream = m_sFilterName.pbGetConfigData(pbTStream);
    COPY_DATA(pbTStream, &m_bEnabled, sizeof(m_bEnabled));
    COPY_DATA(pbTStream, &m_eCurrBus, sizeof(m_eCurrBus));
    COPY_DATA(pbTStream, &m_ushFilters, sizeof(m_ushFilters));

    for (USHORT i = 0; i < m_ushFilters; i++)
    {
        switch (m_eCurrBus)
        {
            case CAN:
            {
                pbTStream = (((SFILTER_CAN*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            case FLEXRAY:
            {
                pbTStream = (((SFILTER_FLEXRAY*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            case MCNET:
            {
                pbTStream = (((SFILTER_MCNET*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            case J1939:
            {
                pbTStream = (((SFILTER_J1939*) m_psFilterInfo) + i)->pbGetConfigData(pbTStream);
            }
            break;
            default:
            {
                ASSERT(FALSE);
            }
            break;
        }
    }

    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve filtering data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a filtering block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves filtering block information and copies them into
                      the current object. Advances the reading pointer to the
                      next byte occurring after the block.
  Member of        :  tagFilterSet
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
******************************************************************************/
BYTE* tagFilterSet::pbSetConfigData(BYTE* pbTarget, bool& Result)
{
    vClear(); // First clear everything

    BYTE* pbTStream = pbTarget;
    Result = true;

    pbTStream = m_sFilterName.pbSetConfigData(pbTStream);
    COPY_DATA_2(&m_bEnabled, pbTStream, sizeof(m_bEnabled));
    COPY_DATA_2(&m_eCurrBus, pbTStream, sizeof(m_eCurrBus));
    COPY_DATA_2(&m_ushFilters, pbTStream, sizeof(m_ushFilters));

    if (m_ushFilters > 0)
    {
        switch (m_eCurrBus)
        {
            case CAN: m_psFilterInfo = new SFILTER_CAN[m_ushFilters]; break;
            case FLEXRAY: m_psFilterInfo = new SFILTER_FLEXRAY[m_ushFilters]; break;
            case MCNET: m_psFilterInfo = new SFILTER_MCNET[m_ushFilters]; break;
            case J1939: m_psFilterInfo = new SFILTER_J1939[m_ushFilters]; break;
            default: ASSERT(FALSE);
        }

        if (NULL != m_psFilterInfo)
        {
            switch (m_eCurrBus)
            {
                case CAN:
                {

                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_CAN*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                case FLEXRAY:
                {

                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_FLEXRAY*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                case MCNET:
                {
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_MCNET*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                case J1939:
                {
                    for (USHORT i = 0; i < m_ushFilters; i++)
                    {
                        pbTStream = (((SFILTER_J1939*) m_psFilterInfo) + i)->pbSetConfigData(pbTStream);
                    }
                }
                break;
                default:
                {
                    ASSERT(FALSE);
                }
                break;
            }
        }
        else
        {
            UINT unFilterSize = 0;
            switch (m_eCurrBus)
            {
                case CAN: unFilterSize = sizeof(SFILTER_CAN); break;
                case FLEXRAY: unFilterSize = sizeof(SFILTER_FLEXRAY); break;
                case MCNET: unFilterSize = sizeof(SFILTER_MCNET); break;
                case J1939: unFilterSize = sizeof(SFILTER_J1939); break;
                default: ASSERT(FALSE);
            }
            pbTStream += m_ushFilters * unFilterSize;
            m_ushFilters = 0;
            Result = false;
        }
    }

    return pbTStream;
}

tagFilterSet* tagFilterSet::psGetFilterSetPointer(tagFilterSet* psSet, UINT Count, char* acFilterName)
{    
    for (UINT i = 0; i < Count; i++)
    {
        tagFilterSet* psTemp = psSet + i;
        if ((psTemp != NULL) &&(_tcscmp(psTemp->m_sFilterName.m_acFilterName, acFilterName) == 0))
        {
            return psTemp;
        }
    }
    return NULL;
}

/* Ends SFILTERSET / tagFilterSet */


































int STJ1939_MSG::m_nSortField = 0;
int STJ1939_MSG::m_nMFactor = 1;


UINT32 tagSTRUCT_29_BIT_ID::unGetPGN(void)
{
    UINT32 unPGN = m_uPGN.m_unPGN & 0x3FFFF;
    if (m_uPGN.m_sPGN.m_byPDU_Format < 240)
    {
        unPGN = m_uPGN.m_unPGN & 0x3FF00;
    }
    return unPGN;
}

void tagSTRUCT_29_BIT_ID::vSetPGN(UINT32 unPGN)
{
    UNION_PGN uPGN;
    uPGN.m_unPGN = unPGN & 0x3FFFF; 
    m_uPGN.m_unPGN = m_uPGN.m_unPGN & 0xFFFC00FF;   
    
    BYTE byPduFormat = (BYTE)(unPGN >> 8);
    if  (byPduFormat < 240)
    {
        m_uPGN.m_unPGN |= (unPGN & 0x3FF00);
    }
    else
    {
        m_uPGN.m_unPGN |= unPGN;
    }
}


tagSTJ1939_MSG::tagSTJ1939_MSG() 
{
    memset(&m_sMsgProperties, 0, sizeof(STJ1939_MSG_PROPERTIES));
    m_unDLC = 0;
    m_pbyData = 0;
}


tagSTJ1939_MSG::~tagSTJ1939_MSG() 
{
    memset(&m_sMsgProperties, 0, sizeof(STJ1939_MSG_PROPERTIES));
    m_unDLC = 0;
    { if (0 != m_pbyData) { delete[] m_pbyData; m_pbyData = 0; } };
}


UINT tagSTJ1939_MSG::unGetSize(void) const
{
    return (sizeof(STJ1939_MSG_PROPERTIES) + sizeof (UINT) + (sizeof (BYTE) * m_unDLC) );
}

void tagSTJ1939_MSG::vGetDataStream(BYTE* pbyData) const
{
    {memcpy(pbyData, &m_sMsgProperties, sizeof(STJ1939_MSG_PROPERTIES)); pbyData += sizeof(STJ1939_MSG_PROPERTIES);};
    {memcpy(pbyData, &m_unDLC, sizeof (UINT)); pbyData += sizeof (UINT);};
    {memcpy(pbyData, m_pbyData, (sizeof (BYTE) * m_unDLC)); pbyData += (sizeof (BYTE) * m_unDLC);};
}

void tagSTJ1939_MSG::vSetDataStream(BYTE* pbyData)
{
    {memcpy(&m_sMsgProperties, pbyData, sizeof(STJ1939_MSG_PROPERTIES)); pbyData += sizeof(STJ1939_MSG_PROPERTIES);};
    UINT unTempDLC = 0;
    {memcpy(&unTempDLC, pbyData, sizeof (UINT)); pbyData += sizeof (UINT);};
    if ( m_pbyData == 0)
    {
        
        m_pbyData = new BYTE[1785];
    }
    m_unDLC = unTempDLC;
    {memcpy(m_pbyData, pbyData, (sizeof (BYTE) * m_unDLC)); pbyData += (sizeof (BYTE) * m_unDLC);};
}
void tagSTJ1939_MSG::vInitialize(int nSize)
{
	if (m_unDLC < (UINT)nSize)
	{
		{ if (0 != m_pbyData) { delete[] m_pbyData; m_pbyData = 0; } };        
        m_pbyData = new BYTE[nSize];
    }
    m_unDLC = nSize;
}

tagSTJ1939_MSG& tagSTJ1939_MSG::operator=(const tagSTJ1939_MSG& RefObj)
{
	m_sMsgProperties = RefObj.m_sMsgProperties;
	if (m_unDLC < RefObj.m_unDLC)
	{
		delete[] m_pbyData;
		m_pbyData = new BYTE[RefObj.m_unDLC];
	}
	memcpy(m_pbyData, RefObj.m_pbyData, RefObj.m_unDLC);
	m_unDLC = RefObj.m_unDLC;
	return *this;
}

void tagSTJ1939_MSG::vSetSortField(int nField)
{
    m_nSortField = nField;
}

void tagSTJ1939_MSG::vSetSortAscending(bool bAscending)
{
    m_nMFactor = bAscending ? 1 : -1;
};

int tagSTJ1939_MSG::DoCompareIndiv(const void* pEntry1, const void* pEntry2)
{
	UINT Result = 0;

    STJ1939_MSG* pJ1939Msg1 = (STJ1939_MSG*) pEntry1;
    STJ1939_MSG* pJ1939Msg2 = (STJ1939_MSG*) pEntry2;

    switch (m_nSortField)
    {
		case 8: 
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_uPGN.m_sPGN.m_byPDU_Specific - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_uPGN.m_sPGN.m_byPDU_Specific);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 7: 
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_bySrcAddress - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_bySrcAddress);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 4: 
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN() - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN());
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 3: 
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_unExtID - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_unExtID);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
        case 2: 
        {
			Result = (int) (pJ1939Msg1->m_sMsgProperties.m_byChannel - pJ1939Msg2->m_sMsgProperties.m_byChannel);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
        case 1: 
        {
			Result = (int) (pJ1939Msg1->m_sMsgProperties.m_un64TimeStamp - 
							pJ1939Msg2->m_sMsgProperties.m_un64TimeStamp);
            Result *= m_nMFactor;
		}
		break;
        default:
        {
            ((void)0);
        }
        break;
    }
    return Result;
}

__int64 tagSTJ1939_MSG::GetSlotID(STJ1939_MSG& pouJ1939Msg)
{				
	
	UINT nMsgID = (((pouJ1939Msg.m_sMsgProperties.m_eDirection & 0x02)) ? (pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN()) : ((pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN()) | TX_MESSAGE));
    
    
    nMsgID = (nMsgID | 0x40000000);
    
    __int64 n64MapIndex = ( ((unsigned __int64)((UINT)(nMsgID))) | (((__int64)(pouJ1939Msg.m_sMsgProperties.m_byChannel)) << 32) );

	n64MapIndex = ( ((unsigned __int64)((n64MapIndex))) | (((__int64)(pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.m_bySrcAddress)) << 40) );

	n64MapIndex = ( ((unsigned __int64)((n64MapIndex))) | (((__int64)(pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.m_uPGN.m_sPGN.m_byPDU_Specific)) << 48) );

	n64MapIndex = ( ((unsigned __int64)((n64MapIndex))) | (((__int64)(pouJ1939Msg.m_sMsgProperties.m_eType)) << 56) );

	return n64MapIndex;
};


void tagSTJ1939_MSG::vClear(void)
{   
    m_sMsgProperties.m_eType = MSG_TYPE_NONE;
    m_unDLC = 0;
    { if (0 != m_pbyData) { delete[] m_pbyData; m_pbyData = 0; } };
}


tagFormattedData_J1939::tagFormattedData_J1939()
{
    _tcsnset(m_acTimeSys,   L'\0', 16);
    _tcsnset(m_acTimeRel,   L'\0', 16);
    _tcsnset(m_acTimeAbs,   L'\0', 16);

    _tcsnset(m_acMsgType,   L'\0', 32     );
    _tcsnset(m_acChannel,   L'\0', 4  );

    _tcsnset(m_acPGNHex,    L'\0', 16      );
    _tcsnset(m_acPGNDec,    L'\0', 16      );
    _tcsnset(m_acMsgName,   L'\0', 64     );
    _tcsnset(m_acSenderName,L'\0', 32 );

    _tcsnset(m_acSrcHex,    L'\0', 4      );
    _tcsnset(m_acSrcDec,    L'\0', 4      );
    _tcsnset(m_acDestHex,   L'\0', 4     );
    _tcsnset(m_acDestDec,   L'\0', 4     );


    _tcsnset(m_acPriority,  L'\0', 4     );
    _tcsnset(m_acMsgDir,    L'\0', 3      );
    _tcsnset(m_acDataLen,   L'\0', 5      );

    m_acMsgDir[3 - 2] = L'x'; 

    m_pcDataHex = 0;
    m_pcDataDec = 0;
}

tagFormattedData_J1939::~tagFormattedData_J1939()
{
    { if (0 != m_pcDataHex) { delete[] m_pcDataHex; m_pcDataHex = 0; } };
    { if (0 != m_pcDataDec) { delete[] m_pcDataDec; m_pcDataDec = 0; } };
}




void GetMessageTypeStr(EJ1939_MSG_TYPE eType, char acResult[32])
{
    switch (eType)
    {
        case MSG_TYPE_NONE:            strcpy(acResult, "NONE");      break;
        case MSG_TYPE_COMMAND:         strcpy(acResult, "CMD");       break;
        case MSG_TYPE_REQUEST:         strcpy(acResult, "RQST");      break;
        case MSG_TYPE_DATA:            strcpy(acResult, "DATA");      break;
        case MSG_TYPE_BROADCAST:       strcpy(acResult, "BROADCAST"); break;
        case MSG_TYPE_ACKNOWLEDGEMENT: strcpy(acResult, "ACK");       break;
        case MSG_TYPE_GROUP_FUNCTIONS: strcpy(acResult, "GRP_FUNC");  break;
             
        case MSG_TYPE_NM_ACL:          strcpy(acResult, "ACL");       break;
        case MSG_TYPE_NM_RQST_ACL:     strcpy(acResult, "RQST_ACL");  break;
        case MSG_TYPE_NM_CMD_ADDRESS:  strcpy(acResult, "CA");        break;
        case MSG_TYPE_NM_TPCM_BAM:     strcpy(acResult, "BAM");       break;
        case MSG_TYPE_NM_TPCM_RTS:     strcpy(acResult, "RTS");       break;
        case MSG_TYPE_NM_TPCM_CTS:     strcpy(acResult, "CTS");       break;
        case MSG_TYPE_NM_TPCM_EOM_ACK: strcpy(acResult, "EOM");       break;
        case MSG_TYPE_NM_TPCM_CON_ABORT: 
                                       strcpy(acResult, "CON_ABORT"); break;
        case MSG_TYPE_NM_TPDT:         strcpy(acResult, "TPDT");      break;
        default: ((void)0);
    }
}


          ß      ß   E   Úÿÿÿÿ   Úÿÿÿÿ    ”~À      expression was true       ((pouJ1939Msg.m_sMsgProperties.m_eDirection & 0x02))    ßÿÿÿÿ   Ú      ßÿÿÿÿ   Ú   E   expression was false       ((pouJ1939Msg.m_sMsgProperties.m_eDirection & 0x02))    ßÿÿÿÿ   Ú      ßÿÿÿÿ   Ú   E               '	°                     Šÿÿÿÿ   Šÿÿÿÿ    ˜Ø      expression was true       bAscending    ÿÿÿÿ   Š      ÿÿÿÿ   Š      expression was false       bAscending    ÿÿÿÿ   Š      ÿÿÿÿ   Š                             ÿÿÿÿ  ÿÿÿÿ    ;¸è      expression was false       0 != m_pcDataDec   ÿÿÿÿ       ÿÿÿÿ                    ;µx                  ÿÿÿÿ  ÿÿÿÿ    ;´`      expression was false       0 != m_pcDataHex   ÿÿÿÿ       ÿÿÿÿ                    ;±x         ú      ú      ïÿÿÿÿ   ïÿÿÿÿ    *=       expression was false       0 != m_pbyData    úÿÿÿÿ   ï      úÿÿÿÿ   ï                  *9         Ç      Ç      Âÿÿÿÿ   Âÿÿÿÿ    /$8      expression was false       Result != 0    Çÿÿÿÿ   Â      Çÿÿÿÿ   Â                  ˆî8         ¾      ¾      ¹ÿÿÿÿ   ¹ÿÿÿÿ           expression was false       Result != 0    ¾ÿÿÿÿ   ¹      ¾ÿÿÿÿ   ¹                  ™p   	      ´      ´      ¯ÿÿÿÿ   ¯ÿÿÿÿ    ™ˆ      expression was false       Result != 0    ´ÿÿÿÿ   ¯      ´ÿÿÿÿ   ¯                  ”{    
      ª      ª      ¥ÿÿÿÿ   ¥ÿÿÿÿ     éÈ      expression was false       Result != 0    ªÿÿÿÿ   ¥      ªÿÿÿÿ   ¥                   6A                        ›ÿÿÿÿ   ›ÿÿÿÿ     2ï       expression was false       Result != 0     ÿÿÿÿ   ›       ÿÿÿÿ   ›                  ‰÷0         ~      ~      yÿÿÿÿ   yÿÿÿÿ     ö@      expression was false       m_unDLC < RefObj.m_unDLC    ~ÿÿÿÿ   y      ~ÿÿÿÿ   y                    u   	   u      pÿÿÿÿ   pÿÿÿÿ    /*      expression was false       0 != m_pbyData    uÿÿÿÿ   p   	   uÿÿÿÿ   p                  =ğ         s      s      nÿÿÿÿ   nÿÿÿÿ    ˆí`      expression was false       m_unDLC < (UINT)nSize    sÿÿÿÿ   n      sÿÿÿÿ   n                    i   
   i      dÿÿÿÿ   dÿÿÿÿ    x      expression was false       m_pbyData == 0    iÿÿÿÿ   d   
   iÿÿÿÿ   d                  5U@         T      T      Oÿÿÿÿ   Oÿÿÿÿ    '      expression was false       0 != m_pbyData    Tÿÿÿÿ   O      Tÿÿÿÿ   O                  VMH         /   	   /   +   *ÿÿÿÿ   *ÿÿÿÿ    ¿Ëx      expression was false       m_uPGN.m_sPGN.m_byPDU_Format < 240    /ÿÿÿÿ   *   	   /ÿÿÿÿ   *   +                =     =     2ÿÿÿÿ  2ÿÿÿÿ    U¨ğ       statement executed        }   =ÿÿÿÿ  2     =ÿÿÿÿ  2                   :   G  :   M  /ÿÿÿÿ  /ÿÿÿÿ    U¨       statement executed        break;   :ÿÿÿÿ  /   G  :ÿÿÿÿ  /   M                9   G  9   M  .ÿÿÿÿ  .ÿÿÿÿ    U§        statement executed        break;   9ÿÿÿÿ  .   G  9ÿÿÿÿ  .   M                7   G  7   M  ,ÿÿÿÿ  ,ÿÿÿÿ    U¥è       statement executed        break;   7ÿÿÿÿ  ,   G  7ÿÿÿÿ  ,   M                6   G  6   M  +ÿÿÿÿ  +ÿÿÿÿ    U¤Ğ       statement executed        break;   6ÿÿÿÿ  +   G  6ÿÿÿÿ  +   M                5   G  5   M  *ÿÿÿÿ  *ÿÿÿÿ    U£¸       statement executed        break;   5ÿÿÿÿ  *   G  5ÿÿÿÿ  *   M                4   G  4   M  )ÿÿÿÿ  )ÿÿÿÿ    U¢        statement executed        break;   4ÿÿÿÿ  )   G  4ÿÿÿÿ  )   M                3   G  3   M  (ÿÿÿÿ  (ÿÿÿÿ    U¡ˆ       statement executed        break;   3ÿÿÿÿ  (   G  3ÿÿÿÿ  (   M                2   G  2   M  'ÿÿÿÿ  'ÿÿÿÿ    U p       statement executed        break;   2ÿÿÿÿ  '   G  2ÿÿÿÿ  '   M                1   G  1   M  &ÿÿÿÿ  &ÿÿÿÿ    ÿP       statement executed        break;   1ÿÿÿÿ  &   G  1ÿÿÿÿ  &   M                /   G  /   M  $ÿÿÿÿ  $ÿÿÿÿ    ş8       statement executed        break;   /ÿÿÿÿ  $   G  /ÿÿÿÿ  $   M                .   G  .   M  #ÿÿÿÿ  #ÿÿÿÿ    ı        statement executed        break;   .ÿÿÿÿ  #   G  .ÿÿÿÿ  #   M                -   G  -   M  "ÿÿÿÿ  "ÿÿÿÿ    ü       statement executed        break;   -ÿÿÿÿ  "   G  -ÿÿÿÿ  "   M                ,   G  ,   M  !ÿÿÿÿ  !ÿÿÿÿ    úğ       statement executed        break;   ,ÿÿÿÿ  !   G  ,ÿÿÿÿ  !   M                 +   G  +   M   ÿÿÿÿ   ÿÿÿÿ    ùØ       statement executed        break;   +ÿÿÿÿ      G  +ÿÿÿÿ      M           !     *   G  *   M  ÿÿÿÿ  ÿÿÿÿ    øÀ       statement executed        break;   *ÿÿÿÿ     G  *ÿÿÿÿ     M           "     )   G  )   M  ÿÿÿÿ  ÿÿÿÿ    ÷¨       statement executed        break;   )ÿÿÿÿ     G  )ÿÿÿÿ     M           #                 ÿÿÿÿ  ÿÿÿÿ    ;¹Ğ       statement executed        }    ÿÿÿÿ        ÿÿÿÿ                $        F     G  ÿÿÿÿ  ÿÿÿÿ    ;¸       statement executed        }   ÿÿÿÿ     F  ÿÿÿÿ     G           %        F     G  ÿÿÿÿ  ÿÿÿÿ    ;³ˆ       statement executed        }   ÿÿÿÿ     F  ÿÿÿÿ     G           &               ÿÿÿÿ  ÿÿÿÿ     şİÀ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                '      û      û      ğÿÿÿÿ   ğÿÿÿÿ    *=è       statement executed        }    ûÿÿÿÿ   ğ      ûÿÿÿÿ   ğ              (      ú   @   ú   A   ïÿÿÿÿ   ïÿÿÿÿ    *<(       statement executed        }    úÿÿÿÿ   ï   @   úÿÿÿÿ   ï   A           )      ò      ò      çÿÿÿÿ   çÿÿÿÿ    –ğ       statement executed        return n64MapIndex;    òÿÿÿÿ   ç      òÿÿÿÿ   ç              *      Ù      Ù      Ôÿÿÿÿ   Ôÿÿÿÿ     é        statement executed        return Result;    Ùÿÿÿÿ   Ô      Ùÿÿÿÿ   Ô              +      ×   	   ×      Òÿÿÿÿ   Òÿÿÿÿ    Oú        statement executed        break;    ×ÿÿÿÿ   Ò   	   ×ÿÿÿÿ   Ò              ,      Ò      Ò   	   Íÿÿÿÿ   Íÿÿÿÿ    °X       statement executed        break;    Òÿÿÿÿ   Í      Òÿÿÿÿ   Í   	           -      É      É      Äÿÿÿÿ   Äÿÿÿÿ    VFØ       statement executed        break;    Éÿÿÿÿ   Ä      Éÿÿÿÿ   Ä              .      À      À      »ÿÿÿÿ   »ÿÿÿÿ    hˆ       statement executed        break;    Àÿÿÿÿ   »      Àÿÿÿÿ   »              /      ¶      ¶      ±ÿÿÿÿ   ±ÿÿÿÿ    ”}è       statement executed        break;    ¶ÿÿÿÿ   ±      ¶ÿÿÿÿ   ±              0      ¬      ¬      §ÿÿÿÿ   §ÿÿÿÿ     éè       statement executed        break;    ¬ÿÿÿÿ   §      ¬ÿÿÿÿ   §              1      ¢      ¢      ÿÿÿÿ   ÿÿÿÿ    OûÀ       statement executed        break;    ¢ÿÿÿÿ         ¢ÿÿÿÿ                 2                  ‹ÿÿÿÿ   ‹ÿÿÿÿ    ˆì       statement executed        }    ÿÿÿÿ   ‹      ÿÿÿÿ   ‹              3      ‹      ‹      †ÿÿÿÿ   †ÿÿÿÿ     ıNø       statement executed        }    ‹ÿÿÿÿ   †      ‹ÿÿÿÿ   †              4      …      …      €ÿÿÿÿ   €ÿÿÿÿ    ˆáX       statement executed        return *this;    …ÿÿÿÿ   €      …ÿÿÿÿ   €              5      ‚      ‚      }ÿÿÿÿ   }ÿÿÿÿ    h¨       statement executed        }    ‚ÿÿÿÿ   }      ‚ÿÿÿÿ   }              6      y      y      tÿÿÿÿ   tÿÿÿÿ    ™°       statement executed        }    yÿÿÿÿ   t      yÿÿÿÿ   t              7      w      w      rÿÿÿÿ   rÿÿÿÿ     ò.       statement executed        }    wÿÿÿÿ   r      wÿÿÿÿ   r              8      u   >   u   ?   pÿÿÿÿ   pÿÿÿÿ    È       statement executed        }    uÿÿÿÿ   p   >   uÿÿÿÿ   p   ?           9      p      p      kÿÿÿÿ   kÿÿÿÿ    ˆï        statement executed        }    pÿÿÿÿ   k      pÿÿÿÿ   k              :      m      m      hÿÿÿÿ   hÿÿÿÿ     6JØ       statement executed        }    mÿÿÿÿ   h      mÿÿÿÿ   h              ;      2      2      -ÿÿÿÿ   -ÿÿÿÿ    
       statement executed        }    2ÿÿÿÿ   -      2ÿÿÿÿ   -              <      3      3      .ÿÿÿÿ   .ÿÿÿÿ    ?‡°       statement executed        return unPGN;    3ÿÿÿÿ   .      3ÿÿÿÿ   .              =      @      @      ;ÿÿÿÿ   ;ÿÿÿÿ    ~X       statement executed        }    @ÿÿÿÿ   ;      @ÿÿÿÿ   ;              >      D      D      ?ÿÿÿÿ   ?ÿÿÿÿ     6Aè       statement executed        }    Dÿÿÿÿ   ?      Dÿÿÿÿ   ?              ?      M      M      Hÿÿÿÿ   Hÿÿÿÿ    Eı¨       statement executed        }    Mÿÿÿÿ   H      Mÿÿÿÿ   H              @      T   @   T   A   Oÿÿÿÿ   Oÿÿÿÿ    ˆåh       statement executed        }    Tÿÿÿÿ   O   @   Tÿÿÿÿ   O   A           A      U      U      Pÿÿÿÿ   Pÿÿÿÿ    ”yØ       statement executed        }    Uÿÿÿÿ   P      Uÿÿÿÿ   P              B      Z      Z   Z   Uÿÿÿÿ   Uÿÿÿÿ     ìÈğ       statement executed        return (sizeof(STJ1939_MSG_PROPERTIES) + sizeof (UINT) + (sizeof (BYTE) * m_unDLC) );    Zÿÿÿÿ   U      Zÿÿÿÿ   U   Z           C      b      b      ]ÿÿÿÿ   ]ÿÿÿÿ     ø(       statement executed        }    bÿÿÿÿ   ]      bÿÿÿÿ   ]           tagSTRUCT_29_BIT_ID::unGetPGN UINT32 tagSTRUCT_29_BIT_ID::unGetPGN(void)    -      4      (ÿÿÿÿ   /ÿÿÿÿtagSTRUCT_29_BIT_ID::vSetPGN void tagSTRUCT_29_BIT_ID::vSetPGN(UINT32 unPGN)    7      E      2ÿÿÿÿ   @ÿÿÿÿtagSTJ1939_MSG::tagSTJ1939_MSG tagSTJ1939_MSG::tagSTJ1939_MSG()    I      M      Dÿÿÿÿ   HÿÿÿÿtagSTJ1939_MSG::~tagSTJ1939_MSG tagSTJ1939_MSG::~tagSTJ1939_MSG()    Q      U      Lÿÿÿÿ   PÿÿÿÿtagSTJ1939_MSG::unGetSize UINT tagSTJ1939_MSG::unGetSize(void)    Y      [      Tÿÿÿÿ   VÿÿÿÿtagSTJ1939_MSG::vGetDataStream void tagSTJ1939_MSG::vGetDataStream(BYTE* pbyData)    ^      b      Yÿÿÿÿ   ]ÿÿÿÿtagSTJ1939_MSG::vSetDataStream void tagSTJ1939_MSG::vSetDataStream(BYTE* pbyData)    e      p      `ÿÿÿÿ   kÿÿÿÿtagSTJ1939_MSG::vInitialize void tagSTJ1939_MSG::vInitialize(int nSize)    r      y      mÿÿÿÿ   tÿÿÿÿtagSTJ1939_MSG::operator= tagSTJ1939_MSG& tagSTJ1939_MSG::operator=(const tagSTJ1939_MSG& RefObj)    |      †      wÿÿÿÿ   ÿÿÿÿtagSTJ1939_MSG::vSetSortField void tagSTJ1939_MSG::vSetSortField(int nField)    ‰      ‹      „ÿÿÿÿ   †ÿÿÿÿtagSTJ1939_MSG::vSetSortAscending void tagSTJ1939_MSG::vSetSortAscending(bool bAscending)                ‰ÿÿÿÿ   ‹ÿÿÿÿtagSTJ1939_MSG::DoCompareIndiv int tagSTJ1939_MSG::DoCompareIndiv(const void* pEntry1, const void* pEntry2)    “      Ú      ÿÿÿÿ   ÕÿÿÿÿtagSTJ1939_MSG::GetSlotID __int64 tagSTJ1939_MSG::GetSlotID(STJ1939_MSG& pouJ1939Msg)    İ      ó      Øÿÿÿÿ   èÿÿÿÿtagSTJ1939_MSG::vClear void tagSTJ1939_MSG::vClear(void)    ÷      û      ìÿÿÿÿ   ğÿÿÿÿtagFormattedData_J1939::tagFormattedData_J1939 tagFormattedData_J1939::tagFormattedData_J1939()    ÿ           ôÿÿÿÿ  ÿÿÿÿtagFormattedData_J1939::~tagFormattedData_J1939 tagFormattedData_J1939::~tagFormattedData_J1939()              ÿÿÿÿ  ÿÿÿÿGetMessageTypeStr void GetMessageTypeStr(EJ1939_MSG_TYPE eType, char acResult[32])   &     =     ÿÿÿÿ  2ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/******************************************************************************
  Project       :  Auto-SAT_Tools
  FileName      :  DataTypes_J1939.cpp
  Description   :  
  $Log:   X:/Archive/Sources/DataTypes/J1939_DataTypes.cpv  $
   
      Rev 1.5   15 Apr 2011 18:55:06   rac2kor
   Inserted RBEI Copyright information text into the file header.
   
      Rev 1.4   04 Mar 2011 17:30:38   CANMNTTM
   Updated to solve the issues in J1939 MsgWnd:
   1. Sorting issues in J1939 Msg Wnd.
   2. Problem with J1939 messages with DLC > 150.
   
      Rev 1.3   18 Feb 2011 12:06:46   CANMNTTM
   Updated to suite multiple message windows for buses.
   
      Rev 1.2   14 Dec 2010 17:52:16   CANMNTTM
   Added a member function vSetPGN for STRUCT_29_BIT_ID.
   
   
      Rev 1.1   13 Dec 2010 21:21:46   rac2kor
   1. Added a data member for message type in SFORMATTEDATA_J1939
   2. Added a helper function to get the associated text for a type.
   
      Rev 1.0   06 Dec 2010 18:34:32   rac2kor
    

  Author(s)     :  Pradeep Kadoor
  Date Created  :  23/11/2010
  Modified By   :  
  Copyright (c) 2011, Robert Bosch Engineering and Business Solutions.  All rights reserved.
******************************************************************************/
#include "Datatypes_stdafx.h"
#include "Include/BaseDefs.h"
#include "Include/Utils_Macro.h"
#include "J1939_DataTypes.h"
#include "application/hashdefines.h"

int STJ1939_MSG::m_nSortField = 0;
int STJ1939_MSG::m_nMFactor = 1;

/* strcut STRUCT_29_BIT_ID*/
UINT32 tagSTRUCT_29_BIT_ID::unGetPGN(void)
{
    UINT32 unPGN = m_uPGN.m_unPGN & 0x3FFFF;
    if (m_uPGN.m_sPGN.m_byPDU_Format < 240)
    {
        unPGN = m_uPGN.m_unPGN & 0x3FF00;
    }
    return unPGN;
}

void tagSTRUCT_29_BIT_ID::vSetPGN(UINT32 unPGN)
{
    UNION_PGN uPGN;
    uPGN.m_unPGN = unPGN & 0x3FFFF; //Mask unecessary bits.
    m_uPGN.m_unPGN = m_uPGN.m_unPGN & 0xFFFC00FF;   //Mask PGN bits 
    
    BYTE byPduFormat = (BYTE)(unPGN >> 8);
    if  (byPduFormat < 240)
    {
        m_uPGN.m_unPGN |= (unPGN & 0x3FF00);
    }
    else
    {
        m_uPGN.m_unPGN |= unPGN;
    }
}

/* Constructor*/
tagSTJ1939_MSG::tagSTJ1939_MSG() 
{
    memset(&m_sMsgProperties, 0, sizeof(STJ1939_MSG_PROPERTIES));
    m_unDLC = 0;
    m_pbyData = NULL;
}

/* Destructor */
tagSTJ1939_MSG::~tagSTJ1939_MSG() 
{
    memset(&m_sMsgProperties, 0, sizeof(STJ1939_MSG_PROPERTIES));
    m_unDLC = 0;
    DELETE_ARRAY(m_pbyData);
}

/* returns the total size of the message.*/
UINT tagSTJ1939_MSG::unGetSize(void) const
{
    return (sizeof(STJ1939_MSG_PROPERTIES) + sizeof (UINT) + (sizeof (BYTE) * m_unDLC) );
}
/* Renders the BYTE stream of the total message. */
void tagSTJ1939_MSG::vGetDataStream(BYTE* pbyData) const
{
    COPY_DATA(pbyData, &m_sMsgProperties, sizeof(STJ1939_MSG_PROPERTIES));
    COPY_DATA(pbyData, &m_unDLC, sizeof (UINT));
    COPY_DATA(pbyData, m_pbyData, (sizeof (BYTE) * m_unDLC));
}

void tagSTJ1939_MSG::vSetDataStream(BYTE* pbyData)
{
    COPY_DATA_2(&m_sMsgProperties, pbyData,  sizeof(STJ1939_MSG_PROPERTIES));
    UINT unTempDLC = 0;
    COPY_DATA_2(&unTempDLC, pbyData, sizeof (UINT));
    if (/*unTempDLC > m_unDLC*/ m_pbyData == NULL)
    {
        //DELETE_ARRAY(m_pbyData);
        m_pbyData = new BYTE[MAX_DATA_LEN_J1939];
    }
    m_unDLC = unTempDLC;
    COPY_DATA_2(m_pbyData, pbyData, (sizeof (BYTE) * m_unDLC));
}
void tagSTJ1939_MSG::vInitialize(int nSize)
{
	if (m_unDLC < (UINT)nSize)
	{
		DELETE_ARRAY(m_pbyData);        
        m_pbyData = new BYTE[nSize];
    }
    m_unDLC = nSize;
}

tagSTJ1939_MSG& tagSTJ1939_MSG::operator=(const tagSTJ1939_MSG& RefObj)
{
	m_sMsgProperties = RefObj.m_sMsgProperties;
	if (m_unDLC < RefObj.m_unDLC)
	{
		delete[] m_pbyData;
		m_pbyData = new BYTE[RefObj.m_unDLC];
	}
	memcpy(m_pbyData, RefObj.m_pbyData, RefObj.m_unDLC);
	m_unDLC = RefObj.m_unDLC;
	return *this;
}

void tagSTJ1939_MSG::vSetSortField(int nField)
{
    m_nSortField = nField;
}

void tagSTJ1939_MSG::vSetSortAscending(bool bAscending)
{
    m_nMFactor = bAscending ? 1 : -1;
};

int tagSTJ1939_MSG::DoCompareIndiv(const void* pEntry1, const void* pEntry2)
{
	UINT Result = 0;

    STJ1939_MSG* pJ1939Msg1 = (STJ1939_MSG*) pEntry1;
    STJ1939_MSG* pJ1939Msg2 = (STJ1939_MSG*) pEntry2;

    switch (m_nSortField)
    {
		case 8: // Sort by DEST
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_uPGN.m_sPGN.m_byPDU_Specific - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_uPGN.m_sPGN.m_byPDU_Specific);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 7: // Sort by SRC
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_bySrcAddress - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_s29BitId.m_bySrcAddress);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 4: // Sort by PGN
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN() - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN());
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 3: // Sort by CANID
        {
			Result = (UINT) (pJ1939Msg1->m_sMsgProperties.m_uExtendedID.m_unExtID - 
							 pJ1939Msg2->m_sMsgProperties.m_uExtendedID.m_unExtID);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
        case 2: // Sort by channel
        {
			Result = (int) (pJ1939Msg1->m_sMsgProperties.m_byChannel - pJ1939Msg2->m_sMsgProperties.m_byChannel);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
        case 1: // Sort by time stamp
        {
			Result = (int) (pJ1939Msg1->m_sMsgProperties.m_un64TimeStamp - 
							pJ1939Msg2->m_sMsgProperties.m_un64TimeStamp);
            Result *= m_nMFactor;
		}
		break;
        default:
        {
            ASSERT(FALSE);
        }
        break;
    }
    return Result;
}

__int64 tagSTJ1939_MSG::GetSlotID(STJ1939_MSG& pouJ1939Msg)
{				
	// Form message to get message index in the CMap
	UINT nMsgID = MAKE_RX_TX_MESSAGE( 
			pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.unGetPGN(), 
			IS_RX_MESSAGE(pouJ1939Msg.m_sMsgProperties.m_eDirection));
    
    // For extended message
    nMsgID = MAKE_EXTENDED_MESSAGE_TYPE(nMsgID);
    // Apply Channel Information
    __int64 n64MapIndex = MAKE_CHANNEL_SPECIFIC_MESSAGE( nMsgID,
							pouJ1939Msg.m_sMsgProperties.m_byChannel);

	n64MapIndex = MAKE_SOURCE_SPECIFIC_MESSAGE( n64MapIndex,
							pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.m_bySrcAddress);

	n64MapIndex = MAKE_DEST_SPECIFIC_MESSAGE( n64MapIndex,
							pouJ1939Msg.m_sMsgProperties.m_uExtendedID.m_s29BitId.m_uPGN.m_sPGN.m_byPDU_Specific);

	n64MapIndex = MAKE_TYPE_SPECIFIC_MESSAGE( n64MapIndex,
							pouJ1939Msg.m_sMsgProperties.m_eType);

	return n64MapIndex;
};


void tagSTJ1939_MSG::vClear(void)
{   
    m_sMsgProperties.m_eType = MSG_TYPE_NONE;
    m_unDLC = 0;
    DELETE_ARRAY(m_pbyData);
}

/* Starts tagFormattedData_J1939 related codes */
tagFormattedData_J1939::tagFormattedData_J1939()
{
    _tcsnset(m_acTimeSys,   L'\0', LEN_STR_TIMESTAMP_J1939);
    _tcsnset(m_acTimeRel,   L'\0', LEN_STR_TIMESTAMP_J1939);
    _tcsnset(m_acTimeAbs,   L'\0', LEN_STR_TIMESTAMP_J1939);

    _tcsnset(m_acMsgType,   L'\0', LEN_STR_TYPE_J1939     );
    _tcsnset(m_acChannel,   L'\0', LEN_STR_CHANNEL_J1939  );

    _tcsnset(m_acPGNHex,    L'\0', LEN_STR_PGN_J1939      );
    _tcsnset(m_acPGNDec,    L'\0', LEN_STR_PGN_J1939      );
    _tcsnset(m_acMsgName,   L'\0', LEN_STR_NAME_J1939     );
    _tcsnset(m_acSenderName,L'\0', LEN_STR_SENDNODE_J1939 );

    _tcsnset(m_acSrcHex,    L'\0', LEN_STR_SRC_J1939      );
    _tcsnset(m_acSrcDec,    L'\0', LEN_STR_SRC_J1939      );
    _tcsnset(m_acDestHex,   L'\0', LEN_STR_DEST_J1939     );
    _tcsnset(m_acDestDec,   L'\0', LEN_STR_DEST_J1939     );


    _tcsnset(m_acPriority,  L'\0', LEN_STR_PRIO_J1939     );
    _tcsnset(m_acMsgDir,    L'\0', LEN_STR_DIR_J1939      );
    _tcsnset(m_acDataLen,   L'\0', LEN_STR_DLC_J1939      );

    m_acMsgDir[LEN_STR_DIR_J1939 - 2] = L'x'; // It will be either Tx or Rx

    m_pcDataHex = NULL;
    m_pcDataDec = NULL;
}

tagFormattedData_J1939::~tagFormattedData_J1939()
{
    DELETE_ARRAY(m_pcDataHex);
    DELETE_ARRAY(m_pcDataDec);
}
/* Ends tagFormattedData_J1939 related codes */


// Helper functions start
void GetMessageTypeStr(EJ1939_MSG_TYPE eType, char acResult[LEN_STR_TYPE_J1939])
{
    switch (eType)
    {
        case MSG_TYPE_NONE:            _tcscpy(acResult, "NONE");      break;
        case MSG_TYPE_COMMAND:         _tcscpy(acResult, "CMD");       break;
        case MSG_TYPE_REQUEST:         _tcscpy(acResult, "RQST");      break;
        case MSG_TYPE_DATA:            _tcscpy(acResult, "DATA");      break;
        case MSG_TYPE_BROADCAST:       _tcscpy(acResult, "BROADCAST"); break;
        case MSG_TYPE_ACKNOWLEDGEMENT: _tcscpy(acResult, "ACK");       break;
        case MSG_TYPE_GROUP_FUNCTIONS: _tcscpy(acResult, "GRP_FUNC");  break;
             
        case MSG_TYPE_NM_ACL:          _tcscpy(acResult, "ACL");       break;
        case MSG_TYPE_NM_RQST_ACL:     _tcscpy(acResult, "RQST_ACL");  break;
        case MSG_TYPE_NM_CMD_ADDRESS:  _tcscpy(acResult, "CA");        break;
        case MSG_TYPE_NM_TPCM_BAM:     _tcscpy(acResult, "BAM");       break;
        case MSG_TYPE_NM_TPCM_RTS:     _tcscpy(acResult, "RTS");       break;
        case MSG_TYPE_NM_TPCM_CTS:     _tcscpy(acResult, "CTS");       break;
        case MSG_TYPE_NM_TPCM_EOM_ACK: _tcscpy(acResult, "EOM");       break;
        case MSG_TYPE_NM_TPCM_CON_ABORT: 
                                       _tcscpy(acResult, "CON_ABORT"); break;
        case MSG_TYPE_NM_TPDT:         _tcscpy(acResult, "TPDT");      break;
        default: ASSERT(FALSE);
    }
}

// Helper functions end








































tagLogInfo::tagLogInfo()
{
    vClear();
}













void tagLogInfo::vClear(void)
{
    m_ushID              = 0x0;
    m_bIsUpdated         = 1;
    m_bEnabled           = 1;
    m_eLogTimerMode      = TIME_MODE_SYSTEM;
    m_eNumFormat         = HEXADECIMAL;
    m_eFileMode          = APPEND_MODE;
    m_bResetAbsTimeStamp = 0;
    m_ChannelSelected    = CHANNEL_All_UNSPECIFIED;
    strcpy_s(m_sLogFileName, 260, "");

    
    m_sLogTrigger.m_unTriggerType = NONE;   
    m_sLogTrigger.m_unStartID = 0;	        
    m_sLogTrigger.m_unStopID = 0;           
}













UINT tagLogInfo::unGetSize(void) const
{
    UINT Result = 
        sizeof(m_bIsUpdated) + sizeof(m_bEnabled) + sizeof(m_eLogTimerMode) + 
        sizeof(m_eNumFormat) + sizeof(m_eFileMode) + sizeof(m_bResetAbsTimeStamp) + sizeof(m_ChannelSelected)
        + sizeof(m_sLogFileName) + sizeof(m_sLogTrigger);

    return Result;
}

















BYTE* tagLogInfo::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    {memcpy(pbTStream, &m_bIsUpdated, sizeof(m_bIsUpdated )); pbTStream += sizeof(m_bIsUpdated );};
    {memcpy(pbTStream, &m_bEnabled, sizeof(m_bEnabled )); pbTStream += sizeof(m_bEnabled );};
    {memcpy(pbTStream, &m_eLogTimerMode, sizeof(m_eLogTimerMode )); pbTStream += sizeof(m_eLogTimerMode );};
    {memcpy(pbTStream, &m_eNumFormat, sizeof(m_eNumFormat )); pbTStream += sizeof(m_eNumFormat );};
    {memcpy(pbTStream, &m_eFileMode, sizeof(m_eFileMode )); pbTStream += sizeof(m_eFileMode );};
    {memcpy(pbTStream, &m_bResetAbsTimeStamp, sizeof(m_bResetAbsTimeStamp)); pbTStream += sizeof(m_bResetAbsTimeStamp);};
    {memcpy(pbTStream, &m_ChannelSelected, sizeof(m_ChannelSelected )); pbTStream += sizeof(m_ChannelSelected );};
    {memcpy(pbTStream, m_sLogFileName, sizeof(m_sLogFileName )); pbTStream += sizeof(m_sLogFileName );};
    {memcpy(pbTStream, &m_sLogTrigger, sizeof(m_sLogTrigger )); pbTStream += sizeof(m_sLogTrigger );};

    return pbTStream;
}

















BYTE* tagLogInfo::pbSetConfigData(BYTE* pbSource, BYTE bytLogVersion)
{
    BYTE* pbSStream = pbSource;

    {memcpy(&m_bIsUpdated, pbSStream, sizeof(m_bIsUpdated )); pbSStream += sizeof(m_bIsUpdated );};
    {memcpy(&m_bEnabled, pbSStream, sizeof(m_bEnabled )); pbSStream += sizeof(m_bEnabled );};
    {memcpy(&m_eLogTimerMode, pbSStream, sizeof(m_eLogTimerMode )); pbSStream += sizeof(m_eLogTimerMode );};
    {memcpy(&m_eNumFormat, pbSStream, sizeof(m_eNumFormat )); pbSStream += sizeof(m_eNumFormat );};
    {memcpy(&m_eFileMode, pbSStream, sizeof(m_eFileMode )); pbSStream += sizeof(m_eFileMode );};

	
	if ( bytLogVersion > 0x1 )
		{memcpy(&m_bResetAbsTimeStamp, pbSStream, sizeof(m_bResetAbsTimeStamp)); pbSStream += sizeof(m_bResetAbsTimeStamp);};
    
	{memcpy(&m_ChannelSelected, pbSStream, sizeof(m_ChannelSelected )); pbSStream += sizeof(m_ChannelSelected );};
    {memcpy(m_sLogFileName, pbSStream, sizeof(m_sLogFileName )); pbSStream += sizeof(m_sLogFileName );};
    {memcpy(&m_sLogTrigger, pbSStream, sizeof(m_sLogTrigger )); pbSStream += sizeof(m_sLogTrigger );};

    return pbSStream;
}

          ¢      ¢      Ÿÿÿÿÿ   Ÿÿÿÿÿ    IĞ      expression was false       bytLogVersion > 0x1    ¢ÿÿÿÿ   Ÿ      ¢ÿÿÿÿ   Ÿ                    ©      ©      ¦ÿÿÿÿ   ¦ÿÿÿÿ    >È       statement executed        return pbSStream;    ©ÿÿÿÿ   ¦      ©ÿÿÿÿ   ¦                    £   v   £   w    ÿÿÿÿ    ÿÿÿÿ    ?‡°       statement executed        }    £ÿÿÿÿ       v   £ÿÿÿÿ       w                 „      „      ÿÿÿÿ   ÿÿÿÿ    ¿Ëx       statement executed        return pbTStream;    „ÿÿÿÿ         „ÿÿÿÿ                       c      c      `ÿÿÿÿ   `ÿÿÿÿ    
       statement executed        return Result;    cÿÿÿÿ   `      cÿÿÿÿ   `                    N      N      Kÿÿÿÿ   Kÿÿÿÿ    /!H       statement executed        }    Nÿÿÿÿ   K      Nÿÿÿÿ   K                    0      0      -ÿÿÿÿ   -ÿÿÿÿ    Oø       statement executed        }    0ÿÿÿÿ   -      0ÿÿÿÿ   -           tagLogInfo::tagLogInfo tagLogInfo::tagLogInfo()    .      0      +ÿÿÿÿ   -ÿÿÿÿtagLogInfo::vClear void tagLogInfo::vClear(void)    ?      N      <ÿÿÿÿ   KÿÿÿÿtagLogInfo::unGetSize UINT tagLogInfo::unGetSize(void)    ]      d      Zÿÿÿÿ   aÿÿÿÿtagLogInfo::pbGetConfigData BYTE* tagLogInfo::pbGetConfigData(BYTE* pbTarget)    w      …      tÿÿÿÿ   ‚ÿÿÿÿtagLogInfo::pbSetConfigData BYTE* tagLogInfo::pbSetConfigData(BYTE* pbSource, BYTE bytLogVersion)    ˜      ª      •ÿÿÿÿ   §ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Log_Datatypes.cpp
 * \brief     Source file for log data types.
 * \author    Ratnadip Choudhury
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file for log data types.
 */


#include "DataTypes_StdAfx.h"
#include "include/Utils_macro.h"
#include "Log_Datatypes.h"


/* tagLogInfo --- STARTS */

/******************************************************************************
  Function Name    :  tagLogInfo
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  tagLogInfo
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
tagLogInfo::tagLogInfo()
{
    vClear();
}

/******************************************************************************
  Function Name    :  vClear
  Input(s)         :  void
  Output           :  void
  Functionality    :  Clears information inthe current logging block
  Member of        :  tagLogInfo
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void tagLogInfo::vClear(void)
{
    m_ushID              = 0x0;
    m_bIsUpdated         = TRUE;
    m_bEnabled           = TRUE;
    m_eLogTimerMode      = TIME_MODE_SYSTEM;
    m_eNumFormat         = HEXADECIMAL;
    m_eFileMode          = APPEND_MODE;
    m_bResetAbsTimeStamp = FALSE;
    m_ChannelSelected    = CHANNEL_All_UNSPECIFIED;
    strcpy_s(m_sLogFileName, _MAX_PATH, "");

    // Init Trigger Condition
    m_sLogTrigger.m_unTriggerType = NONE;   // No trigger
    m_sLogTrigger.m_unStartID = 0;	        // No Start-ID
    m_sLogTrigger.m_unStopID = 0;           // No Stop-ID
}

/******************************************************************************
  Function Name    :  unGetSize
  Input(s)         :  void
  Output           :  UINT - size of the current logging block
  Functionality    :  Returns in bytes size of the current logging block.
  Member of        :  tagLogInfo
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
UINT tagLogInfo::unGetSize(void) const
{
    UINT Result = 
        sizeof(m_bIsUpdated) + sizeof(m_bEnabled) + sizeof(m_eLogTimerMode) + 
        sizeof(m_eNumFormat) + sizeof(m_eFileMode) + sizeof(m_bResetAbsTimeStamp) + sizeof(m_ChannelSelected)
        + sizeof(m_sLogFileName) + sizeof(m_sLogTrigger);

    return Result;
}

/******************************************************************************
  Function Name    :  pbGetConfigData
  Input(s)         :  pbTarget - The target buffer to save logging data.
                      It assumes that pbTarget is currently pointing to a loca-
                      tion having sufficient space.
  Output           :  BYTE * - Location of the next available buffer.
  Functionality    :  Saves logging block information of the current object into
                      the target buffer. Advances the writing pointer to the
                      next byte occurring after the written block.
  Member of        :  tagLogInfo
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* tagLogInfo::pbGetConfigData(BYTE* pbTarget) const
{
    BYTE* pbTStream = pbTarget;

    COPY_DATA(pbTStream, &m_bIsUpdated,       sizeof(m_bIsUpdated        ));
    COPY_DATA(pbTStream, &m_bEnabled,         sizeof(m_bEnabled          ));
    COPY_DATA(pbTStream, &m_eLogTimerMode,    sizeof(m_eLogTimerMode     ));
    COPY_DATA(pbTStream, &m_eNumFormat,       sizeof(m_eNumFormat        ));
    COPY_DATA(pbTStream, &m_eFileMode,        sizeof(m_eFileMode         ));
    COPY_DATA(pbTStream, &m_bResetAbsTimeStamp, sizeof(m_bResetAbsTimeStamp));
    COPY_DATA(pbTStream, &m_ChannelSelected,  sizeof(m_ChannelSelected   ));
    COPY_DATA(pbTStream, m_sLogFileName,      sizeof(m_sLogFileName      ));
    COPY_DATA(pbTStream, &m_sLogTrigger,      sizeof(m_sLogTrigger       ));

    return pbTStream;
}

/******************************************************************************
  Function Name    :  pbSetConfigData
  Input(s)         :  pbSource - The source buffer to retrieve logging data.
                      It assumes that pbSource is currently pointing to locati-
                      on of a logging block data.
  Output           :  BYTE * - Location of the next byte after the block.
  Functionality    :  Retrieves logging block information and copies them into
                      the current object. Advances the reading pointer to the
                      next byte occurring after the block.
  Member of        :  tagLogInfo
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
BYTE* tagLogInfo::pbSetConfigData(BYTE* pbSource, BYTE bytLogVersion)
{
    BYTE* pbSStream = pbSource;

    COPY_DATA_2(&m_bIsUpdated,       pbSStream, sizeof(m_bIsUpdated      ));
    COPY_DATA_2(&m_bEnabled,         pbSStream, sizeof(m_bEnabled        ));
    COPY_DATA_2(&m_eLogTimerMode,    pbSStream, sizeof(m_eLogTimerMode   ));
    COPY_DATA_2(&m_eNumFormat,       pbSStream, sizeof(m_eNumFormat      ));
    COPY_DATA_2(&m_eFileMode,        pbSStream, sizeof(m_eFileMode       ));

	/* If version is 1.6.2 and above */
	if ( bytLogVersion > 0x1 )
		COPY_DATA_2(&m_bResetAbsTimeStamp, pbSStream, sizeof(m_bResetAbsTimeStamp));
    
	COPY_DATA_2(&m_ChannelSelected,  pbSStream, sizeof(m_ChannelSelected ));
    COPY_DATA_2(m_sLogFileName,      pbSStream, sizeof(m_sLogFileName    ));
    COPY_DATA_2(&m_sLogTrigger,      pbSStream, sizeof(m_sLogTrigger     ));

    return pbSStream;
}
/* tagLogInfo --- ENDS */

























SGUIPARAMS::SGUIPARAMS()
{
    m_acTitleName[260 - 1]     = '\0';
    m_acMainListName[260 - 1]  = '\0';
    m_acUnSelListName[260 - 1] = '\0';
    m_acSelListName[260 - 1]   = '\0';

    _tcsset(m_acTitleName, '\0');
    _tcsset(m_acMainListName, '\0');
    _tcsset(m_acUnSelListName, '\0');
    _tcsset(m_acSelListName, '\0');

    m_pomImageList      = 0;
    m_unUnSelIconIndex  = 0;
    m_unSelIconIndex    = 0;
    m_bCombine          = 1;
}



tagSubEntry::tagSubEntry()
{
}

tagSubEntry::~tagSubEntry()
{
}

BOOL tagSubEntry::operator ==(const tagSubEntry& RefObj) const
{
    BOOL bResult = 0;
    if (
        (m_omSubEntryName == RefObj.m_omSubEntryName))
    {
        bResult = 1;
    }
    return bResult;
}




tagMainEntry::tagMainEntry()
{
    vResetAll();
}

tagMainEntry::~tagMainEntry()
{
    vResetAll();
}

void tagMainEntry::vResetAll(void)
{
    m_unMainEntryID = 0;
    m_omMainEntryName = "";
    m_odUnSelEntryList.RemoveAll();
    m_odSelEntryList.RemoveAll();
}

tagMainEntry& tagMainEntry::operator=(tagMainEntry& RefObj)
{
    vResetAll();

    m_unMainEntryID     = RefObj.m_unMainEntryID;
    m_omMainEntryName   = RefObj.m_omMainEntryName;
    m_odUnSelEntryList.AddTail(&(RefObj.m_odUnSelEntryList));
    m_odSelEntryList.AddTail(&(RefObj.m_odSelEntryList));

    return *this;
}

BOOL tagMainEntry::operator==(const tagMainEntry& RefObj) const
{
    BOOL bResult = 0;
    if ((m_unMainEntryID == RefObj.m_unMainEntryID) ||
        (m_omMainEntryName == RefObj.m_omMainEntryName))
    {
        bResult = 1;
    }
    return bResult;
}

          g   	   g   4   eÿÿÿÿ   eÿÿÿÿ    h	8      expression was true       (m_unMainEntryID == RefObj.m_unMainEntryID)    gÿÿÿÿ   e   	   gÿÿÿÿ   e   4   expression was false       (m_unMainEntryID == RefObj.m_unMainEntryID)    gÿÿÿÿ   e   	   gÿÿÿÿ   e   4               ˆåh         h   	   h   8   fÿÿÿÿ   fÿÿÿÿ    /!H      expression was true       (m_omMainEntryName == RefObj.m_omMainEntryName)    hÿÿÿÿ   f   	   hÿÿÿÿ   f   8   expression was false       (m_omMainEntryName == RefObj.m_omMainEntryName)    hÿÿÿÿ   f   	   hÿÿÿÿ   f   8               ¿Ëx         <   	   <   6   :ÿÿÿÿ   :ÿÿÿÿ    VDğ      expression was false       (m_omSubEntryName == RefObj.m_omSubEntryName)    <ÿÿÿÿ   :   	   <ÿÿÿÿ   :   6               .Òˆ         l      l      jÿÿÿÿ   jÿÿÿÿ    Gx       statement executed        return bResult;    lÿÿÿÿ   j      lÿÿÿÿ   j                    k      k      iÿÿÿÿ   iÿÿÿÿ    h¦À       statement executed        }    kÿÿÿÿ   i      kÿÿÿÿ   i                    a      a      _ÿÿÿÿ   _ÿÿÿÿ    H˜ğ       statement executed        return *this;    aÿÿÿÿ   _      aÿÿÿÿ   _                    V      V      Tÿÿÿÿ   Tÿÿÿÿ     ö-Ø       statement executed        }    Vÿÿÿÿ   T      Vÿÿÿÿ   T              	      N      N      Lÿÿÿÿ   Lÿÿÿÿ    5U@       statement executed        }    Nÿÿÿÿ   L      Nÿÿÿÿ   L              
      I      I      Gÿÿÿÿ   Gÿÿÿÿ    EøÈ       statement executed        }    Iÿÿÿÿ   G      Iÿÿÿÿ   G                    @      @      >ÿÿÿÿ   >ÿÿÿÿ     6JØ       statement executed        return bResult;    @ÿÿÿÿ   >      @ÿÿÿÿ   >                    ?      ?      =ÿÿÿÿ   =ÿÿÿÿ    x       statement executed        }    ?ÿÿÿÿ   =      ?ÿÿÿÿ   =                    6      6      4ÿÿÿÿ   4ÿÿÿÿ     ó±è       statement executed        }    6ÿÿÿÿ   4      6ÿÿÿÿ   4                    2      2      0ÿÿÿÿ   0ÿÿÿÿ     ò.       statement executed        }    2ÿÿÿÿ   0      2ÿÿÿÿ   0                    ,      ,      *ÿÿÿÿ   *ÿÿÿÿ    Oø       statement executed        }    ,ÿÿÿÿ   *      ,ÿÿÿÿ   *           SGUIPARAMS::SGUIPARAMS SGUIPARAMS::SGUIPARAMS()          ,      ÿÿÿÿ   *ÿÿÿÿtagSubEntry::tagSubEntry tagSubEntry::tagSubEntry()    1      2      /ÿÿÿÿ   0ÿÿÿÿtagSubEntry::~tagSubEntry tagSubEntry::~tagSubEntry()    5      6      3ÿÿÿÿ   4ÿÿÿÿtagSubEntry::operator == BOOL tagSubEntry::operator ==(const tagSubEntry& RefObj)    9      A      7ÿÿÿÿ   ?ÿÿÿÿtagMainEntry::tagMainEntry tagMainEntry::tagMainEntry()    G      I      Eÿÿÿÿ   GÿÿÿÿtagMainEntry::~tagMainEntry tagMainEntry::~tagMainEntry()    L      N      Jÿÿÿÿ   LÿÿÿÿtagMainEntry::vResetAll void tagMainEntry::vResetAll(void)    Q      V      Oÿÿÿÿ   TÿÿÿÿtagMainEntry::operator= tagMainEntry& tagMainEntry::operator=(tagMainEntry& RefObj)    Y      b      Wÿÿÿÿ   `ÿÿÿÿtagMainEntry::operator== BOOL tagMainEntry::operator==(const tagMainEntry& RefObj)    e      m      cÿÿÿÿ   kÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      MainSubEntry.cpp
 * \brief     Implementation file for main sub entry entities.
 * \author    Ratnadip Choudhury
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implementation file for main sub entry entities.
 */
#include "DataTypes_stdafx.h"
#include "MainSubEntry.h"

// Starts SGUIPARAMS
SGUIPARAMS::SGUIPARAMS()
{
    m_acTitleName[MAX_PATH - 1]     = _T('\0');
    m_acMainListName[MAX_PATH - 1]  = _T('\0');
    m_acUnSelListName[MAX_PATH - 1] = _T('\0');
    m_acSelListName[MAX_PATH - 1]   = _T('\0');

    _tcsset(m_acTitleName, _T('\0'));
    _tcsset(m_acMainListName, _T('\0'));
    _tcsset(m_acUnSelListName, _T('\0'));
    _tcsset(m_acSelListName, _T('\0'));

    m_pomImageList      = NULL;
    m_unUnSelIconIndex  = 0;
    m_unSelIconIndex    = 0;
    m_bCombine          = TRUE;
}
// Ends SGUIPARAMS

// Starts tagSubEntry 
tagSubEntry::tagSubEntry()
{
}

tagSubEntry::~tagSubEntry()
{
}

BOOL tagSubEntry::operator ==(const tagSubEntry& RefObj) const
{
    BOOL bResult = FALSE;
    if (/*(m_unSubEntryID == RefObj.m_unSubEntryID) || */
        (m_omSubEntryName == RefObj.m_omSubEntryName))
    {
        bResult = TRUE;
    }
    return bResult;
}
// Ends tagSubEntry


// Starts tagMainEntry structure
tagMainEntry::tagMainEntry()
{
    vResetAll();
}

tagMainEntry::~tagMainEntry()
{
    vResetAll();
}

void tagMainEntry::vResetAll(void)
{
    m_unMainEntryID = 0;
    m_omMainEntryName = "";
    m_odUnSelEntryList.RemoveAll();
    m_odSelEntryList.RemoveAll();
}

tagMainEntry& tagMainEntry::operator=(tagMainEntry& RefObj)
{
    vResetAll();

    m_unMainEntryID     = RefObj.m_unMainEntryID;
    m_omMainEntryName   = RefObj.m_omMainEntryName;
    m_odUnSelEntryList.AddTail(&(RefObj.m_odUnSelEntryList));
    m_odSelEntryList.AddTail(&(RefObj.m_odSelEntryList));

    return *this;
}

BOOL tagMainEntry::operator==(const tagMainEntry& RefObj) const
{
    BOOL bResult = FALSE;
    if ((m_unMainEntryID == RefObj.m_unMainEntryID) ||
        (m_omMainEntryName == RefObj.m_omMainEntryName))
    {
        bResult = TRUE;
    }
    return bResult;
}
// Ends tagMainEntry structure





































const size_t DATA_LEN_SIZE = sizeof(WORD);
const size_t TYPE_SIZE     = sizeof(BYTE);

const int HEADER_LEN = TYPE_SIZE + DATA_LEN_SIZE;

















CMsgBufVSE::CMsgBufVSE(void)
{
    m_nBufferSize = 5000;
    m_pbyMsgBuffer = new BYTE[5000];
    vClearMessageBuffer(); 
    InitializeCriticalSection(&m_CritSectionForGB);
    m_hNotifyingEvent = CreateEventA(0, 0, 0, 0);
}


CMsgBufVSE::~CMsgBufVSE(void)
{
    CloseHandle(m_hNotifyingEvent);
    m_hNotifyingEvent = 0;
    if (m_pbyMsgBuffer != 0)
    {
        delete[] m_pbyMsgBuffer;
        m_pbyMsgBuffer = 0;
    }
    DeleteCriticalSection(&m_CritSectionForGB);
}











void CMsgBufVSE::vClearMessageBuffer(void)
{
    memset(m_pbyMsgBuffer, 0, m_nBufferSize);
    m_nIndexRead = 0;
    m_nIndexWrite = 0;
    m_nMsgCount = 0;
    m_nMsgSkipped = 0;
}














HRESULT CMsgBufVSE::ReadFromBuffer(INT& nType, BYTE* pbyMsg, INT& nSize)
{
    HRESULT Result = CALL_SUCCESS;






    
    EnterCriticalSection(&m_CritSectionForGB);

    if (m_nMsgCount == 0)
    {
        Result = EMPTY_APP_BUFFER;
    }
    else
    {
        
        if ((Result = ReadBuffer(nType, pbyMsg, nSize)) == CALL_SUCCESS)
        {
            m_nMsgCount--;
        }
    }
    
    LeaveCriticalSection(&m_CritSectionForGB);

    return Result;
}














int CMsgBufVSE::WriteIntoBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;






    EnterCriticalSection(&m_CritSectionForGB);
    
    if (nSize > m_nBufferSize)
    {
        nResult = ERR_WRITE_MSG_TOO_LARGE;
    }
    else
    {
        nResult = nHandleBufferOverrun(nSize + HEADER_LEN);
        nWriteBuffer(nType, pbyMsg, nSize);
        ++m_nMsgCount;
        SetEvent(m_hNotifyingEvent);
    }

    LeaveCriticalSection(&m_CritSectionForGB);

    return nResult;
}

int CMsgBufVSE::GetMsgCount(void) const
{
    return m_nMsgCount;
}

HANDLE CMsgBufVSE::hGetNotifyingEvent(void) const
{
    return m_hNotifyingEvent;
}

int CMsgBufVSE::GetBufferLength(void) const
{
    return m_nBufferSize;
}
















int CMsgBufVSE::nSetBufferSize(int& nSize)
{
    int nResult = CALL_SUCCESS;
    if (nSize < 5000)
    {
        nSize = 5000;
        nResult =  WARN_BUFFER_SIZE_MIN_ASSUMED;
    }
    else if (nSize > 100000)
    {
        nSize = 5000;
        nResult = WARN_BUFFER_SIZE_MAX_ASSUMED;
    }

    EnterCriticalSection(&m_CritSectionForGB);

    if (m_pbyMsgBuffer != 0)
    {
        delete[] m_pbyMsgBuffer;
    }
    m_nBufferSize = nSize;
    m_pbyMsgBuffer = new BYTE[nSize];
    if (m_pbyMsgBuffer == 0)
    {
        nResult = ERR_CREATE_MEMORY_FAIL;
        m_nBufferSize = 0;
    }
    else
    {
        vClearMessageBuffer();
    }

    LeaveCriticalSection(&m_CritSectionForGB);
    
    return nResult;
}













HRESULT CMsgBufVSE::AdvanceToNextMsg()
{
    HRESULT Result = CALL_SUCCESS;
    if (m_nMsgCount == 0)
    {
        Result = EMPTY_APP_BUFFER;
    }
    else
    {        
        nAdvanceReadIndex();
                            
    }
    return Result;
}











int CMsgBufVSE::nAdvanceReadIndex(void)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[HEADER_LEN] = {0};
    nGetCurrMsgHeader(abyHeader); 

    int nMsgLen = 0;
    memcpy(&nMsgLen, abyHeader + 1, DATA_LEN_SIZE);
    if ((m_nIndexRead + HEADER_LEN + nMsgLen) < m_nBufferSize)
    {
        m_nIndexRead += (HEADER_LEN + nMsgLen);
    }
    else
    {
        m_nIndexRead = (m_nIndexRead + HEADER_LEN + nMsgLen) - m_nBufferSize;
    }    
    m_nMsgSkipped++;
    m_nMsgCount--;        
    return nResult;
}













int CMsgBufVSE::nWriteBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[HEADER_LEN] = {0};
    nResult = nConstructHeader(nType, nSize, abyHeader);
    ((void)0);
    if ((m_nIndexWrite + HEADER_LEN + nSize) <= m_nBufferSize)
    {
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, HEADER_LEN);
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + HEADER_LEN, pbyMsg, nSize);

        m_nIndexWrite += (HEADER_LEN + nSize);
    }
    else if (m_nIndexWrite + HEADER_LEN <= m_nBufferSize)
    {   
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, HEADER_LEN);
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + HEADER_LEN, pbyMsg, (m_nBufferSize - m_nIndexWrite - HEADER_LEN));
        memcpy(m_pbyMsgBuffer, pbyMsg +(m_nBufferSize - m_nIndexWrite - HEADER_LEN), nSize - (m_nBufferSize - m_nIndexWrite - HEADER_LEN));

        m_nIndexWrite = (nSize - (m_nBufferSize - m_nIndexWrite - HEADER_LEN));
    }
    else
    {
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, (m_nBufferSize - m_nIndexWrite));
        memcpy(m_pbyMsgBuffer, abyHeader + (m_nBufferSize - m_nIndexWrite), HEADER_LEN - (m_nBufferSize - m_nIndexWrite));
        
        memcpy(m_pbyMsgBuffer + (HEADER_LEN - (m_nBufferSize - m_nIndexWrite)), pbyMsg, nSize);
        m_nIndexWrite = (HEADER_LEN - (m_nBufferSize - m_nIndexWrite)) + nSize;
    }
    return nResult;
}













HRESULT CMsgBufVSE::ReadBuffer(INT& nType, BYTE* pbyMsg, INT& nSize) 
{
    HRESULT Return = CALL_SUCCESS;
    BYTE abyHeader[HEADER_LEN];
    Return = nGetCurrMsgHeader(abyHeader);
    
    ((void)0);
    WORD MsgLen = 0;
    BYTE Type;
    memcpy(&Type, (abyHeader + 0), TYPE_SIZE);
    nType = (INT) Type;
    memcpy(&MsgLen, (abyHeader + 1), DATA_LEN_SIZE);
    if ((int) MsgLen > nSize)
    {
        Return = ERR_READ_MEMORY_SHORT;
        nSize   = MsgLen - nSize;
    }
    else  
    {            
        if ((m_nIndexRead + HEADER_LEN + MsgLen) <= m_nBufferSize)
        { 
            memcpy(pbyMsg, (m_pbyMsgBuffer + m_nIndexRead + HEADER_LEN), MsgLen);
            m_nIndexRead += (HEADER_LEN + MsgLen);
        }
        else if ((m_nIndexRead + HEADER_LEN) <= m_nBufferSize)
        {                     
            memcpy(pbyMsg, (m_pbyMsgBuffer + m_nIndexRead + HEADER_LEN), (m_nBufferSize - m_nIndexRead - HEADER_LEN));
            memcpy((pbyMsg + (m_nBufferSize - m_nIndexRead - HEADER_LEN)), m_pbyMsgBuffer, (MsgLen - (m_nBufferSize - m_nIndexRead - HEADER_LEN)));
            m_nIndexRead = MsgLen - (m_nBufferSize - m_nIndexRead - HEADER_LEN);                
        }
        else
        {
            memcpy(pbyMsg, (m_pbyMsgBuffer + (m_nIndexRead + HEADER_LEN - m_nBufferSize)), MsgLen);
            m_nIndexRead = (m_nIndexRead + HEADER_LEN - m_nBufferSize) +  MsgLen;
        }
        nSize = MsgLen;
    }
    return Return;
}











int CMsgBufVSE::nConstructHeader(INT nType, INT nSize, BYTE* pbyHeader)
{
    BYTE Type = (BYTE)nType;
    WORD MsgLen = (WORD)nSize;
    memcpy(pbyHeader + 0, &Type, TYPE_SIZE);
    memcpy(pbyHeader + 1, &MsgLen, DATA_LEN_SIZE);
    return CALL_SUCCESS;
}












int CMsgBufVSE::nGetCurrMsgHeader(BYTE* pbyHeader)
{
    if ((m_nIndexRead + HEADER_LEN) <= m_nBufferSize)
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + m_nIndexRead), HEADER_LEN);
    }
    else
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + m_nIndexRead), m_nBufferSize - m_nIndexRead);
        memcpy(pbyHeader + (m_nBufferSize - m_nIndexRead), m_pbyMsgBuffer, (m_nIndexRead + HEADER_LEN) - m_nBufferSize);
    }
    return CALL_SUCCESS;
}














int CMsgBufVSE::nHandleBufferOverrun(INT nSize)
{
    int nResult = CALL_SUCCESS;
    if (m_nIndexRead < m_nIndexWrite)
    {
        if ((m_nIndexRead + m_nBufferSize) <=  (m_nIndexWrite + nSize))
        {
            nResult = WARN_BUFFER_OVERRUN;
            nAdvanceReadIndex();
            nHandleBufferOverrun(nSize);
        }
    }
    else if (m_nIndexRead > m_nIndexWrite)
    {
        if ((m_nIndexRead) <=  (m_nIndexWrite + nSize))
        {
            nResult = WARN_BUFFER_OVERRUN;
            nAdvanceReadIndex();
            nHandleBufferOverrun(nSize);
        }
    }
    else
    {
        if (m_nMsgCount != 0)
        {
            nResult = WARN_BUFFER_OVERRUN;
            nAdvanceReadIndex();
            nHandleBufferOverrun(nSize);
        }
    }
    return nResult;
}
         ì     ì     éÿÿÿÿ  éÿÿÿÿ    ~8€      expression was false       m_nMsgCount != 0   ìÿÿÿÿ  é     ìÿÿÿÿ  é                  ™X        ã     ã   7  àÿÿÿÿ  àÿÿÿÿ    ™h      expression was false       (m_nIndexRead) <=  (m_nIndexWrite + nSize)   ãÿÿÿÿ  à     ãÿÿÿÿ  à   7               ™ˆ        Ú     Ú   G  ×ÿÿÿÿ  ×ÿÿÿÿ     ìË@      expression was false       (m_nIndexRead + m_nBufferSize) <=  (m_nIndexWrite + nSize)   Úÿÿÿÿ  ×     Úÿÿÿÿ  ×   G                ìÇÀ         é   	   é      æÿÿÿÿ   æÿÿÿÿ    ˆæ8      expression was false       m_pbyMsgBuffer != 0    éÿÿÿÿ   æ   	   éÿÿÿÿ   æ                  f Ø         á      á      Şÿÿÿÿ   Şÿÿÿÿ    x0      expression was false       nSize > 100000    áÿÿÿÿ   Ş      áÿÿÿÿ   Ş                    ‡      ‡   H   „ÿÿÿÿ   „ÿÿÿÿ    hĞ      expression was false       (Result = ReadBuffer(nType, pbyMsg, nSize)) == CALL_SUCCESS    ‡ÿÿÿÿ   „      ‡ÿÿÿÿ   „   H                ø(         L   	   L      Iÿÿÿÿ   Iÿÿÿÿ    f¸      expression was false       m_pbyMsgBuffer != 0    Lÿÿÿÿ   I   	   Lÿÿÿÿ   I                  ?‡°        ó     ó     ğÿÿÿÿ  ğÿÿÿÿ    ~;ğ       statement executed        return nResult;   óÿÿÿÿ  ğ     óÿÿÿÿ  ğ                   ò     ò     ïÿÿÿÿ  ïÿÿÿÿ    ~9h       statement executed        }   òÿÿÿÿ  ï     òÿÿÿÿ  ï              	     ñ   	  ñ   
  îÿÿÿÿ  îÿÿÿÿ    ~7¨       statement executed        }   ñÿÿÿÿ  î   	  ñÿÿÿÿ  î   
           
     é     é     æÿÿÿÿ  æÿÿÿÿ    ™P       statement executed        }   éÿÿÿÿ  æ     éÿÿÿÿ  æ                   è   	  è   
  åÿÿÿÿ  åÿÿÿÿ    ™       statement executed        }   èÿÿÿÿ  å   	  èÿÿÿÿ  å   
                à     à     İÿÿÿÿ  İÿÿÿÿ     ìÌ(       statement executed        }   àÿÿÿÿ  İ     àÿÿÿÿ  İ                   ß   	  ß   
  Üÿÿÿÿ  Üÿÿÿÿ     ìÊh       statement executed        }   ßÿÿÿÿ  Ü   	  ßÿÿÿÿ  Ü   
                Å     Å     Âÿÿÿÿ  Âÿÿÿÿ    ”wÀ       statement executed        return CALL_SUCCESS;   Åÿÿÿÿ  Â     Åÿÿÿÿ  Â                   Ä     Ä     Áÿÿÿÿ  Áÿÿÿÿ    –       statement executed        }   Äÿÿÿÿ  Á     Äÿÿÿÿ  Á                   ¿     ¿     ¼ÿÿÿÿ  ¼ÿÿÿÿ    –œÀ       statement executed        }   ¿ÿÿÿÿ  ¼     ¿ÿÿÿÿ  ¼                   ¬     ¬     ©ÿÿÿÿ  ©ÿÿÿÿ    –—Ø       statement executed        return CALL_SUCCESS;   ¬ÿÿÿÿ  ©     ¬ÿÿÿÿ  ©                   ™     ™     –ÿÿÿÿ  –ÿÿÿÿ    'H       statement executed        return Return;   ™ÿÿÿÿ  –     ™ÿÿÿÿ  –                   ˜     ˜     •ÿÿÿÿ  •ÿÿÿÿ     6FĞ       statement executed        }   ˜ÿÿÿÿ  •     ˜ÿÿÿÿ  •                   –   	  –   
  “ÿÿÿÿ  “ÿÿÿÿ     6BĞ       statement executed        }   –ÿÿÿÿ  “   	  –ÿÿÿÿ  “   
                ‘   	  ‘   
  ÿÿÿÿ  ÿÿÿÿ     éØ       statement executed        }   ‘ÿÿÿÿ     	  ‘ÿÿÿÿ     
                ‹   	  ‹   
  ˆÿÿÿÿ  ˆÿÿÿÿ    ²€       statement executed        }   ‹ÿÿÿÿ  ˆ   	  ‹ÿÿÿÿ  ˆ   
                „     „     ÿÿÿÿ  ÿÿÿÿ    h       statement executed        }   „ÿÿÿÿ       „ÿÿÿÿ                     e     e     bÿÿÿÿ  bÿÿÿÿ    5È¨       statement executed        return nResult;   eÿÿÿÿ  b     eÿÿÿÿ  b                   d     d     aÿÿÿÿ  aÿÿÿÿ    V@ˆ       statement executed        }   dÿÿÿÿ  a     dÿÿÿÿ  a                   [     [     Xÿÿÿÿ  Xÿÿÿÿ    Rtˆ       statement executed        }   [ÿÿÿÿ  X     [ÿÿÿÿ  X                   R     R     Oÿÿÿÿ  Oÿÿÿÿ    ?ƒ       statement executed        }   Rÿÿÿÿ  O     Rÿÿÿÿ  O                   5     5     2ÿÿÿÿ  2ÿÿÿÿ     ,…`       statement executed        return nResult;   5ÿÿÿÿ  2     5ÿÿÿÿ  2                   2     2     /ÿÿÿÿ  /ÿÿÿÿ    ?‚(       statement executed        }   2ÿÿÿÿ  /     2ÿÿÿÿ  /                   .     .     +ÿÿÿÿ  +ÿÿÿÿ    5Ç        statement executed        }   .ÿÿÿÿ  +     .ÿÿÿÿ  +                             ÿÿÿÿ  ÿÿÿÿ    `       statement executed        return Result;   ÿÿÿÿ       ÿÿÿÿ                                ÿÿÿÿ  ÿÿÿÿ     ıN       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                !               ÿÿÿÿ  ÿÿÿÿ    .İ¸       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                "      û      û      øÿÿÿÿ   øÿÿÿÿ    ?‚¸       statement executed        return nResult;    ûÿÿÿÿ   ø      ûÿÿÿÿ   ø              #      ÷      ÷      ôÿÿÿÿ   ôÿÿÿÿ    -n@       statement executed        }    ÷ÿÿÿÿ   ô      ÷ÿÿÿÿ   ô              $      ó      ó      ğÿÿÿÿ   ğÿÿÿÿ    -o        statement executed        }    óÿÿÿÿ   ğ      óÿÿÿÿ   ğ              %      ì      ì      éÿÿÿÿ   éÿÿÿÿ     /Üğ       statement executed        }    ìÿÿÿÿ   é      ìÿÿÿÿ   é              &      å      å      âÿÿÿÿ   âÿÿÿÿ    (©        statement executed        }    åÿÿÿÿ   â      åÿÿÿÿ   â              '      à      à      İÿÿÿÿ   İÿÿÿÿ     ô       statement executed        }    àÿÿÿÿ   İ      àÿÿÿÿ   İ              (      Ç      Ç      Äÿÿÿÿ   Äÿÿÿÿ    VN`       statement executed        return m_nBufferSize;    Çÿÿÿÿ   Ä      Çÿÿÿÿ   Ä              )      Â      Â      ¿ÿÿÿÿ   ¿ÿÿÿÿ    4Íà       statement executed        return m_hNotifyingEvent;    Âÿÿÿÿ   ¿      Âÿÿÿÿ   ¿              *      ½      ½      ºÿÿÿÿ   ºÿÿÿÿ    5Rh       statement executed        return m_nMsgCount;    ½ÿÿÿÿ   º      ½ÿÿÿÿ   º              +      ¸      ¸      µÿÿÿÿ   µÿÿÿÿ     õ        statement executed        return nResult;    ¸ÿÿÿÿ   µ      ¸ÿÿÿÿ   µ              ,      ´      ´      ±ÿÿÿÿ   ±ÿÿÿÿ    5V˜       statement executed        }    ´ÿÿÿÿ   ±      ´ÿÿÿÿ   ±              -      ­      ­      ªÿÿÿÿ   ªÿÿÿÿ    f¨       statement executed        }    ­ÿÿÿÿ   ª      ­ÿÿÿÿ   ª              .                  Œÿÿÿÿ   Œÿÿÿÿ    5Z        statement executed        return Result;    ÿÿÿÿ   Œ      ÿÿÿÿ   Œ              /      ‹      ‹      ˆÿÿÿÿ   ˆÿÿÿÿ    µ0       statement executed        }    ‹ÿÿÿÿ   ˆ      ‹ÿÿÿÿ   ˆ              0      Š   	   Š   
   ‡ÿÿÿÿ   ‡ÿÿÿÿ    hx       statement executed        }    Šÿÿÿÿ   ‡   	   Šÿÿÿÿ   ‡   
           1      ƒ      ƒ      €ÿÿÿÿ   €ÿÿÿÿ    x       statement executed        }    ƒÿÿÿÿ   €      ƒÿÿÿÿ   €              2      E      E      Bÿÿÿÿ   Bÿÿÿÿ    Do        statement executed        }    Eÿÿÿÿ   B      Eÿÿÿÿ   B              3      P      P      Mÿÿÿÿ   Mÿÿÿÿ    VB˜       statement executed        }    Pÿÿÿÿ   M      Pÿÿÿÿ   M              4      R      R      Oÿÿÿÿ   Oÿÿÿÿ    4Ïx       statement executed        }    Rÿÿÿÿ   O      Rÿÿÿÿ   O              5      e      e      bÿÿÿÿ   bÿÿÿÿ    5Pà       statement executed        }    eÿÿÿÿ   b      eÿÿÿÿ   b           CMsgBufVSE::CMsgBufVSE CMsgBufVSE::CMsgBufVSE(void)    ?      E      <ÿÿÿÿ   BÿÿÿÿCMsgBufVSE::~CMsgBufVSE CMsgBufVSE::~CMsgBufVSE(void)    I      R      Fÿÿÿÿ   OÿÿÿÿCMsgBufVSE::vClearMessageBuffer void CMsgBufVSE::vClearMessageBuffer(void)    _      e      \ÿÿÿÿ   bÿÿÿÿCMsgBufVSE::ReadFromBuffer HRESULT CMsgBufVSE::ReadFromBuffer(INT& nType, BYTE* pbyMsg, INT& nSize)    u            rÿÿÿÿ   ÿÿÿÿCMsgBufVSE::WriteIntoBuffer int CMsgBufVSE::WriteIntoBuffer(INT nType, BYTE* pbyMsg, INT nSize)           ¹      ÿÿÿÿ   ¶ÿÿÿÿCMsgBufVSE::GetMsgCount int CMsgBufVSE::GetMsgCount(void)    ¼      ¾      ¹ÿÿÿÿ   »ÿÿÿÿCMsgBufVSE::hGetNotifyingEvent HANDLE CMsgBufVSE::hGetNotifyingEvent(void)    Á      Ã      ¾ÿÿÿÿ   ÀÿÿÿÿCMsgBufVSE::GetBufferLength int CMsgBufVSE::GetBufferLength(void)    Æ      È      Ãÿÿÿÿ   ÅÿÿÿÿCMsgBufVSE::nSetBufferSize int CMsgBufVSE::nSetBufferSize(int& nSize)    Ú      ü      ×ÿÿÿÿ   ùÿÿÿÿCMsgBufVSE::AdvanceToNextMsg HRESULT CMsgBufVSE::AdvanceToNextMsg()             ÿÿÿÿ  ÿÿÿÿCMsgBufVSE::nAdvanceReadIndex int CMsgBufVSE::nAdvanceReadIndex(void)   $     6     !ÿÿÿÿ  3ÿÿÿÿCMsgBufVSE::nWriteBuffer int CMsgBufVSE::nWriteBuffer(INT nType, BYTE* pbyMsg, INT nSize)   E     f     Bÿÿÿÿ  cÿÿÿÿCMsgBufVSE::ReadBuffer HRESULT CMsgBufVSE::ReadBuffer(INT& nType, BYTE* pbyMsg, INT& nSize)   u     š     rÿÿÿÿ  —ÿÿÿÿCMsgBufVSE::nConstructHeader int CMsgBufVSE::nConstructHeader(INT nType, INT nSize, BYTE* pbyHeader)   §     ­     ¤ÿÿÿÿ  ªÿÿÿÿCMsgBufVSE::nGetCurrMsgHeader int CMsgBufVSE::nGetCurrMsgHeader(BYTE* pbyHeader)   »     Æ     ¸ÿÿÿÿ  ÃÿÿÿÿCMsgBufVSE::nHandleBufferOverrun int CMsgBufVSE::nHandleBufferOverrun(INT nSize)   Ö     ô     Óÿÿÿÿ  ñÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      MsgBufVSE.cpp
 * \brief     Source file of concrete class for circular queue in VSE.
 * \author    Pradeep Kadoor
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file of concrete class for circular queue in VSE.
 */


// Insert your headers here
//#include "CommonInclude.h"
#include "DataTypes_stdafx.h"
#include "MsgBufVSE.h"
//Error definition
#include "include/Error.h"


//type 
#define DATA_LEN   WORD
#define TYPE       BYTE
#define MAX_BUFFER_SIZE 100000
#define MIN_BUFFER_SIZE 5000

// Const variables
const size_t DATA_LEN_SIZE = sizeof(DATA_LEN);
const size_t TYPE_SIZE     = sizeof(TYPE);
//length
const int HEADER_LEN = TYPE_SIZE + DATA_LEN_SIZE;

//offset
#define TYPE_OFFSET     0
#define MSGLEN_OFFSET   1


/**********************************************************************************
Function Name   :   CMsgBufVSE() 
Input           :   
Output          :   
Functionality   :   Initializes buffer with minimum memory.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
CMsgBufVSE::CMsgBufVSE(void)
{
    m_nBufferSize = MIN_BUFFER_SIZE;
    m_pbyMsgBuffer = new BYTE[MIN_BUFFER_SIZE];// allocate memory first
    vClearMessageBuffer(); // Clear the message buffer
    InitializeCriticalSection(&m_CritSectionForGB);
    m_hNotifyingEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

//Destructor deallocates memory
CMsgBufVSE::~CMsgBufVSE(void)
{
    CloseHandle(m_hNotifyingEvent);
    m_hNotifyingEvent = NULL;
    if (m_pbyMsgBuffer != NULL)
    {
        delete[] m_pbyMsgBuffer;
        m_pbyMsgBuffer = NULL;
    }
    DeleteCriticalSection(&m_CritSectionForGB);
}
/**********************************************************************************
Function Name   :   vClearMessageBuffer()
Input           :   
Output          :   
Functionality   :   Clears msg buffer and initializes all variables.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
void CMsgBufVSE::vClearMessageBuffer(void)
{
    memset(m_pbyMsgBuffer, 0, m_nBufferSize);
    m_nIndexRead = 0;
    m_nIndexWrite = 0;
    m_nMsgCount = 0;
    m_nMsgSkipped = 0;
}

/**********************************************************************************
Function Name   :   ReadFromBuffer()
Input           :   TYPE, SIZE, pointer to msg.
Output          :   CALL_SUCCESS for success.                    
                    ERR_READ_MEMORY_SHORT when caller specifies size of the msg
                    less than required size.
Functionality   :   Interface function. reads current msg from circular buffer.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVSE::ReadFromBuffer(INT& nType, BYTE* pbyMsg, INT& nSize)
{
    HRESULT Result = CALL_SUCCESS;

#ifdef _DEBUG
    ASSERT(pbyMsg != NULL);
    ASSERT(!(m_nIndexRead > m_nBufferSize));
#endif

    // Lock the buffer
    EnterCriticalSection(&m_CritSectionForGB);

    if (m_nMsgCount == 0)
    {
        Result = EMPTY_APP_BUFFER;
    }
    else
    {
        //call the Helper function to read buffer
        if ((Result = ReadBuffer(nType, pbyMsg, nSize)) == CALL_SUCCESS)
        {
            m_nMsgCount--;
        }
    }
    // Unlock the buffer
    LeaveCriticalSection(&m_CritSectionForGB);

    return Result;
}

/**********************************************************************************
Function Name   :   WriteIntoBuffer()
Input           :   TYPE, SIZE, pointer to msg.
Output          :   CALL_SUCCESS for success.                    
                    ERR_WRITE_MSG_TOO_LARGE when caller specifies size of the msg
                    more than buffer size.
Functionality   :   Interface function. Writes msg into circular function.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVSE::WriteIntoBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;

#ifdef _DEBUG
    ASSERT(pbyMsg != NULL);
    ASSERT(!(m_nIndexWrite > m_nBufferSize));
#endif

    EnterCriticalSection(&m_CritSectionForGB);
    // Check the size of the message
    if (nSize > m_nBufferSize)
    {
        nResult = ERR_WRITE_MSG_TOO_LARGE;
    }
    else
    {
        nResult = nHandleBufferOverrun(nSize + HEADER_LEN);//helper function to handle buffer overrun
        nWriteBuffer(nType, pbyMsg, nSize);//helper function to write buffer
        ++m_nMsgCount;
        SetEvent(m_hNotifyingEvent);
    }

    LeaveCriticalSection(&m_CritSectionForGB);

    return nResult;
}

int CMsgBufVSE::GetMsgCount(void) const
{
    return m_nMsgCount;
}

HANDLE CMsgBufVSE::hGetNotifyingEvent(void) const
{
    return m_hNotifyingEvent;
}

int CMsgBufVSE::GetBufferLength(void) const
{
    return m_nBufferSize;
}

/**********************************************************************************
Function Name   :   nSetBufferSize()
Output          :   CALL_SUCCESS for success. 
                    WARN_BUFFER_SIZE_MIN_ASSUMED when caller specifies less than
                    minimum buffer size.
                    WARN_BUFFER_SIZE_MAX_ASSUMED when caller specifies more than
                    maximum buffer size.
Functionality   :   Interface function. Caller can set the buffer size.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/

int CMsgBufVSE::nSetBufferSize(int& nSize)
{
    int nResult = CALL_SUCCESS;
    if (nSize < MIN_BUFFER_SIZE)
    {
        nSize = MIN_BUFFER_SIZE;
        nResult =  WARN_BUFFER_SIZE_MIN_ASSUMED;
    }
    else if (nSize > MAX_BUFFER_SIZE)
    {
        nSize = MIN_BUFFER_SIZE;
        nResult = WARN_BUFFER_SIZE_MAX_ASSUMED;
    }

    EnterCriticalSection(&m_CritSectionForGB);

    if (m_pbyMsgBuffer != NULL)
    {
        delete[] m_pbyMsgBuffer;
    }
    m_nBufferSize = nSize;
    m_pbyMsgBuffer = new BYTE[nSize];
    if (m_pbyMsgBuffer == NULL)
    {
        nResult = ERR_CREATE_MEMORY_FAIL;
        m_nBufferSize = 0;
    }
    else
    {
        vClearMessageBuffer();
    }

    LeaveCriticalSection(&m_CritSectionForGB);
    
    return nResult;
}
/**********************************************************************************
Function Name   :   AdvanceToNextMsg()
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
                    if allocated memory by the caller is not enough.
Functionality   :   Interface function. Current msg is skipped.
                    Caller can use this function when wishes to skip the 
                    current msg due to memory constraint.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVSE::AdvanceToNextMsg()
{
    HRESULT Result = CALL_SUCCESS;
    if (m_nMsgCount == 0)
    {
        Result = EMPTY_APP_BUFFER;
    }
    else
    {        
        nAdvanceReadIndex();//Helper function to advance the read index
                            //to the next msg.
    }
    return Result;
}
/**********************************************************************************
Function Name   :   nAdvanceReadIndex()
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
                    if allocated memory by the caller is not enough.
Functionality   :   Helper function. Current msg is skipped.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVSE::nAdvanceReadIndex(void)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[HEADER_LEN] = {0};
    nGetCurrMsgHeader(abyHeader); // Get current msg header TYPE, MSG LENGTH

    int nMsgLen = 0;
    memcpy(&nMsgLen, abyHeader + MSGLEN_OFFSET, DATA_LEN_SIZE);
    if ((m_nIndexRead + HEADER_LEN + nMsgLen) < m_nBufferSize)
    {
        m_nIndexRead += (HEADER_LEN + nMsgLen);
    }
    else
    {
        m_nIndexRead = (m_nIndexRead + HEADER_LEN + nMsgLen) - m_nBufferSize;
    }    
    m_nMsgSkipped++;
    m_nMsgCount--;        
    return nResult;
}

/**********************************************************************************
Function Name   :   nWriteBuffer()
Input(s)        :   TYPE, SIZE, pointer to the message.
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   Helper function. Current msg is written into the 
                    circular buffer.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVSE::nWriteBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[HEADER_LEN] = {0};
    nResult = nConstructHeader(nType, nSize, abyHeader);//Helper function to construct header from TYPE, MSG LENGTH
    ASSERT(nResult == CALL_SUCCESS);
    if ((m_nIndexWrite + HEADER_LEN + nSize) <= m_nBufferSize)
    {
        //Write header
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, HEADER_LEN);
        //Write msg
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + HEADER_LEN, pbyMsg, nSize);

        m_nIndexWrite += (HEADER_LEN + nSize);
    }
    else if (m_nIndexWrite + HEADER_LEN <= m_nBufferSize)
    {   
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, HEADER_LEN);
        // Write msg
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + HEADER_LEN, pbyMsg, (m_nBufferSize - m_nIndexWrite - HEADER_LEN));
        memcpy(m_pbyMsgBuffer, pbyMsg +(m_nBufferSize - m_nIndexWrite - HEADER_LEN), nSize - (m_nBufferSize - m_nIndexWrite - HEADER_LEN));

        m_nIndexWrite = (nSize - (m_nBufferSize - m_nIndexWrite - HEADER_LEN));
    }
    else
    {
        //write the header
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, (m_nBufferSize - m_nIndexWrite));
        memcpy(m_pbyMsgBuffer, abyHeader + (m_nBufferSize - m_nIndexWrite), HEADER_LEN - (m_nBufferSize - m_nIndexWrite));
        //write the msg
        memcpy(m_pbyMsgBuffer + (HEADER_LEN - (m_nBufferSize - m_nIndexWrite)), pbyMsg, nSize);
        m_nIndexWrite = (HEADER_LEN - (m_nBufferSize - m_nIndexWrite)) + nSize;
    }
    return nResult;
}
/**********************************************************************************
Function Name   :   ReadBuffer()
Input(s)        :   TYPE, SIZE, pointer to the byte where header will be stored.
Output          :   CALL_SUCCESS for success. ERR_READ_MEMORY_SHORT
                    if allocated memory by the caller is not enough.
Functionality   :   Helper function. Current msg pointed by read index
                    is read.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVSE::ReadBuffer(INT& nType, BYTE* pbyMsg, INT& nSize) 
{
    HRESULT Return = CALL_SUCCESS;
    BYTE abyHeader[HEADER_LEN];
    Return = nGetCurrMsgHeader(abyHeader);
    // It is expected to return CALL_SUCCESS
    ASSERT(Return == CALL_SUCCESS);
    DATA_LEN MsgLen = 0;
    TYPE Type;
    memcpy(&Type, (abyHeader + TYPE_OFFSET), TYPE_SIZE);
    nType = (INT) Type;
    memcpy(&MsgLen, (abyHeader + MSGLEN_OFFSET), DATA_LEN_SIZE);
    if ((int) MsgLen > nSize)
    {
        Return = ERR_READ_MEMORY_SHORT;
        nSize   = MsgLen - nSize;
    }
    else  
    {            
        if ((m_nIndexRead + HEADER_LEN + MsgLen) <= m_nBufferSize)
        { 
            memcpy(pbyMsg, (m_pbyMsgBuffer + m_nIndexRead + HEADER_LEN), MsgLen);
            m_nIndexRead += (HEADER_LEN + MsgLen);
        }
        else if ((m_nIndexRead + HEADER_LEN) <= m_nBufferSize)
        {                     
            memcpy(pbyMsg, (m_pbyMsgBuffer + m_nIndexRead + HEADER_LEN), (m_nBufferSize - m_nIndexRead - HEADER_LEN));
            memcpy((pbyMsg + (m_nBufferSize - m_nIndexRead - HEADER_LEN)), m_pbyMsgBuffer, (MsgLen - (m_nBufferSize - m_nIndexRead - HEADER_LEN)));
            m_nIndexRead = MsgLen - (m_nBufferSize - m_nIndexRead - HEADER_LEN);                
        }
        else
        {
            memcpy(pbyMsg, (m_pbyMsgBuffer + (m_nIndexRead + HEADER_LEN - m_nBufferSize)), MsgLen);
            m_nIndexRead = (m_nIndexRead + HEADER_LEN - m_nBufferSize) +  MsgLen;
        }
        nSize = MsgLen;
    }
    return Return;
}
/**********************************************************************************
Function Name   :   nConstructHeader()
Input(s)        :   TYPE, SIZE, Array of byte where header will be stored.
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   Header is constructed with TYPE & SIZE.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVSE::nConstructHeader(INT nType, INT nSize, BYTE* pbyHeader)
{
    TYPE Type = (TYPE)nType;
    DATA_LEN MsgLen = (DATA_LEN)nSize;
    memcpy(pbyHeader + TYPE_OFFSET, &Type, TYPE_SIZE);
    memcpy(pbyHeader + MSGLEN_OFFSET, &MsgLen, DATA_LEN_SIZE);
    return CALL_SUCCESS;
}

/**********************************************************************************
Function Name   :   nGetCurrMsgHeader()
Input(s)        :   Array of byte where header will be stored.
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   Current msg's header is retrieved.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVSE::nGetCurrMsgHeader(BYTE* pbyHeader)
{
    if ((m_nIndexRead + HEADER_LEN) <= m_nBufferSize)
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + m_nIndexRead), HEADER_LEN);
    }
    else
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + m_nIndexRead), m_nBufferSize - m_nIndexRead);
        memcpy(pbyHeader + (m_nBufferSize - m_nIndexRead), m_pbyMsgBuffer, (m_nIndexRead + HEADER_LEN) - m_nBufferSize);
    }
    return CALL_SUCCESS;
}

/**********************************************************************************
Function Name   :   nHandleBufferOverrun()
Input(s)        :   -
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   If buffer overrun criteria is met, read index 
                    is advanced until it solves buffer overrun.
Member of       :   CMsgBufVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/

int CMsgBufVSE::nHandleBufferOverrun(INT nSize)
{
    int nResult = CALL_SUCCESS;
    if (m_nIndexRead < m_nIndexWrite)
    {
        if ((m_nIndexRead + m_nBufferSize) <=  (m_nIndexWrite + nSize))
        {
            nResult = WARN_BUFFER_OVERRUN;
            nAdvanceReadIndex();
            nHandleBufferOverrun(nSize);
        }
    }
    else if (m_nIndexRead > m_nIndexWrite)
    {
        if ((m_nIndexRead) <=  (m_nIndexWrite + nSize))
        {
            nResult = WARN_BUFFER_OVERRUN;
            nAdvanceReadIndex();
            nHandleBufferOverrun(nSize);
        }
    }
    else
    {
        if (m_nMsgCount != 0)
        {
            nResult = WARN_BUFFER_OVERRUN;
            nAdvanceReadIndex();
            nHandleBufferOverrun(nSize);
        }
    }
    return nResult;
}



































const size_t DATA_LEN_SIZE = sizeof(WORD);
const size_t TYPE_SIZE     = sizeof(BYTE);



















CMsgBufVVSE::CMsgBufVVSE(void)
{
    m_nBufferSize = 50000;
    m_pbyMsgBuffer = new BYTE[50000];
    vClearMessageBuffer(); 
    InitializeCriticalSection(&m_CritSectionForGB);
    m_hNotifyingEvent = CreateEventA(0, 1, 0, 0);
}


CMsgBufVVSE::~CMsgBufVVSE(void)
{
    CloseHandle(m_hNotifyingEvent);
    m_hNotifyingEvent = 0;
    if (m_pbyMsgBuffer != 0)
    {
        delete[] m_pbyMsgBuffer;
        m_pbyMsgBuffer = 0;
    }
    DeleteCriticalSection(&m_CritSectionForGB);
}











void CMsgBufVVSE::vClearMessageBuffer(void)
{
    memset(m_pbyMsgBuffer, 0, m_nBufferSize);
    m_nIndexWrite   = 0;
    m_nMsgCount     = 0;
    m_nStartIndex   = 0;
    m_nReadIndexTmp = 0;
    m_nTmpMsgCount  = 0;
}













HRESULT CMsgBufVVSE::SetStartPos(int nEntry)
{
    HRESULT Result = CALL_SUCCESS;
    if (nEntry < 0 || nEntry > m_nMsgCount)
    {
        Result = ERR_INVALID_INDEX;
    }
    else
    {
        m_nReadIndexTmp = m_nStartIndex;
        for (int i = 0; i < nEntry; i++)
        {
            nAdvanceReadIndex(m_nReadIndexTmp);
            m_nTmpMsgCount++;
        }
    }
    return Result;

}















HRESULT CMsgBufVVSE::ReadEntry(int& nType, BYTE* pbyMsg, int& nSize, int nEntry, BOOL bSetNextIndexStartPos)
{
    
    EnterCriticalSection(&m_CritSectionForGB);

    HRESULT Result = CALL_SUCCESS;
    if ((nEntry < 0) || ((nEntry + m_nTmpMsgCount) > m_nMsgCount))
    {
        Result = ERR_INVALID_INDEX;
    }
    else
    {
        int nTmpIndex = m_nReadIndexTmp;
        for (int i = 0; i < nEntry; i++)
        {
            nAdvanceReadIndex(nTmpIndex);
        }
        Result = ReadBuffer(nType, pbyMsg, nSize, nTmpIndex);
        if ((Result == CALL_SUCCESS) && (bSetNextIndexStartPos == 1))
        {
            m_nReadIndexTmp = nTmpIndex;
            m_nTmpMsgCount += nEntry;
        }
    }

    
    LeaveCriticalSection(&m_CritSectionForGB);
    return Result;
}














int CMsgBufVVSE::WriteIntoBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;






    EnterCriticalSection(&m_CritSectionForGB);
    
    if (nSize > m_nBufferSize)
    {
        nResult = ERR_WRITE_MSG_TOO_LARGE;
    }
    else
    {
        nResult = nHandleStartIndex(nSize + 3);
        nWriteBuffer(nType, pbyMsg, nSize);
        ++m_nMsgCount;
        SetEvent(m_hNotifyingEvent);
    }

    LeaveCriticalSection(&m_CritSectionForGB);

    return nResult;
}

int CMsgBufVVSE::GetMsgCount(void) const
{
    return m_nMsgCount;
}

HANDLE CMsgBufVVSE::hGetNotifyingEvent(void) const
{
    return m_hNotifyingEvent;
}
















int CMsgBufVVSE::nSetBufferSize(int& nSize)
{
    int nResult = CALL_SUCCESS;
    if (nSize < 50000)
    {
        nSize = 50000;
        nResult =  WARN_BUFFER_SIZE_MIN_ASSUMED;
    }
    else if (nSize > 200000)
    {
        nSize = 50000;
        nResult = WARN_BUFFER_SIZE_MAX_ASSUMED;
    }

    EnterCriticalSection(&m_CritSectionForGB);

    if (m_pbyMsgBuffer != 0)
    {
        delete[] m_pbyMsgBuffer;
    }
    m_nBufferSize = nSize;
    m_pbyMsgBuffer = new BYTE[nSize];
    if (m_pbyMsgBuffer == 0)
    {
        nResult = ERR_CREATE_MEMORY_FAIL;
        m_nBufferSize = 0;
    }
    else
    {
        vClearMessageBuffer();
    }

    LeaveCriticalSection(&m_CritSectionForGB);
    
    return nResult;
}













HRESULT CMsgBufVVSE::AdvanceToNextMsg()
{
    HRESULT Result = CALL_SUCCESS;
    if (m_nMsgCount == 0)
    {
        Result = EMPTY_APP_BUFFER;
    }
    else
    {        
        nAdvanceReadIndex(m_nStartIndex);
                            
        m_nMsgCount--;
    }
    return Result;
}











int CMsgBufVVSE::nAdvanceReadIndex(int& nReadIndex)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[3] = {0};
    nGetCurrMsgHeader(nReadIndex, abyHeader); 

    int nMsgLen = 0;
    memcpy(&nMsgLen, abyHeader + 1, DATA_LEN_SIZE);
    if ((nReadIndex + 3 + nMsgLen) < m_nBufferSize)
    {
        nReadIndex += (3 + nMsgLen);
    }
    else
    {
        nReadIndex = (nReadIndex + 3 + nMsgLen) - m_nBufferSize;
    }    
    return nResult;
}












int CMsgBufVVSE::nWriteBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[3] = {0};
    nResult = nConstructHeader(nType, nSize, abyHeader);
    ((void)0);
    if ((m_nIndexWrite + 3 + nSize) <= m_nBufferSize)
    {
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, 3);
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + 3, pbyMsg, nSize);

        m_nIndexWrite += (3 + nSize);
    }
    else if (m_nIndexWrite + 3 <= m_nBufferSize)
    {   
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, 3);
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + 3, pbyMsg, (m_nBufferSize - m_nIndexWrite - 3));
        memcpy(m_pbyMsgBuffer, pbyMsg +(m_nBufferSize - m_nIndexWrite - 3), nSize - (m_nBufferSize - m_nIndexWrite - 3));

        m_nIndexWrite = (nSize - (m_nBufferSize - m_nIndexWrite - 3));
    }
    else
    {
        
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, (m_nBufferSize - m_nIndexWrite));
        memcpy(m_pbyMsgBuffer, abyHeader + (m_nBufferSize - m_nIndexWrite), 3 - (m_nBufferSize - m_nIndexWrite));
        
        memcpy(m_pbyMsgBuffer + (3 - (m_nBufferSize - m_nIndexWrite)), pbyMsg, nSize);
        m_nIndexWrite = (3 - (m_nBufferSize - m_nIndexWrite)) + nSize;
    }
    return nResult;
}














HRESULT CMsgBufVVSE::ReadBuffer(INT& nType, BYTE* pbyMsg, INT& nSize, INT& nIndex) 
{
    HRESULT Return = CALL_SUCCESS;
    BYTE abyHeader[3];
    Return = nGetCurrMsgHeader(nIndex, abyHeader);
    
    ((void)0);
    int nMsgLen = 0;
    memcpy(&nType, (abyHeader + 0), TYPE_SIZE);
    memcpy(&nMsgLen, (abyHeader + 1), DATA_LEN_SIZE);
    if (nMsgLen > nSize)
    {
        Return = ERR_READ_MEMORY_SHORT;
        nSize   = nMsgLen - nSize;
    }
    else  
    {            
        if ((nIndex + 3 + nMsgLen) <= m_nBufferSize)
        { 
            memcpy(pbyMsg, (m_pbyMsgBuffer + nIndex + 3), nMsgLen);
            nIndex += (3 + nMsgLen);
        }
        else if ((nIndex + 3) <= m_nBufferSize)
        {                     
            memcpy(pbyMsg, (m_pbyMsgBuffer + nIndex + 3), (m_nBufferSize - nIndex - 3));
            memcpy((pbyMsg + (m_nBufferSize - nIndex - 3)), m_pbyMsgBuffer, (nMsgLen - (m_nBufferSize - nIndex - 3)));
            nIndex = nMsgLen - (m_nBufferSize - nIndex - 3);                
        }
        else
        {
            memcpy(pbyMsg, (m_pbyMsgBuffer + (nIndex + 3 - m_nBufferSize)), nMsgLen);
            nIndex = (nIndex + 3 - m_nBufferSize) +  nMsgLen;
        }
        nSize = nMsgLen;
    }
    return Return;
}











int CMsgBufVVSE::nConstructHeader(INT nType, INT nSize, BYTE* pbyHeader)
{
    memcpy(pbyHeader + 0, &nType, TYPE_SIZE);
    memcpy(pbyHeader + 1, &nSize, DATA_LEN_SIZE);
    return CALL_SUCCESS;
}











int CMsgBufVVSE::nGetCurrMsgHeader(int nIndex, BYTE* pbyHeader)
{
    if ((nIndex + 3) <= m_nBufferSize)
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + nIndex), 3);
    }
    else
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + nIndex), m_nBufferSize - nIndex);
        memcpy(pbyHeader + (m_nBufferSize - nIndex), m_pbyMsgBuffer, (nIndex + 3) - m_nBufferSize);
    }
    return CALL_SUCCESS;
}













int CMsgBufVVSE::nHandleStartIndex(int nSize)
{
    int nResult = CALL_SUCCESS;
    if (m_nStartIndex < m_nIndexWrite)
    {
        if ((m_nStartIndex + m_nBufferSize) <=  (m_nIndexWrite + nSize))
        {
            1 ? (void)0 : ::AfxTrace("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nAdvanceReadIndex(m_nStartIndex);
            m_nMsgCount--;
            m_nReadIndexTmp = m_nStartIndex;
            m_nTmpMsgCount = 0;
            1 ? (void)0 : ::AfxTrace("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nHandleStartIndex(nSize);
            
        }
    }
    else if (m_nStartIndex > m_nIndexWrite)
    {
        if ((m_nStartIndex) <=  (m_nIndexWrite + nSize))
        {
            1 ? (void)0 : ::AfxTrace("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nAdvanceReadIndex(m_nStartIndex);
            m_nMsgCount--;
            m_nReadIndexTmp = m_nStartIndex;
            m_nTmpMsgCount = 0;
            1 ? (void)0 : ::AfxTrace("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nHandleStartIndex(nSize);
            
        }
    }
    else
    {
        if (m_nMsgCount != 0)
        {
            ((void)0);
        }
    }
    1 ? (void)0 : ::AfxTrace("handled<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
    return nResult;
}
          š   	   š      —ÿÿÿÿ   —ÿÿÿÿ    hªÈ      expression was true       (nEntry < 0)    šÿÿÿÿ   —   	   šÿÿÿÿ   —      expression was false       (nEntry < 0)    šÿÿÿÿ   —   	   šÿÿÿÿ   —                            u      u   +   rÿÿÿÿ   rÿÿÿÿ    /(h      expression was true       nEntry > m_nMsgCount    uÿÿÿÿ   r      uÿÿÿÿ   r   +   expression was false       nEntry > m_nMsgCount    uÿÿÿÿ   r      uÿÿÿÿ   r   +                 u   	   u      rÿÿÿÿ   rÿÿÿÿ    /%P      expression was true       nEntry < 0    uÿÿÿÿ   r   	   uÿÿÿÿ   r      expression was false       nEntry < 0    uÿÿÿÿ   r   	   uÿÿÿÿ   r                    ¡      ¡   #   ÿÿÿÿ   ÿÿÿÿ    h¡p      expression was false       i < nEntry    ¡ÿÿÿÿ         ¡ÿÿÿÿ      #                 |      |   #   yÿÿÿÿ   yÿÿÿÿ    Rph      expression was false       i < nEntry    |ÿÿÿÿ   y      |ÿÿÿÿ   y   #                 š      š   B   —ÿÿÿÿ   —ÿÿÿÿ    h©p      expression was true       ((nEntry + m_nTmpMsgCount) > m_nMsgCount)    šÿÿÿÿ   —      šÿÿÿÿ   —   B   expression was false       ((nEntry + m_nTmpMsgCount) > m_nMsgCount)    šÿÿÿÿ   —      šÿÿÿÿ   —   B                   
      ¦      ¦   %   £ÿÿÿÿ   £ÿÿÿÿ    ?€Ğ      expression was true       (Result == CALL_SUCCESS)    ¦ÿÿÿÿ   £      ¦ÿÿÿÿ   £   %   expression was false       (Result == CALL_SUCCESS)    ¦ÿÿÿÿ   £      ¦ÿÿÿÿ   £   %               5U@        
     
     ÿÿÿÿ  ÿÿÿÿ    hP      expression was false       m_nMsgCount != 0   
ÿÿÿÿ       
ÿÿÿÿ                    hˆ        ü     ü   8  ùÿÿÿÿ  ùÿÿÿÿ    h ˜      expression was false       (m_nStartIndex) <=  (m_nIndexWrite + nSize)   üÿÿÿÿ  ù     üÿÿÿÿ  ù   8               ™p        î     î   H  ëÿÿÿÿ  ëÿÿÿÿ    EôP      expression was false       (m_nStartIndex + m_nBufferSize) <=  (m_nIndexWrite + nSize)   îÿÿÿÿ  ë     îÿÿÿÿ  ë   H               ˆï            	       ÿÿÿÿ  ÿÿÿÿ    h       expression was false       m_pbyMsgBuffer != 0   ÿÿÿÿ     	  ÿÿÿÿ                     õ          ü      ü      ùÿÿÿÿ   ùÿÿÿÿ    Ä~`      expression was false       nSize > 200000    üÿÿÿÿ   ù      üÿÿÿÿ   ù                    ¦   )   ¦   E   £ÿÿÿÿ   £ÿÿÿÿ    ¹8      expression was true       (bSetNextIndexStartPos == 1)    ¦ÿÿÿÿ   £   )   ¦ÿÿÿÿ   £   E   expression was false       (bSetNextIndexStartPos == 1)    ¦ÿÿÿÿ   £   )   ¦ÿÿÿÿ   £   E               ?‚(         J   	   J      Gÿÿÿÿ   Gÿÿÿÿ    f	ø      expression was false       m_pbyMsgBuffer != 0    Jÿÿÿÿ   G   	   Jÿÿÿÿ   G                  f¨                  ÿÿÿÿ  ÿÿÿÿ    Oø¨       statement executed        return nResult;   ÿÿÿÿ       ÿÿÿÿ                               ÿÿÿÿ  ÿÿÿÿ    h8       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                        	     
  
ÿÿÿÿ  
ÿÿÿÿ    hx       statement executed        }   ÿÿÿÿ  
   	  ÿÿÿÿ  
   
                          ÿÿÿÿ  ÿÿÿÿ    h€       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                        	     
  ÿÿÿÿ  ÿÿÿÿ    h        statement executed        }   ÿÿÿÿ     	  ÿÿÿÿ     
                ù     ù     öÿÿÿÿ  öÿÿÿÿ    Eõ8       statement executed        }   ùÿÿÿÿ  ö     ùÿÿÿÿ  ö                   ø   	  ø   
  õÿÿÿÿ  õÿÿÿÿ    Eóx       statement executed        }   øÿÿÿÿ  õ   	  øÿÿÿÿ  õ   
                Ú     Ú     ×ÿÿÿÿ  ×ÿÿÿÿ    cğ       statement executed        return CALL_SUCCESS;   Úÿÿÿÿ  ×     Úÿÿÿÿ  ×                   Ù     Ù     Öÿÿÿÿ  Öÿÿÿÿ    b0       statement executed        }   Ùÿÿÿÿ  Ö     Ùÿÿÿÿ  Ö                   Ô     Ô     Ñÿÿÿÿ  Ñÿÿÿÿ    `Ø       statement executed        }   Ôÿÿÿÿ  Ñ     Ôÿÿÿÿ  Ñ                   Â     Â     ¿ÿÿÿÿ  ¿ÿÿÿÿ     ö+à       statement executed        return CALL_SUCCESS;   Âÿÿÿÿ  ¿     Âÿÿÿÿ  ¿                   ±     ±     ®ÿÿÿÿ  ®ÿÿÿÿ     ó²À       statement executed        return Return;   ±ÿÿÿÿ  ®     ±ÿÿÿÿ  ®                    °     °     ­ÿÿÿÿ  ­ÿÿÿÿ     ó±       statement executed        }   °ÿÿÿÿ  ­     °ÿÿÿÿ  ­              !     ®   	  ®   
  «ÿÿÿÿ  «ÿÿÿÿ     ò-x       statement executed        }   ®ÿÿÿÿ  «   	  ®ÿÿÿÿ  «   
           "     ©   	  ©   
  ¦ÿÿÿÿ  ¦ÿÿÿÿ    /-˜       statement executed        }   ©ÿÿÿÿ  ¦   	  ©ÿÿÿÿ  ¦   
           #     £   	  £   
   ÿÿÿÿ   ÿÿÿÿ    /&¸       statement executed        }   £ÿÿÿÿ      	  £ÿÿÿÿ      
           $     œ     œ     ™ÿÿÿÿ  ™ÿÿÿÿ    Hœ       statement executed        }   œÿÿÿÿ  ™     œÿÿÿÿ  ™              %     ~     ~     {ÿÿÿÿ  {ÿÿÿÿ    0       statement executed        return nResult;   ~ÿÿÿÿ  {     ~ÿÿÿÿ  {              &     }     }     zÿÿÿÿ  zÿÿÿÿ    V~ˆ       statement executed        }   }ÿÿÿÿ  z     }ÿÿÿÿ  z              '     t     t     qÿÿÿÿ  qÿÿÿÿ    ÃX       statement executed        }   tÿÿÿÿ  q     tÿÿÿÿ  q              (     k     k     hÿÿÿÿ  hÿÿÿÿ    .Í¸       statement executed        }   kÿÿÿÿ  h     kÿÿÿÿ  h              )     O     O     Lÿÿÿÿ  Lÿÿÿÿ    h ˜       statement executed        return nResult;   Oÿÿÿÿ  L     Oÿÿÿÿ  L              *     N     N     Kÿÿÿÿ  Kÿÿÿÿ    ?Š0       statement executed        }   Nÿÿÿÿ  K     Nÿÿÿÿ  K              +     J     J     Gÿÿÿÿ  Gÿÿÿÿ    ¿Í8       statement executed        }   Jÿÿÿÿ  G     Jÿÿÿÿ  G              ,     2     2     /ÿÿÿÿ  /ÿÿÿÿ    ‰ù        statement executed        return Result;   2ÿÿÿÿ  /     2ÿÿÿÿ  /              -     1     1     .ÿÿÿÿ  .ÿÿÿÿ    -b       statement executed        }   1ÿÿÿÿ  .     1ÿÿÿÿ  .              .     +     +     (ÿÿÿÿ  (ÿÿÿÿ    H–€       statement executed        }   +ÿÿÿÿ  (     +ÿÿÿÿ  (              /               ÿÿÿÿ  ÿÿÿÿ    5Ì°       statement executed        return nResult;   ÿÿÿÿ       ÿÿÿÿ                0               ÿÿÿÿ  ÿÿÿÿ    R|        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                1               ÿÿÿÿ  ÿÿÿÿ    Rw        statement executed        }   ÿÿÿÿ       ÿÿÿÿ                2               ÿÿÿÿ  ÿÿÿÿ    Eùà       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                3                  ıÿÿÿÿ   ıÿÿÿÿ    ÎP       statement executed        }    ÿÿÿÿ   ı      ÿÿÿÿ   ı              4      û      û      øÿÿÿÿ   øÿÿÿÿ    x       statement executed        }    ûÿÿÿÿ   ø      ûÿÿÿÿ   ø              5      â      â      ßÿÿÿÿ   ßÿÿÿÿ     4z        statement executed        return m_hNotifyingEvent;    âÿÿÿÿ   ß      âÿÿÿÿ   ß              6      İ      İ      Úÿÿÿÿ   Úÿÿÿÿ    (­¸       statement executed        return m_nMsgCount;    İÿÿÿÿ   Ú      İÿÿÿÿ   Ú              7      Ø      Ø      Õÿÿÿÿ   Õÿÿÿÿ     .¸       statement executed        return nResult;    Øÿÿÿÿ   Õ      Øÿÿÿÿ   Õ              8      Ô      Ô      Ñÿÿÿÿ   Ñÿÿÿÿ     öĞ       statement executed        }    Ôÿÿÿÿ   Ñ      Ôÿÿÿÿ   Ñ              9      Í      Í      Êÿÿÿÿ   Êÿÿÿÿ    h
       statement executed        }    Íÿÿÿÿ   Ê      Íÿÿÿÿ   Ê              :      ¯      ¯      ¬ÿÿÿÿ   ¬ÿÿÿÿ    h(       statement executed        return Result;    ¯ÿÿÿÿ   ¬      ¯ÿÿÿÿ   ¬              ;      «      «      ¨ÿÿÿÿ   ¨ÿÿÿÿ    ±(       statement executed        }    «ÿÿÿÿ   ¨      «ÿÿÿÿ   ¨              <      ª   	   ª   
   §ÿÿÿÿ   §ÿÿÿÿ    ³Ø       statement executed        }    ªÿÿÿÿ   §   	   ªÿÿÿÿ   §   
           =      ¤   	   ¤   
   ¡ÿÿÿÿ   ¡ÿÿÿÿ    h¢¸       statement executed        }    ¤ÿÿÿÿ   ¡   	   ¤ÿÿÿÿ   ¡   
           >      C      C      @ÿÿÿÿ   @ÿÿÿÿ    ‰ü        statement executed        }    Cÿÿÿÿ   @      Cÿÿÿÿ   @              ?      N      N      Kÿÿÿÿ   Kÿÿÿÿ    fğ       statement executed        }    Nÿÿÿÿ   K      Nÿÿÿÿ   K              @      P      P      Mÿÿÿÿ   Mÿÿÿÿ    f        statement executed        }    Pÿÿÿÿ   M      Pÿÿÿÿ   M              A      d      d      aÿÿÿÿ   aÿÿÿÿ    VL0       statement executed        }    dÿÿÿÿ   a      dÿÿÿÿ   a              B      x      x      uÿÿÿÿ   uÿÿÿÿ    Ry8       statement executed        }    xÿÿÿÿ   u      xÿÿÿÿ   u              C      €   	   €   
   }ÿÿÿÿ   }ÿÿÿÿ    Rs€       statement executed        }    €ÿÿÿÿ   }   	   €ÿÿÿÿ   }   
           D                  ~ÿÿÿÿ   ~ÿÿÿÿ    `       statement executed        }    ÿÿÿÿ   ~      ÿÿÿÿ   ~              E      ‚      ‚      ÿÿÿÿ   ÿÿÿÿ    Ğ       statement executed        return Result;    ‚ÿÿÿÿ         ‚ÿÿÿÿ                 F                  šÿÿÿÿ   šÿÿÿÿ    h¥h       statement executed        }    ÿÿÿÿ   š      ÿÿÿÿ   š           CMsgBufVVSE::CMsgBufVVSE CMsgBufVVSE::CMsgBufVVSE(void)    =      C      :ÿÿÿÿ   @ÿÿÿÿCMsgBufVVSE::~CMsgBufVVSE CMsgBufVVSE::~CMsgBufVVSE(void)    G      P      Dÿÿÿÿ   MÿÿÿÿCMsgBufVVSE::vClearMessageBuffer void CMsgBufVVSE::vClearMessageBuffer(void)    ]      d      Zÿÿÿÿ   aÿÿÿÿCMsgBufVVSE::SetStartPos HRESULT CMsgBufVVSE::SetStartPos(int nEntry)    s      „      pÿÿÿÿ   ÿÿÿÿCMsgBufVVSE::ReadEntry HRESULT CMsgBufVVSE::ReadEntry(int& nType, BYTE* pbyMsg, int& nSize, int nEntry, BOOL bSetNextIndexStartPos)    •      °      ’ÿÿÿÿ   ­ÿÿÿÿCMsgBufVVSE::WriteIntoBuffer int CMsgBufVVSE::WriteIntoBuffer(INT nType, BYTE* pbyMsg, INT nSize)    À      Ù      ½ÿÿÿÿ   ÖÿÿÿÿCMsgBufVVSE::GetMsgCount int CMsgBufVVSE::GetMsgCount(void)    Ü      Ş      Ùÿÿÿÿ   ÛÿÿÿÿCMsgBufVVSE::hGetNotifyingEvent HANDLE CMsgBufVVSE::hGetNotifyingEvent(void)    á      ã      Şÿÿÿÿ   àÿÿÿÿCMsgBufVVSE::nSetBufferSize int CMsgBufVVSE::nSetBufferSize(int& nSize)    õ           òÿÿÿÿ  ÿÿÿÿCMsgBufVVSE::AdvanceToNextMsg HRESULT CMsgBufVVSE::AdvanceToNextMsg()   &     3     #ÿÿÿÿ  0ÿÿÿÿCMsgBufVVSE::nAdvanceReadIndex int CMsgBufVVSE::nAdvanceReadIndex(int& nReadIndex)   @     P     =ÿÿÿÿ  MÿÿÿÿCMsgBufVVSE::nWriteBuffer int CMsgBufVVSE::nWriteBuffer(INT nType, BYTE* pbyMsg, INT nSize)   ^          [ÿÿÿÿ  |ÿÿÿÿCMsgBufVVSE::ReadBuffer HRESULT CMsgBufVVSE::ReadBuffer(INT& nType, BYTE* pbyMsg, INT& nSize, INT& nIndex)        ²     Œÿÿÿÿ  ¯ÿÿÿÿCMsgBufVVSE::nConstructHeader int CMsgBufVVSE::nConstructHeader(INT nType, INT nSize, BYTE* pbyHeader)   ¿     Ã     ¼ÿÿÿÿ  ÀÿÿÿÿCMsgBufVVSE::nGetCurrMsgHeader int CMsgBufVVSE::nGetCurrMsgHeader(int nIndex, BYTE* pbyHeader)   Ğ     Û     Íÿÿÿÿ  ØÿÿÿÿCMsgBufVVSE::nHandleStartIndex int CMsgBufVVSE::nHandleStartIndex(int nSize)   ê          çÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      MsgBufVVSE.cpp
 * \brief     Implements the variant of circular queue class in VSE.
 * \author    Pradeep Kadoor
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Implements the variant of circular queue class in VSE.
 */

// Insert your headers here
#include "Datatypes_stdafx.h"
#include "MsgBufVVSE.h"
//Error definition
#include "include/Error.h"



//type 
#define DATA_LEN   WORD
#define TYPE       BYTE
#define MAX_BUFFER_SIZE 200000
#define MIN_BUFFER_SIZE 50000
// Const variables
const size_t DATA_LEN_SIZE = sizeof(DATA_LEN);
const size_t TYPE_SIZE     = sizeof(TYPE);
//length
#define HEADER_LEN 3

//offset
#define TYPE_OFFSET     0
#define MSGLEN_OFFSET   1


/**********************************************************************************
Function Name   :   CMsgBufVVSE() 
Input           :   
Output          :   
Functionality   :   Initializes buffer with minimum memory.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
CMsgBufVVSE::CMsgBufVVSE(void)
{
    m_nBufferSize = MIN_BUFFER_SIZE;
    m_pbyMsgBuffer = new BYTE[MIN_BUFFER_SIZE];// allocate memory first
    vClearMessageBuffer(); // Clear the message buffer
    InitializeCriticalSection(&m_CritSectionForGB);
    m_hNotifyingEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
}

//Destructor deallocates memory
CMsgBufVVSE::~CMsgBufVVSE(void)
{
    CloseHandle(m_hNotifyingEvent);
    m_hNotifyingEvent = NULL;
    if (m_pbyMsgBuffer != NULL)
    {
        delete[] m_pbyMsgBuffer;
        m_pbyMsgBuffer = NULL;
    }
    DeleteCriticalSection(&m_CritSectionForGB);
}
/**********************************************************************************
Function Name   :   vClearMessageBuffer()
Input           :   
Output          :   
Functionality   :   Clears msg buffer and initializes all variables.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
void CMsgBufVVSE::vClearMessageBuffer(void)
{
    memset(m_pbyMsgBuffer, 0, m_nBufferSize);
    m_nIndexWrite   = 0;
    m_nMsgCount     = 0;
    m_nStartIndex   = 0;
    m_nReadIndexTmp = 0;
    m_nTmpMsgCount  = 0;
}

/**********************************************************************************
Function Name   :   nSetStartPos
Input           :   Entry Number - nIndex
Output          :   CALL_SUCCESS for success.
                    ERR_INVALID_INDEX for invalid index.
Functionality   :   Interface function. Sets the start pos to the 'nIndex'th entry.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   10/11/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVVSE::SetStartPos(int nEntry)
{
    HRESULT Result = CALL_SUCCESS;
    if (nEntry < 0 || nEntry > m_nMsgCount)
    {
        Result = ERR_INVALID_INDEX;
    }
    else
    {
        m_nReadIndexTmp = m_nStartIndex;
        for (int i = 0; i < nEntry; i++)
        {
            nAdvanceReadIndex(m_nReadIndexTmp);
            m_nTmpMsgCount++;
        }
    }
    return Result;

}
/**********************************************************************************
Function Name   :   ReadEntry
Input           :   INDEX, bSetNextIndexStartPos.
Output          :   CALL_SUCCESS for success.                    
                    ERR_READ_MEMORY_SHORT when caller specifies size of the msg
                    less than required size.
                    ERR_INVALID_INDEX for invalid index.
Functionality   :   Interface function. Reads the entry from the given index and 
                    user will have an option set the next entry start pos.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVVSE::ReadEntry(int& nType, BYTE* pbyMsg, int& nSize, int nEntry, BOOL bSetNextIndexStartPos)
{
    // Lock the buffer
    EnterCriticalSection(&m_CritSectionForGB);

    HRESULT Result = CALL_SUCCESS;
    if ((nEntry < 0) || ((nEntry + m_nTmpMsgCount) > m_nMsgCount))
    {
        Result = ERR_INVALID_INDEX;
    }
    else
    {
        int nTmpIndex = m_nReadIndexTmp;
        for (int i = 0; i < nEntry; i++)
        {
            nAdvanceReadIndex(nTmpIndex);
        }
        Result = ReadBuffer(nType, pbyMsg, nSize, nTmpIndex);
        if ((Result == CALL_SUCCESS) && (bSetNextIndexStartPos == TRUE))
        {
            m_nReadIndexTmp = nTmpIndex;
            m_nTmpMsgCount += nEntry;
        }
    }

    // Unlock the buffer
    LeaveCriticalSection(&m_CritSectionForGB);
    return Result;
}

/**********************************************************************************
Function Name   :   WriteIntoBuffer()
Input           :   TYPE, SIZE, pointer to msg.
Output          :   CALL_SUCCESS for success.                    
                    ERR_WRITE_MSG_TOO_LARGE when caller specifies size of the msg
                    more than buffer size.
Functionality   :   Interface function. Writes msg into circular function.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVVSE::WriteIntoBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;

#ifdef _DEBUG
    ASSERT(pbyMsg != NULL);
    ASSERT(!(m_nIndexWrite > m_nBufferSize));
#endif

    EnterCriticalSection(&m_CritSectionForGB);
    // Check the size of the message
    if (nSize > m_nBufferSize)
    {
        nResult = ERR_WRITE_MSG_TOO_LARGE;
    }
    else
    {
        nResult = nHandleStartIndex(nSize + HEADER_LEN);//helper function to handle buffer overrun
        nWriteBuffer(nType, pbyMsg, nSize);//helper function to write buffer
        ++m_nMsgCount;
        SetEvent(m_hNotifyingEvent);
    }

    LeaveCriticalSection(&m_CritSectionForGB);

    return nResult;
}

int CMsgBufVVSE::GetMsgCount(void) const
{
    return m_nMsgCount;
}

HANDLE CMsgBufVVSE::hGetNotifyingEvent(void) const
{
    return m_hNotifyingEvent;
}

/**********************************************************************************
Function Name   :   nSetBufferSize()
Output          :   CALL_SUCCESS for success. 
                    WARN_BUFFER_SIZE_MIN_ASSUMED when caller specifies less than
                    minimum buffer size.
                    WARN_BUFFER_SIZE_MAX_ASSUMED when caller specifies more than
                    maximum buffer size.
Functionality   :   Interface function. Caller can set the buffer size.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/

int CMsgBufVVSE::nSetBufferSize(int& nSize)
{
    int nResult = CALL_SUCCESS;
    if (nSize < MIN_BUFFER_SIZE)
    {
        nSize = MIN_BUFFER_SIZE;
        nResult =  WARN_BUFFER_SIZE_MIN_ASSUMED;
    }
    else if (nSize > MAX_BUFFER_SIZE)
    {
        nSize = MIN_BUFFER_SIZE;
        nResult = WARN_BUFFER_SIZE_MAX_ASSUMED;
    }

    EnterCriticalSection(&m_CritSectionForGB);

    if (m_pbyMsgBuffer != NULL)
    {
        delete[] m_pbyMsgBuffer;
    }
    m_nBufferSize = nSize;
    m_pbyMsgBuffer = new BYTE[nSize];
    if (m_pbyMsgBuffer == NULL)
    {
        nResult = ERR_CREATE_MEMORY_FAIL;
        m_nBufferSize = 0;
    }
    else
    {
        vClearMessageBuffer();
    }

    LeaveCriticalSection(&m_CritSectionForGB);
    
    return nResult;
}
/**********************************************************************************
Function Name   :   AdvanceToNextMsg()
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
                    if allocated memory by the caller is not enough.
Functionality   :   Interface function. Current msg is skipped.
                    Caller can use this function when wishes to skip the 
                    current msg due to memory constraint.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVVSE::AdvanceToNextMsg()
{
    HRESULT Result = CALL_SUCCESS;
    if (m_nMsgCount == 0)
    {
        Result = EMPTY_APP_BUFFER;
    }
    else
    {        
        nAdvanceReadIndex(m_nStartIndex);//Helper function to advance the read index
                            //to the next msg.
        m_nMsgCount--;
    }
    return Result;
}
/**********************************************************************************
Function Name   :   nAdvanceReadIndex(int& nIndex)
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
                    if allocated memory by the caller is not enough.
Functionality   :   Helper function. Advances the nIndex to the next entry
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVVSE::nAdvanceReadIndex(int& nReadIndex)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[HEADER_LEN] = {0};
    nGetCurrMsgHeader(nReadIndex, abyHeader); // Get current msg header TYPE, MSG LENGTH

    int nMsgLen = 0;
    memcpy(&nMsgLen, abyHeader + MSGLEN_OFFSET, DATA_LEN_SIZE);
    if ((nReadIndex + HEADER_LEN + nMsgLen) < m_nBufferSize)
    {
        nReadIndex += (HEADER_LEN + nMsgLen);
    }
    else
    {
        nReadIndex = (nReadIndex + HEADER_LEN + nMsgLen) - m_nBufferSize;
    }    
    return nResult;
}
/**********************************************************************************
Function Name   :   nWriteBuffer()
Input(s)        :   TYPE, SIZE, pointer to the message.
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   Helper function. Current msg is written into the 
                    circular buffer.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVVSE::nWriteBuffer(INT nType, BYTE* pbyMsg, INT nSize)
{
    int nResult = CALL_SUCCESS;
    static BYTE abyHeader[HEADER_LEN] = {0};
    nResult = nConstructHeader(nType, nSize, abyHeader);//Helper function to construct header from TYPE, MSG LENGTH
    ASSERT(nResult == CALL_SUCCESS);
    if ((m_nIndexWrite + HEADER_LEN + nSize) <= m_nBufferSize)
    {
        //Write header
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, HEADER_LEN);
        //Write msg
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + HEADER_LEN, pbyMsg, nSize);

        m_nIndexWrite += (HEADER_LEN + nSize);
    }
    else if (m_nIndexWrite + HEADER_LEN <= m_nBufferSize)
    {   
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, HEADER_LEN);
        // Write msg
        memcpy(m_pbyMsgBuffer + m_nIndexWrite + HEADER_LEN, pbyMsg, (m_nBufferSize - m_nIndexWrite - HEADER_LEN));
        memcpy(m_pbyMsgBuffer, pbyMsg +(m_nBufferSize - m_nIndexWrite - HEADER_LEN), nSize - (m_nBufferSize - m_nIndexWrite - HEADER_LEN));

        m_nIndexWrite = (nSize - (m_nBufferSize - m_nIndexWrite - HEADER_LEN));
    }
    else
    {
        //write the header
        memcpy(m_pbyMsgBuffer + m_nIndexWrite, abyHeader, (m_nBufferSize - m_nIndexWrite));
        memcpy(m_pbyMsgBuffer, abyHeader + (m_nBufferSize - m_nIndexWrite), HEADER_LEN - (m_nBufferSize - m_nIndexWrite));
        //write the msg
        memcpy(m_pbyMsgBuffer + (HEADER_LEN - (m_nBufferSize - m_nIndexWrite)), pbyMsg, nSize);
        m_nIndexWrite = (HEADER_LEN - (m_nBufferSize - m_nIndexWrite)) + nSize;
    }
    return nResult;
}

/**********************************************************************************
Function Name   :   ReadBuffer()
Input(s)        :   TYPE, SIZE, pointer to the byte where MSG will be stored.
Output          :   CALL_SUCCESS for success. ERR_READ_MEMORY_SHORT
                    if allocated memory by the caller is not enough.
Functionality   :   Helper function. Current msg pointed by nIndex
                    is read.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
HRESULT CMsgBufVVSE::ReadBuffer(INT& nType, BYTE* pbyMsg, INT& nSize, INT& nIndex) 
{
    HRESULT Return = CALL_SUCCESS;
    BYTE abyHeader[HEADER_LEN];
    Return = nGetCurrMsgHeader(nIndex, abyHeader);
    // It is expected to return CALL_SUCCESS
    ASSERT(Return == CALL_SUCCESS);
    int nMsgLen = 0;
    memcpy(&nType, (abyHeader + TYPE_OFFSET), TYPE_SIZE);
    memcpy(&nMsgLen, (abyHeader + MSGLEN_OFFSET), DATA_LEN_SIZE);
    if (nMsgLen > nSize)
    {
        Return = ERR_READ_MEMORY_SHORT;
        nSize   = nMsgLen - nSize;
    }
    else  
    {            
        if ((nIndex + HEADER_LEN + nMsgLen) <= m_nBufferSize)
        { 
            memcpy(pbyMsg, (m_pbyMsgBuffer + nIndex + HEADER_LEN), nMsgLen);
            nIndex += (HEADER_LEN + nMsgLen);
        }
        else if ((nIndex + HEADER_LEN) <= m_nBufferSize)
        {                     
            memcpy(pbyMsg, (m_pbyMsgBuffer + nIndex + HEADER_LEN), (m_nBufferSize - nIndex - HEADER_LEN));
            memcpy((pbyMsg + (m_nBufferSize - nIndex - HEADER_LEN)), m_pbyMsgBuffer, (nMsgLen - (m_nBufferSize - nIndex - HEADER_LEN)));
            nIndex = nMsgLen - (m_nBufferSize - nIndex - HEADER_LEN);                
        }
        else
        {
            memcpy(pbyMsg, (m_pbyMsgBuffer + (nIndex + HEADER_LEN - m_nBufferSize)), nMsgLen);
            nIndex = (nIndex + HEADER_LEN - m_nBufferSize) +  nMsgLen;
        }
        nSize = nMsgLen;
    }
    return Return;
}
/**********************************************************************************
Function Name   :   nConstructHeader()
Input(s)        :   TYPE, SIZE, Array of byte where header will be stored.
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   Header is constructed with TYPE & SIZE.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVVSE::nConstructHeader(INT nType, INT nSize, BYTE* pbyHeader)
{
    memcpy(pbyHeader + TYPE_OFFSET, &nType, TYPE_SIZE);
    memcpy(pbyHeader + MSGLEN_OFFSET, &nSize, DATA_LEN_SIZE);
    return CALL_SUCCESS;
}
/**********************************************************************************
Function Name   :   nGetCurrMsgHeader(int nIndex, BYTE* pbyHeader)
Input(s)        :   Array of byte where header will be stored.
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   header of the msg at the 'nIndex' is retrieved.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVVSE::nGetCurrMsgHeader(int nIndex, BYTE* pbyHeader)
{
    if ((nIndex + HEADER_LEN) <= m_nBufferSize)
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + nIndex), HEADER_LEN);
    }
    else
    {
        memcpy(pbyHeader, (m_pbyMsgBuffer + nIndex), m_nBufferSize - nIndex);
        memcpy(pbyHeader + (m_nBufferSize - nIndex), m_pbyMsgBuffer, (nIndex + HEADER_LEN) - m_nBufferSize);
    }
    return CALL_SUCCESS;
}

/**********************************************************************************
Function Name   :   nHandleStartIndex()
Input(s)        :   -
Output          :   CALL_SUCCESS for success. CALL_FAILURE for failure.
Functionality   :   If buffer overrun criteria is met, start index 
                    is advanced until it solves buffer overrun.
Member of       :   CMsgBufVVSE
Friend of       :   -
Authors         :   Pradeep Kadoor
Date Created    :   22/06/2009
Modifications   :   -
************************************************************************************/
int CMsgBufVVSE::nHandleStartIndex(int nSize)
{
    int nResult = CALL_SUCCESS;
    if (m_nStartIndex < m_nIndexWrite)
    {
        if ((m_nStartIndex + m_nBufferSize) <=  (m_nIndexWrite + nSize))
        {
            TRACE("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nAdvanceReadIndex(m_nStartIndex);
            m_nMsgCount--;
            m_nReadIndexTmp = m_nStartIndex;
            m_nTmpMsgCount = 0;
            TRACE("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nHandleStartIndex(nSize);
            
        }
    }
    else if (m_nStartIndex > m_nIndexWrite)
    {
        if ((m_nStartIndex) <=  (m_nIndexWrite + nSize))
        {
            TRACE("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nAdvanceReadIndex(m_nStartIndex);
            m_nMsgCount--;
            m_nReadIndexTmp = m_nStartIndex;
            m_nTmpMsgCount = 0;
            TRACE("<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
            nHandleStartIndex(nSize);
            
        }
    }
    else
    {
        if (m_nMsgCount != 0)
        {
            ASSERT(FALSE);
        }
    }
    TRACE("handled<start>%d<read>%d<write>%d<count>%d<tmpCount>%d\n",m_nStartIndex, m_nReadIndexTmp, m_nIndexWrite, m_nMsgCount, m_nTmpMsgCount);
    return nResult;
}




















CSignalDescVal::CSignalDescVal()
{
    m_omStrSignalDescriptor = "";
    
	m_DescValue.un64Value = 0x0;
    m_pouNextSignalSignalDescVal = 0;
}

CSignalDescVal::~CSignalDescVal()
{
}

void CSignalDescVal::vClearNext(void)
{
    
    if (0 != m_pouNextSignalSignalDescVal)
    {
        m_pouNextSignalSignalDescVal->vClearNext();
        delete m_pouNextSignalSignalDescVal;
        m_pouNextSignalSignalDescVal = 0;
    }
}

CSignalDescVal& CSignalDescVal::operator=(const CSignalDescVal& RefObj)
{
    vClearNext();

    m_omStrSignalDescriptor = RefObj.m_omStrSignalDescriptor;
    
    m_DescValue          = RefObj.m_DescValue;

    



    


    CSignalDescVal** ppouCurrTgt = &m_pouNextSignalSignalDescVal;

    
    for (CSignalDescVal *pouCurrSrc = RefObj.m_pouNextSignalSignalDescVal;
         pouCurrSrc != 0; 
         pouCurrSrc = pouCurrSrc->m_pouNextSignalSignalDescVal)
    {
        (*ppouCurrTgt) = new CSignalDescVal; 
        (*ppouCurrTgt)->m_omStrSignalDescriptor = pouCurrSrc->m_omStrSignalDescriptor;
        
        (*ppouCurrTgt)->m_DescValue = pouCurrSrc->m_DescValue;
        
        ppouCurrTgt = &((*ppouCurrTgt)->m_pouNextSignalSignalDescVal);
    }

    return *this;
}



sWaveformInfo::sWaveformInfo(): m_eSignalWaveType(eWave_NONE),
					  m_fAmplitude(0.0), m_fFrequency(0.0), m_fGranularity(0.0)
{
}

sWaveformInfo& sWaveformInfo::operator=(const sWaveformInfo& RefObj)
{
	m_eSignalWaveType   = RefObj.m_eSignalWaveType;
	m_fAmplitude        = RefObj.m_fAmplitude;
	m_fFrequency        = RefObj.m_fFrequency;
    m_fGranularity      = RefObj.m_fGranularity;

	return *this;
}

CString sWaveformInfo::omGetWaveformName(eWAVEFORMTYPE eWaveform)
{
    CString Result = "";

    switch (eWaveform)
    {
        case eWave_SINE: Result = "Sine wave"; break;
        case eWave_TRIANGLE: Result = "Triangular wave"; break;
		case eWave_COS: Result = "Cos wave"; break;
    }

    return Result;
}




sSigWaveMap::sSigWaveMap()
{
    m_omSigName = "";
}

sSigWaveMap& sSigWaveMap::operator=(const sSigWaveMap& RefObj)
{
    m_omSigName = RefObj.m_omSigName;
    sWaveInfo   = RefObj.sWaveInfo;

    return *this;
}

BOOL sSigWaveMap::operator==(const sSigWaveMap& RefObj) const
{
	return (m_omSigName == RefObj.m_omSigName);
}




SSigGeneration::SSigGeneration()
{
    Reset();
}
SSigGeneration::~SSigGeneration()
{
    Reset();
}

void SSigGeneration::Reset(void)
{
    m_nMsgID = 0x0;
    m_fDefaultAmplitude = (float) 0.0;
    m_omSigWaveMapList.RemoveAll();
}

BOOL SSigGeneration::operator==(const SSigGeneration& RefObj) const
{
	return (m_nMsgID == RefObj.m_nMsgID);
}

SSigGeneration& SSigGeneration::operator=(const SSigGeneration& RefObj)
{
    Reset();

	m_nMsgID = RefObj.m_nMsgID;
	m_fDefaultAmplitude = RefObj.m_fDefaultAmplitude;

    POSITION Pos = RefObj.m_omSigWaveMapList.GetHeadPosition();
    while (0 != Pos)
    {
        const sSigWaveMap& CurrObj = RefObj.m_omSigWaveMapList.GetNext(Pos);
        sSigWaveMap TmpObj = CurrObj;
        m_omSigWaveMapList.AddTail(TmpObj);
    }

	return *this;
}





UINT64 sSIGNALS::un64GetBitMask(sSIGNALS* CurrSig)
{
    UINT64 Result = 0x1;

    
    Result <<= CurrSig->m_unSignalLength;
    --Result; 

    
    short Shift = (DATA_FORMAT_INTEL == CurrSig->m_eFormat) ? 
        ((short)CurrSig->m_unStartByte - 1) * 8 + CurrSig->m_byStartBit
        : 64 - ((short)CurrSig->m_unStartByte * 8 - CurrSig->m_byStartBit);
    Result <<= Shift;

    if (DATA_FORMAT_MOTOROLA == CurrSig->m_eFormat)
    {
        BYTE* pbStr = (BYTE *) &Result;

        BYTE bTmp = 0x0;
        bTmp = pbStr[0]; pbStr[0] = pbStr[7] ; pbStr[7] = bTmp;
        bTmp = pbStr[1]; pbStr[1] = pbStr[6] ; pbStr[6] = bTmp;
        bTmp = pbStr[2]; pbStr[2] = pbStr[5] ; pbStr[5] = bTmp;
        bTmp = pbStr[3]; pbStr[3] = pbStr[4] ; pbStr[4] = bTmp;
    }
    return Result;
}

void sSIGNALS::vSetSignalValue(sSIGNALS* pouCurrSignal, UCHAR aucData[8], 
                               UINT64 u64SignVal)
{
    ((void)0);

    






    UINT64* pu64Target = (UINT64 *) aucData; 
    BYTE* pbData = (BYTE *) &u64SignVal;     
                                             

    if (pouCurrSignal->m_eFormat == DATA_FORMAT_INTEL)
    {
        int Offset = (pouCurrSignal->m_unStartByte - 1) * 8 +
                                             pouCurrSignal->m_byStartBit;
        u64SignVal <<= Offset; 
    }
    else    
    {
        int Offset = pouCurrSignal->m_unStartByte * 8 -
                                             pouCurrSignal->m_byStartBit;
        u64SignVal <<= (64 - Offset);

        BYTE byTmp = 0x0;

        byTmp = pbData[7]; pbData[7] = pbData[0]; pbData[0] = byTmp;
        byTmp = pbData[6]; pbData[6] = pbData[1]; pbData[1] = byTmp;
        byTmp = pbData[5]; pbData[5] = pbData[2]; pbData[2] = byTmp;
        byTmp = pbData[4]; pbData[4] = pbData[3]; pbData[3] = byTmp;
    }

	
    UINT64 unTmp = un64GetBitMask(pouCurrSignal);
    *pu64Target |= unTmp;  
                           
    *pu64Target &= u64SignVal;
}







tagSMSGENTRY::tagSMSGENTRY() 
{ 
    m_psMsg = 0; 
    m_psNext = 0; 
}

tagSMSGENTRY::~tagSMSGENTRY()
{
    if (0 != m_psMsg) 
    {
        delete m_psMsg;
        m_psMsg = 0;
    }
    if (0 != m_psNext)
    {
        delete m_psNext;
        m_psNext = 0;
    }
}

void tagSMSGENTRY::vClearMsgList(SMSGENTRY*& psMsgRoot)
{
    SMSGENTRY* psCurrEntry = psMsgRoot;
    while (0 != psCurrEntry) 
    {
        SMSGENTRY* psNext = psCurrEntry->m_psNext;

        vClearSignalList(psCurrEntry->m_psMsg->m_psSignals); 
        psCurrEntry->m_psNext = 0;
        { if (0 != psCurrEntry) { delete psCurrEntry; psCurrEntry = 0; } };    

        psCurrEntry = psNext; 

    } 
    psMsgRoot = 0;
}


void tagSMSGENTRY::vClearSignalList(sSIGNALS* psSignals)
{
    sSIGNALS* psCurrSignal = psSignals;

    while (0 != psCurrSignal)
    {
        sSIGNALS* psSignalNext = psCurrSignal->m_psNextSignalList;
        psCurrSignal->m_psNextSignalList = 0;
        if (0 != psCurrSignal->m_oSignalIDVal)
        {
            psCurrSignal->m_oSignalIDVal->vClearNext();
            { if (0 != psCurrSignal->m_oSignalIDVal) { delete psCurrSignal->m_oSignalIDVal; psCurrSignal->m_oSignalIDVal = 0; } };
        }
        { if (0 != psCurrSignal) { delete psCurrSignal; psCurrSignal = 0; } };
        psCurrSignal = psSignalNext;
    } 
}


sMESSAGE* tagSMSGENTRY::psCopyMsgVal(sMESSAGE* psMsg)
{
    sMESSAGE* Result = new sMESSAGE;

    if (0 != Result)
    {
        Result->m_omStrMessageName      = psMsg->m_omStrMessageName;
        Result->m_unMessageCode         = psMsg->m_unMessageCode;
        Result->m_unNumberOfSignals     = psMsg->m_unNumberOfSignals;
        Result->m_unMessageLength       = psMsg->m_unMessageLength;
        Result->m_bMessageFrameFormat   = psMsg->m_bMessageFrameFormat;
        Result->m_psSignals             = 0;
        memcpy(Result->m_bySignalMatrix, psMsg->m_bySignalMatrix, 8);
        Result->m_nMsgDataFormat        = psMsg->m_nMsgDataFormat;
    }
    else
    {
        ((void)0);
    }
    return Result;
}



sSIGNALS* tagSMSGENTRY::psCopySignalVal(sSIGNALS* psSignal)
{
    sSIGNALS* Result = new sSIGNALS;

    if (0 != Result)
    {
        Result->m_omStrSignalName       = psSignal->m_omStrSignalName;
        Result->m_unStartByte           = psSignal->m_unStartByte;
        Result->m_unSignalLength        = psSignal->m_unSignalLength;
        Result->m_byStartBit            = psSignal->m_byStartBit;
        Result->m_bySignalType          = psSignal->m_bySignalType;
        Result->m_SignalMinValue        = psSignal->m_SignalMinValue;
        Result->m_SignalMaxValue        = psSignal->m_SignalMaxValue;
        Result->m_fSignalFactor         = psSignal->m_fSignalFactor;
        Result->m_fSignalOffset         = psSignal->m_fSignalOffset;
        Result->m_omStrSignalUnit       = psSignal->m_omStrSignalUnit;
        Result->m_eFormat               = psSignal->m_eFormat;
        Result->m_oSignalIDVal          = 0;
        Result->m_psNextSignalList      = 0;

        if (0 != psSignal->m_oSignalIDVal)
        {
            Result->m_oSignalIDVal = new CSignalDescVal;
            *(Result->m_oSignalIDVal) = *(psSignal->m_oSignalIDVal);
        }
    }
    else
    {
        ((void)0);
    }
    return Result;
}


sSIGNALS* tagSMSGENTRY::psCopySignalList(sSIGNALS* psSignal)
{
    sSIGNALS* Result = 0;

    sSIGNALS** ppsCurrDest = &Result;
    sSIGNALS** ppsCurrSrc = &psSignal;

    while (0 != *ppsCurrSrc)
    {
        *ppsCurrDest = psCopySignalVal(*ppsCurrSrc); 

        ppsCurrDest = &((*ppsCurrDest)->m_psNextSignalList); 
        ppsCurrSrc = &((*ppsCurrSrc)->m_psNextSignalList); 
    }

    return Result;
}


BOOL tagSMSGENTRY::bUpdateMsgList(SMSGENTRY*& Root, 
                                        sMESSAGE* psMsg)
{
    BOOL Result = 1;

    SMSGENTRY** ppsCurrDest = &Root;
    

    while (0 != *ppsCurrDest) 
    {
        ppsCurrDest = &((*ppsCurrDest)->m_psNext); 
    }
    
    *ppsCurrDest = new SMSGENTRY; 
    (*ppsCurrDest)->m_psMsg = psCopyMsgVal(psMsg); 
    (*ppsCurrDest)->m_psMsg->m_psSignals = 
                psCopySignalList(psMsg->m_psSignals); 

    return Result;
}
BOOL SMSGENTRY::bGetMsgPtrFromMsgId(const tagSMSGENTRY* psRoot,UINT unMsgId, sMESSAGE*& pMsg)
{
    BOOL bResult = 0;
    const SMSGENTRY* pTemp = psRoot;
    while (pTemp != 0 && bResult == 0)
    {
        if (pTemp->m_psMsg->m_unMessageCode == unMsgId)
        {
            pMsg = pTemp->m_psMsg;
            bResult = 1;
            break;
        }
        pTemp = pTemp->m_psNext;
    }
    return bResult;
}

         Ÿ     Ÿ     šÿÿÿÿ  šÿÿÿÿ    VO8      expression was true       pTemp != 0   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š      expression was false       pTemp != 0   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š                  VMH         ¾      ¾   <   ¹ÿÿÿÿ   ¹ÿÿÿÿ     õø      expression was true       (DATA_FORMAT_INTEL == CurrSig->m_eFormat)    ¾ÿÿÿÿ   ¹      ¾ÿÿÿÿ   ¹   <   expression was false       (DATA_FORMAT_INTEL == CurrSig->m_eFormat)    ¾ÿÿÿÿ   ¹      ¾ÿÿÿÿ   ¹   <               Ä8         E   
   E      @ÿÿÿÿ   @ÿÿÿÿ    ˆä˜      expression was false       pouCurrSrc != 0    Eÿÿÿÿ   @   
   Eÿÿÿÿ   @                  ­ÃØ        Ÿ     Ÿ   &  šÿÿÿÿ  šÿÿÿÿ    / `      expression was true       bResult == 0   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š   &   expression was false       bResult == 0   Ÿÿÿÿÿ  š     Ÿÿÿÿÿ  š   &               VN`                  Šÿÿÿÿ  Šÿÿÿÿ    VE€      expression was false       0 != *ppsCurrDest   ÿÿÿÿ  Š     ÿÿÿÿ  Š                  VB˜        {     {     vÿÿÿÿ  vÿÿÿÿ    f°      expression was false       0 != *ppsCurrSrc   {ÿÿÿÿ  v     {ÿÿÿÿ  v                  f¸   	     +     +     &ÿÿÿÿ  &ÿÿÿÿ    Hœ       expression was false       0 != psCurrSignal   +ÿÿÿÿ  &     +ÿÿÿÿ  &                  4Ê   
               ÿÿÿÿ  ÿÿÿÿ    4Ä0      expression was false       0 != psCurrEntry   ÿÿÿÿ       ÿÿÿÿ                    5È¨         §      §      ¢ÿÿÿÿ   ¢ÿÿÿÿ    Eı       expression was false       0 != Pos    §ÿÿÿÿ   ¢      §ÿÿÿÿ   ¢                  ÎP        ¡     ¡   7  œÿÿÿÿ  œÿÿÿÿ    /'       expression was false       pTemp->m_psMsg->m_unMessageCode == unMsgId   ¡ÿÿÿÿ  œ     ¡ÿÿÿÿ  œ   7               /"È        f     f   *  aÿÿÿÿ  aÿÿÿÿ    ‰ı°      expression was false       0 != psSignal->m_oSignalIDVal   fÿÿÿÿ  a     fÿÿÿÿ  a   *               ‰ù         4     4      /ÿÿÿÿ  /ÿÿÿÿ    H™¨      expression was false       0 != psCurrSignal   4ÿÿÿÿ  /     4ÿÿÿÿ  /                   H–€        2     2   4  -ÿÿÿÿ  -ÿÿÿÿ    H“¨      expression was false       0 != psCurrSignal->m_oSignalIDVal   2ÿÿÿÿ  -     2ÿÿÿÿ  -   4               4Ïx        /     /   .  *ÿÿÿÿ  *ÿÿÿÿ    H•h      expression was false       0 != psCurrSignal->m_oSignalIDVal   /ÿÿÿÿ  *     /ÿÿÿÿ  *   .               4Íà                  ÿÿÿÿ  ÿÿÿÿ    4ÁX      expression was false       0 != psCurrEntry   ÿÿÿÿ       ÿÿÿÿ                    5Ì°           	       	ÿÿÿÿ  	ÿÿÿÿ    5Ãè      expression was false       0 != m_psNext   ÿÿÿÿ  	   	  ÿÿÿÿ  	                  R|         	   	  	     ÿÿÿÿ  ÿÿÿÿ    Rzè      expression was false       0 != m_psMsg   	ÿÿÿÿ     	  	ÿÿÿÿ                    Rw          Ã   	   Ã   3   ¾ÿÿÿÿ   ¾ÿÿÿÿ    ?ƒØ      expression was false       DATA_FORMAT_MOTOROLA == CurrSig->m_eFormat    Ãÿÿÿÿ   ¾   	   Ãÿÿÿÿ   ¾   3               h          *   	   *   *   %ÿÿÿÿ   %ÿÿÿÿ     )a¨      expression was false       0 != m_pouNextSignalSignalDescVal    *ÿÿÿÿ   %   	   *ÿÿÿÿ   %   *               IĞ        ©     ©     ¤ÿÿÿÿ  ¤ÿÿÿÿ    /+        statement executed        return bResult;   ©ÿÿÿÿ  ¤     ©ÿÿÿÿ  ¤                   ¨     ¨     £ÿÿÿÿ  £ÿÿÿÿ    /)@       statement executed        }   ¨ÿÿÿÿ  £     ¨ÿÿÿÿ  £                   ¥     ¥      ÿÿÿÿ   ÿÿÿÿ    /&(       statement executed        break;   ¥ÿÿÿÿ        ¥ÿÿÿÿ                      ™     ™     ”ÿÿÿÿ  ”ÿÿÿÿ    VG°       statement executed        return Result;   ™ÿÿÿÿ  ”     ™ÿÿÿÿ  ”                   ’     ’     ÿÿÿÿ  ÿÿÿÿ    VD¨       statement executed        }   ’ÿÿÿÿ       ’ÿÿÿÿ                     ƒ     ƒ     ~ÿÿÿÿ  ~ÿÿÿÿ    f˜       statement executed        return Result;   ƒÿÿÿÿ  ~     ƒÿÿÿÿ  ~                             |ÿÿÿÿ  |ÿÿÿÿ    fØ       statement executed        }   ÿÿÿÿ  |     ÿÿÿÿ  |                   p     p     kÿÿÿÿ  kÿÿÿÿ    f°       statement executed        return Result;   pÿÿÿÿ  k     pÿÿÿÿ  k                   o     o     jÿÿÿÿ  jÿÿÿÿ    f H       statement executed        }   oÿÿÿÿ  j     oÿÿÿÿ  j                   k     k     fÿÿÿÿ  fÿÿÿÿ    ‰ş˜       statement executed        }   kÿÿÿÿ  f     kÿÿÿÿ  f                    j   	  j   
  eÿÿÿÿ  eÿÿÿÿ    ‰üØ       statement executed        }   jÿÿÿÿ  e   	  jÿÿÿÿ  e   
           !     M     M     Hÿÿÿÿ  Hÿÿÿÿ    .Î       statement executed        return Result;   Mÿÿÿÿ  H     Mÿÿÿÿ  H              "     L     L     Gÿÿÿÿ  Gÿÿÿÿ    -o       statement executed        }   Lÿÿÿÿ  G     Lÿÿÿÿ  G              #     H     H     Cÿÿÿÿ  Cÿÿÿÿ    -n@       statement executed        }   Hÿÿÿÿ  C     Hÿÿÿÿ  C              $     7     7     2ÿÿÿÿ  2ÿÿÿÿ    Hˆ       statement executed        }   7ÿÿÿÿ  2     7ÿÿÿÿ  2              %     6     6     1ÿÿÿÿ  1ÿÿÿÿ    H›È       statement executed        }   6ÿÿÿÿ  1     6ÿÿÿÿ  1              &     4   K  4   L  /ÿÿÿÿ  /ÿÿÿÿ    H˜Ğ       statement executed        }   4ÿÿÿÿ  /   K  4ÿÿÿÿ  /   L           '     3   	  3   
  .ÿÿÿÿ  .ÿÿÿÿ    H”       statement executed        }   3ÿÿÿÿ  .   	  3ÿÿÿÿ  .   
           (     2     2   €  -ÿÿÿÿ  -ÿÿÿÿ    H’Ğ       statement executed        }   2ÿÿÿÿ  -     2ÿÿÿÿ  -   €           )     $     $     ÿÿÿÿ  ÿÿÿÿ    4Æ        statement executed        }   $ÿÿÿÿ       $ÿÿÿÿ                *     "     "     ÿÿÿÿ  ÿÿÿÿ    4ÃX       statement executed        }   "ÿÿÿÿ       "ÿÿÿÿ                +        H     I  ÿÿÿÿ  ÿÿÿÿ    5Ï        statement executed        }   ÿÿÿÿ     H  ÿÿÿÿ     I           ,               ÿÿÿÿ  ÿÿÿÿ    5ÄĞ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                -               ÿÿÿÿ  ÿÿÿÿ    5Ã       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                .               ÿÿÿÿ  ÿÿÿÿ    Rz       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                /                ÿÿÿÿ   ÿÿÿÿ    Ru`       statement executed        }   ÿÿÿÿ        ÿÿÿÿ                 0      ù      ù      ôÿÿÿÿ   ôÿÿÿÿ    Rq@       statement executed        }    ùÿÿÿÿ   ô      ùÿÿÿÿ   ô              1      ò      ò      íÿÿÿÿ   íÿÿÿÿ    ¨       statement executed        }    òÿÿÿÿ   í      òÿÿÿÿ   í              2      å      å      àÿÿÿÿ   àÿÿÿÿ    5Wp       statement executed        }    åÿÿÿÿ   à      åÿÿÿÿ   à              3      Í      Í      Èÿÿÿÿ   Èÿÿÿÿ    ?„À       statement executed        return Result;    Íÿÿÿÿ   È      Íÿÿÿÿ   È              4      Ì      Ì      Çÿÿÿÿ   Çÿÿÿÿ    ?ƒ        statement executed        }    Ìÿÿÿÿ   Ç      Ìÿÿÿÿ   Ç              5      ®      ®      ©ÿÿÿÿ   ©ÿÿÿÿ    Eı°       statement executed        return *this;    ®ÿÿÿÿ   ©      ®ÿÿÿÿ   ©              6      ¬      ¬      §ÿÿÿÿ   §ÿÿÿÿ    Eûà       statement executed        }    ¬ÿÿÿÿ   §      ¬ÿÿÿÿ   §              7      œ      œ   '   —ÿÿÿÿ   —ÿÿÿÿ     ó¹¸       statement executed        return (m_nMsgID == RefObj.m_nMsgID);    œÿÿÿÿ   —      œÿÿÿÿ   —   '           8      ˜      ˜      “ÿÿÿÿ   “ÿÿÿÿ     4p       statement executed        }    ˜ÿÿÿÿ   “      ˜ÿÿÿÿ   “              9      ‘      ‘      Œÿÿÿÿ   Œÿÿÿÿ    yP       statement executed        }    ‘ÿÿÿÿ   Œ      ‘ÿÿÿÿ   Œ              :                  ˆÿÿÿÿ   ˆÿÿÿÿ    ø¸       statement executed        }    ÿÿÿÿ   ˆ      ÿÿÿÿ   ˆ              ;      „      „   -   ÿÿÿÿ   ÿÿÿÿ     ñ_0       statement executed        return (m_omSigName == RefObj.m_omSigName);    „ÿÿÿÿ         „ÿÿÿÿ      -           <                  zÿÿÿÿ   zÿÿÿÿ    Eÿ(       statement executed        return *this;    ÿÿÿÿ   z      ÿÿÿÿ   z              =      x      x      sÿÿÿÿ   sÿÿÿÿ    õ`       statement executed        }    xÿÿÿÿ   s      xÿÿÿÿ   s              >      o      o      jÿÿÿÿ   jÿÿÿÿ    C(       statement executed        return Result;    oÿÿÿÿ   j      oÿÿÿÿ   j              ?      l   (   l   .   gÿÿÿÿ   gÿÿÿÿ    (®°       statement executed        break;    lÿÿÿÿ   g   (   lÿÿÿÿ   g   .           @      k   :   k   @   fÿÿÿÿ   fÿÿÿÿ    Uh       statement executed        break;    kÿÿÿÿ   f   :   kÿÿÿÿ   f   @           A      j   0   j   6   eÿÿÿÿ   eÿÿÿÿ    Mœà       statement executed        break;    jÿÿÿÿ   e   0   jÿÿÿÿ   e   6           B      a      a      \ÿÿÿÿ   \ÿÿÿÿ     .       statement executed        return *this;    aÿÿÿÿ   \      aÿÿÿÿ   \              C      X      X      Sÿÿÿÿ   Sÿÿÿÿ    ˆâø       statement executed        }    Xÿÿÿÿ   S      Xÿÿÿÿ   S              D      P      P      Kÿÿÿÿ   Kÿÿÿÿ    ˆãÈ       statement executed        return *this;    Pÿÿÿÿ   K      Pÿÿÿÿ   K              E      N      N      Iÿÿÿÿ   Iÿÿÿÿ    ­À`       statement executed        }    Nÿÿÿÿ   I      Nÿÿÿÿ   I              F      0      0      +ÿÿÿÿ   +ÿÿÿÿ    Ë       statement executed        }    0ÿÿÿÿ   +      0ÿÿÿÿ   +              G      /      /      *ÿÿÿÿ   *ÿÿÿÿ    kè       statement executed        }    /ÿÿÿÿ   *      /ÿÿÿÿ   *              H      %      %       ÿÿÿÿ    ÿÿÿÿ     3Í¨       statement executed        }    %ÿÿÿÿ          %ÿÿÿÿ                  I      !      !      ÿÿÿÿ   ÿÿÿÿ            statement executed        }    !ÿÿÿÿ         !ÿÿÿÿ              CSignalDescVal::CSignalDescVal CSignalDescVal::CSignalDescVal()          !      ÿÿÿÿ   ÿÿÿÿCSignalDescVal::~CSignalDescVal CSignalDescVal::~CSignalDescVal()    $      %      ÿÿÿÿ    ÿÿÿÿCSignalDescVal::vClearNext void CSignalDescVal::vClearNext(void)    (      0      #ÿÿÿÿ   +ÿÿÿÿCSignalDescVal::operator= CSignalDescVal& CSignalDescVal::operator=(const CSignalDescVal& RefObj)    3      Q      .ÿÿÿÿ   LÿÿÿÿsWaveformInfo::sWaveformInfo sWaveformInfo::sWaveformInfo()    W      X      Rÿÿÿÿ   SÿÿÿÿsWaveformInfo::operator= sWaveformInfo& sWaveformInfo::operator=(const sWaveformInfo& RefObj)    [      b      Vÿÿÿÿ   ]ÿÿÿÿsWaveformInfo::omGetWaveformName CString sWaveformInfo::omGetWaveformName(eWAVEFORMTYPE eWaveform)    e      p      `ÿÿÿÿ   kÿÿÿÿsSigWaveMap::sSigWaveMap sSigWaveMap::sSigWaveMap()    v      x      qÿÿÿÿ   sÿÿÿÿsSigWaveMap::operator= sSigWaveMap& sSigWaveMap::operator=(const sSigWaveMap& RefObj)    {      €      vÿÿÿÿ   {ÿÿÿÿsSigWaveMap::operator== BOOL sSigWaveMap::operator==(const sSigWaveMap& RefObj)    ƒ      …      ~ÿÿÿÿ   €ÿÿÿÿSSigGeneration::SSigGeneration SSigGeneration::SSigGeneration()    ‹            †ÿÿÿÿ   ˆÿÿÿÿSSigGeneration::~SSigGeneration SSigGeneration::~SSigGeneration()          ‘      Šÿÿÿÿ   ŒÿÿÿÿSSigGeneration::Reset void SSigGeneration::Reset(void)    ”      ˜      ÿÿÿÿ   “ÿÿÿÿSSigGeneration::operator== BOOL SSigGeneration::operator==(const SSigGeneration& RefObj)    ›            –ÿÿÿÿ   ˜ÿÿÿÿSSigGeneration::operator= SSigGeneration& SSigGeneration::operator=(const SSigGeneration& RefObj)           ¯      ›ÿÿÿÿ   ªÿÿÿÿsSIGNALS::un64GetBitMask UINT64 sSIGNALS::un64GetBitMask(sSIGNALS* CurrSig)    ¶      Î      ±ÿÿÿÿ   ÉÿÿÿÿsSIGNALS::vSetSignalValue void sSIGNALS::vSetSignalValue(sSIGNALS* pouCurrSignal, UCHAR aucData[8], 
                               UINT64 u64SignVal)    Ò      ù      Íÿÿÿÿ   ôÿÿÿÿtagSMSGENTRY::tagSMSGENTRY tagSMSGENTRY::tagSMSGENTRY()              ıÿÿÿÿ   ÿÿÿÿtagSMSGENTRY::~tagSMSGENTRY tagSMSGENTRY::~tagSMSGENTRY()             ÿÿÿÿ  ÿÿÿÿtagSMSGENTRY::vClearMsgList void tagSMSGENTRY::vClearMsgList(SMSGENTRY*& psMsgRoot)        $     ÿÿÿÿ  ÿÿÿÿtagSMSGENTRY::vClearSignalList void tagSMSGENTRY::vClearSignalList(sSIGNALS* psSignals)   (     7     #ÿÿÿÿ  2ÿÿÿÿtagSMSGENTRY::psCopyMsgVal sMESSAGE* tagSMSGENTRY::psCopyMsgVal(sMESSAGE* psMsg)   ;     N     6ÿÿÿÿ  IÿÿÿÿtagSMSGENTRY::psCopySignalVal sSIGNALS* tagSMSGENTRY::psCopySignalVal(sSIGNALS* psSignal)   S     q     Nÿÿÿÿ  lÿÿÿÿtagSMSGENTRY::psCopySignalList sSIGNALS* tagSMSGENTRY::psCopySignalList(sSIGNALS* psSignal)   u     „     pÿÿÿÿ  ÿÿÿÿtagSMSGENTRY::bUpdateMsgList BOOL tagSMSGENTRY::bUpdateMsgList(SMSGENTRY*& Root, 
                                        sMESSAGE* psMsg)   ‰     š     „ÿÿÿÿ  •ÿÿÿÿSMSGENTRY::bGetMsgPtrFromMsgId BOOL SMSGENTRY::bGetMsgPtrFromMsgId(const tagSMSGENTRY* psRoot,UINT unMsgId, sMESSAGE*& pMsg)   œ     ª     —ÿÿÿÿ  ¥ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      MsgSignal_Datatypes.cpp
 * \author    Ratnadip Choudhury
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 */
#include "Datatypes_stdafx.h"
#include "Include/BaseDefs.h"
#include "Include/Utils_macro.h"
#include "MsgSignal_Datatypes.h"
#include <math.h>
// Starts CSignalDescVal
CSignalDescVal::CSignalDescVal()
{
    m_omStrSignalDescriptor = "";
    //m_n64SignalVal = 0x0;
	m_DescValue.un64Value = 0x0;
    m_pouNextSignalSignalDescVal = NULL;
}

CSignalDescVal::~CSignalDescVal()
{
}

void CSignalDescVal::vClearNext(void)
{
    // This function clears all the succeeding entries
    if (NULL != m_pouNextSignalSignalDescVal)
    {
        m_pouNextSignalSignalDescVal->vClearNext();
        delete m_pouNextSignalSignalDescVal;
        m_pouNextSignalSignalDescVal = NULL;
    }
}

CSignalDescVal& CSignalDescVal::operator=(const CSignalDescVal& RefObj)
{
    vClearNext();

    m_omStrSignalDescriptor = RefObj.m_omStrSignalDescriptor;
    //m_n64SignalVal          = RefObj.m_n64SignalVal;
    m_DescValue          = RefObj.m_DescValue;

    /* This is the case of copying a linked list. Recursion would have been the
    simplest approach. Howsoever, an iterative approach has been adopted with a
    view to realising something new and avoiding defining some more functions*/

    /* The technique of double pointer in order to avoid usage of multiple poi-
    nters. The double pointer contains value of the current 'next' pointer. We
    start by storing address of the 'next' variable of current node. */
    CSignalDescVal** ppouCurrTgt = &m_pouNextSignalSignalDescVal;

    // Clearly, we must go on until the end of the reference linked list.
    for (CSignalDescVal *pouCurrSrc = RefObj.m_pouNextSignalSignalDescVal;
         pouCurrSrc != NULL; 
         pouCurrSrc = pouCurrSrc->m_pouNextSignalSignalDescVal)
    {
        (*ppouCurrTgt) = new CSignalDescVal; // Indirect value assigning to 'next'
        (*ppouCurrTgt)->m_omStrSignalDescriptor = pouCurrSrc->m_omStrSignalDescriptor;
        //(*ppouCurrTgt)->m_n64SignalVal = pouCurrSrc->m_n64SignalVal;
        (*ppouCurrTgt)->m_DescValue = pouCurrSrc->m_DescValue;
        // Now it should point to the 'next' of current node.
        ppouCurrTgt = &((*ppouCurrTgt)->m_pouNextSignalSignalDescVal);
    }

    return *this;
}
// Ends CSignalDescVal

// Starts sWaveformInfo
sWaveformInfo::sWaveformInfo(): m_eSignalWaveType(eWave_NONE),
					  m_fAmplitude(0.0), m_fFrequency(0.0), m_fGranularity(0.0)
{
}

sWaveformInfo& sWaveformInfo::operator=(const sWaveformInfo& RefObj)
{
	m_eSignalWaveType   = RefObj.m_eSignalWaveType;
	m_fAmplitude        = RefObj.m_fAmplitude;
	m_fFrequency        = RefObj.m_fFrequency;
    m_fGranularity      = RefObj.m_fGranularity;

	return *this;
}

CString sWaveformInfo::omGetWaveformName(eWAVEFORMTYPE eWaveform)
{
    CString Result = "";

    switch (eWaveform)
    {
        case eWave_SINE: Result = "Sine wave"; break;
        case eWave_TRIANGLE: Result = "Triangular wave"; break;
		case eWave_COS: Result = "Cos wave"; break;
    }

    return Result;
}

// Ends sWaveformInfo

// Starts sSigWaveMap
sSigWaveMap::sSigWaveMap()
{
    m_omSigName = "";
}

sSigWaveMap& sSigWaveMap::operator=(const sSigWaveMap& RefObj)
{
    m_omSigName = RefObj.m_omSigName;
    sWaveInfo   = RefObj.sWaveInfo;

    return *this;
}

BOOL sSigWaveMap::operator==(const sSigWaveMap& RefObj) const
{
	return (m_omSigName == RefObj.m_omSigName);
}
// Ends sSigWaveMap


// Starts SSigGeneration
SSigGeneration::SSigGeneration()
{
    Reset();
}
SSigGeneration::~SSigGeneration()
{
    Reset();
}

void SSigGeneration::Reset(void)
{
    m_nMsgID = 0x0;
    m_fDefaultAmplitude = (float) 0.0;
    m_omSigWaveMapList.RemoveAll();
}

BOOL SSigGeneration::operator==(const SSigGeneration& RefObj) const
{
	return (m_nMsgID == RefObj.m_nMsgID);
}

SSigGeneration& SSigGeneration::operator=(const SSigGeneration& RefObj)
{
    Reset();

	m_nMsgID = RefObj.m_nMsgID;
	m_fDefaultAmplitude = RefObj.m_fDefaultAmplitude;

    POSITION Pos = RefObj.m_omSigWaveMapList.GetHeadPosition();
    while (NULL != Pos)
    {
        const sSigWaveMap& CurrObj = RefObj.m_omSigWaveMapList.GetNext(Pos);
        sSigWaveMap TmpObj = CurrObj;
        m_omSigWaveMapList.AddTail(TmpObj);
    }

	return *this;
}
// Ends SSigGeneration


// Starts static functions of sSIGNALS

UINT64 sSIGNALS::un64GetBitMask(sSIGNALS* CurrSig)
{
    UINT64 Result = 0x1;

    // First make the required number of bits (m_unSignalLength) up.
    Result <<= CurrSig->m_unSignalLength;
    --Result; // These bits are now up.

    // Then shift them to the appropriate place.
    short Shift = (DATA_FORMAT_INTEL == CurrSig->m_eFormat) ? 
        ((short)CurrSig->m_unStartByte - 1) * 8 + CurrSig->m_byStartBit
        : 64 - ((short)CurrSig->m_unStartByte * 8 - CurrSig->m_byStartBit);
    Result <<= Shift;

    if (DATA_FORMAT_MOTOROLA == CurrSig->m_eFormat)
    {
        BYTE* pbStr = (BYTE *) &Result;

        BYTE bTmp = 0x0;
        bTmp = pbStr[0]; pbStr[0] = pbStr[7] ; pbStr[7] = bTmp;
        bTmp = pbStr[1]; pbStr[1] = pbStr[6] ; pbStr[6] = bTmp;
        bTmp = pbStr[2]; pbStr[2] = pbStr[5] ; pbStr[5] = bTmp;
        bTmp = pbStr[3]; pbStr[3] = pbStr[4] ; pbStr[4] = bTmp;
    }
    return Result;
}

void sSIGNALS::vSetSignalValue(sSIGNALS* pouCurrSignal, UCHAR aucData[8], 
                               UINT64 u64SignVal)
{
    ASSERT(pouCurrSignal != NULL);

    /* Signal value data type happens to be of the same size of the entire CAN
    data byte array. Hence there is an opportunity to take advantage of this
    idiosyncratic characteristics. We will shifts the bit array in u64SignVal
    by the required number of bit positions to exactly map it as a data byte
    array and then interchange positions of bytes as per the endianness and
    finally use it as the etching mask on the target. */

    UINT64* pu64Target = (UINT64 *) aucData; // We should be able to work on
    BYTE* pbData = (BYTE *) &u64SignVal;     // these variables as an array of
                                             // bytes and vice versa.

    if (pouCurrSignal->m_eFormat == DATA_FORMAT_INTEL)// If Intel format
    {
        int Offset = (pouCurrSignal->m_unStartByte - 1) * 8 +
                                             pouCurrSignal->m_byStartBit;
        u64SignVal <<= Offset; // Exactly map the data bits on the data bytes.
    }
    else    // If Motorola format
    {
        int Offset = pouCurrSignal->m_unStartByte * 8 -
                                             pouCurrSignal->m_byStartBit;
        u64SignVal <<= (64 - Offset);

        BYTE byTmp = 0x0;

        byTmp = pbData[7]; pbData[7] = pbData[0]; pbData[0] = byTmp;
        byTmp = pbData[6]; pbData[6] = pbData[1]; pbData[1] = byTmp;
        byTmp = pbData[5]; pbData[5] = pbData[2]; pbData[2] = byTmp;
        byTmp = pbData[4]; pbData[4] = pbData[3]; pbData[3] = byTmp;
    }

	//Arun
    UINT64 unTmp = un64GetBitMask(pouCurrSignal);
    *pu64Target |= unTmp;  // All bits related to the current signal will be
                           // be made 0xFF.
    *pu64Target &= u64SignVal;
}
// Ends static functions of sSIGNALS


/* STARTS static public functions of SMSGENTRY */

// Given the root, this clears the message linked list

tagSMSGENTRY::tagSMSGENTRY() 
{ 
    m_psMsg = NULL; 
    m_psNext = NULL; 
}

tagSMSGENTRY::~tagSMSGENTRY()
{
    if (NULL != m_psMsg) 
    {
        delete m_psMsg;
        m_psMsg = NULL;
    }
    if (NULL != m_psNext)
    {
        delete m_psNext;
        m_psNext = NULL;
    }
}

void tagSMSGENTRY::vClearMsgList(SMSGENTRY*& psMsgRoot)
{
    SMSGENTRY* psCurrEntry = psMsgRoot;
    while (NULL != psCurrEntry) // The message list
    {
        SMSGENTRY* psNext = psCurrEntry->m_psNext;

        vClearSignalList(psCurrEntry->m_psMsg->m_psSignals); // delete all
        psCurrEntry->m_psNext = NULL;
        DELETE_PTR(psCurrEntry);    // the data

        psCurrEntry = psNext; // Get on with the next one

    } // while (NULL != psCurrEntry)
    psMsgRoot = NULL;
}

// Given the root, this clears the signal linked list
void tagSMSGENTRY::vClearSignalList(sSIGNALS* psSignals)
{
    sSIGNALS* psCurrSignal = psSignals;

    while (NULL != psCurrSignal)
    {
        sSIGNALS* psSignalNext = psCurrSignal->m_psNextSignalList;
        psCurrSignal->m_psNextSignalList = NULL;
        if (NULL != psCurrSignal->m_oSignalIDVal)
        {
            psCurrSignal->m_oSignalIDVal->vClearNext();
            DELETE_PTR(psCurrSignal->m_oSignalIDVal);
        }
        DELETE_PTR(psCurrSignal);
        psCurrSignal = psSignalNext;
    } // while (NULL != psCurrSignal)
}

// This function copies the current message entry except the signal list
sMESSAGE* tagSMSGENTRY::psCopyMsgVal(sMESSAGE* psMsg)
{
    sMESSAGE* Result = new sMESSAGE;

    if (NULL != Result)
    {
        Result->m_omStrMessageName      = psMsg->m_omStrMessageName;
        Result->m_unMessageCode         = psMsg->m_unMessageCode;
        Result->m_unNumberOfSignals     = psMsg->m_unNumberOfSignals;
        Result->m_unMessageLength       = psMsg->m_unMessageLength;
        Result->m_bMessageFrameFormat   = psMsg->m_bMessageFrameFormat;
        Result->m_psSignals             = NULL;
        memcpy(Result->m_bySignalMatrix, psMsg->m_bySignalMatrix, 8);
        Result->m_nMsgDataFormat        = psMsg->m_nMsgDataFormat;
    }
    else
    {
        ASSERT(FALSE);
    }
    return Result;
}

// This function copies the current signal entry including the descriptor list.
// The copy operation excludes the next signal in the signal linked list.
sSIGNALS* tagSMSGENTRY::psCopySignalVal(sSIGNALS* psSignal)
{
    sSIGNALS* Result = new sSIGNALS;

    if (NULL != Result)
    {
        Result->m_omStrSignalName       = psSignal->m_omStrSignalName;
        Result->m_unStartByte           = psSignal->m_unStartByte;
        Result->m_unSignalLength        = psSignal->m_unSignalLength;
        Result->m_byStartBit            = psSignal->m_byStartBit;
        Result->m_bySignalType          = psSignal->m_bySignalType;
        Result->m_SignalMinValue        = psSignal->m_SignalMinValue;
        Result->m_SignalMaxValue        = psSignal->m_SignalMaxValue;
        Result->m_fSignalFactor         = psSignal->m_fSignalFactor;
        Result->m_fSignalOffset         = psSignal->m_fSignalOffset;
        Result->m_omStrSignalUnit       = psSignal->m_omStrSignalUnit;
        Result->m_eFormat               = psSignal->m_eFormat;
        Result->m_oSignalIDVal          = NULL;
        Result->m_psNextSignalList      = NULL;

        if (NULL != psSignal->m_oSignalIDVal)
        {
            Result->m_oSignalIDVal = new CSignalDescVal;
            *(Result->m_oSignalIDVal) = *(psSignal->m_oSignalIDVal);
        }
    }
    else
    {
        ASSERT(FALSE);
    }
    return Result;
}

// This function copies the signal linked list and returns root of the new list
sSIGNALS* tagSMSGENTRY::psCopySignalList(sSIGNALS* psSignal)
{
    sSIGNALS* Result = NULL;

    sSIGNALS** ppsCurrDest = &Result;
    sSIGNALS** ppsCurrSrc = &psSignal;

    while (NULL != *ppsCurrSrc)
    {
        *ppsCurrDest = psCopySignalVal(*ppsCurrSrc); // Copy signal values

        ppsCurrDest = &((*ppsCurrDest)->m_psNextSignalList); // Keep the next entry ready
        ppsCurrSrc = &((*ppsCurrSrc)->m_psNextSignalList); // Iterate to the next source entry
    }

    return Result;
}

// This function copies the message linked list and returns root of the new list
BOOL tagSMSGENTRY::bUpdateMsgList(SMSGENTRY*& Root, 
                                        sMESSAGE* psMsg)
{
    BOOL Result = TRUE;

    SMSGENTRY** ppsCurrDest = &Root;
    //sMESSAGE** ppsCurrSrc = &psMsg;

    while (NULL != *ppsCurrDest) // The idea is to reach the end of message list
    {
        ppsCurrDest = &((*ppsCurrDest)->m_psNext); // Iterate to the next entry
    }
    // We're at the end of list
    *ppsCurrDest = new SMSGENTRY; // Create an initialised entry
    (*ppsCurrDest)->m_psMsg = psCopyMsgVal(psMsg); // Copy message values
    (*ppsCurrDest)->m_psMsg->m_psSignals = 
                psCopySignalList(psMsg->m_psSignals); // Copy signal list

    return Result;
}
BOOL SMSGENTRY::bGetMsgPtrFromMsgId(const tagSMSGENTRY* psRoot,UINT unMsgId, sMESSAGE*& pMsg)
{
    BOOL bResult = FALSE;
    const SMSGENTRY* pTemp = psRoot;
    while (pTemp != NULL && bResult == FALSE)
    {
        if (pTemp->m_psMsg->m_unMessageCode == unMsgId)
        {
            pMsg = pTemp->m_psMsg;
            bResult = TRUE;
            break;
        }
        pTemp = pTemp->m_psNext;
    }
    return bResult;
}
/* ENDS static public functions of SMSGENTRY */





























FILESTORAGEINFO::FILESTORAGEINFO()
{
    memset(m_FilePath, '\0', 260);
}

















void PROJECTDATA::Initialise(void)
{
    SYSTEMTIME CurrSysTime;
    GetSystemTime(&CurrSysTime);

    m_ProjectName   = "";
    m_Language      = "eng";
    memcpy(&m_ProjSysTime, &CurrSysTime, sizeof (SYSTEMTIME));
	m_fAppVersion = 0;
	m_dwAppUniqueId = 0;
};













PROJECTDATA::PROJECTDATA()
{
    Initialise();
}













PROJECTDATA::~PROJECTDATA()
{
}













PROJECTDATA& PROJECTDATA::operator=(const PROJECTDATA& RefObj)
{
    m_ProjectName = RefObj.m_ProjectName;
    m_Language    = RefObj.m_Language;
	m_fAppVersion = RefObj.m_fAppVersion;
	m_dwAppUniqueId = RefObj.m_dwAppUniqueId;
	memcpy(&m_ProjSysTime, &RefObj.m_ProjSysTime, sizeof (SYSTEMTIME));

    return *this;
}













bool PROJECTDATA::Write(FILE* pFile)
{
	bool bResult = false;

    








	const char* Buffer = m_ProjectName.c_str();
	int n =  (int) strlen(Buffer);
	if (fwrite(&n, sizeof(int), 1, pFile) == 1)
	{
		if ((int) fwrite(Buffer, sizeof(char), n, pFile) == n)
		{
			Buffer = m_Language.c_str();
			n =  (int) strlen(Buffer);
			if (fwrite(&n, sizeof(int), 1, pFile) == 1)
			{
				if ((int) fwrite(Buffer, sizeof(char), n, pFile) == n)
				{
					if (fwrite(&m_ProjSysTime, sizeof(SYSTEMTIME), 1, pFile) == 1)
					{
						if (fwrite(&m_fAppVersion, sizeof(float), 1, pFile) == 1)
						{
							if (fwrite(&m_dwAppUniqueId, sizeof(DWORD), 1, pFile) == 1)
							{
								bResult = true;
							}
						}
					}
				}
			}
		}
	}
    return bResult;
}















bool PROJECTDATA::Read(FILE* pFile)
{
    Initialise();

    bool bResult = false;
    char Buffer[260] = {'\0'};
	int n;

    
	if (fread(&n, sizeof(int), 1, pFile) == 1)
	{
		if (fread(Buffer, sizeof(char) * n, 1, pFile) != 0)
		{
			m_ProjectName = Buffer;
			if (fread(&n, sizeof(int), 1, pFile) == 1)
			{
				if (fread(Buffer, sizeof(char) * n, 1, pFile) != 0)
				{
					m_Language = Buffer;
					if (fread(&m_ProjSysTime, sizeof(SYSTEMTIME), 1, pFile) == 1)
					{
						if (fread(&m_fAppVersion, sizeof(float), 1, pFile) == 1)
						{
							if (fread(&m_dwAppUniqueId, sizeof(DWORD), 1, pFile) == 1)
							{
								bResult = true;
							}
						}
					}
				}
			}
		}
	}
    return bResult;
}

















SECTIONDATA::SECTIONDATA()
{
    m_bBLOB = 0;
    m_nBLOBLen = 0;
    m_omSectionName = "";
}













SECTIONDATA::~SECTIONDATA()
{
    Initialise();
}













void SECTIONDATA::Initialise(void)
{
	if (0 != m_bBLOB)
	{
		delete[] m_bBLOB;
		m_bBLOB = 0;
	}
    m_nBLOBLen = 0;
    m_omSectionName = "";
}













SECTIONDATA& SECTIONDATA::operator=(const SECTIONDATA& RefObj)
{
    Initialise();

	m_bBLOB = new BYTE[RefObj.m_nBLOBLen];
    if (m_bBLOB != 0)
    {
        m_nBLOBLen = RefObj.m_nBLOBLen;
		memcpy(m_bBLOB, RefObj.m_bBLOB, RefObj.m_nBLOBLen);
        m_omSectionName = RefObj.m_omSectionName;
    }
    return *this;
}













bool SECTIONDATA::Write(FILE* pFile)
{
    bool bResult = false;

    





    const char* Buffer = m_omSectionName.c_str();
	int n = (int) strlen(Buffer);
	if (fwrite(&n, sizeof(int), 1, pFile) == 1)
	{
		if ((int) fwrite(Buffer, sizeof(char), n, pFile) == n)
		{
			if (fwrite(&m_nBLOBLen, sizeof(m_nBLOBLen), 1, pFile) == 1)
			{
				if (m_bBLOB != 0)
				{
					if ((int) fwrite(m_bBLOB, 1, m_nBLOBLen, pFile) == m_nBLOBLen)
					{
						bResult = true;
					}
				}
			}
		}
	}
	return bResult;
}















bool SECTIONDATA::Read(FILE* pFile)
{
    Initialise();

    bool bResult = false;
	char Buffer[260] = {'\0'};
	int n;

	if (fread(&n, sizeof(int), 1, pFile) == 1)
	{
		if (fread(Buffer, sizeof(char) * n, 1,pFile) != 0)
		{
			m_omSectionName = Buffer;
			if (fread(&m_nBLOBLen, sizeof(m_nBLOBLen), 1, pFile) == 1)
			{
				m_bBLOB = new BYTE[m_nBLOBLen];
				if (m_bBLOB != 0)
				{
					if ((int) fread(m_bBLOB, 1, m_nBLOBLen, pFile) == m_nBLOBLen)
					{
						bResult = true;
					}
				}
			}
		}
	}
    return bResult;
}

         †   
  †   B  „ÿÿÿÿ  „ÿÿÿÿ    E÷      expression was false       (int) fread(m_bBLOB, 1, m_nBLOBLen, pFile) == m_nBLOBLen   †ÿÿÿÿ  „   
  †ÿÿÿÿ  „   B                *ü°        „   	  „     ‚ÿÿÿÿ  ‚ÿÿÿÿ    EøÈ      expression was false       m_bBLOB != 0   „ÿÿÿÿ  ‚   	  „ÿÿÿÿ  ‚                   *ú`                =  ÿÿÿÿ  ÿÿÿÿ    Eúx      expression was false       fread(&m_nBLOBLen, sizeof(m_nBLOBLen), 1, pFile) == 1   ÿÿÿÿ       ÿÿÿÿ     =                *÷ğ        ~     ~   4  |ÿÿÿÿ  |ÿÿÿÿ    Eü8      expression was false       fread(Buffer, sizeof(char) * n, 1,pFile) != 0   ~ÿÿÿÿ  |     ~ÿÿÿÿ  |   4               wˆ        |     |   +  zÿÿÿÿ  zÿÿÿÿ    Eıø      expression was false       fread(&n, sizeof(int), 1, pFile) == 1   |ÿÿÿÿ  z     |ÿÿÿÿ  z   +               vp        [   
  [   C  Yÿÿÿÿ  Yÿÿÿÿ     iH      expression was false       (int) fwrite(m_bBLOB, 1, m_nBLOBLen, pFile) == m_nBLOBLen   [ÿÿÿÿ  Y   
  [ÿÿÿÿ  Y   C                6NX        Y   	  Y     Wÿÿÿÿ  Wÿÿÿÿ     jø      expression was false       m_bBLOB != 0   Yÿÿÿÿ  W   	  Yÿÿÿÿ  W                   6L        W     W   >  Uÿÿÿÿ  Uÿÿÿÿ     l¨      expression was false       fwrite(&m_nBLOBLen, sizeof(m_nBLOBLen), 1, pFile) == 1   Wÿÿÿÿ  U     Wÿÿÿÿ  U   >                6JØ        U     U   8  Sÿÿÿÿ  Sÿÿÿÿ     nX      expression was false       (int) fwrite(Buffer, sizeof(char), n, pFile) == n   Uÿÿÿÿ  S     Uÿÿÿÿ  S   8                6I˜   	     S     S   ,  Qÿÿÿÿ  Qÿÿÿÿ    pP      expression was false       fwrite(&n, sizeof(int), 1, pFile) == 1   Sÿÿÿÿ  Q     Sÿÿÿÿ  Q   ,               ––Ğ   
     2   	  2     0ÿÿÿÿ  0ÿÿÿÿ    (­È      expression was false       m_bBLOB != 0   2ÿÿÿÿ  0   	  2ÿÿÿÿ  0                  (©                   ÿÿÿÿ  ÿÿÿÿ    @P      expression was false       0 != m_bBLOB   ÿÿÿÿ       ÿÿÿÿ                    Mœà         Õ      Õ   A   Óÿÿÿÿ   Óÿÿÿÿ     ,(      expression was false       fread(&m_dwAppUniqueId, sizeof(DWORD), 1, pFile) == 1    Õÿÿÿÿ   Ó      Õÿÿÿÿ   Ó   A               x`         Ó      Ó   >   Ñÿÿÿÿ   Ñÿÿÿÿ     ,‚Ø      expression was false       fread(&m_fAppVersion, sizeof(float), 1, pFile) == 1    Óÿÿÿÿ   Ñ      Óÿÿÿÿ   Ñ   >               x0         Ñ   
   Ñ   B   Ïÿÿÿÿ   Ïÿÿÿÿ     ,„ˆ      expression was false       fread(&m_ProjSysTime, sizeof(SYSTEMTIME), 1, pFile) == 1    Ñÿÿÿÿ   Ï   
   Ñÿÿÿÿ   Ï   B               x          Î   	   Î   7   Ìÿÿÿÿ   Ìÿÿÿÿ    `P      expression was false       fread(Buffer, sizeof(char) * n, 1, pFile) != 0    Îÿÿÿÿ   Ì   	   Îÿÿÿÿ   Ì   7               ­ÃØ         Ì      Ì   -   Êÿÿÿÿ   Êÿÿÿÿ    b       expression was false       fread(&n, sizeof(int), 1, pFile) == 1    Ìÿÿÿÿ   Ê      Ìÿÿÿÿ   Ê   -               ­ÂÀ         É      É   5   Çÿÿÿÿ   Çÿÿÿÿ    c°      expression was false       fread(Buffer, sizeof(char) * n, 1, pFile) != 0    Éÿÿÿÿ   Ç      Éÿÿÿÿ   Ç   5               ­À`         Ç      Ç   +   Åÿÿÿÿ   Åÿÿÿÿ    e`      expression was false       fread(&n, sizeof(int), 1, pFile) == 1    Çÿÿÿÿ   Å      Çÿÿÿÿ   Å   +               VÂà         £      £   B   ¡ÿÿÿÿ   ¡ÿÿÿÿ    U¯      expression was false       fwrite(&m_dwAppUniqueId, sizeof(DWORD), 1, pFile) == 1    £ÿÿÿÿ   ¡      £ÿÿÿÿ   ¡   B               ÷Ø         ¡      ¡   ?   Ÿÿÿÿÿ   Ÿÿÿÿÿ    HÀ      expression was false       fwrite(&m_fAppVersion, sizeof(float), 1, pFile) == 1    ¡ÿÿÿÿ   Ÿ      ¡ÿÿÿÿ   Ÿ   ?               ûp         Ÿ   
   Ÿ   C   ÿÿÿÿ   ÿÿÿÿ     .È      expression was false       fwrite(&m_ProjSysTime, sizeof(SYSTEMTIME), 1, pFile) == 1    Ÿÿÿÿÿ      
   Ÿÿÿÿÿ      C               H{P            	      :   ›ÿÿÿÿ   ›ÿÿÿÿ    Q~€      expression was false       (int) fwrite(Buffer, sizeof(char), n, pFile) == n    ÿÿÿÿ   ›   	   ÿÿÿÿ   ›   :               x@         ›      ›   .   ™ÿÿÿÿ   ™ÿÿÿÿ     4p      expression was false       fwrite(&n, sizeof(int), 1, pFile) == 1    ›ÿÿÿÿ   ™      ›ÿÿÿÿ   ™   .               ş˜         —      —   8   •ÿÿÿÿ   •ÿÿÿÿ    »0˜      expression was false       (int) fwrite(Buffer, sizeof(char), n, pFile) == n    —ÿÿÿÿ   •      —ÿÿÿÿ   •   8               ùˆ         •      •   ,   “ÿÿÿÿ   “ÿÿÿÿ    0      expression was false       fwrite(&n, sizeof(int), 1, pFile) == 1    •ÿÿÿÿ   “      •ÿÿÿÿ   “   ,                ò%˜                  Œÿÿÿÿ  Œÿÿÿÿ    Eşà       statement executed        return bResult;   ÿÿÿÿ  Œ     ÿÿÿÿ  Œ                             ‹ÿÿÿÿ  ‹ÿÿÿÿ    Eı        statement executed        }   ÿÿÿÿ  ‹     ÿÿÿÿ  ‹                   Œ     Œ     Šÿÿÿÿ  Šÿÿÿÿ    Eû`       statement executed        }   Œÿÿÿÿ  Š     Œÿÿÿÿ  Š                   ‹     ‹     ‰ÿÿÿÿ  ‰ÿÿÿÿ    Eù        statement executed        }   ‹ÿÿÿÿ  ‰     ‹ÿÿÿÿ  ‰                   Š     Š     ˆÿÿÿÿ  ˆÿÿÿÿ    E÷ğ       statement executed        }   Šÿÿÿÿ  ˆ     Šÿÿÿÿ  ˆ                   ‰     ‰     ‡ÿÿÿÿ  ‡ÿÿÿÿ     *ÿ       statement executed        }   ‰ÿÿÿÿ  ‡     ‰ÿÿÿÿ  ‡                    c     c     aÿÿÿÿ  aÿÿÿÿ    q(       statement executed        return bResult;   cÿÿÿÿ  a     cÿÿÿÿ  a              !     b     b     `ÿÿÿÿ  `ÿÿÿÿ     o@       statement executed        }   bÿÿÿÿ  `     bÿÿÿÿ  `              "     a     a     _ÿÿÿÿ  _ÿÿÿÿ     m€       statement executed        }   aÿÿÿÿ  _     aÿÿÿÿ  _              #      $      $      "ÿÿÿÿ   "ÿÿÿÿ    &¨       statement executed        }    $ÿÿÿÿ   "      $ÿÿÿÿ   "              $      @      @      >ÿÿÿÿ   >ÿÿÿÿ     ê¦       statement executed        }    @ÿÿÿÿ   >      @ÿÿÿÿ   >              %      Q      Q      Oÿÿÿÿ   Oÿÿÿÿ     ê¤h       statement executed        }    Qÿÿÿÿ   O      Qÿÿÿÿ   O              &      a      a      _ÿÿÿÿ   _ÿÿÿÿ    g¨       statement executed        }    aÿÿÿÿ   _      aÿÿÿÿ   _              '      w      w      uÿÿÿÿ   uÿÿÿÿ     (ì@       statement executed        return *this;    wÿÿÿÿ   u      wÿÿÿÿ   u              (      ¦      ¦   	   ¤ÿÿÿÿ   ¤ÿÿÿÿ     .ˆ       statement executed        }    ¦ÿÿÿÿ   ¤      ¦ÿÿÿÿ   ¤   	           )      §      §      ¥ÿÿÿÿ   ¥ÿÿÿÿ    H0       statement executed        }    §ÿÿÿÿ   ¥      §ÿÿÿÿ   ¥              *      ¨      ¨      ¦ÿÿÿÿ   ¦ÿÿÿÿ     óº        statement executed        }    ¨ÿÿÿÿ   ¦      ¨ÿÿÿÿ   ¦              +      ©      ©      §ÿÿÿÿ   §ÿÿÿÿ    Q}ğ       statement executed        }    ©ÿÿÿÿ   §      ©ÿÿÿÿ   §              ,      ª      ª      ¨ÿÿÿÿ   ¨ÿÿÿÿ     4yà       statement executed        }    ªÿÿÿÿ   ¨      ªÿÿÿÿ   ¨              -      «      «      ©ÿÿÿÿ   ©ÿÿÿÿ    »0       statement executed        }    «ÿÿÿÿ   ©      «ÿÿÿÿ   ©              .      ¬      ¬      ªÿÿÿÿ   ªÿÿÿÿ    ~X       statement executed        }    ¬ÿÿÿÿ   ª      ¬ÿÿÿÿ   ª              /      ­      ­      «ÿÿÿÿ   «ÿÿÿÿ    |­˜       statement executed        return bResult;    ­ÿÿÿÿ   «      ­ÿÿÿÿ   «              0      Ø      Ø   	   Öÿÿÿÿ   Öÿÿÿÿ     ,€P       statement executed        }    Øÿÿÿÿ   Ö      Øÿÿÿÿ   Ö   	           1      Ù      Ù      ×ÿÿÿÿ   ×ÿÿÿÿ     ,‚        statement executed        }    Ùÿÿÿÿ   ×      Ùÿÿÿÿ   ×              2      Ú      Ú      Øÿÿÿÿ   Øÿÿÿÿ     ,ƒ°       statement executed        }    Úÿÿÿÿ   Ø      Úÿÿÿÿ   Ø              3      Û      Û      Ùÿÿÿÿ   Ùÿÿÿÿ     ,…`       statement executed        }    Ûÿÿÿÿ   Ù      Ûÿÿÿÿ   Ù              4      Ü      Ü      Úÿÿÿÿ   Úÿÿÿÿ    a(       statement executed        }    Üÿÿÿÿ   Ú      Üÿÿÿÿ   Ú              5      İ      İ      Ûÿÿÿÿ   Ûÿÿÿÿ    bØ       statement executed        }    İÿÿÿÿ   Û      İÿÿÿÿ   Û              6      Ş      Ş      Üÿÿÿÿ   Üÿÿÿÿ    dˆ       statement executed        }    Şÿÿÿÿ   Ü      Şÿÿÿÿ   Ü              7      ß      ß      İÿÿÿÿ   İÿÿÿÿ    ğP       statement executed        return bResult;    ßÿÿÿÿ   İ      ßÿÿÿÿ   İ              8      ÷      ÷      õÿÿÿÿ   õÿÿÿÿ    õ       statement executed        }    ÷ÿÿÿÿ   õ      ÷ÿÿÿÿ   õ              9               ÿÿÿÿ  ÿÿÿÿ    Mš@       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                :               ÿÿÿÿ  ÿÿÿÿ    MŸP       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                ;               ÿÿÿÿ  ÿÿÿÿ    C(       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                <     7     7     5ÿÿÿÿ  5ÿÿÿÿ    (¬ğ       statement executed        }   7ÿÿÿÿ  5     7ÿÿÿÿ  5              =     8     8     6ÿÿÿÿ  6ÿÿÿÿ    (®°       statement executed        return *this;   8ÿÿÿÿ  6     8ÿÿÿÿ  6              >     ^     ^     \ÿÿÿÿ  \ÿÿÿÿ     hp       statement executed        }   ^ÿÿÿÿ  \     ^ÿÿÿÿ  \              ?     _     _     ]ÿÿÿÿ  ]ÿÿÿÿ     j        statement executed        }   _ÿÿÿÿ  ]     _ÿÿÿÿ  ]              @     `     `     ^ÿÿÿÿ  ^ÿÿÿÿ     kĞ       statement executed        }   `ÿÿÿÿ  ^     `ÿÿÿÿ  ^           FILESTORAGEINFO::FILESTORAGEINFO FILESTORAGEINFO::FILESTORAGEINFO()    "      $       ÿÿÿÿ   "ÿÿÿÿPROJECTDATA::Initialise void PROJECTDATA::Initialise(void)    7      @      5ÿÿÿÿ   >ÿÿÿÿPROJECTDATA::PROJECTDATA PROJECTDATA::PROJECTDATA()    O      Q      Mÿÿÿÿ   OÿÿÿÿPROJECTDATA::~PROJECTDATA PROJECTDATA::~PROJECTDATA()    `      a      ^ÿÿÿÿ   _ÿÿÿÿPROJECTDATA::operator= PROJECTDATA& PROJECTDATA::operator=(const PROJECTDATA& RefObj)    p      x      nÿÿÿÿ   vÿÿÿÿPROJECTDATA::Write bool PROJECTDATA::Write(FILE* pFile)    ‡      ®      …ÿÿÿÿ   ¬ÿÿÿÿPROJECTDATA::Read bool PROJECTDATA::Read(FILE* pFile)    ¿      à      ½ÿÿÿÿ   ŞÿÿÿÿSECTIONDATA::SECTIONDATA SECTIONDATA::SECTIONDATA()    ó      ÷      ñÿÿÿÿ   õÿÿÿÿSECTIONDATA::~SECTIONDATA SECTIONDATA::~SECTIONDATA()             ÿÿÿÿ  ÿÿÿÿSECTIONDATA::Initialise void SECTIONDATA::Initialise(void)             ÿÿÿÿ  ÿÿÿÿSECTIONDATA::operator= SECTIONDATA& SECTIONDATA::operator=(const SECTIONDATA& RefObj)   .     9     ,ÿÿÿÿ  7ÿÿÿÿSECTIONDATA::Write bool SECTIONDATA::Write(FILE* pFile)   H     d     Fÿÿÿÿ  bÿÿÿÿSECTIONDATA::Read bool SECTIONDATA::Read(FILE* pFile)   u          sÿÿÿÿ  ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      ProjConfig_DataTypes.cpp
 * \brief     Source file for project configuration data types.
 * \author    Ratnadip Choudhury
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file for project configuration data types.
 */


// Insert your headers here
#include "DataTypes_StdAfx.h"

#include "ProjConfig_DataTypes.h"

/* STARTS IMPLEMENTATION OF FILESTORAGEINFO */

FILESTORAGEINFO::FILESTORAGEINFO()
{
    memset(m_FilePath, '\0', _MAX_PATH);
}
/* ENDS IMPLEMENTATION OF FILESTORAGEINFO */


/* STARTS IMPLEMENTATION OF PROJECTDATA */

/******************************************************************************
  Function Name    :  Initialise
  Input(s)         :  void
  Output           :  void
  Functionality    :  Does initialisation.
  Member of        :  PROJECTDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void PROJECTDATA::Initialise(void)
{
    SYSTEMTIME CurrSysTime;
    GetSystemTime(&CurrSysTime);

    m_ProjectName   = "";
    m_Language      = "eng";
    memcpy(&m_ProjSysTime, &CurrSysTime, sizeof (SYSTEMTIME));
	m_fAppVersion = 0;
	m_dwAppUniqueId = 0;
};

/******************************************************************************
  Function Name    :  PROJECTDATA
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  PROJECTDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
PROJECTDATA::PROJECTDATA()
{
    Initialise();
}

/******************************************************************************
  Function Name    :  ~PROJECTDATA
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  PROJECTDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
PROJECTDATA::~PROJECTDATA()
{
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  PROJECTDATA - The soure object
  Output           :  PROJECTDATA& - The current object, the modified one.
  Functionality    :  Equal operator overloaded.
  Member of        :  PROJECTDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
PROJECTDATA& PROJECTDATA::operator=(const PROJECTDATA& RefObj)
{
    m_ProjectName = RefObj.m_ProjectName;
    m_Language    = RefObj.m_Language;
	m_fAppVersion = RefObj.m_fAppVersion;
	m_dwAppUniqueId = RefObj.m_dwAppUniqueId;
	memcpy(&m_ProjSysTime, &RefObj.m_ProjSysTime, sizeof (SYSTEMTIME));

    return *this;
}

/******************************************************************************
  Function Name    :  Write
  Input(s)         :  pFile - The target file pointer.
  Output           :  true if all the operations are successful, else false.
  Functionality    :  Writes the current object data into the target file.
  Member of        :  PROJECTDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
bool PROJECTDATA::Write(FILE* pFile)
{
	bool bResult = false;

    /* Below is shown the order in which project data are saved:
    1. Length of the project name [int]
    2. Project name [character stream]
    3. Length of language name [int]
    4. Language name [character stream]
    5. System time and date [SYSTEMTIME, byte stream]
    6. Application version number [float]
    7. Application identifier [DWORD] */

	const char* Buffer = m_ProjectName.c_str();
	int n =  (int) strlen(Buffer);
	if (fwrite(&n, sizeof(int), 1, pFile) == 1)
	{
		if ((int) fwrite(Buffer, sizeof(char), n, pFile) == n)
		{
			Buffer = m_Language.c_str();
			n =  (int) strlen(Buffer);
			if (fwrite(&n, sizeof(int), 1, pFile) == 1)
			{
				if ((int) fwrite(Buffer, sizeof(char), n, pFile) == n)
				{
					if (fwrite(&m_ProjSysTime, sizeof(SYSTEMTIME), 1, pFile) == 1)
					{
						if (fwrite(&m_fAppVersion, sizeof(float), 1, pFile) == 1)
						{
							if (fwrite(&m_dwAppUniqueId, sizeof(DWORD), 1, pFile) == 1)
							{
								bResult = true;
							}
						}
					}
				}
			}
		}
	}
    return bResult;
}

/******************************************************************************
  Function Name    :  Read
  Input(s)         :  pFile - The source file pointer.
  Output           :  true if all the operations are successful, else false.
  Functionality    :  Assuming the current file pointer points to a project 
                      data entry, this function retrieves project data entry 
                      and initialises the current object with the information.
  Member of        :  PROJECTDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
bool PROJECTDATA::Read(FILE* pFile)
{
    Initialise();

    bool bResult = false;
    char Buffer[_MAX_PATH] = {'\0'};
	int n;

    // For obvious reason reading takes place in the same order as writing.
	if (fread(&n, sizeof(int), 1, pFile) == 1)
	{
		if (fread(Buffer, sizeof(char) * n, 1, pFile) != NULL)
		{
			m_ProjectName = Buffer;
			if (fread(&n, sizeof(int), 1, pFile) == 1)
			{
				if (fread(Buffer, sizeof(char) * n, 1, pFile) != NULL)
				{
					m_Language = Buffer;
					if (fread(&m_ProjSysTime, sizeof(SYSTEMTIME), 1, pFile) == 1)
					{
						if (fread(&m_fAppVersion, sizeof(float), 1, pFile) == 1)
						{
							if (fread(&m_dwAppUniqueId, sizeof(DWORD), 1, pFile) == 1)
							{
								bResult = true;
							}
						}
					}
				}
			}
		}
	}
    return bResult;
}
/* ENDS IMPLEMENTATION OF PROJECTDATA */


/* STARTS IMPLEMENTATION OF SECTIONDATA */

/******************************************************************************
  Function Name    :  SECTIONDATA
  Input(s)         :  -
  Output           :  -
  Functionality    :  Standard constructor
  Member of        :  SECTIONDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SECTIONDATA::SECTIONDATA()
{
    m_bBLOB = NULL;
    m_nBLOBLen = 0;
    m_omSectionName = "";
}

/******************************************************************************
  Function Name    :  ~SECTIONDATA
  Input(s)         :  -
  Output           :  -
  Functionality    :  Destructor
  Member of        :  SECTIONDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SECTIONDATA::~SECTIONDATA()
{
    Initialise();
}

/******************************************************************************
  Function Name    :  Initialise
  Input(s)         :  void
  Output           :  void
  Functionality    :  Does initialisation
  Member of        :  SECTIONDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
void SECTIONDATA::Initialise(void)
{
	if (NULL != m_bBLOB)
	{
		delete[] m_bBLOB;
		m_bBLOB = NULL;
	}
    m_nBLOBLen = 0;
    m_omSectionName = "";
}

/******************************************************************************
  Function Name    :  operator=
  Input(s)         :  SECTIONDATA - The soure object
  Output           :  SECTIONDATA& - The current object, the modified one.
  Functionality    :  Equal operator overloaded.
  Member of        :  SECTIONDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
SECTIONDATA& SECTIONDATA::operator=(const SECTIONDATA& RefObj)
{
    Initialise();

	m_bBLOB = new BYTE[RefObj.m_nBLOBLen];
    if (m_bBLOB != NULL)
    {
        m_nBLOBLen = RefObj.m_nBLOBLen;
		memcpy(m_bBLOB, RefObj.m_bBLOB, RefObj.m_nBLOBLen);
        m_omSectionName = RefObj.m_omSectionName;
    }
    return *this;
}

/******************************************************************************
  Function Name    :  Write
  Input(s)         :  pFile - The target file pointer.
  Output           :  true if all the operations are successful, else false.
  Functionality    :  Writes the current object data into the target file.
  Member of        :  SECTIONDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
bool SECTIONDATA::Write(FILE* pFile)
{
    bool bResult = false;

    /* Below is shown the order in which section data are saved:
    1. Length of the section name [int]
    2. Section name [character stream]
    3. Length of BLOB [int]
    4. BLOB (section data) [byte stream] */

    const char* Buffer = m_omSectionName.c_str();
	int n = (int) strlen(Buffer);
	if (fwrite(&n, sizeof(int), 1, pFile) == 1)
	{
		if ((int) fwrite(Buffer, sizeof(char), n, pFile) == n)
		{
			if (fwrite(&m_nBLOBLen, sizeof(m_nBLOBLen), 1, pFile) == 1)
			{
				if (m_bBLOB != NULL)
				{
					if ((int) fwrite(m_bBLOB, 1, m_nBLOBLen, pFile) == m_nBLOBLen)
					{
						bResult = true;
					}
				}
			}
		}
	}
	return bResult;
}

/******************************************************************************
  Function Name    :  Read
  Input(s)         :  pFile - The source file pointer.
  Output           :  true if all the operations are successful, else false.
  Functionality    :  Assuming the current file pointer points to a section 
                      entry, this function retrieves section entry and 
                      initialises the current object with the information.
  Member of        :  SECTIONDATA
  Friend of        :  -                                   
  Author(s)        :  Ratnadip Choudhury
  Date Created     :  1.12.2009
  Modification date:  
  Modification By  :  
******************************************************************************/
bool SECTIONDATA::Read(FILE* pFile)
{
    Initialise();

    bool bResult = false;
	char Buffer[_MAX_PATH] = {'\0'};
	int n;

	if (fread(&n, sizeof(int), 1, pFile) == 1)
	{
		if (fread(Buffer, sizeof(char) * n, 1,pFile) != NULL)
		{
			m_omSectionName = Buffer;
			if (fread(&m_nBLOBLen, sizeof(m_nBLOBLen), 1, pFile) == 1)
			{
				m_bBLOB = new BYTE[m_nBLOBLen];
				if (m_bBLOB != NULL)
				{
					if ((int) fread(m_bBLOB, 1, m_nBLOBLen, pFile) == m_nBLOBLen)
					{
						bResult = true;
					}
				}
			}
		}
	}
    return bResult;
}
/* ENDS IMPLEMENTATION OF SECTIONDATA */





















int sTCANDATA::m_nSortField = 0;
int sTCANDATA::m_nMFactor = 1;

void sTCANDATA::vSetSortField(int nField)
{
    m_nSortField = nField;
}

void sTCANDATA::vSetSortAscending(bool bAscending)
{
    m_nMFactor = bAscending ? 1 : -1;
};

int sTCANDATA::DoCompareIndiv(const void* pEntry1, const void* pEntry2)
{
    int Result = 0;

    sTCANDATA* pDatCAN1 = (sTCANDATA*) pEntry1;
    sTCANDATA* pDatCAN2 = (sTCANDATA*) pEntry2;

    switch (m_nSortField)
    {
        case 3: 
        {
            Result = (int) (pDatCAN1->m_uDataInfo.m_sCANMsg.m_ucChannel - pDatCAN2->m_uDataInfo.m_sCANMsg.m_ucChannel);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 5: 
        {
			Result = (int) (pDatCAN1->m_uDataInfo.m_sCANMsg.m_unMsgID - pDatCAN2->m_uDataInfo.m_sCANMsg.m_unMsgID);
			Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
        }
        case 1: 
        {
            Result = (int) (pDatCAN1->m_lTickCount.QuadPart - pDatCAN2->m_lTickCount.QuadPart);
            Result *= m_nMFactor;
        }
        break;
        default:
        {
            ((void)0);
        }
        break;
    }
    return Result;
};

__int64 sTCANDATA::GetSlotID(sTCANDATA& pDatCAN)
{				
    STCAN_MSG &sMsg = pDatCAN.m_uDataInfo.m_sCANMsg;
    
    int nMsgID = (((pDatCAN.m_ucDataType & 0x02)) ? (sMsg.m_unMsgID) : ((sMsg.m_unMsgID) | TX_MESSAGE));

    nMsgID = (nMsgID & 0x3fffffff);
    
    if (sMsg.m_ucEXTENDED)
    {
        nMsgID = (nMsgID | 0x40000000);
    }
    
    __int64 n64MapIndex = ( ((unsigned __int64)((UINT)(nMsgID))) | (((__int64)(sMsg.m_ucChannel)) << 32) );	
	return n64MapIndex;
};

          T      T   2   Qÿÿÿÿ   Qÿÿÿÿ     4y˜      expression was true       ((pDatCAN.m_ucDataType & 0x02))    Tÿÿÿÿ   Q      Tÿÿÿÿ   Q   2   expression was false       ((pDatCAN.m_ucDataType & 0x02))    Tÿÿÿÿ   Q      Tÿÿÿÿ   Q   2               ?x         #      #       ÿÿÿÿ    ÿÿÿÿ    gP      expression was true       bAscending    #ÿÿÿÿ          #ÿÿÿÿ          expression was false       bAscending    #ÿÿÿÿ          #ÿÿÿÿ                        Y   	   Y      Uÿÿÿÿ   Uÿÿÿÿ    õ°      expression was false       sMsg.m_ucEXTENDED    Yÿÿÿÿ   U   	   Yÿÿÿÿ   U                    <      <      9ÿÿÿÿ   9ÿÿÿÿ     4~€      expression was false       Result != 0    <ÿÿÿÿ   9      <ÿÿÿÿ   9                   ò,          3      3      0ÿÿÿÿ   0ÿÿÿÿ    H|p      expression was false       Result != 0    3ÿÿÿÿ   0      3ÿÿÿÿ   0                  Hx          `      `      [ÿÿÿÿ   [ÿÿÿÿ    H{       statement executed        return n64MapIndex;    `ÿÿÿÿ   [      `ÿÿÿÿ   [                    \      \      Xÿÿÿÿ   Xÿÿÿÿ    Lø       statement executed        }    \ÿÿÿÿ   X      \ÿÿÿÿ   X              	      M      M      Jÿÿÿÿ   Jÿÿÿÿ    Hx       statement executed        return Result;    Mÿÿÿÿ   J      Mÿÿÿÿ   J              
      K   	   K      Hÿÿÿÿ   Hÿÿÿÿ    h­       statement executed        break;    Kÿÿÿÿ   H   	   Kÿÿÿÿ   H                    F   	   F      Cÿÿÿÿ   Cÿÿÿÿ    h¬x       statement executed        break;    Fÿÿÿÿ   C   	   Fÿÿÿÿ   C                    >      >      ;ÿÿÿÿ   ;ÿÿÿÿ     ò,°       statement executed        break;    >ÿÿÿÿ   ;      >ÿÿÿÿ   ;                    5      5      2ÿÿÿÿ   2ÿÿÿÿ    {(       statement executed        break;    5ÿÿÿÿ   2      5ÿÿÿÿ   2                    $      $      !ÿÿÿÿ   !ÿÿÿÿ    ¨       statement executed        }    $ÿÿÿÿ   !      $ÿÿÿÿ   !                                ÿÿÿÿ   ÿÿÿÿ    şx       statement executed        }    ÿÿÿÿ         ÿÿÿÿ              sTCANDATA::vSetSortField void sTCANDATA::vSetSortField(int nField)                ÿÿÿÿ   ÿÿÿÿsTCANDATA::vSetSortAscending void sTCANDATA::vSetSortAscending(bool bAscending)    "      $      ÿÿÿÿ   !ÿÿÿÿsTCANDATA::DoCompareIndiv int sTCANDATA::DoCompareIndiv(const void* pEntry1, const void* pEntry2)    '      N      $ÿÿÿÿ   KÿÿÿÿsTCANDATA::GetSlotID __int64 sTCANDATA::GetSlotID(sTCANDATA& pDatCAN)    Q      a      Nÿÿÿÿ   \ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      Struct_BUS.cpp
 * \author    Ratnadip Choudhury
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 */
#include "DataTypes_stdafx.h"
#include "include/Struct_CAN.h"
#include "application/hashdefines.h"

int sTCANDATA::m_nSortField = 0;
int sTCANDATA::m_nMFactor = 1;

void sTCANDATA::vSetSortField(int nField)
{
    m_nSortField = nField;
}

void sTCANDATA::vSetSortAscending(bool bAscending)
{
    m_nMFactor = bAscending ? 1 : -1;
};

int sTCANDATA::DoCompareIndiv(const void* pEntry1, const void* pEntry2)
{
    int Result = 0;

    sTCANDATA* pDatCAN1 = (sTCANDATA*) pEntry1;
    sTCANDATA* pDatCAN2 = (sTCANDATA*) pEntry2;

    switch (m_nSortField)
    {
        case 3: // Sort by channel
        {
            Result = (int) (pDatCAN1->m_uDataInfo.m_sCANMsg.m_ucChannel - pDatCAN2->m_uDataInfo.m_sCANMsg.m_ucChannel);
            Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
		}
		case 5: // Sort by CAN id
        {
			Result = (int) (pDatCAN1->m_uDataInfo.m_sCANMsg.m_unMsgID - pDatCAN2->m_uDataInfo.m_sCANMsg.m_unMsgID);
			Result *= m_nMFactor;
			if (Result != 0)
            {
                break;
            }
        }
        case 1: // Sort by time stamp
        {
            Result = (int) (pDatCAN1->m_lTickCount.QuadPart - pDatCAN2->m_lTickCount.QuadPart);
            Result *= m_nMFactor;
        }
        break;
        default:
        {
            ASSERT(FALSE);
        }
        break;
    }
    return Result;
};

__int64 sTCANDATA::GetSlotID(sTCANDATA& pDatCAN)
{				
    STCAN_MSG &sMsg = pDatCAN.m_uDataInfo.m_sCANMsg;
    // Form message to get message index in the CMap
    int nMsgID = MAKE_RX_TX_MESSAGE( sMsg.m_unMsgID, 
									IS_RX_MESSAGE(pDatCAN.m_ucDataType));

    nMsgID = MAKE_DEFAULT_MESSAGE_TYPE(nMsgID);
    // For extended message
    if (sMsg.m_ucEXTENDED)
    {
        nMsgID = MAKE_EXTENDED_MESSAGE_TYPE(nMsgID);
    }
    // Apply Channel Information
    __int64 n64MapIndex = MAKE_CHANNEL_SPECIFIC_MESSAGE( nMsgID,
                                                         sMsg.m_ucChannel );	
	return n64MapIndex;
};
































#pragma argsused




















const int SIZE_CHAR = sizeof(char);
namespace DataTypes_Tester { static boost::unit_test::ut_detail::auto_test_unit_registrar DataTypes_Tester_registrar65( "DataTypes_Tester" );

CMsgBufVSE  oMsgBufVSE;
CMsgBufVVSE oMsgBufVVSE;

struct CMsgBufVSE_WriteIntoBuffer_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVSE_WriteIntoBuffer_Test_invoker() { CMsgBufVSE_WriteIntoBuffer_Test t; t.test_method(); } struct CMsgBufVSE_WriteIntoBuffer_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVSE_WriteIntoBuffer_Test_registrar70( boost::unit_test::make_test_case( &CMsgBufVSE_WriteIntoBuffer_Test_invoker, "CMsgBufVSE_WriteIntoBuffer_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVSE_WriteIntoBuffer_Test_id>::instance()->value() ); void CMsgBufVSE_WriteIntoBuffer_Test::test_method()
{
	INT nType = 0;
	
	int	nBufferSize = oMsgBufVSE.GetBufferLength();
	BYTE* pByte = new BYTE[nBufferSize];

	oMsgBufVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize += 100;
	oMsgBufVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize -= 110;
	oMsgBufVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

}

struct CMsgBufVSE_ReadFromBuffer_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVSE_ReadFromBuffer_Test_invoker() { CMsgBufVSE_ReadFromBuffer_Test t; t.test_method(); } struct CMsgBufVSE_ReadFromBuffer_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVSE_ReadFromBuffer_Test_registrar87( boost::unit_test::make_test_case( &CMsgBufVSE_ReadFromBuffer_Test_invoker, "CMsgBufVSE_ReadFromBuffer_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVSE_ReadFromBuffer_Test_id>::instance()->value() ); void CMsgBufVSE_ReadFromBuffer_Test::test_method()
{
	INT nType = 0;
	
	int	nBufferSize = oMsgBufVSE.GetBufferLength();
	BYTE* pByte = new BYTE[nBufferSize], *pByteCpy = new BYTE;
	
	pByteCpy = pByte;
	*pByte = (BYTE)12344;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;

	oMsgBufVSE.ReadFromBuffer(nType, pByte, nBufferSize);

	nBufferSize += 100;
	
	oMsgBufVSE.ReadFromBuffer(nType, pByte, nBufferSize);

	nBufferSize -= 110;
	oMsgBufVSE.ReadFromBuffer(nType, pByte, nBufferSize);
	
	oMsgBufVSE.AdvanceToNextMsg();

	CMsgBufVSE  oMsgBufVSE1;
	nBufferSize += 110;
	oMsgBufVSE1.ReadFromBuffer(nType, pByte, nBufferSize);
	
	
}

struct CMsgBufVSE_GetMsgCnt_NotifyEvent_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_invoker() { CMsgBufVSE_GetMsgCnt_NotifyEvent_Test t; t.test_method(); } struct CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_registrar125( boost::unit_test::make_test_case( &CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_invoker, "CMsgBufVSE_GetMsgCnt_NotifyEvent_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_id>::instance()->value() ); void CMsgBufVSE_GetMsgCnt_NotifyEvent_Test::test_method()
{
	int nMsgCnt = oMsgBufVSE.GetMsgCount();

	HANDLE hHandle = oMsgBufVSE.hGetNotifyingEvent(); 
	
}

struct CMsgBufVSE_SetBufferSize_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVSE_SetBufferSize_Test_invoker() { CMsgBufVSE_SetBufferSize_Test t; t.test_method(); } struct CMsgBufVSE_SetBufferSize_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVSE_SetBufferSize_Test_registrar133( boost::unit_test::make_test_case( &CMsgBufVSE_SetBufferSize_Test_invoker, "CMsgBufVSE_SetBufferSize_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVSE_SetBufferSize_Test_id>::instance()->value() ); void CMsgBufVSE_SetBufferSize_Test::test_method()
{
	int	nBufferSize = 4000;
	oMsgBufVSE.nSetBufferSize(nBufferSize);

		nBufferSize = 140000;
	oMsgBufVSE.nSetBufferSize(nBufferSize);

	nBufferSize = oMsgBufVSE.GetBufferLength();
	oMsgBufVSE.nSetBufferSize(nBufferSize);
}

struct CMsgBufVSE_AdvanceToNxtMsg_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVSE_AdvanceToNxtMsg_Test_invoker() { CMsgBufVSE_AdvanceToNxtMsg_Test t; t.test_method(); } struct CMsgBufVSE_AdvanceToNxtMsg_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVSE_AdvanceToNxtMsg_Test_registrar145( boost::unit_test::make_test_case( &CMsgBufVSE_AdvanceToNxtMsg_Test_invoker, "CMsgBufVSE_AdvanceToNxtMsg_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVSE_AdvanceToNxtMsg_Test_id>::instance()->value() ); void CMsgBufVSE_AdvanceToNxtMsg_Test::test_method()
{
	CMsgBufVSE  oMsgBufVSE2;
	oMsgBufVSE2.AdvanceToNextMsg();	
}

struct CMsgBufVVSE_WriteIntoBuffer_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVVSE_WriteIntoBuffer_Test_invoker() { CMsgBufVVSE_WriteIntoBuffer_Test t; t.test_method(); } struct CMsgBufVVSE_WriteIntoBuffer_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVVSE_WriteIntoBuffer_Test_registrar151( boost::unit_test::make_test_case( &CMsgBufVVSE_WriteIntoBuffer_Test_invoker, "CMsgBufVVSE_WriteIntoBuffer_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVVSE_WriteIntoBuffer_Test_id>::instance()->value() ); void CMsgBufVVSE_WriteIntoBuffer_Test::test_method()
{
	INT nType = 0;
	
	int	nBufferSize = 50000;
	BYTE* pByte = new BYTE[nBufferSize];

	oMsgBufVVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize += 100;
	oMsgBufVVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize -= 110;
	oMsgBufVVSE.WriteIntoBuffer(nType, pByte, nBufferSize);
}

struct CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_invoker() { CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test t; t.test_method(); } struct CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_registrar167( boost::unit_test::make_test_case( &CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_invoker, "CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_id>::instance()->value() ); void CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test::test_method()
{
	int nType = 0  ;
	int	nBufferSize = 50000;
	BYTE* pByte = new BYTE[nBufferSize];

	oMsgBufVVSE.SetStartPos(-1);
	oMsgBufVVSE.SetStartPos(10);
	oMsgBufVVSE.SetStartPos(1);

	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,0,1);
	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,1,1);
	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,-1,1);
	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,10,1);
	
}

struct CMsgBufVVSE_SetBufferSize_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CMsgBufVVSE_SetBufferSize_Test_invoker() { CMsgBufVVSE_SetBufferSize_Test t; t.test_method(); } struct CMsgBufVVSE_SetBufferSize_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CMsgBufVVSE_SetBufferSize_Test_registrar184( boost::unit_test::make_test_case( &CMsgBufVVSE_SetBufferSize_Test_invoker, "CMsgBufVVSE_SetBufferSize_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CMsgBufVVSE_SetBufferSize_Test_id>::instance()->value() ); void CMsgBufVVSE_SetBufferSize_Test::test_method()
{
	int	nBufferSize = 4000;
	oMsgBufVVSE.nSetBufferSize(nBufferSize);

		nBufferSize = 240000;
	oMsgBufVVSE.nSetBufferSize(nBufferSize);

	nBufferSize = 150000;
	oMsgBufVVSE.nSetBufferSize(nBufferSize);
}

STCANDATA		sCanData;
struct STCANDATA_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void STCANDATA_Test_invoker() { STCANDATA_Test t; t.test_method(); } struct STCANDATA_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar STCANDATA_Test_registrar197( boost::unit_test::make_test_case( &STCANDATA_Test_invoker, "STCANDATA_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< STCANDATA_Test_id>::instance()->value() ); void STCANDATA_Test::test_method()
{
	int		nField = 1;
	sCanData.vSetSortField(nField);
	sCanData.vSetSortAscending(1);
	sCanData.vSetSortAscending(0);
}
struct STCANDATA_CompareDiv_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void STCANDATA_CompareDiv_Test_invoker() { STCANDATA_CompareDiv_Test t; t.test_method(); } struct STCANDATA_CompareDiv_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar STCANDATA_CompareDiv_Test_registrar204( boost::unit_test::make_test_case( &STCANDATA_CompareDiv_Test_invoker, "STCANDATA_CompareDiv_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< STCANDATA_CompareDiv_Test_id>::instance()->value() ); void STCANDATA_CompareDiv_Test::test_method()
{
	STCANDATA	*pCanData1 = new STCANDATA;
	STCANDATA	*pCanData2 = new STCANDATA;
	for(int nCnt =0;nCnt <= 5; nCnt++)
	{
		sCanData.vSetSortField(nCnt);
		sCanData.DoCompareIndiv((void*)pCanData1,(void*)pCanData2);
	}

	pCanData1->m_uDataInfo.m_sCANMsg.m_ucChannel = 1;
	pCanData1->m_uDataInfo.m_sCANMsg.m_unMsgID = 124;
	pCanData1->m_lTickCount.QuadPart			 = 56865;

	for(int nCnt =0;nCnt <= 5; nCnt++)
	{
		sCanData.vSetSortField(nCnt);
		sCanData.DoCompareIndiv((void*)pCanData1,(void*)pCanData2);
	}
}

struct STCANDATA_GetSlotID_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void STCANDATA_GetSlotID_Test_invoker() { STCANDATA_GetSlotID_Test t; t.test_method(); } struct STCANDATA_GetSlotID_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar STCANDATA_GetSlotID_Test_registrar225( boost::unit_test::make_test_case( &STCANDATA_GetSlotID_Test_invoker, "STCANDATA_GetSlotID_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< STCANDATA_GetSlotID_Test_id>::instance()->value() ); void STCANDATA_GetSlotID_Test::test_method()
{
	STCANDATA	*pCanData1 = new STCANDATA;
	sCanData.GetSlotID(*pCanData1);
	pCanData1->m_uDataInfo.m_sCANMsg.m_ucEXTENDED = 0;
	sCanData.GetSlotID(*pCanData1); 
	pCanData1->m_ucDataType = 0;
	sCanData.GetSlotID(*pCanData1); 
	pCanData1->m_ucDataType = 2;
	sCanData.GetSlotID(*pCanData1);
}

PROJECTDATA			sProjectData;


struct PROJECTDATA_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void PROJECTDATA_Test_invoker() { PROJECTDATA_Test t; t.test_method(); } struct PROJECTDATA_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar PROJECTDATA_Test_registrar240( boost::unit_test::make_test_case( &PROJECTDATA_Test_invoker, "PROJECTDATA_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< PROJECTDATA_Test_id>::instance()->value() ); void PROJECTDATA_Test::test_method()
{
	SYSTEMTIME		nSys;
	sProjectData.m_ProjectName = "Name";  
	sProjectData.m_Language = "Lang";      
	sProjectData.m_ProjSysTime = nSys;
	sProjectData.m_fAppVersion = 1.0;  
	sProjectData.m_dwAppUniqueId = 568; 

	PROJECTDATA			sProjectData1;
	sProjectData1 = sProjectData;
}

struct PROJECTDATA_Write_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void PROJECTDATA_Write_Test_invoker() { PROJECTDATA_Write_Test t; t.test_method(); } struct PROJECTDATA_Write_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar PROJECTDATA_Write_Test_registrar253( boost::unit_test::make_test_case( &PROJECTDATA_Write_Test_invoker, "PROJECTDATA_Write_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< PROJECTDATA_Write_Test_id>::instance()->value() ); void PROJECTDATA_Write_Test::test_method()
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "wb" );
	sProjectData.Write(pFile);
	sProjectData.m_Language = "\0"; 
	sProjectData.Write(pFile);
	fclose (pFile);
}

struct PROJECTDATA_Read_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void PROJECTDATA_Read_Test_invoker() { PROJECTDATA_Read_Test t; t.test_method(); } struct PROJECTDATA_Read_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar PROJECTDATA_Read_Test_registrar263( boost::unit_test::make_test_case( &PROJECTDATA_Read_Test_invoker, "PROJECTDATA_Read_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< PROJECTDATA_Read_Test_id>::instance()->value() ); void PROJECTDATA_Read_Test::test_method()
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "rb" );
	sProjectData.Read(pFile);
	fclose (pFile);
}


SECTIONDATA			sSectionData;

struct SECTIONDATA_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void SECTIONDATA_Test_invoker() { SECTIONDATA_Test t; t.test_method(); } struct SECTIONDATA_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar SECTIONDATA_Test_registrar274( boost::unit_test::make_test_case( &SECTIONDATA_Test_invoker, "SECTIONDATA_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< SECTIONDATA_Test_id>::instance()->value() ); void SECTIONDATA_Test::test_method()
{
    sSectionData.m_omSectionName = "NAME"; 
    sSectionData.m_nBLOBLen = 4;       
    sSectionData.m_bBLOB = new BYTE;  

	SECTIONDATA			sSectionData1;
	sSectionData1 = sSectionData;
}

struct SECTIONDATA_Write_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void SECTIONDATA_Write_Test_invoker() { SECTIONDATA_Write_Test t; t.test_method(); } struct SECTIONDATA_Write_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar SECTIONDATA_Write_Test_registrar284( boost::unit_test::make_test_case( &SECTIONDATA_Write_Test_invoker, "SECTIONDATA_Write_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< SECTIONDATA_Write_Test_id>::instance()->value() ); void SECTIONDATA_Write_Test::test_method()
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "wb" );
	sSectionData.Write(pFile);
	fclose (pFile);
}

struct SECTIONDATA_Read_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void SECTIONDATA_Read_Test_invoker() { SECTIONDATA_Read_Test t; t.test_method(); } struct SECTIONDATA_Read_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar SECTIONDATA_Read_Test_registrar292( boost::unit_test::make_test_case( &SECTIONDATA_Read_Test_invoker, "SECTIONDATA_Read_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< SECTIONDATA_Read_Test_id>::instance()->value() ); void SECTIONDATA_Read_Test::test_method()
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "rb" );
	sSectionData.Read(pFile);
	fclose (pFile);
}

struct CSignalDescVal_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void CSignalDescVal_Test_invoker() { CSignalDescVal_Test t; t.test_method(); } struct CSignalDescVal_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar CSignalDescVal_Test_registrar300( boost::unit_test::make_test_case( &CSignalDescVal_Test_invoker, "CSignalDescVal_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< CSignalDescVal_Test_id>::instance()->value() ); void CSignalDescVal_Test::test_method()
{
	CSignalDescVal *pCSignalDescVal = new CSignalDescVal();
	CSignalDescVal objSig, objSig1;

	objSig.m_DescValue.n64Value = 20;
	objSig.m_DescValue.un64Value = 200;

	
	objSig1 = objSig;

	objSig1.m_pouNextSignalSignalDescVal = new CSignalDescVal();

	objSig1.vClearNext();

	if(pCSignalDescVal != 0)
	{
		delete pCSignalDescVal;
	}
}

struct sWaveformInfo_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void sWaveformInfo_Test_invoker() { sWaveformInfo_Test t; t.test_method(); } struct sWaveformInfo_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar sWaveformInfo_Test_registrar321( boost::unit_test::make_test_case( &sWaveformInfo_Test_invoker, "sWaveformInfo_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< sWaveformInfo_Test_id>::instance()->value() ); void sWaveformInfo_Test::test_method()
{
	sWaveformInfo *pWaveForm = new sWaveformInfo();
	sWaveformInfo objsWaveformInfo, objWaveform1;

	objsWaveformInfo.m_eSignalWaveType = eWave_SINE;
	objsWaveformInfo.m_fAmplitude = 2.0;
	objsWaveformInfo.m_fFrequency = 3.0;
	objsWaveformInfo.m_fGranularity = 4.0;

	objWaveform1 = objsWaveformInfo;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	objsWaveformInfo.m_eSignalWaveType = eWave_NONE;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	objsWaveformInfo.m_eSignalWaveType = eWave_TRIANGLE;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	objsWaveformInfo.m_eSignalWaveType = eWave_COS;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	if(pWaveForm != 0)
	{
		delete pWaveForm;
	}
}

struct sSigWaveMap_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void sSigWaveMap_Test_invoker() { sSigWaveMap_Test t; t.test_method(); } struct sSigWaveMap_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar sSigWaveMap_Test_registrar353( boost::unit_test::make_test_case( &sSigWaveMap_Test_invoker, "sSigWaveMap_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< sSigWaveMap_Test_id>::instance()->value() ); void sSigWaveMap_Test::test_method()
{
	sSigWaveMap *pSigWaveMap = new sSigWaveMap();

	sSigWaveMap objsSigWaveMap, objsSigWaveMap1;

	objsSigWaveMap.m_omSigName ="Signal1";

	objsSigWaveMap.sWaveInfo.m_eSignalWaveType = eWave_SINE;
	objsSigWaveMap.sWaveInfo.m_fAmplitude = 2.0;
	objsSigWaveMap.sWaveInfo.m_fFrequency = 3.0;
	objsSigWaveMap.sWaveInfo.m_fGranularity = 4.0;

	objsSigWaveMap1 = objsSigWaveMap;

	if(pSigWaveMap != 0)
	{
		delete pSigWaveMap;
	}
}

struct SSigGeneration_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void SSigGeneration_Test_invoker() { SSigGeneration_Test t; t.test_method(); } struct SSigGeneration_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar SSigGeneration_Test_registrar374( boost::unit_test::make_test_case( &SSigGeneration_Test_invoker, "SSigGeneration_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< SSigGeneration_Test_id>::instance()->value() ); void SSigGeneration_Test::test_method()
{
	SSigGeneration *pSSigGeneration = new SSigGeneration();
	SSigGeneration objSigGen;

	objSigGen.m_nMsgID = 100;
	objSigGen.m_fDefaultAmplitude = 1.0;

	sSigWaveMap objsSigWaveMap;
	objsSigWaveMap.m_omSigName ="Signal1";

	objsSigWaveMap.sWaveInfo.m_eSignalWaveType = eWave_SINE;
	objsSigWaveMap.sWaveInfo.m_fAmplitude = 2.0;
	objsSigWaveMap.sWaveInfo.m_fFrequency = 3.0;
	objsSigWaveMap.sWaveInfo.m_fGranularity = 4.0;

	
	objSigGen.m_omSigWaveMapList.AddTail(objsSigWaveMap);

	objSigGen.Reset();

	if(pSSigGeneration != 0)
	{
		delete pSSigGeneration;
	}

}

struct sSIGNALS_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void sSIGNALS_Test_invoker() { sSIGNALS_Test t; t.test_method(); } struct sSIGNALS_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar sSIGNALS_Test_registrar402( boost::unit_test::make_test_case( &sSIGNALS_Test_invoker, "sSIGNALS_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< sSIGNALS_Test_id>::instance()->value() ); void sSIGNALS_Test::test_method()
{
	sSIGNALS *pSig = new sSIGNALS();

	sSIGNALS objsSIGNALS;

	
	objsSIGNALS.m_omStrSignalName = "Signal1";
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 6;
	objsSIGNALS.m_byStartBit = 0;
	objsSIGNALS.m_bySignalType = 'I';
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_fSignalFactor = 1.0;
	objsSIGNALS.m_fSignalOffset = 1.0;
	objsSIGNALS.m_omStrSignalUnit = "";
	objsSIGNALS.m_eFormat = DATA_FORMAT_INTEL;

	objsSIGNALS.m_oSignalIDVal = new CSignalDescVal();

	objsSIGNALS.m_oSignalIDVal->m_DescValue.n64Value = 4;
	objsSIGNALS.m_oSignalIDVal->m_DescValue.un64Value = 10;

	objsSIGNALS.m_psNextSignalList = new sSIGNALS();

	UCHAR aucData[8];

	for(INT nIndex = 0; nIndex < 2; nIndex++)
	{
		aucData[nIndex] = 'A';
	}

	UINT64 unSigVal = 10;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	
	objsSIGNALS.m_bySignalType = 'B';
	objsSIGNALS.m_eFormat = DATA_FORMAT_MOTOROLA;
	objsSIGNALS.m_SignalMinValue.n64Value = 0;
	objsSIGNALS.m_SignalMinValue.un64Value = 0;
	objsSIGNALS.m_SignalMaxValue.n64Value = 1;
	objsSIGNALS.m_SignalMaxValue.un64Value = 1;
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 1;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	
	objsSIGNALS.m_bySignalType = 'U';
	objsSIGNALS.m_eFormat = DATA_FORMAT_INTEL;
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 4;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	
	objsSIGNALS.m_bySignalType = 'U';
	objsSIGNALS.m_eFormat = DATA_FORMAT_MOTOROLA;
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 4;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	if(objsSIGNALS.m_oSignalIDVal != 0)
	{
		delete objsSIGNALS.m_oSignalIDVal;
	}

}

struct tagSMSGENTRY_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void tagSMSGENTRY_Test_invoker() { tagSMSGENTRY_Test t; t.test_method(); } struct tagSMSGENTRY_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar tagSMSGENTRY_Test_registrar492( boost::unit_test::make_test_case( &tagSMSGENTRY_Test_invoker, "tagSMSGENTRY_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< tagSMSGENTRY_Test_id>::instance()->value() ); void tagSMSGENTRY_Test::test_method()
{
	sMESSAGE objMessage;

	objMessage.m_omStrMessageName = "Msg1";
	objMessage.m_unMessageCode = 100;
	objMessage.m_unNumberOfSignals = 1;
	objMessage.m_unMessageLength = 8;
	
	objMessage.m_bMessageFrameFormat = 0;
	objMessage.m_psSignals = new sSIGNALS();

	
	sSIGNALS objsSIGNALS;
	objsSIGNALS.m_omStrSignalName = "Signal1";
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 6;
	objsSIGNALS.m_byStartBit = 0;
	objsSIGNALS.m_bySignalType = 'I';
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_fSignalFactor = 1.0;
	objsSIGNALS.m_fSignalOffset = 1.0;
	objsSIGNALS.m_omStrSignalUnit = "";
	objsSIGNALS.m_eFormat = DATA_FORMAT_INTEL;

	objsSIGNALS.m_oSignalIDVal = new CSignalDescVal();

	objsSIGNALS.m_oSignalIDVal->m_DescValue.n64Value = 4;
	objsSIGNALS.m_oSignalIDVal->m_DescValue.un64Value = 10;

	objsSIGNALS.m_psNextSignalList = new sSIGNALS();

	objsSIGNALS.m_psNextSignalList = 0;

	UCHAR aucData[8];

	for(INT nIndex = 0; nIndex < 2; nIndex++)
	{
		aucData[nIndex] = 'A';
	}

	objMessage.m_psSignals = new sSIGNALS();
	objMessage.m_psSignals = &objsSIGNALS;

	tagSMSGENTRY objMsgEntry;

	objMsgEntry.psCopyMsgVal(&objMessage);
	objMsgEntry.psCopySignalVal(objMessage.m_psSignals);	

	SMSGENTRY* m_psMsgRoot = new SMSGENTRY();
	m_psMsgRoot->m_psMsg = new sMESSAGE();
	m_psMsgRoot->psCopyMsgVal(&objMessage);
	
	m_psMsgRoot->m_psMsg->m_psSignals = new sSIGNALS();
	m_psMsgRoot->psCopySignalVal(objMessage.m_psSignals);

	SMSGENTRY* pDestRoot = 0;
	SMSGENTRY* pTempSrc = m_psMsgRoot;

	m_psMsgRoot->m_psMsg->m_psSignals->m_oSignalIDVal = new CSignalDescVal();

	m_psMsgRoot->m_psMsg->m_psSignals->m_oSignalIDVal->m_DescValue.n64Value = 1;
	m_psMsgRoot->m_psMsg->m_psSignals->m_oSignalIDVal->m_DescValue.un64Value = 1;

	
	m_psMsgRoot->m_psMsg->m_psSignals = &objsSIGNALS;
	m_psMsgRoot->psCopySignalList(&objsSIGNALS);	

	

	sMESSAGE* pMsg12s = 0;

	objMsgEntry.bGetMsgPtrFromMsgId(m_psMsgRoot, 100, pMsg12s);

	m_psMsgRoot->bUpdateMsgList(m_psMsgRoot, &objMessage);	
	
	objMsgEntry.vClearSignalList(&objsSIGNALS);
	objMsgEntry.vClearMsgList(m_psMsgRoot);	

	if(objsSIGNALS.m_oSignalIDVal != 0)
	{
		delete objsSIGNALS.m_oSignalIDVal;
	}

	if(objsSIGNALS.m_psNextSignalList != 0)
	{
		delete objsSIGNALS.m_psNextSignalList;
	}

	if(m_psMsgRoot != 0)
	{
		delete m_psMsgRoot;
	}

	

	

	

	
	

	
	

}

struct sINTERPRETSIGNALINFO_Test : public BOOST_AUTO_TEST_CASE_FIXTURE { void test_method(); }; static void sINTERPRETSIGNALINFO_Test_invoker() { sINTERPRETSIGNALINFO_Test t; t.test_method(); } struct sINTERPRETSIGNALINFO_Test_id {}; static boost::unit_test::ut_detail::auto_test_unit_registrar sINTERPRETSIGNALINFO_Test_registrar603( boost::unit_test::make_test_case( &sINTERPRETSIGNALINFO_Test_invoker, "sINTERPRETSIGNALINFO_Test" ), boost::unit_test::ut_detail::auto_tc_exp_fail< sINTERPRETSIGNALINFO_Test_id>::instance()->value() ); void sINTERPRETSIGNALINFO_Test::test_method()
{
	sINTERPRETSIGNALINFO *pIntepretMsg = new sINTERPRETSIGNALINFO();

	sINTERPRETSIGNALINFO objInterpret;

	objInterpret.m_omStrSignalName = "Sig1";

	objInterpret.m_un64RawValue = 1;
    objInterpret.m_dPhyValue = 1;
    objInterpret.m_omStrSignalDescValue = "20";
    objInterpret.m_omStrUnit = "ms";
    objInterpret.m_ucSigLength = 8;
}

static boost::unit_test::ut_detail::auto_test_unit_registrar end_suite618_registrar618( 1 ); }
                    ÿÿÿÿ  ÿÿÿÿ     -ù`      expression was false       nIndex < 2   ÿÿÿÿ       ÿÿÿÿ                      °     °      ¥ÿÿÿÿ  ¥ÿÿÿÿ    YÄ       expression was false       nIndex < 2   °ÿÿÿÿ  ¥     °ÿÿÿÿ  ¥                     Ú      Ú      Ïÿÿÿÿ   Ïÿÿÿÿ    /Ÿ@      expression was false       nCnt <= 5    Úÿÿÿÿ   Ï      Úÿÿÿÿ   Ï                  /œX         Ğ      Ğ      Åÿÿÿÿ   Åÿÿÿÿ    /•¨      expression was false       nCnt <= 5    Ğÿÿÿÿ   Å      Ğÿÿÿÿ   Å                  /’À        H     H     =ÿÿÿÿ  =ÿÿÿÿ    S”H      expression was false       m_psMsgRoot != 0   Hÿÿÿÿ  =     Hÿÿÿÿ  =                  S‘ø        C     C   (  8ÿÿÿÿ  8ÿÿÿÿ    Sà      expression was false       objsSIGNALS.m_psNextSignalList != 0   Cÿÿÿÿ  8     Cÿÿÿÿ  8   (               S@        >     >   $  3ÿÿÿÿ  3ÿÿÿÿ    S(      expression was false       objsSIGNALS.m_oSignalIDVal != 0   >ÿÿÿÿ  3     >ÿÿÿÿ  3   $               SŠ        å     å   $  Úÿÿÿÿ  Úÿÿÿÿ    a      expression was false       objsSIGNALS.m_oSignalIDVal != 0   åÿÿÿÿ  Ú     åÿÿÿÿ  Ú   $               ax        ‹     ‹     €ÿÿÿÿ  €ÿÿÿÿ    M>p      expression was false       pSSigGeneration != 0   ‹ÿÿÿÿ  €     ‹ÿÿÿÿ  €                  >}x   	     p     p     eÿÿÿÿ  eÿÿÿÿ    >cØ      expression was false       pSigWaveMap != 0   pÿÿÿÿ  e     pÿÿÿÿ  e                  >aˆ   
     [     [     Pÿÿÿÿ  Pÿÿÿÿ    @z°      expression was false       pWaveForm != 0   [ÿÿÿÿ  P     [ÿÿÿÿ  P                  @x`        ;     ;     0ÿÿÿÿ  0ÿÿÿÿ     ñcğ      expression was false       pCSignalDescVal != 0   ;ÿÿÿÿ  0     ;ÿÿÿÿ  0                   ña         h     h     ]ÿÿÿÿ  ]ÿÿÿÿ    sIÀ       statement executed        }   hÿÿÿÿ  ]     hÿÿÿÿ  ]                   [   Á  [   Â  Pÿÿÿÿ  Pÿÿÿÿ    S™ğ       statement executed        }   [ÿÿÿÿ  P   Á  [ÿÿÿÿ  P   Â                Y     Y     Nÿÿÿÿ  Nÿÿÿÿ    S•0       statement executed        }   Yÿÿÿÿ  N     Yÿÿÿÿ  N                   K     K     @ÿÿÿÿ  @ÿÿÿÿ    S“p       statement executed        }   Kÿÿÿÿ  @     Kÿÿÿÿ  @                   F     F     ;ÿÿÿÿ  ;ÿÿÿÿ    S       statement executed        }   Fÿÿÿÿ  ;     Fÿÿÿÿ  ;                   A     A     6ÿÿÿÿ  6ÿÿÿÿ    SŒP       statement executed        }   Aÿÿÿÿ  6     Aÿÿÿÿ  6                             ÿÿÿÿ  ÿÿÿÿ     -øˆ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                     ì   ©  ì   ª  áÿÿÿÿ  áÿÿÿÿ    a#x       statement executed        }   ìÿÿÿÿ  á   ©  ìÿÿÿÿ  á   ª                ê     ê     ßÿÿÿÿ  ßÿÿÿÿ    aø       statement executed        }   êÿÿÿÿ  ß     êÿÿÿÿ  ß                   è     è     İÿÿÿÿ  İÿÿÿÿ    a8       statement executed        }   èÿÿÿÿ  İ     èÿÿÿÿ  İ                   ³     ³     ¨ÿÿÿÿ  ¨ÿÿÿÿ    YÃH       statement executed        }   ³ÿÿÿÿ  ¨     ³ÿÿÿÿ  ¨                   ’     ’     ‡ÿÿÿÿ  ‡ÿÿÿÿ    MCÈ       statement executed        }   ’ÿÿÿÿ  ‡     ’ÿÿÿÿ  ‡                             …ÿÿÿÿ  …ÿÿÿÿ    M?H       statement executed        }   ÿÿÿÿ  …     ÿÿÿÿ  …                             ƒÿÿÿÿ  ƒÿÿÿÿ    >~ğ       statement executed        }   ÿÿÿÿ  ƒ     ÿÿÿÿ  ƒ                   v   ¯  v   °  kÿÿÿÿ  kÿÿÿÿ    >i@       statement executed        }   vÿÿÿÿ  k   ¯  vÿÿÿÿ  k   °                t     t     iÿÿÿÿ  iÿÿÿÿ    >dÀ       statement executed        }   tÿÿÿÿ  i     tÿÿÿÿ  i                   s     s     hÿÿÿÿ  hÿÿÿÿ    >c        statement executed        }   sÿÿÿÿ  h     sÿÿÿÿ  h                   a   ¦  a   §  Vÿÿÿÿ  Vÿÿÿÿ    @€(       statement executed        }   aÿÿÿÿ  V   ¦  aÿÿÿÿ  V   §                _     _     Tÿÿÿÿ  Tÿÿÿÿ    @{˜       statement executed        }   _ÿÿÿÿ  T     _ÿÿÿÿ  T                   ^     ^     Sÿÿÿÿ  Sÿÿÿÿ    @yØ       statement executed        }   ^ÿÿÿÿ  S     ^ÿÿÿÿ  S                    A   ¬  A   ­  6ÿÿÿÿ  6ÿÿÿÿ     ñih       statement executed        }   Aÿÿÿÿ  6   ¬  Aÿÿÿÿ  6   ­           !     ?     ?     4ÿÿÿÿ  4ÿÿÿÿ     ñdØ       statement executed        }   ?ÿÿÿÿ  4     ?ÿÿÿÿ  4              "     >     >     3ÿÿÿÿ  3ÿÿÿÿ     ñc       statement executed        }   >ÿÿÿÿ  3     >ÿÿÿÿ  3              #     ,   ¯  ,   °  !ÿÿÿÿ  !ÿÿÿÿ    a        statement executed        }   ,ÿÿÿÿ  !   ¯  ,ÿÿÿÿ  !   °           $     *     *     ÿÿÿÿ  ÿÿÿÿ    \€       statement executed        }   *ÿÿÿÿ       *ÿÿÿÿ                %     $   µ  $   ¶  ÿÿÿÿ  ÿÿÿÿ    Tğ       statement executed        }   $ÿÿÿÿ     µ  $ÿÿÿÿ     ¶           &     "     "     ÿÿÿÿ  ÿÿÿÿ    Pp       statement executed        }   "ÿÿÿÿ       "ÿÿÿÿ                '        ¸     ¹  ÿÿÿÿ  ÿÿÿÿ    j        statement executed        }   ÿÿÿÿ     ¸  ÿÿÿÿ     ¹           (               ÿÿÿÿ  ÿÿÿÿ    jˆ       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                )        ¦     §  ÿÿÿÿ  ÿÿÿÿ    iıH       statement executed        }   ÿÿÿÿ     ¦  ÿÿÿÿ     §           *               ÿÿÿÿ  ÿÿÿÿ    iø8       statement executed        }   ÿÿÿÿ       ÿÿÿÿ                +        µ     ¶   üÿÿÿÿ   üÿÿÿÿ    „‹˜       statement executed        }   ÿÿÿÿ   ü   µ  ÿÿÿÿ   ü   ¶           ,                úÿÿÿÿ   úÿÿÿÿ    „‡       statement executed        }   ÿÿÿÿ   ú     ÿÿÿÿ   ú              -      ı   ¸   ı   ¹   òÿÿÿÿ   òÿÿÿÿ    „}¸       statement executed        }    ıÿÿÿÿ   ò   ¸   ıÿÿÿÿ   ò   ¹           .      û      û      ğÿÿÿÿ   ğÿÿÿÿ    „y        statement executed        }    ûÿÿÿÿ   ğ      ûÿÿÿÿ   ğ              /      ğ   ¦   ğ   §   åÿÿÿÿ   åÿÿÿÿ     Âà       statement executed        }    ğÿÿÿÿ   å   ¦   ğÿÿÿÿ   å   §           0      ë      ë      àÿÿÿÿ   àÿÿÿÿ     ½Ğ       statement executed        }    ëÿÿÿÿ   à      ëÿÿÿÿ   à              1      á   ¾   á   ¿   Öÿÿÿÿ   Öÿÿÿÿ    /¤       statement executed        }    áÿÿÿÿ   Ö   ¾   áÿÿÿÿ   Ö   ¿           2      ß      ß      Ôÿÿÿÿ   Ôÿÿÿÿ     »À       statement executed        }    ßÿÿÿÿ   Ô      ßÿÿÿÿ   Ô              3      Ş      Ş      Óÿÿÿÿ   Óÿÿÿÿ    /h       statement executed        }    Şÿÿÿÿ   Ó      Şÿÿÿÿ   Ó              4      Ô      Ô      Éÿÿÿÿ   Éÿÿÿÿ    /”Ğ       statement executed        }    Ôÿÿÿÿ   É      Ôÿÿÿÿ   É              5      Ì   Á   Ì   Â   Áÿÿÿÿ   Áÿÿÿÿ    G-ğ       statement executed        }    Ìÿÿÿÿ   Á   Á   Ìÿÿÿÿ   Á   Â           6      Ë      Ë      Àÿÿÿÿ   Àÿÿÿÿ    G)°       statement executed        }    Ëÿÿÿÿ   À      Ëÿÿÿÿ   À              7      Å       Å   ¡   ºÿÿÿÿ   ºÿÿÿÿ    G"X       statement executed        }    Åÿÿÿÿ   º       Åÿÿÿÿ   º   ¡           8      Â      Â      ·ÿÿÿÿ   ·ÿÿÿÿ    G        statement executed        }    Âÿÿÿÿ   ·      Âÿÿÿÿ   ·              9      ¸   Ğ   ¸   Ñ   ­ÿÿÿÿ   ­ÿÿÿÿ    "–       statement executed        }    ¸ÿÿÿÿ   ­   Ğ   ¸ÿÿÿÿ   ­   Ñ           :      ¶      ¶      «ÿÿÿÿ   «ÿÿÿÿ    "‘Ğ       statement executed        }    ¶ÿÿÿÿ   «      ¶ÿÿÿÿ   «              ;      §   ú   §   û   œÿÿÿÿ   œÿÿÿÿ    	¤X       statement executed        }    §ÿÿÿÿ   œ   ú   §ÿÿÿÿ   œ   û           <      ¥      ¥      šÿÿÿÿ   šÿÿÿÿ     ê®à       statement executed        }    ¥ÿÿÿÿ   š      ¥ÿÿÿÿ   š              =      —   Ö   —   ×   Œÿÿÿÿ   Œÿÿÿÿ     ê¢@       statement executed        }    —ÿÿÿÿ   Œ   Ö   —ÿÿÿÿ   Œ   ×           >      •      •      Šÿÿÿÿ   Šÿÿÿÿ    Zì8       statement executed        }    •ÿÿÿÿ   Š      •ÿÿÿÿ   Š              ?      ‘   Ó   ‘   Ô   †ÿÿÿÿ   †ÿÿÿÿ    Zå˜       statement executed        }    ‘ÿÿÿÿ   †   Ó   ‘ÿÿÿÿ   †   Ô           @                  „ÿÿÿÿ   „ÿÿÿÿ    Zà°       statement executed        }    ÿÿÿÿ   „      ÿÿÿÿ   „              A      …   Í   …   Î   zÿÿÿÿ   zÿÿÿÿ    £        statement executed        }    …ÿÿÿÿ   z   Í   …ÿÿÿÿ   z   Î           B      ƒ      ƒ      xÿÿÿÿ   xÿÿÿÿ            statement executed        }    ƒÿÿÿÿ   x      ƒÿÿÿÿ   x              C      }   å   }   æ   rÿÿÿÿ   rÿÿÿÿ     ø        statement executed        }    }ÿÿÿÿ   r   å   }ÿÿÿÿ   r   æ           D      {      {      pÿÿÿÿ   pÿÿÿÿ     ø        statement executed        }    {ÿÿÿÿ   p      {ÿÿÿÿ   p              E      W   Ğ   W   Ñ   Lÿÿÿÿ   Lÿÿÿÿ    5(       statement executed        }    Wÿÿÿÿ   L   Ğ   Wÿÿÿÿ   L   Ñ           F      U      U      Jÿÿÿÿ   Jÿÿÿÿ    "æh       statement executed        }    Uÿÿÿÿ   J      Uÿÿÿÿ   J              G      F   Ó   F   Ô   ;ÿÿÿÿ   ;ÿÿÿÿ     '7¸       statement executed        }    Fÿÿÿÿ   ;   Ó   Fÿÿÿÿ   ;   Ô        DataTypes_Tester::CMsgBufVSE_WriteIntoBuffer_Test_invoker static void CMsgBufVSE_WriteIntoBuffer_Test_invoker()    F      F   Ô   ;ÿÿÿÿ   ;ÿÿÿÿDataTypes_Tester::CMsgBufVSE_WriteIntoBuffer_Test::test_method void CMsgBufVSE_WriteIntoBuffer_Test::test_method()    G      U      <ÿÿÿÿ   JÿÿÿÿDataTypes_Tester::CMsgBufVSE_ReadFromBuffer_Test_invoker static void CMsgBufVSE_ReadFromBuffer_Test_invoker()    W   ›   W   Ñ   Lÿÿÿÿ   LÿÿÿÿDataTypes_Tester::CMsgBufVSE_ReadFromBuffer_Test::test_method void CMsgBufVSE_ReadFromBuffer_Test::test_method()    X      {      Mÿÿÿÿ   pÿÿÿÿDataTypes_Tester::CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_invoker static void CMsgBufVSE_GetMsgCnt_NotifyEvent_Test_invoker()    }   ©   }   æ   rÿÿÿÿ   rÿÿÿÿDataTypes_Tester::CMsgBufVSE_GetMsgCnt_NotifyEvent_Test::test_method void CMsgBufVSE_GetMsgCnt_NotifyEvent_Test::test_method()    ~      ƒ      sÿÿÿÿ   xÿÿÿÿDataTypes_Tester::CMsgBufVSE_SetBufferSize_Test_invoker static void CMsgBufVSE_SetBufferSize_Test_invoker()    …   ™   …   Î   zÿÿÿÿ   zÿÿÿÿDataTypes_Tester::CMsgBufVSE_SetBufferSize_Test::test_method void CMsgBufVSE_SetBufferSize_Test::test_method()    †            {ÿÿÿÿ   „ÿÿÿÿDataTypes_Tester::CMsgBufVSE_AdvanceToNxtMsg_Test_invoker static void CMsgBufVSE_AdvanceToNxtMsg_Test_invoker()    ‘      ‘   Ô   †ÿÿÿÿ   †ÿÿÿÿDataTypes_Tester::CMsgBufVSE_AdvanceToNxtMsg_Test::test_method void CMsgBufVSE_AdvanceToNxtMsg_Test::test_method()    ’      •      ‡ÿÿÿÿ   ŠÿÿÿÿDataTypes_Tester::CMsgBufVVSE_WriteIntoBuffer_Test_invoker static void CMsgBufVVSE_WriteIntoBuffer_Test_invoker()    —   Ÿ   —   ×   Œÿÿÿÿ   ŒÿÿÿÿDataTypes_Tester::CMsgBufVVSE_WriteIntoBuffer_Test::test_method void CMsgBufVVSE_WriteIntoBuffer_Test::test_method()    ˜      ¥      ÿÿÿÿ   šÿÿÿÿDataTypes_Tester::CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_invoker static void CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test_invoker()    §   ·   §   û   œÿÿÿÿ   œÿÿÿÿDataTypes_Tester::CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test::test_method void CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test::test_method()    ¨      ¶      ÿÿÿÿ   «ÿÿÿÿDataTypes_Tester::CMsgBufVVSE_SetBufferSize_Test_invoker static void CMsgBufVVSE_SetBufferSize_Test_invoker()    ¸   ›   ¸   Ñ   ­ÿÿÿÿ   ­ÿÿÿÿDataTypes_Tester::CMsgBufVVSE_SetBufferSize_Test::test_method void CMsgBufVVSE_SetBufferSize_Test::test_method()    ¹      Â      ®ÿÿÿÿ   ·ÿÿÿÿDataTypes_Tester::STCANDATA_Test_invoker static void STCANDATA_Test_invoker()    Å   {   Å   ¡   ºÿÿÿÿ   ºÿÿÿÿDataTypes_Tester::STCANDATA_Test::test_method void STCANDATA_Test::test_method()    Æ      Ë      »ÿÿÿÿ   ÀÿÿÿÿDataTypes_Tester::STCANDATA_CompareDiv_Test_invoker static void STCANDATA_CompareDiv_Test_invoker()    Ì   ‘   Ì   Â   Áÿÿÿÿ   ÁÿÿÿÿDataTypes_Tester::STCANDATA_CompareDiv_Test::test_method void STCANDATA_CompareDiv_Test::test_method()    Í      ß      Âÿÿÿÿ   ÔÿÿÿÿDataTypes_Tester::STCANDATA_GetSlotID_Test_invoker static void STCANDATA_GetSlotID_Test_invoker()    á      á   ¿   Öÿÿÿÿ   ÖÿÿÿÿDataTypes_Tester::STCANDATA_GetSlotID_Test::test_method void STCANDATA_GetSlotID_Test::test_method()    â      ë      ×ÿÿÿÿ   àÿÿÿÿDataTypes_Tester::PROJECTDATA_Test_invoker static void PROJECTDATA_Test_invoker()    ğ      ğ   §   åÿÿÿÿ   åÿÿÿÿDataTypes_Tester::PROJECTDATA_Test::test_method void PROJECTDATA_Test::test_method()    ñ      û      æÿÿÿÿ   ğÿÿÿÿDataTypes_Tester::PROJECTDATA_Write_Test_invoker static void PROJECTDATA_Write_Test_invoker()    ı   ‹   ı   ¹   òÿÿÿÿ   òÿÿÿÿDataTypes_Tester::PROJECTDATA_Write_Test::test_method void PROJECTDATA_Write_Test::test_method()    ş           óÿÿÿÿ   úÿÿÿÿDataTypes_Tester::PROJECTDATA_Read_Test_invoker static void PROJECTDATA_Read_Test_invoker()      ‰     ¶   üÿÿÿÿ   üÿÿÿÿDataTypes_Tester::PROJECTDATA_Read_Test::test_method void PROJECTDATA_Read_Test::test_method()              ıÿÿÿÿ  ÿÿÿÿDataTypes_Tester::SECTIONDATA_Test_invoker static void SECTIONDATA_Test_invoker()           §  ÿÿÿÿ  ÿÿÿÿDataTypes_Tester::SECTIONDATA_Test::test_method void SECTIONDATA_Test::test_method()             ÿÿÿÿ  ÿÿÿÿDataTypes_Tester::SECTIONDATA_Write_Test_invoker static void SECTIONDATA_Write_Test_invoker()      ‹     ¹  ÿÿÿÿ  ÿÿÿÿDataTypes_Tester::SECTIONDATA_Write_Test::test_method void SECTIONDATA_Write_Test::test_method()        "     ÿÿÿÿ  ÿÿÿÿDataTypes_Tester::SECTIONDATA_Read_Test_invoker static void SECTIONDATA_Read_Test_invoker()   $   ‰  $   ¶  ÿÿÿÿ  ÿÿÿÿDataTypes_Tester::SECTIONDATA_Read_Test::test_method void SECTIONDATA_Read_Test::test_method()   %     *     ÿÿÿÿ  ÿÿÿÿDataTypes_Tester::CSignalDescVal_Test_invoker static void CSignalDescVal_Test_invoker()   ,   …  ,   °  !ÿÿÿÿ  !ÿÿÿÿDataTypes_Tester::CSignalDescVal_Test::test_method void CSignalDescVal_Test::test_method()   -     ?     "ÿÿÿÿ  4ÿÿÿÿDataTypes_Tester::sWaveformInfo_Test_invoker static void sWaveformInfo_Test_invoker()   A   ƒ  A   ­  6ÿÿÿÿ  6ÿÿÿÿDataTypes_Tester::sWaveformInfo_Test::test_method void sWaveformInfo_Test::test_method()   B     _     7ÿÿÿÿ  TÿÿÿÿDataTypes_Tester::sSigWaveMap_Test_invoker static void sSigWaveMap_Test_invoker()   a     a   §  Vÿÿÿÿ  VÿÿÿÿDataTypes_Tester::sSigWaveMap_Test::test_method void sSigWaveMap_Test::test_method()   b     t     Wÿÿÿÿ  iÿÿÿÿDataTypes_Tester::SSigGeneration_Test_invoker static void SSigGeneration_Test_invoker()   v   …  v   °  kÿÿÿÿ  kÿÿÿÿDataTypes_Tester::SSigGeneration_Test::test_method void SSigGeneration_Test::test_method()   w          lÿÿÿÿ  …ÿÿÿÿDataTypes_Tester::sSIGNALS_Test_invoker static void sSIGNALS_Test_invoker()   ’   y  ’     ‡ÿÿÿÿ  ‡ÿÿÿÿDataTypes_Tester::sSIGNALS_Test::test_method void sSIGNALS_Test::test_method()   “     ê     ˆÿÿÿÿ  ßÿÿÿÿDataTypes_Tester::tagSMSGENTRY_Test_invoker static void tagSMSGENTRY_Test_invoker()   ì     ì   ª  áÿÿÿÿ  áÿÿÿÿDataTypes_Tester::tagSMSGENTRY_Test::test_method void tagSMSGENTRY_Test::test_method()   í     Y     âÿÿÿÿ  NÿÿÿÿDataTypes_Tester::sINTERPRETSIGNALINFO_Test_invoker static void sINTERPRETSIGNALINFO_Test_invoker()   [   ‘  [   Â  Pÿÿÿÿ  PÿÿÿÿDataTypes_Tester::sINTERPRETSIGNALINFO_Test::test_method void sINTERPRETSIGNALINFO_Test::test_method()   \     h     Qÿÿÿÿ  ]ÿÿÿÿ  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file      J1939_Tester.cpp
 * \brief     Source file for J1939_Tester
 * \author    Arunkumar Karri
 * \copyright Copyright (c) 2011, Robert Bosch Engineering and Business Solutions. All rights reserved.
 *
 * Source file for CFrameProcessor_Common class realising the
 */


// J1939_Tester.cpp : Defines the initialization routines for the DLL.
//

#include <J1939_Tester_StdAfx.h>
#include <tchar.h>
//---------------------------------------------------------------------------

#pragma argsused

//---------------------------------------------------------------------------

#define BOOST_TEST_MODULE MyTest
#define USAGE_IMPORT 1
#include <boost/test/unit_test.hpp>



//#include "DataTypes/BaseAppServices.h"
//#include "DataTypes/Base_WrapperErrorLogger.h"
//#include "DataTypes/BaseMsgBufAll.h"
//#include "DataTypes/DIL_Datatypes.h"
#include "DataTypes/Filter_Datatypes.h"
#include "DataTypes/J1939_DataTypes.h"
//#include "DataTypes/KeyPanel_Datatypes.h"
#include "DataTypes/Log_Datatypes.h"
#include "DataTypes/MainSubEntry.h"
#include "DataTypes/MsgBufCANVFSE.h"
//#include "DataTypes/MsgBufFSE.h"
//#include "DataTypes/MsgBufVFSE.h"
#include "DataTypes/MsgBufVSE.h"
#include "DataTypes/MsgBufVVSE.h"
#include "DataTypes/MsgSignal_Datatypes.h"
//#include "DataTypes/MsgSignal_Datatypes.h"
#include "DataTypes/ProjConfig_DataTypes.h"
//#include "DataTypes/SigWatch_Datatypes.h"
//#include "DataTypes/SigGrphWnd_Datatypes.h"
#include "include/Struct_CAN.h"

const int SIZE_CHAR = sizeof(char);
BOOST_AUTO_TEST_SUITE( DataTypes_Tester )

CMsgBufVSE  oMsgBufVSE;
CMsgBufVVSE oMsgBufVVSE;

BOOST_AUTO_TEST_CASE(CMsgBufVSE_WriteIntoBuffer_Test )
{
	INT nType = 0;
	//CMsgBufVSE  oMsgBufVSE;
	int	nBufferSize = oMsgBufVSE.GetBufferLength();
	BYTE* pByte = new BYTE[nBufferSize];

	oMsgBufVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize += 100;
	oMsgBufVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize -= 110;
	oMsgBufVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

}

BOOST_AUTO_TEST_CASE(CMsgBufVSE_ReadFromBuffer_Test )
{
	INT nType = 0;
	//CMsgBufVSE  oMsgBufVSE;
	int	nBufferSize = oMsgBufVSE.GetBufferLength();
	BYTE* pByte = new BYTE[nBufferSize], *pByteCpy = new BYTE;
	
	pByteCpy = pByte;
	*pByte = (BYTE)12344;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;
	pByte += sizeof(BYTE);
	*pByte = (BYTE)45645;

	oMsgBufVSE.ReadFromBuffer(nType, pByte, nBufferSize);

	nBufferSize += 100;
	
	oMsgBufVSE.ReadFromBuffer(nType, pByte, nBufferSize);

	nBufferSize -= 110;
	oMsgBufVSE.ReadFromBuffer(nType, pByte, nBufferSize);
	
	oMsgBufVSE.AdvanceToNextMsg();

	CMsgBufVSE  oMsgBufVSE1;
	nBufferSize += 110;
	oMsgBufVSE1.ReadFromBuffer(nType, pByte, nBufferSize);
	
	
}

BOOST_AUTO_TEST_CASE(CMsgBufVSE_GetMsgCnt_NotifyEvent_Test )
{
	int nMsgCnt = oMsgBufVSE.GetMsgCount();

	HANDLE hHandle = oMsgBufVSE.hGetNotifyingEvent(); 
	
}

BOOST_AUTO_TEST_CASE(CMsgBufVSE_SetBufferSize_Test )
{
	int	nBufferSize = 4000;
	oMsgBufVSE.nSetBufferSize(nBufferSize);

		nBufferSize = 140000;
	oMsgBufVSE.nSetBufferSize(nBufferSize);

	nBufferSize = oMsgBufVSE.GetBufferLength();
	oMsgBufVSE.nSetBufferSize(nBufferSize);
}

BOOST_AUTO_TEST_CASE(CMsgBufVSE_AdvanceToNxtMsg_Test )
{
	CMsgBufVSE  oMsgBufVSE2;
	oMsgBufVSE2.AdvanceToNextMsg();	
}

BOOST_AUTO_TEST_CASE(CMsgBufVVSE_WriteIntoBuffer_Test )
{
	INT nType = 0;
	//CMsgBufVSE  oMsgBufVSE;
	int	nBufferSize = 50000;
	BYTE* pByte = new BYTE[nBufferSize];

	oMsgBufVVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize += 100;
	oMsgBufVVSE.WriteIntoBuffer(nType, pByte, nBufferSize);

	nBufferSize -= 110;
	oMsgBufVVSE.WriteIntoBuffer(nType, pByte, nBufferSize);
}

BOOST_AUTO_TEST_CASE(CMsgBufVVSE_AdvanceToNxtMsg_SetStartPos_Test )
{
	int nType = 0  ;
	int	nBufferSize = 50000;
	BYTE* pByte = new BYTE[nBufferSize];

	oMsgBufVVSE.SetStartPos(-1);
	oMsgBufVVSE.SetStartPos(10);
	oMsgBufVVSE.SetStartPos(1);

	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,0,TRUE);
	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,1,TRUE);
	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,-1,TRUE);
	oMsgBufVVSE.ReadEntry(nType, pByte, nBufferSize,10,TRUE);
	
}

BOOST_AUTO_TEST_CASE(CMsgBufVVSE_SetBufferSize_Test )
{
	int	nBufferSize = 4000;
	oMsgBufVVSE.nSetBufferSize(nBufferSize);

		nBufferSize = 240000;
	oMsgBufVVSE.nSetBufferSize(nBufferSize);

	nBufferSize = 150000;
	oMsgBufVVSE.nSetBufferSize(nBufferSize);
}

STCANDATA		sCanData;
BOOST_AUTO_TEST_CASE(STCANDATA_Test )
{
	int		nField = 1;
	sCanData.vSetSortField(nField);
	sCanData.vSetSortAscending(TRUE);
	sCanData.vSetSortAscending(FALSE);
}
BOOST_AUTO_TEST_CASE(STCANDATA_CompareDiv_Test )
{
	STCANDATA	*pCanData1 = new STCANDATA;
	STCANDATA	*pCanData2 = new STCANDATA;
	for(int nCnt =0;nCnt <= 5; nCnt++)
	{
		sCanData.vSetSortField(nCnt);
		sCanData.DoCompareIndiv((void*)pCanData1,(void*)pCanData2);
	}

	pCanData1->m_uDataInfo.m_sCANMsg.m_ucChannel = 1;
	pCanData1->m_uDataInfo.m_sCANMsg.m_unMsgID = 124;
	pCanData1->m_lTickCount.QuadPart			 = 56865;

	for(int nCnt =0;nCnt <= 5; nCnt++)
	{
		sCanData.vSetSortField(nCnt);
		sCanData.DoCompareIndiv((void*)pCanData1,(void*)pCanData2);
	}
}

BOOST_AUTO_TEST_CASE(STCANDATA_GetSlotID_Test )
{
	STCANDATA	*pCanData1 = new STCANDATA;
	sCanData.GetSlotID(*pCanData1);
	pCanData1->m_uDataInfo.m_sCANMsg.m_ucEXTENDED = 0;
	sCanData.GetSlotID(*pCanData1); 
	pCanData1->m_ucDataType = 0;
	sCanData.GetSlotID(*pCanData1); 
	pCanData1->m_ucDataType = 2;
	sCanData.GetSlotID(*pCanData1);
}

PROJECTDATA			sProjectData;


BOOST_AUTO_TEST_CASE(PROJECTDATA_Test )
{
	SYSTEMTIME		nSys;
	sProjectData.m_ProjectName = "Name";  
	sProjectData.m_Language = "Lang";      
	sProjectData.m_ProjSysTime = nSys;
	sProjectData.m_fAppVersion = 1.0;  
	sProjectData.m_dwAppUniqueId = 568; 

	PROJECTDATA			sProjectData1;
	sProjectData1 = sProjectData;
}

BOOST_AUTO_TEST_CASE(PROJECTDATA_Write_Test )
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "wb" );
	sProjectData.Write(pFile);
	sProjectData.m_Language = "\0"; 
	sProjectData.Write(pFile);
	fclose (pFile);
}

BOOST_AUTO_TEST_CASE(PROJECTDATA_Read_Test )
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "rb" );
	sProjectData.Read(pFile);
	fclose (pFile);
}


SECTIONDATA			sSectionData;

BOOST_AUTO_TEST_CASE(SECTIONDATA_Test )
{
    sSectionData.m_omSectionName = "NAME"; 
    sSectionData.m_nBLOBLen = 4;       
    sSectionData.m_bBLOB = new BYTE;  

	SECTIONDATA			sSectionData1;
	sSectionData1 = sSectionData;
}

BOOST_AUTO_TEST_CASE(SECTIONDATA_Write_Test )
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "wb" );
	sSectionData.Write(pFile);
	fclose (pFile);
}

BOOST_AUTO_TEST_CASE(SECTIONDATA_Read_Test )
{
	FILE* pFile;
	pFile = fopen ( "myfile.txt" , "rb" );
	sSectionData.Read(pFile);
	fclose (pFile);
}

BOOST_AUTO_TEST_CASE(CSignalDescVal_Test )
{
	CSignalDescVal *pCSignalDescVal = new CSignalDescVal();
	CSignalDescVal objSig, objSig1;

	objSig.m_DescValue.n64Value = 20;
	objSig.m_DescValue.un64Value = 200;

	// operator =
	objSig1 = objSig;

	objSig1.m_pouNextSignalSignalDescVal = new CSignalDescVal();

	objSig1.vClearNext();

	if(pCSignalDescVal != NULL)
	{
		delete pCSignalDescVal;
	}
}

BOOST_AUTO_TEST_CASE(sWaveformInfo_Test )
{
	sWaveformInfo *pWaveForm = new sWaveformInfo();
	sWaveformInfo objsWaveformInfo, objWaveform1;

	objsWaveformInfo.m_eSignalWaveType = eWave_SINE;
	objsWaveformInfo.m_fAmplitude = 2.0;
	objsWaveformInfo.m_fFrequency = 3.0;
	objsWaveformInfo.m_fGranularity = 4.0;

	objWaveform1 = objsWaveformInfo;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	objsWaveformInfo.m_eSignalWaveType = eWave_NONE;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	objsWaveformInfo.m_eSignalWaveType = eWave_TRIANGLE;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	objsWaveformInfo.m_eSignalWaveType = eWave_COS;

	objWaveform1.omGetWaveformName(objsWaveformInfo.m_eSignalWaveType);

	if(pWaveForm != NULL)
	{
		delete pWaveForm;
	}
}

BOOST_AUTO_TEST_CASE(sSigWaveMap_Test )
{
	sSigWaveMap *pSigWaveMap = new sSigWaveMap();

	sSigWaveMap objsSigWaveMap, objsSigWaveMap1;

	objsSigWaveMap.m_omSigName ="Signal1";

	objsSigWaveMap.sWaveInfo.m_eSignalWaveType = eWave_SINE;
	objsSigWaveMap.sWaveInfo.m_fAmplitude = 2.0;
	objsSigWaveMap.sWaveInfo.m_fFrequency = 3.0;
	objsSigWaveMap.sWaveInfo.m_fGranularity = 4.0;

	objsSigWaveMap1 = objsSigWaveMap;

	if(pSigWaveMap != NULL)
	{
		delete pSigWaveMap;
	}
}

BOOST_AUTO_TEST_CASE(SSigGeneration_Test )
{
	SSigGeneration *pSSigGeneration = new SSigGeneration();
	SSigGeneration objSigGen;

	objSigGen.m_nMsgID = 100;
	objSigGen.m_fDefaultAmplitude = 1.0;

	sSigWaveMap objsSigWaveMap;
	objsSigWaveMap.m_omSigName ="Signal1";

	objsSigWaveMap.sWaveInfo.m_eSignalWaveType = eWave_SINE;
	objsSigWaveMap.sWaveInfo.m_fAmplitude = 2.0;
	objsSigWaveMap.sWaveInfo.m_fFrequency = 3.0;
	objsSigWaveMap.sWaveInfo.m_fGranularity = 4.0;

	//sSigWaveMap TmpObj = CurrObj;
	objSigGen.m_omSigWaveMapList.AddTail(objsSigWaveMap);

	objSigGen.Reset();

	if(pSSigGeneration != NULL)
	{
		delete pSSigGeneration;
	}

}

BOOST_AUTO_TEST_CASE(sSIGNALS_Test )
{
	sSIGNALS *pSig = new sSIGNALS();

	sSIGNALS objsSIGNALS;

	// INT Type
	objsSIGNALS.m_omStrSignalName = "Signal1";
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 6;
	objsSIGNALS.m_byStartBit = 0;
	objsSIGNALS.m_bySignalType = 'I';
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_fSignalFactor = 1.0;
	objsSIGNALS.m_fSignalOffset = 1.0;
	objsSIGNALS.m_omStrSignalUnit = "";
	objsSIGNALS.m_eFormat = DATA_FORMAT_INTEL;

	objsSIGNALS.m_oSignalIDVal = new CSignalDescVal();

	objsSIGNALS.m_oSignalIDVal->m_DescValue.n64Value = 4;
	objsSIGNALS.m_oSignalIDVal->m_DescValue.un64Value = 10;

	objsSIGNALS.m_psNextSignalList = new sSIGNALS();

	UCHAR aucData[8];

	for(INT nIndex = 0; nIndex < 2; nIndex++)
	{
		aucData[nIndex] = 'A';
	}

	UINT64 unSigVal = 10;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	// BOOL type
	objsSIGNALS.m_bySignalType = 'B';
	objsSIGNALS.m_eFormat = DATA_FORMAT_MOTOROLA;
	objsSIGNALS.m_SignalMinValue.n64Value = 0;
	objsSIGNALS.m_SignalMinValue.un64Value = 0;
	objsSIGNALS.m_SignalMaxValue.n64Value = 1;
	objsSIGNALS.m_SignalMaxValue.un64Value = 1;
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 1;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	// UNSIGNED INT
	objsSIGNALS.m_bySignalType = 'U';
	objsSIGNALS.m_eFormat = DATA_FORMAT_INTEL;
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 4;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	// UNSIGNED INT motorola
	objsSIGNALS.m_bySignalType = 'U';
	objsSIGNALS.m_eFormat = DATA_FORMAT_MOTOROLA;
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 4;

	pSig->vSetSignalValue(&objsSIGNALS, aucData, unSigVal);

	pSig->un64GetBitMask(&objsSIGNALS);

	if(objsSIGNALS.m_oSignalIDVal != NULL)
	{
		delete objsSIGNALS.m_oSignalIDVal;
	}

}

BOOST_AUTO_TEST_CASE(tagSMSGENTRY_Test )
{
	sMESSAGE objMessage;

	objMessage.m_omStrMessageName = "Msg1";
	objMessage.m_unMessageCode = 100;
	objMessage.m_unNumberOfSignals = 1;
	objMessage.m_unMessageLength = 8;
	// Standard
	objMessage.m_bMessageFrameFormat = 0;
	objMessage.m_psSignals = new sSIGNALS();

	// Signal Pointer creation
	sSIGNALS objsSIGNALS;
	objsSIGNALS.m_omStrSignalName = "Signal1";
	objsSIGNALS.m_unStartByte = 0;
	objsSIGNALS.m_unSignalLength = 6;
	objsSIGNALS.m_byStartBit = 0;
	objsSIGNALS.m_bySignalType = 'I';
	objsSIGNALS.m_SignalMinValue.n64Value = 1;
	objsSIGNALS.m_SignalMinValue.un64Value = 1;
	objsSIGNALS.m_SignalMaxValue.n64Value = 100;
	objsSIGNALS.m_SignalMaxValue.un64Value = 100;
	objsSIGNALS.m_fSignalFactor = 1.0;
	objsSIGNALS.m_fSignalOffset = 1.0;
	objsSIGNALS.m_omStrSignalUnit = "";
	objsSIGNALS.m_eFormat = DATA_FORMAT_INTEL;

	objsSIGNALS.m_oSignalIDVal = new CSignalDescVal();

	objsSIGNALS.m_oSignalIDVal->m_DescValue.n64Value = 4;
	objsSIGNALS.m_oSignalIDVal->m_DescValue.un64Value = 10;

	objsSIGNALS.m_psNextSignalList = new sSIGNALS();

	objsSIGNALS.m_psNextSignalList = NULL;

	UCHAR aucData[8];

	for(INT nIndex = 0; nIndex < 2; nIndex++)
	{
		aucData[nIndex] = 'A';
	}

	objMessage.m_psSignals = new sSIGNALS();
	objMessage.m_psSignals = &objsSIGNALS;

	tagSMSGENTRY objMsgEntry;

	objMsgEntry.psCopyMsgVal(&objMessage);
	objMsgEntry.psCopySignalVal(objMessage.m_psSignals);	

	SMSGENTRY* m_psMsgRoot = new SMSGENTRY();
	m_psMsgRoot->m_psMsg = new sMESSAGE();
	m_psMsgRoot->psCopyMsgVal(&objMessage);
	
	m_psMsgRoot->m_psMsg->m_psSignals = new sSIGNALS();
	m_psMsgRoot->psCopySignalVal(objMessage.m_psSignals);

	SMSGENTRY* pDestRoot = NULL;
	SMSGENTRY* pTempSrc = m_psMsgRoot;

	m_psMsgRoot->m_psMsg->m_psSignals->m_oSignalIDVal = new CSignalDescVal();

	m_psMsgRoot->m_psMsg->m_psSignals->m_oSignalIDVal->m_DescValue.n64Value = 1;
	m_psMsgRoot->m_psMsg->m_psSignals->m_oSignalIDVal->m_DescValue.un64Value = 1;

	
	m_psMsgRoot->m_psMsg->m_psSignals = &objsSIGNALS;
	m_psMsgRoot->psCopySignalList(&objsSIGNALS);	

	//const SMSGENTRY *pconstmsg = new SMSGENTRY();

	sMESSAGE* pMsg12s = NULL;

	objMsgEntry.bGetMsgPtrFromMsgId(m_psMsgRoot, 100, pMsg12s);

	m_psMsgRoot->bUpdateMsgList(m_psMsgRoot, &objMessage);	
	
	objMsgEntry.vClearSignalList(&objsSIGNALS);
	objMsgEntry.vClearMsgList(m_psMsgRoot);	

	if(objsSIGNALS.m_oSignalIDVal != NULL)
	{
		delete objsSIGNALS.m_oSignalIDVal;
	}

	if(objsSIGNALS.m_psNextSignalList != NULL)
	{
		delete objsSIGNALS.m_psNextSignalList;
	}

	if(m_psMsgRoot != NULL)
	{
		delete m_psMsgRoot;
	}

	

	//objMsgEntry.m_psNext = &objMsgEntry;

	//m_psMsgRoot->m_psMsg = &objMessage;

	//objMsgEntry.psCopyMsgVal(&objMessage);
	//objMsgEntry.psCopySignalVal(objMessage.m_psSignals);

	//objMsgEntry.vClearMsgList(NULL);
	//objMsgEntry.vClearSignalList(NULL);

}

BOOST_AUTO_TEST_CASE(sINTERPRETSIGNALINFO_Test )
{
	sINTERPRETSIGNALINFO *pIntepretMsg = new sINTERPRETSIGNALINFO();

	sINTERPRETSIGNALINFO objInterpret;

	objInterpret.m_omStrSignalName = "Sig1";

	objInterpret.m_un64RawValue = 1;
    objInterpret.m_dPhyValue = 1;
    objInterpret.m_omStrSignalDescValue = "20";
    objInterpret.m_omStrUnit = "ms";
    objInterpret.m_ucSigLength = 8;
}

BOOST_AUTO_TEST_SUITE_END()
   (d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp                   ^ş Ôğ·÷e~    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp           ^ş      ~Q Ôğ*†!
    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp           İO      + ÔğË;Ø)    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\filter_datatypes.cpp ..\..\..\Sources\DataTypes\Filter_Datatypes.cpp           òz      Üo Ôğ; ÄÌ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp          Îé      !Q rÆØ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp          ğ:      #´ rc{|÷    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp          î       rîá‚[    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\j1939_datatypes.cpp ..\..\..\Sources\DataTypes\J1939_DataTypes.cpp          Œ      'X r{`    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp          Bä      ù ®~=üëª    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp          Oİ      ¬ ®~=Oã    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp          S‰      
 ®~=ôÁª    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\log_datatypes.cpp ..\..\..\Sources\DataTypes\Log_Datatypes.cpp          U“      ö ®~=ä*Ü¦    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp          q‰      © ˜16šäş    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp          x2      ˆ ˜10Ûm    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp          €º      ‚ ˜1»->I    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\mainsubentry.cpp ..\..\..\Sources\DataTypes\MainSubEntry.cpp          „<      - ˜1®ÂŠÔ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp          i      !” ÛÁRBU€    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp          °ı      a ÛÁRxÁU    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp          Í^      ï ÛÁR•¥bd    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvse.cpp ..\..\..\Sources\DataTypes\MsgBufVSE.cpp          ÔM      C‘ ÛÁRE«Ó    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp          Ş      %â ÍúVV    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp          =À      $S Í‡ÜÏ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp          b      Q Íz–ƒd    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgbufvvse.cpp ..\..\..\Sources\DataTypes\MsgBufVVSE.cpp          id      Jü Ír“øÍ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp          ´`      'E ˜u¤Z(Ğ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp          Û¥      '8 ˜u×F;¬    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp          İ      ä ˜u?´øn    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\msgsignal_datatypes.cpp ..\..\..\Sources\DataTypes\MsgSignal_Datatypes.cpp          Á      4€ ˜uû:    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp          CA      P ÈÚÄ¤@j    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp          T‘      %« ÈÚÄ€~$R    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp          z<      Ø ÈÚÄ„    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\projconfig_datatypes.cpp ..\..\..\Sources\DataTypes\ProjConfig_DataTypes.cpp                1µ ÈÚÄ«Ğ±    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp          °É      " _H×     d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp          ·ë      - _HR¿ÛÈ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp          À      İ _HÙŸ«µ    d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp d:\busmaster\workspace\29-6-2012-old\sources\datatypes\struct_bus.cpp ..\..\..\Sources\DataTypes\Struct_BUS.cpp          Áõ      ; _HÑJ$    d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp          Í0      fö |—ÓX)
    d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp          4&      $‰ |—²·Î¶    d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp          X¯      º |—¸‚ã½    d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp d:\busmaster\workspace\29-6-2012-old\tests\unit test coverage\j1939_tester\datatypes_tester2.cpp .\DataTypes_Tester2.cpp          qi      = |—HÚ|¿      *”31
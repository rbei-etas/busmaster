#ifndef ETAS_OCI_CAN_IO_H
#define ETAS_OCI_CAN_IO_H

/**
* @file       ocicanio.h
* @brief      CAN specific part of the Open Contoller Interface (OCI) API
*             excluding the stronly typed controller configuration.
* @copyright  Copyright (c) 2007-2008 ETAS GmbH. All rights reserved.
*
* $Revision: 4831 $
*/


#include "ocibase.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
* @addtogroup GROUP_OCI_CAN_CONTROLLER OCI CAN
* @brief      CAN specific part of the Open Controller Interface (OCI). 
* @details    The CAN controller interface instance supports a single 
*             TxQueue and a single RxQueue. All CAN frames will be 
*             queued and transmitted in the same order as they are 
*             delivered via @ref OCI_WriteCANData() to the TxQueue.
* @{
*/

/**
* @addtogroup GROUP_OCI_CAN_INITIALIZATION Initialization
* @{
*/

/**
* Specific structure for CAN controller capabilities.
*/
typedef struct OCI_CANControllerCapabilities
{
    /** 
    * Specifies the supported samples per bit of this adapter.
    * Valid values are OR-gated into the member.
    * @flags        The following flags are valid:
    * @n            OCI_CAN_ONE_SAMPLE_PER_BIT
    * @n            OCI_CAN_THREE_SAMPLES_PER_BIT
    * @sa           @ref OCI_ANCHOR_CAN_SAMPLES_PER_BIT_VALUES
    *               "OCI CAN samples per bit values"
    */
    uint32 samplesPerBit;
    
    /** 
    * Specifies the supported sync edge mode of this adapter.
    * Valid values are OR-gated into the member. 
    * @flags        The following flags are valid:
    * @n            OCI_CAN_SINGLE_SYNC_EDGE
    * @n            OCI_CAN_DUAL_SYNC_EDGE
    * @sa           @ref OCI_ANCHOR_CAN_SYNC_EDGE_VALUES
    *               "OCI CAN sync edge values"
    */
    uint32 syncEdge;
    
    /** 
    * Specifies the supported media types of this adapter.
    * Valid values are OR-gated into the member. 
    * @flags        The following flags are valid:
    * @n            OCI_CAN_MEDIA_HIGH_SPEED
    * @n            OCI_CAN_MEDIA_FAULT_TOLERANT
    * @sa           @ref OCI_ANCHOR_CAN_MEDIA_TYPE
    *               "OCI CAN media type"
    */
    uint32 physicalMedia;

    /** Reserved member. Always @c zero */
    uint32 reserved;

    /** 
    * Specifies the kind of bus events that can be generated by this
    * adapter. Valid values are OR-gated into the member. 
    * @flags        The following flags are valid:
    
    */
    uint32 busEvents;

    /** 
    * Specifies which kind of error frames can be detected and generated
    * by this adapter. Valid values are OR-gated into the member. 
    * @flags        The following flags are valid:
    * @n            @ref OCI_CAN_ERR_TYPE_BITSTUFF
    * @n            @ref OCI_CAN_ERR_TYPE_FORMAT
    * @n            @ref OCI_CAN_ERR_TYPE_ACK
    * @n            @ref OCI_CAN_ERR_TYPE_BIT
    * @n            @ref OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
    * @n            @ref OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
    * @n            @ref OCI_CAN_ERR_TYPE_CRC
    * @n            @ref OCI_CAN_ERR_TYPE_OVERLOAD
    * @n            @ref OCI_CAN_ERR_TYPE_OTHER
    * @sa           @ref OCI_ANCHOR_CAN_ERROR_FRAME_TYPES
    *               "CAN error frame types" 
    */ 
    uint32 errorFrames;
    
    /**
    * Specifies which kind of message flags (message types) are supported by
    * this adapter. Valid values are OR-gated into the member. 
    * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
    * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
    * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
    * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
    *           "OCI CAN message flags"
    */
    uint32 messageFlags;
    
} OCI_CANControllerCapabilities;


/**
* Specific structure for the CAN controller status. 
*/

typedef struct OCI_CANControllerStatus
{
    /* Temporary field */
    uint32 reserved;

} OCI_CANControllerStatus;


/**
 Query the capabilities of a specific CAN controller instance.

 The capabilities are static information, which will never change for a specific instance.

 @controllerState CREATED, SUSPENDED, RUNNING.

 @param[in]  controller   Handle of the CAN controller interface instance for which the status is requested.
 @param[out] capabilities Pointer to a buffer receiving the requested capability information of the CAN 
                          controller.
 
 @return
   <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. The @capabilities are filled with valid information. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a controller handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a capabilities paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_TIMEOUT </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             The state of the session is undefined. All subsequent calls will return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyFlexRayController() for this handle called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. The state of the session is undefined. All subsequent calls to the same 
             controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyFlexRayController() for this handle is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
  </TABLE> 
*/
#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_GetCANControllerCapabilities(
    OCI_ControllerHandle controller, 
    OCI_CANControllerCapabilities* capabilities);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_GetCANControllerCapabilities)(
    OCI_ControllerHandle controller, 
    OCI_CANControllerCapabilities* capabilities);

/**
 Query the status of a specific CAN controller instance.

 The status information of a CAN controller may change by some events on the CAN bus.
 
 @controllerState CREATED, SUSPENDED, RUNNING.

 @param[in]  controller  handle of the CAN controller interface instance for which the status is requested.
 @param[out] status      Pointer to a buffer receiving the requested status information of the CAN controller.
 
 @return
   <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. The @a status information is filled with valid information </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a controller handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a status paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
  </TABLE> 

*/
#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_GetCANControllerStatus(
    OCI_ControllerHandle controller,
    OCI_CANControllerStatus* status);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_GetCANControllerStatus)(
    OCI_ControllerHandle controller,
    OCI_CANControllerStatus* status);

/**
* @}
* @addtogroup GROUP_OCI_CAN_QUEUES Queues
* @{
*/

struct OCI_CANMessage;

/** 
 Signature of a callback function for CAN event and message handling. The callback function registered by the
 user must have this signature to receive CAN Frames and CAN errors.

 @param[in] userData Pointer to a user defined structure or handle for user supplied information. Any callback
                     of a single instance will use the same value, that is supplied during the callback registration
                     in the @ref OCI_CANRxCallback structure during execution of OCI_CreateCANRxQueue().
 @param[in] msg      Pointer to the received message or event. The object is owned by the caller of the API. The
                     reference must not used after completion of the callback. When the user requires access to the
                     data after completion of the callback the callback must create a copy of the data.
                     
                     @todo verify implementation of resource ownership and description!

 @todo 2009-01-28: define OCI_DOCU to expand OCI_CALLBACK to nothing --> correct signature
*/

typedef void (OCI_CALLBACK *OCI_CANRxCallbackFunction)(void *userData, struct OCI_CANMessage* msg);

/**
    Callback for CAN event and message handling.

    The callback consists of a callback function and context information (user data),
    e.g. a queue handle or a pointer to some related data structure controlled by
    the program that uses OCI.

    The OCI user sets a callback when creating an RX queue.
*/
typedef struct OCI_CANRxCallback
{
    /** Callback function pointer */
    OCI_CANRxCallbackFunction function;

    /**
     * Opaque context information that will be passed to the callback 
     * @a function. The pointer is supplied by the caller and not 
     * interpreted or modified by the OCD implementation. 
     * May be @c NULL.
     */
    void *userData;

} OCI_CANRxCallback;


/** 
 * Specific structure for the CAN RX queue configuration.
 */

typedef struct OCI_CANRxQueueConfiguration
{
    /** 
    * Callback function for the reception of a CAN frame.
    *
    * When a frame arrives which matches one of the frame filters defined for the queue instance,
    * there are two possibilities:
    *   - If @ref onFrame is not @c NULL, the frame is passed to @ref onFrame.
    *   - If @ref onFrame is @c NULL, the frame is added to the RX queue.
    *
    * Note that if @ref OCI_DestroyCANRxQueue() is used to destroy the queue while reception is in progress,
    * it is possible for @ref onFrame to be called a short time @em after OCI_DestroyCANRxQueue() has returned
    * successfully.
    *
    * @sa @ref PAGE_OCI_RECEIVE_MESSAGES "Receive Messages"
    */
    OCI_CANRxCallback     onFrame;
    
    /** 
    * Callback function for the reception of an event.
    *
    * When an event is fired which matches one of the event filters defined for the queue instance,
    * there are several possibilities:
    *   - If @ref onEvent is not @c NULL, and if the @c destination member of the matched filter specifies
    *     @ref OCI_EVENT_DESTINATION_CALLBACK, then the event is passed to @ref onEvent.
    *   - If the @c destination member of the matched filter specifies @ref OCI_EVENT_DESTINATION_INBAND,
    *     then the event is delivered to the application in the same way as a data frame.
    *   - If @ref onEvent is @c NULL, then the event is always delivered to the application in the
    *     same way as a data frame.
    *
    * Note:
    *   - The @c destination member of a filter can specify both @ref OCI_EVENT_DESTINATION_CALLBACK and
    *     @ref OCI_EVENT_DESTINATION_INBAND. In other words, the first two possibilities above are not mutually
    *     exclusive.
    *   - See @ref onFrame for a description of how received data frames are delivered to the application.
    *   - If @ref OCI_DestroyCANRxQueue() is used to destroy the queue while reception is in progress, it is
    *     possible for @ref onEvent to be called a short time @em after OCI_DestroyCANRxQueue() has returned
    *     successfully.
    *   - Setting only @ref onEvent but not @ref onFrame allows a lazy reaction on frame reception and a
    *     quick reaction on every enabled event.
    *
    * @sa   @ref PAGE_OCI_RECEIVE_MESSAGES "Receive Messages"
    * @sa   OCI_QueueEventFilter
    */
    OCI_CANRxCallback     onEvent;
        
    /**
    * Specify whether self-recepted frames shall be forwarded to this queue.
    * @note        This flag will be AND-gated with the respective
    *              @ref OCI_CANConfiguration setting.
    * @values      The following values are valid:
    * @n           OCI_SELF_RECEPTION_OFF
    * @n           OCI_SELF_RECEPTION_ON
    * @sa          @ref OCI_SelfReceptionMode
    *              "OCI Self Reception Mode"
    */
    OCI_SelfReceptionMode selfReceptionMode;
} OCI_CANRxQueueConfiguration;


/** 
 * Specific structure for the CAN TX queue configuration. 
 * This structure is currently reserved and has no members. 
 */

typedef struct OCI_CANTxQueueConfiguration
{
    /** Reserved for future use. Set to @c zero.*/
    uint32 reserved;

} OCI_CANTxQueueConfiguration;


/** 
  Create a a receive queue or register callback functions for frame reception for a specific CAN controller. 
  
  CAN controller allow a single receive queue per controller. The configuration parameter allows the
  registration of a callback function for frames and a callback function for events. When these callbacks are
  set to NULL the data will be queued and must be read by OCI_ReadCANData(). When the callbacks are set
  the data will not be stored in the queue, but a reference is passed to the callback function whenever a frame
  is received. 

  All Frames and Events must pass a white filter to be stored in the queue. The filter conditions must be set
  by OCI_AddCANFrameFilter(), OCI_AddCANErrorFrameFilter() and OCI_AddCANBusEventFilter(). After creation of a 
  receive queue the queue will not receive any data, because no white filter is active and all data is blocked.

  @controllerState SUSPENDED, RUNNING. 

  @param[in]  controller     Handle of the controller instance. 
  @param[in]  configuration  Pointer to the buffer that contains the configuration structure. 
  @param[out] queue          Handle of the newly created receive queue. 

  @return
   <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. 
             The @a queue handle is vaild and must be used in any subsequent call accessing the queue. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a controller handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a configuration paramter or queue parameter is NULL or references to an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_STATE </td>
        <td> The @a controller was not opened. The controller is not in the @a RUNNING or @a SUSPENDED state. </td>
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
        <td> An unexpected implementation error occured. </td> 
   </tr>
  </TABLE> 
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_CreateCANRxQueue(
    OCI_ControllerHandle controller, 
    OCI_CANRxQueueConfiguration * configuration,
    OCI_QueueHandle * queue);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_CreateCANRxQueue)(
    OCI_ControllerHandle controller, 
    OCI_CANRxQueueConfiguration * configuration,
    OCI_QueueHandle * queue);


/** 
  Destroy a receive queue and unregister callback routines for data and event reception for a specific CAN controller.

  Any data in the queue, that is not read by OCI_ReadCANData() will be discarded. The registered callback routines
  for data reception and event reception (see @ref OCI_CANRxQueueConfiguration) will not be called after completion of
  this routine. All white filter added to this queue will be discarded.  
  
  The handle for the queue must not used any longer. 

  @todo This call needs a synchronization of the data transmission via callback mechanism 
  and the synchronous command processing through all transport layer!

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE. \n
                   When the controller is in the DISCONNECTED state the function may be called to do local clean
                   up. 

  @param[in]  queue  Handle of the queue.

  @return     
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. The queue is destroyed and the handle must not be used any longer. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>

   </TABLE> 
 */
#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_DestroyCANRxQueue(
    OCI_QueueHandle queue);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_DestroyCANRxQueue)(
    OCI_QueueHandle queue);


/** 
  Create a CAN transmit queue. 
  
  A transmit queue is necessary to transmit frames for a specific CAN controller instance. CAN controller
  support only a single transmit queue. All frames written to the transmit queue by OCI_WriteCANData() will 
  be sent in the same order on the CAN-Bus.

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE.

  @param[in]  controller     The handle of the controller instance. 
  @param[in]  configuration  The configuration of the transmit queue. 
                             Currently reserved, must be set to @c NULL.
  @param[out] queue          Receives the handle of the newly created transmit queue. 

 @return
   <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. 
             The @a queue handle is valid and can be used for any subsequent access to the queue. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a controller handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The queue paramter is NULL or references an invalid object.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
        <td> An unexpected implementation error occured. </td> 
   </tr>
  </TABLE> 
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_CreateCANTxQueue(
    OCI_ControllerHandle controller, 
    OCI_CANTxQueueConfiguration* configuration,
    OCI_QueueHandle* queue);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_CreateCANTxQueue)(
    OCI_ControllerHandle controller, 
    OCI_CANTxQueueConfiguration* configuration,
    OCI_QueueHandle* queue);


/**
 Destroy a CAN transmit queue.

 The transmission Queue of a CAN controller is destroyed and all resources used by the queue are released. If the
 queue is not empty and some frames are waiting for transmission the frames are silently discarded. If the 
 application wants to be sure, that all frames are send before the queue is destroyed it can use the 
 OCI_GetQueueStatus() command to wait for an empty queue before calling this command. 
 
 The handle is invalid after this call and must not be used any longer. 

 @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE.
                   When the controller is in the DISCONNECTED state the function may be called to do local clean
                   up. 
 
 @note Frames already stored in the send register of a CAN controller, but stalled by higher prior messages on the
       Bus may be sent, when the controller wins arbitration, even when this call already returned and the send
       queue is invalid.

 @param[in] queue The handle of the queue to destroy. 
    
 @return
   <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. 
             The @a queue is destroyed and the handle must not be used any longer.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
        <td> An unexpected implementation error occured. </td> 
   </tr>
  </TABLE> */

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_DestroyCANTxQueue(
    OCI_QueueHandle queue);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_DestroyCANTxQueue)(
    OCI_QueueHandle queue);


/**
* @}
* @addtogroup GROUP_OCI_CAN_FILTERING Filter
* @{ */
    

/** 
* Structure that defines a single CAN (read) frame filter. For a given  
* logical link, there may be a number of frame filters. A frame will 
* pass them and be added to the receive queue, if it matches the condition 
* of at least one of them. 
*
* A frame filter describes a mask conditions:
*
* pass =    ((frame.ID & @a frameIDMask) == @a frameIDValue)
*/

typedef struct OCI_CANRxFilter
{
    /** 
    * Value that the frame id must match after AND-gating it with 
    * @a frameIDMask.
    */

    uint32 frameIDValue;

    /**
    * Bit mask to be applied to the frame id. If the frame id is shorter 
    * than 32 bits, the "missing" high bits are padded with 0.
    */

    uint32 frameIDMask;

    /**
    * Application defined filter tag. All received frames which match
    * this filter are tagged with this value.
    */
    uint32 tag;

} OCI_CANRxFilter;


/**
* @anchor  OCI_ANCHOR_CAN_BUS_EVENTS
* @name    OCI CAN configuration values for the media type.
* @brief   Constant values to specify the kind of a CAN bus event.
*          These are possible values of @ref OCI_CANEventFilter.event.
*          
* @{ */

/** The CAN controller has switched into the active state. */
#define OCI_CAN_BUS_EVENT_STATE_ACTIVE              (0x00000001u)
    
/** The CAN controller has switched into the passive state. */
#define OCI_CAN_BUS_EVENT_STATE_PASSIVE             (0x00000002u)
    
/** The warning limit of the error counter has exceeded. */
#define OCI_CAN_BUS_EVENT_STATE_ERRLIMIT            (0x00000004u)
    
/** The controller has switched into the bus off state. */
#define OCI_CAN_BUS_EVENT_STATE_BUSOFF              (0x00000008u)

/** 
 * The controller has switched to single wire mode. 
 * (fault tolerant physical medium only) 
 */
#define OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE (0x00000010u)

/** @} */

/**
* Specific structure to define a filter for a CAN bus event. 
*/

typedef struct OCI_CANEventFilter
{
    /** 
    * Specifies which kind of CAN bus event this filter matches 
    * Valid values may be OR-gated as flags into the member to
    * specify that this filter matches multiple events.
    * The value of @a event is internally AND-gated with
    * @ref OCI_CANControllerCapabilities.busEvents.
    * @flags       The following flags are valid:
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_ACTIVE
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_PASSIVE
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_ERRLIMIT
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_BUSOFF
    * @n           @ref OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
    * @sa          OCI_ANCHOR_CAN_BUS_EVENTS
    *              "OCI CAN bus events"
    */
    uint32 eventCode;
    
    /**
    * Application defined filter tag. All received events which match
    * this filter are tagged with this value.
    */
    uint32 tag;

    /** 
    * Destination of the event. When @ref OCI_EVENT_DESTINATION_INBAND 
    * is set, the event will be delivered inband to the application. 
    * When the @ref OCI_EVENT_DESTINATION_CALLBACK is set the event 
    * will trigger the event handler of the receive queue for that 
    * event. When both flags are combined the event is duplicated and 
    * the callback is triggered and the event is stored inband in the 
    * queue.
    */
    uint32 destination;

} OCI_CANEventFilter;


/**
* Specific structure to define a CAN error frame filter.
*/

typedef struct OCI_CANErrorFrameFilter
{
    /** 
    * Specifies which kind of CAN error frames this filter matches. 
    * Valid values may be OR-gated as flags into the member to
    * specify that this filter matches different kinds of error frames.
    * The value of @a errorFrame is internally AND-gated with 
    * @ref OCI_CANControllerCapabilities.errorFrames.
    * @flags        The following flags are valid:
    * @n            @ref OCI_CAN_ERR_TYPE_BITSTUFF
    * @n            @ref OCI_CAN_ERR_TYPE_FORMAT
    * @n            @ref OCI_CAN_ERR_TYPE_ACK
    * @n            @ref OCI_CAN_ERR_TYPE_BIT
    * @n            @ref OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
    * @n            @ref OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
    * @n            @ref OCI_CAN_ERR_TYPE_CRC
    * @n            @ref OCI_CAN_ERR_TYPE_OVERLOAD
    * @n            @ref OCI_CAN_ERR_TYPE_OTHER
    * @sa           OCI_ANCHOR_CAN_ERROR_FRAME_TYPES
    *               "CAN error frame types" 
    */
    uint32 errorFrame;
    
    /**
    * Application defined filter tag. All received events which match
    * this filter are tagged with this value.
    */
    uint32 tag;

    /** 
    * Destination of the event. When @ref OCI_EVENT_DESTINATION_INBAND 
    * is set, the event will be delivered inband to the application. 
    * When the @ref OCI_EVENT_DESTINATION_CALLBACK is set the event 
    * will trigger the event handler of the receive queue for that 
    * event. When both flags are combined the event is duplicated and 
    * the callback is triggered and the event is stored inband in the 
    * queue.
    */
    uint32 destination;

} OCI_CANErrorFrameFilter;


/** 
  Add white filter condition(s) to enable the reception of CAN frames for a specific CAN receive queue.

  In the default configuration of a receive queue no data will be received because any data is blocked by
  some filter condition. The application must enable the reception of the data by setting white filter 
  (defining pass conditions). 

  This function allows the reception of specific CAN frames identified by a masked CAN-ID on the CAN bus. 
  The frames may be queued and read by OCI_ReadCANData() or a callback is triggered whenever a frame passes 
  the filter. The signalization path to the application is defined by the creation of the receive queue. 
  (See OCI_CreateCANRxQueue()).
  
  Filter conditions allow an effective reduction of the payload, that must be handled by the driver and
  application. The sequence of processing the filter array is undefined. When a frame matches to more than 
  one filter the frame will be passed to the application, but the used filter tag (identifying the matching
  filter) is implementation specific and may change in different versions and on different hardware. 

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE. 

  @param[in]  queue    Handle of the CAN receive queue that will receive the messages. 
  @param[in]  filter   A pointer to an array of @a count entries of type @ref OCI_CANRxFilter.
  @param[in]  count    Number of entries in the @a filter array. 

  @return     
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a filter are added.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a filter paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
        <td> One or more @a filter objects are invalid or already exist.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_NO_RESOURCES </td>
        <td> The limit of the filter that can be handled by the driver is exceeded. It is not possible to add
             some more filter. A hardware implementation may limit the number of supported filter to avoid an
             overload of the hardware. Some implementation may share the filter resources between all logical
             controller instances of a hardware controller or even all logical controller of a hardware system.
             Terminate other application that access the same system to release resources required by them.
             Limit hardware filter in OCI-layer to reduce the number of frames forwarded to the queue and use
             software filter (OLI-...) for an exact filtering. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
        <td> An unexpected implementation error in the driver occured. Please contact the vendor of the driver. </td> 
   </tr>

  </TABLE> 

  @sa GROUP_OCI_EVENT_HANDLING, @ref PAGE_OCI_RECEIVE_MESSAGES.
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_AddCANFrameFilter(
    OCI_QueueHandle queue, 
    OCI_CANRxFilter filter[], 
    uint32 count);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_AddCANFrameFilter)(
    OCI_QueueHandle queue, 
    OCI_CANRxFilter filter[], 
    uint32 count);

/**
  Remove white filter condition(s) to disable the reception of CAN frames for a specific CAN receive queue.

  In the default configuration of a receive queue no data will be received because any data is blocked by
  some filter condition. The application must enable the reception of the data by setting white filter 
  (defining pass conditions). 

  This function allows to withdraw one or more white filter conditions set by OCI_AddCANFrameFilter(). Each
  @ref OCI_CANRxFilter of the @a filter array must exact match to a previously added filter. It is
  not possible to restrict an existing white filter, without redrawing it and adding a new more restrictive
  one.
     
  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE. \n
                   When the controller is in the DISCONNECTED state the function may be called to do local clean
                   up. Only a limitied plausibility check may be done in this case.  

  @param[in]  queue    Handle of the CAN receive queue from which are filter withdrawn. 
  @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANRxFilter.
  @param[in]  count    Number of entries in the @a filter array. 

  @return
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a filter are withdrawn. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a filter paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
        <td> One or more filter objects are not set and can not be removed. The processing of the rest of the
             filter array is undefined. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
  </TABLE> 
  
  @sa GROUP_OCI_EVENT_HANDLING, @ref PAGE_OCI_RECEIVE_MESSAGES.
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_RemoveCANFrameFilter(
    OCI_QueueHandle queue, 
    OCI_CANRxFilter filter[], 
    uint32 count);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_RemoveCANFrameFilter)(
    OCI_QueueHandle queue, 
    OCI_CANRxFilter filter[], 
    uint32 count);


/** 
  Add white filter condition(s) to enable the reception of CAN bus events for a specific CAN receive queue.

  In the default configuration of a receive queue no data will be received because any data is blocked by
  some filter condition. The application must enable the reception of the data by setting white filter 
  (defining pass conditions). 

  This function allows the reception of specific events on the CAN bus. The events may be delivered in-order
  in the normal data stream or generate a callback. The signalization path to the application is defined by 
  the creation of the receive queue and by the definition of the filter condition in this call. 
  For any filter in the array it is possible to set OCI_CANEventFilter::destination to a combination of
  @li  @ref OCI_EVENT_DESTINATION_CALLBACK 
       The event will generate the OCI_CANRxQueueConfiguration::onEvent callback.
  @li  @ref OCI_EVENT_DESTINATION_INBAND 
       The event will use the same path as any received frame. Dependent on the configuration of the Queue the 
       event will generate the OCI_CANRxQueueConfiguration::onFrame callback or will be queued. Queued events 
       and frames can be read by OCI_ReadCANData().  
  
  When both Flags are set the event will be duplicated and use both signalization paths. 
  When no Flag is set @ref OCI_ERR_INVALID_FILTER is returned.

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE.

  @param[in]  queue    Handle of the CAN receive queue that will receive the event(s). 
  @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANEventFilter.
  @param[in]  count    Number of entries in the @a filter array. 

  @return
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a filter are added. The events will be received. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a filter paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
        <td> One or more @a filter objects are invalid or alredy exist.</td> 
   </tr>
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
  </TABLE> 
  
  @sa GROUP_OCI_EVENT_HANDLING, @ref PAGE_OCI_RECEIVE_MESSAGES "Receive Messages"
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_AddCANBusEventFilter(
    OCI_QueueHandle queue, 
    OCI_CANEventFilter filter[], 
    uint32 count);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_AddCANBusEventFilter)(
    OCI_QueueHandle queue, 
    OCI_CANEventFilter filter[], 
    uint32 count);


/**
  Remove white filter condition(s) to disable the reception of CAN-Bus events for a specific CAN receive queue.

  In the default configuration of a receive queue no data will be received because any data is blocked by
  some filter condition. The application must enable the reception of the data by setting white filter 
  (defining pass conditions). 

  This function allows to withdraw one or more white filter conditions set by OCI_AddCANBusEventFilter(). Each
  @ref OCI_CANEventFilter of the @a filter array must exact match to a previously added filter. It is
  not possible to restrict an existing white filter, without redrawing it and adding a new more restrictive
  one.

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE. \n
                   When the controller is in the DISCONNECTED state the function may be called to do local clean
                   up. Only a limitied plausibility check may be done in this case.  

  @param[in]  queue   Handle of the CAN receive queue to modify. 
  @param[in]  filter  Pointer to an array of @a count entries of type @ref OCI_CANEventFilter. 
  @param[in]  count   Number of entries in the @a filter array. 

  @return
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a filter are withdrawn. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a filter paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_FILTER_UNKNOWN </td>
        <td> One or more @a filter objects are not set and can not be removed. The processing of the
             filter array is undefined. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
  </TABLE> 
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode 
OCI_CALL OCI_RemoveCANBusEventFilter(
    OCI_QueueHandle queue, 
    OCI_CANEventFilter filter[], 
    uint32 count);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_RemoveCANBusEventFilter)(
    OCI_QueueHandle queue, 
    OCI_CANEventFilter filter[], 
    uint32 count);


/** 
  Add white filter condition(s) to enable the reception of CAN error frames for a specific CAN receive queue.

  In the default configuration of a receive queue no data will be received because any data is blocked by
  some filter condition. The application must enable the reception of the data by setting white filter 
  (defining pass conditions). 

  This function allows the reception of CAN Error frames. The error frames may be delivered in-order
  in the normal data stream or generate a callback.  The signalization path to the application is defined by 
  the creation of the receive queue and by the definition of the filter condition in this call. 
  @li  When the OCI_CANErrorFrameFilter::destination is @ref OCI_EVENT_DESTINATION_CALLBACK the error frames
       will generate the OCI_CANRxQueueConfiguration::onEvent callback. 
  @li  When the OCI_CANErrorFrameFilter::destination is @ref OCI_EVENT_DESTINATION_INBAND the error frames
       will use the same path as any received frame. Dependent on the configuration of the Queue the error frames
       will generate the OCI_CANRxQueueConfiguration::onFrame callback or will be queued. Queued error frames
       (and CAN frames) can be read by OCI_ReadCANData().  
 
  When both Flags are set the event will be duplicated and use both signalization paths. 
  When no Flag is set @ref OCI_ERR_INVALID_FILTER is returned.

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE.

  @param[in]  queue    Handle of the CAN receive queue that will receive the event(s). 
  @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANErrorFrameFilter. 
  @param[in]  count    Number of entries in the @a filter array. 

  @return
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a filter are added. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a filter paramter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
        <td> One or more @a filter objects are invalid or alredy exist.</td> 
   </tr>
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
        <td> An unexpected implementation error in the driver occured. Please contact the vendor of the driver. </td> 
   </tr>
  </TABLE> 
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode
OCI_CALL OCI_AddCANErrorFrameFilter(
    OCI_QueueHandle queue,
    OCI_CANErrorFrameFilter filter[],
    uint32 count);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_AddCANErrorFrameFilter)(
    OCI_QueueHandle queue,
    OCI_CANErrorFrameFilter filter[],
    uint32 count);


/**
  Remove white filter condition(s) to disable the reception of CAN-Error Frames for a specific CAN receive queue.

  In the default configuration of a receive queue no data will be received because any data is blocked by
  some filter condition. The application must enable the reception of the data by setting white filter 
  (defining pass conditions). 

  This function allows to withdraw one or more white filter conditions set by OCI_AddCANErrorFrameFilter(). Each
  @ref OCI_CANErrorFrameFilter of the @a filter array must exact match to a previously added filter. It is
  not possible to restrict an existing white filter, without redrawing it and adding a new more restrictive
  one.
 
  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE. \n
                   When the controller is in the DISCONNECTED state the function may be called to do local clean
                   up. Only a limitied plausibility check may be done in this case.  

  @param[in]  queue    Handle of the CAN receive queue to modify. 
  @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANErrorFrameFilter.
  @param[in]  count    Number of entries in the @a filter array. 

  @return
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a filter are withdrawn. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a filter paramter is NULL or points to an invalid object.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
        <td> One or more @a filter objects are not set and can not be removed. The processing of the rest of the
             filter array is undefined. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
  </TABLE>
*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode
OCI_CALL OCI_RemoveCANErrorFrameFilter(
    OCI_QueueHandle queue,
    OCI_CANErrorFrameFilter filter[],
    uint32 count);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_RemoveCANErrorFrameFilter)(
    OCI_QueueHandle queue,
    OCI_CANErrorFrameFilter filter[],
    uint32 count);


/**
* @}
* @addtogroup GROUP_OCI_CAN_MESSAGES Messages
* @{
*/

/**
* @anchor ANCHOR_OCI_MESSAGE_TYPES
* @name   OCI Message Types.
* @brief  Possible values of @ref OCI_CANMessage.type. 
*         The values are used to select a specific part of a discriminated
*         union.
* @{
*/

typedef enum OCI_CANMessageDataType
{
    /** Message type is @ref OCI_CANRxMessage */
    OCI_CAN_RX_MESSAGE                          = 1,

    /** Message type is @ref OCI_CANTxMessage */
    OCI_CAN_TX_MESSAGE                          = 2,

    /** Message type is @ref OCI_CANErrorFrameMessage */
    OCI_CAN_ERROR_FRAME                         = 3,
    
    /** Message type is @ref OCI_CANEventMessage */
    OCI_CAN_BUS_EVENT                           = 4,
    
    /** Message type is @ref OCI_InternalErrorEvent*/
    OCI_CAN_INTERNAL_ERROR_EVENT                = 5,
    
    /** Message type is @ref OCI_QueueEvent */
    OCI_CAN_QUEUE_EVENT                         = 6,
    
    /** Message type is @ref OCI_TimerEvent */
    OCI_CAN_TIMER_EVENT                         = 7

}OCI_CANMessageDataType;

/** @} */


/**
* @anchor  ANCHOR_OCI_CAN_MESSAGE_FLAGS
* @name    OCI CAN Message Flags.
* @brief   Flags to specify additional information of a CAN message.
*          These are possible values of @ref OCI_CANRxMessage.flags.
*/

/** @{ */
/** 
* Message with extended 29-bit ID. If this flag is not set, the message has a standard 11-bit ID.
*/
#define OCI_CAN_MSG_FLAG_EXTENDED               (0x1u)

/** 
* The message is a remote frame.
*/
#define OCI_CAN_MSG_FLAG_REMOTE_FRAME           (0x2u)

/** 
* The message is a self reception frame.
*/
#define OCI_CAN_MSG_FLAG_SELFRECEPTION          (0x4u)

/** @} */


/** 
* Specific structure for CAN bus data messages.
*/

typedef struct OCI_CANTxMessage
{     
    /** CAN frame ID. */
    uint32 frameID;
    
    /** 
    * Additional information and settings of the CAN data message. 
    * @flags    The following flags are valid:
    * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
    * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
    * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
    * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
    *           "OCI CAN Message Flags"
    */    
    uint16 flags;

    /** Reserved data field. */
    uint8 res;

    /**
     * The data length code (DLC) of the CAN frame to be transmitted. Usually, the DLC indicates the number of data bytes in
     * the frame, (i.e. the number of valid bytes in @ref data) and is therefore <= 8. However, the CAN specification implicitly
     * permits DLC values which are > 8 and <= 15, though in such a case the frame will still contain only 8 data bytes.
     * Consequently, some CAN controllers are able to transmit a frame with DLC > 8, though such a frame still only contains 8
     * data bytes. The OCI_CAN API allows a caller to request the transmission of such a frame, though the underlying OCD may
     * refuse to transmit the frame and return an error.
     */
    uint8 dlc;
    
    /** Payload. If @ref dlc is <= 8, only the first @ref dlc bytes are valid. If @ref dlc is > 8, all 8 bytes are valid. */
    uint8 data[8];

} OCI_CANTxMessage;

/** Specific structure for CAN bus data frames. */
typedef struct OCI_CANRxMessage
{
    /** 
    * Global receive time stamp. Depending on the implementation, this may be 
    * based on a hardware-internal timer with no global synchronization. 
    * In particular, the epoch (i.e.\ value 0) may be the point in time the 
    * hardware was switched on.
    */
    OCI_Time timeStamp;

    /** Filter tag ID. This ID is set by the definition of the RxFilter. */
    uint32 tag;

    /** CAN frame ID. */
    uint32 frameID;

    /** 
    * Additional information and settings of the CAN data message. 
    * @flags    The following flags are valid:
    * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
    * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
    * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
    * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
    *           "OCI CAN Message Flags"
    */    
    uint16 flags;

    /** Reserved data field. */
    uint8 res;

    /**
     * The data length code (DLC) of the received CAN frame. Usually, the DLC indicates the number of data bytes in the frame,
     * (i.e. the number of valid bytes in @ref data) and is therefore <= 8. However, the CAN specification implicitly permits
     * DLC values which are > 8 and <= 15, though in such a case the frame will still contain only 8 data bytes. Consequently,
     * some CAN controllers are able to receive a frame with DLC > 8 (though such a frame still only contains 8 data bytes),
     * and the OCI_CAN API will process such a frame as usual, except that @ref dlc will be > 8 and @ref data will contain 8 bytes.
     */
    uint8 dlc;
    
    /** keep 64 Bit alignment for first data byte */
    uint8 res1[4];
    
    /** Payload. If @ref dlc is <= 8, only the first @ref dlc bytes are valid. If @ref dlc is > 8, all 8 bytes are valid. */
    uint8 data[8];

} OCI_CANRxMessage;


/**
* @anchor  OCI_ANCHOR_CAN_ERROR_FRAME_TYPES
* @name    OCI CAN Error Frame Types.
* @brief   Constants to specify the content of a error frame. 
*          These constants are valid for @ref OCI_CANErrorFrameMessage.type.
*/

/** @{ */
/** Bit stuff error */
#define OCI_CAN_ERR_TYPE_BITSTUFF               (0x00000001u)

/** Format error */
#define OCI_CAN_ERR_TYPE_FORMAT                 (0x00000002u)

/** Acknowledge error */
#define OCI_CAN_ERR_TYPE_ACK                    (0x00000004u)

/** Bit error */
#define OCI_CAN_ERR_TYPE_BIT                    (0x00000008u)

/** CRC error */
#define OCI_CAN_ERR_TYPE_CRC                    (0x00000010u)

/** 
  * Bit error desired recessive but monitored dominant  
  * Could happen if e.g. another node or the physical 
  * layer driver is defect and produces a permenant dominant
  * level.
  */
#define OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT (0x00000020u)


/**
  * Bit error desired dominant but monitored recessive
  * Could happen if e.g. the bus topilogy wasn't correctly
  * designed 
  */

#define OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV (0x00000040u)

/** Overload error */
#define OCI_CAN_ERR_TYPE_OVERLOAD               (0x00000080u)

/** Other unspecified error */
#define OCI_CAN_ERR_TYPE_OTHER                  (0x80000000u)

/** Unknown error 
@todo Define value for OCI_CAN_ERR_TYPE_UNKNOWN 
*/
#define OCI_CAN_ERR_TYPE_UNKNOWN                (0x80000000u)    
/** @} */


/** 
* Specific structure for CAN bus data messages.
*/

typedef struct OCI_CANErrorFrameMessage
{     
    /** 
    * Global receive time stamp. Depending on the implementation, 
    * this may be based on a hardware-internal timer with no global 
    * synchronization. In particular, the epoch (i.e.\ value 0) may
    * be the point in time the hardware was switched on.
    */
    OCI_Time timeStamp;
    
    /** 
    * CAN filter tag ID. This ID matches the @ref OCI_CANErrorFrameFilter.tag 
    * of the first defined frame filter which caused this frame to be
    * received. 
    */
    uint32 tag;

    /** CAN frame ID. May be @c 0xffffffff if unknown*/
    uint32 frameID;

   /** 
    * Additional information and settings of the CAN data message. 
    * @flags    The following flags are valid:
    * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
    * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
    * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
    * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
    *           "OCI CAN Message Flags"
    */    
    uint16 flags;

    /** Reserved data field. */
    uint8 res;

    /** 
    * Number of (valid) data bytes. 
    * CAN allows for frames to be shorter than 8 bytes.
    * May be @c 0xff if unknown
    */
    uint8 dlc;

    /** 
    * Type of the error frame. If this feature is not supported,
    * the value is always @ref OCI_CAN_ERR_TYPE_UNKNOWN.
    * @values   The following values are valid:
    * @n        @ref OCI_CAN_ERR_TYPE_BITSTUFF
    * @n        @ref OCI_CAN_ERR_TYPE_FORMAT
    * @n        @ref OCI_CAN_ERR_TYPE_ACK
    * @n        @ref OCI_CAN_ERR_TYPE_BIT
    * @n        @ref OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
    * @n        @ref OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
    * @n        @ref OCI_CAN_ERR_TYPE_CRC
    * @n        @ref OCI_CAN_ERR_TYPE_OVERLOAD
    * @n        @ref OCI_CAN_ERR_TYPE_OTHER
    * @n        @ref OCI_CAN_ERR_TYPE_UNKNOWN
    * @sa       @ref ANCHOR_OCI_CAN_ERROR_FRAME_TYPES
    *           "OCI CAN Error Frame Types"
    */    
    uint32 type;

    /**
    * Destination of the event. The event message will use the combination 
    * of @ref OCI_EVENT_DESTINATION_INBAND and 
    * @ref OCI_EVENT_DESTINATION_CALLBACK that was 
    * registered for this event by calling OCI_AddCANBusEventFilter().
    */
    uint32 destination;
} OCI_CANErrorFrameMessage;


/** 
* Specific structure for CAN bus events.
*/

typedef struct OCI_CANEventMessage
{     
   /** 
    * Global receive time stamp. Depending on the implementation, 
    * this may be based on a hardware-internal timer with no global 
    * synchronization. In particular, the epoch (i.e.\ value 0) may
    * be the point in time the hardware was switched on.
    */
    OCI_Time timeStamp;

    /**
    * Filter tag specified in @ref OCI_CANEventFilter.
    */
    uint32 tag;

   /** 
    * Specifies the of CAN bus events.
    * Valid values may be OR-gated as flags into the member to
    * specify that this filter matches multiple events.
    * The value of @a event is internally AND-gated with
    * @ref OCI_CANControllerCapabilities.busEvents.
    * @flags       The following flags are valid:
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_ACTIVE
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_PASSIVE
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_ERRLIMIT
    * @n           @ref OCI_CAN_BUS_EVENT_STATE_BUSOFF
    * @n           @ref OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
    * @sa          OCI_ANCHOR_CAN_BUS_EVENTS
    *              "OCI CAN bus events"
    */
    uint32 eventCode;
    
    /**
    * Destination of the event. The event message will use the combination 
    * of @ref OCI_EVENT_DESTINATION_INBAND and 
    * @ref OCI_EVENT_DESTINATION_CALLBACK that was 
    * registered for this event by calling OCI_AddCANBusEventFilter().
    */
    uint32 destination;
    
} OCI_CANEventMessage;
/**
* Shared structure of CAN bus relevant data.
*/

typedef union OCI_CANMessageData 
{    
    /** 
    * Read Data of a CAN message. 
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_RX_MESSAGE.
    */
    OCI_CANRxMessage rxMessage;

    /** 
    * Write data of a CAN message. 
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_TX_MESSAGE.
    */
    OCI_CANTxMessage txMessage;

    /** 
    * Information about a bus error. 
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_ERROR_FRAME.
    */
    OCI_CANErrorFrameMessage errorFrameMessage;
    
    /** 
    * Specific CAN bus event, e.g.\ bus off.
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_BUS_EVENT.
    */ 
    OCI_CANEventMessage canEventMessage; 
    
    /** 
    * Data of a CAN message. 
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_INTERNAL_ERROR_EVENT.
    */
    OCI_InternalErrorEventMessage internalErrorEventMessage;

    /** 
    * Data of a CAN message. 
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_TIMER_EVENT.
    */
    OCI_TimerEventMessage timerEventMessage;

    /** 
    * Data of a CAN message. 
    * Use this part, if @ref OCI_CANMessage.type is 
    * @ref OCI_CAN_QUEUE_EVENT.
    */
    OCI_QueueEventMessage queueEventMessage;
    
} OCI_CANMessageData;


/**
* Shared structure of a CAN bus event.
*/

typedef struct OCI_CANMessage
{
    /** Discriminator of the @a OCI_CANMessageData union. */
    OCI_CANMessageDataType type;

    /** reserved parameter necessary for 64 Bit alignment of OCI_CANMessageData */
    uint32 reserved;

    /** Data of the message dependent on the @a type of the message. */
    OCI_CANMessageData data;

} OCI_CANMessage;


/**
* @}
* @addtogroup GROUP_OCI_CAN_QUEUES Queues
* @{
*/

/** 
  Queue Data for transmission on a CAN Bus Interface. 
  
  The routine returns, when all frames can be queued. Since the transmit queue has a limited capacity, 
  this function may need to block until the last entry could be placed into the queue. A @ref timeout
  can be specified to limit the blocking.
  
  There is no information, when the frames are send on the CAN bus. There may be a delay between storing the frames 
  in the queue and sending them, because of other frames in the same queue and arbitration of the CAN-Bus. Some 
  fatal error on the CAN-Bus (e.g. Controller Bus-Off) may occur before the frames can be send. 

  When the fatal error condition occurs when the function is executed, this function will return immediately with 
  an error code. It will not try to push the remaining messages into the queues. Already queued entries will not 
  be discarded.
  
  @note: A low prior frame in front of a send queue on a busy CAN bus may loose arbitration process with other CAN
  controller and stall the transmission of higher prior frames written to the queue at a later time.

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE.


  @param[in]  queue     The handle of the @a queue that will transmit the frames. 
  @param[in]  timeout   Maximum time (delta, not global time stamp) to wait for messages to be queued.
                        The timeout uses the same resolution as the controller timestamp. The resolution may vary
                        between different driver for different hardware. The interval may be increased to the time
                        slice(s) used by the Operating System and jitter in this magnitude.
                        Use @ref OCI_NO_TIME to wait indefinitely if necessary. 
                        0 will queue as many messages as possible without waiting for them to be transmitted.
  @param[in]  messages  A pointer to an array of @a size @ref OCI_CANMessage elements. 
  @param[in]  size      The number of entries in the @a messages array. 
  @param[out] remaining Number of entries not processed. Will be 0 on success. Will be smaller or equal to @a size,
                        when an error or timeout occured.  
                        May be @c NULL.

  @return     
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. All @a messages are queued. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td> 
        <td> At least one message has an invalid format. 
             (e.g.\ messages[i].OCI_CANMessageDataType != OCI_CAN_TX_MESSAGE). </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_QUEUE_IS_FULL </td>
        <td> The specified @a queue is full; at least one message could not be added to the queue. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td> 
        <td> A fatal internal error occured in queue handling. </td> 
   </tr>                              
   </TABLE> 

*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode
OCI_CALL OCI_WriteCANData(
    OCI_QueueHandle queue,
    OCI_Time timeout, 
    OCI_CANMessage messages[], 
    uint32 size,
    uint32 *remaining);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_WriteCANData)(
    OCI_QueueHandle queue,
    OCI_Time timeout, 
    OCI_CANMessage messages[], 
    uint32 size,
    uint32 *remaining);


/** 
  Read entries from a receive queue or wait for a timeout when less than requested entries are available. 
  
  The returned number of entries may be less than the requested number. A non blocking call can be executed,
  when @a timeout is set to 0. Even when waiting an infinite time for the entries the function may return with
  less data. 

  This function delivers as long queued data as possible. When the integrity of the returned data can be 
  guaranteed the function will not return any error, even when the controller or some part of the driver
  already entered an error state. The function does not block, when the driver is in error state. In this 
  case it delivers the remaining data without an error code or - when empty - the error code.

  @controllerState SUSPENDED, RUNNING. \n
                   When the controller is in the CREATED state no valid Queue can exist and the call will return
                   @ref OCI_ERR_INVALID_HANDLE.

  @param[in]  queue     Handle of the receive queue.
  @param[in]  timeout   Maximum time (delta, not global time stamp) to wait at the queue to receive @a size entries. 
                        The timeout uses the same resolution as the controller timestamp. The resolution may vary
                        between different driver for different hardware. The interval may be increased to the time
                        slice(s) used by the Operating System and jitter in this magnitude.
                        Use @ref OCI_NO_TIME to wait indefinitely if necessary. 
                        0 will fetch the queue's current content.
                        Must not be @c NULL.
  @param[in]  messages  A pointer to an array that can receive @a size @ref OCI_CANMessage elements. 
  @param[in]  size      Number of entries allocated in the @a messages array. 
                        Must not be 0.
  @param[out] count     Number of entries actually read with 0 <= @a count <= @a size. 
                        Must not be @c NULL.
  @param[out] remaining Number of entries still in the queue after moving @a count into @a messages. 
                        May be @c NULL.

  @return     
  <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">  
   <tr> <td> @ref OCI_SUCCESS </td> 
        <td> The operation was successful. @a count entries are filled in the @messages array. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>  
        <td> The @a queue handle is not valid. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
        <td> The @a messages or @a count parameter is NULL or references an invalid address.</td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
        <td> The driver for a removable hardware received no response to a request. The hardware may be removed. 
             It is not known wether the request is lost and the command not exectuted or the response is lost and
             the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will 
             return @ref OCI_ERR_DRIVER_DISCONNECTED. 
             Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
        <td> The driver for a removable hardware detected a communication problem (in asynchromous communication, 
             by event signalling or during a previous call to the same hardware) and is not able to communicate to 
             the hardware any more. 
             The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to 
             the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until 
             OCI_DestroyCANController() for the controller is called.  </td> 
   </tr>
   <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
        <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple 
             clients and large send and receive queues. The error may indicate a resource leak in the driver 
             implementation. When multiple application access the same resource (interface hardware or physical
             controller) the termination of a different application may return the resources required for this 
             instance. </td> 
   </tr>

   </TABLE> 

*/

#ifndef OCI_DYNAMICDLL
OCI_DECLSPEC OCI_ErrorCode
OCI_CALL OCI_ReadCANData(
    OCI_QueueHandle queue, 
    OCI_Time timeout,
    OCI_CANMessage messages[], 
    uint32 size, 
    uint32 *count,
    uint32 *remaining);
#endif

typedef OCI_ErrorCode
(OCI_CALL *PF_OCI_ReadCANData)(
    OCI_QueueHandle queue, 
    OCI_Time timeout,
    OCI_CANMessage messages[], 
    uint32 size, 
    uint32 *count,
    uint32 *remaining);


typedef struct OCI_CANIO_VTable
{
    PF_OCI_GetCANControllerCapabilities getCANControllerCapabilities;
    PF_OCI_GetCANControllerStatus getCANControllerStatus;

    PF_OCI_CreateCANTxQueue createCANTxQueue;
    PF_OCI_WriteCANData writeCANData;
    PF_OCI_DestroyCANTxQueue destroyCANTxQueue;

    PF_OCI_CreateCANRxQueue createCANRxQueue;
    PF_OCI_ReadCANData readCANData;
    PF_OCI_DestroyCANRxQueue destroyCANRxQueue;

    PF_OCI_AddCANFrameFilter addCANFrameFilter;
    PF_OCI_RemoveCANFrameFilter removeCANFrameFilter;
    PF_OCI_AddCANBusEventFilter addCANBusEventFilter;
    PF_OCI_RemoveCANBusEventFilter removeCANBusEventFilter;
    PF_OCI_AddCANErrorFrameFilter addCANErrorFrameFilter;
    PF_OCI_RemoveCANErrorFrameFilter removeCANErrorFrameFilter;
} OCI_CANIO_VTable;

/** @} */

/** @} */

#ifdef __cplusplus
}
#endif

#endif
